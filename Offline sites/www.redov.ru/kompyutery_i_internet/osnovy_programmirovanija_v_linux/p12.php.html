<html>
<head>
<meta http-equiv="Content-Language" content="ru">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<link href="../../0img/style.css" rel="stylesheet" type="text/css" />
<link rel="SHORTCUT ICON" href="http://www.redov.ru/0img/favicon.ico" type="image/x-icon"> 
<title>Глава 8 MySQL / Основы программирования в Linux</title>
</head>
<body>
<div align="center">
<center>
<table border="0" cellpadding="0" cellspacing="0" width="1260">
<tr>
<td colspan="3" valign="top" align="left" height="100">
<table border="0" cellpadding="0" cellspacing="0" width="1260" height="100">
<tr>
<td valign="middle" align="center" width="350">
<a href="../../index.html"><img src="../../0img/logo.jpg" width="350" height="100" title="Онлайн библиотека redov.ru"/></a>
</td>
<td valign="middle" align="center" width="910">

<noindex>

<!-- SAPE RTB JS -->
<script
    async="async"
    src="http://cdn-rtb.sape.ru/rtb-b/js/393/2/106393.js"
    type="text/javascript">
</script>
<!-- SAPE RTB END -->

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507025"></div>
<!-- SAPE RTB END -->

</noindex>

</td>
</tr>
</table>
</td>
</tr>
<tr>
<td colspan="3" valign="middle" align="left">

<div id="menu">
<ul>
		<li><a href="../../index.html"><span>Главная</span></a></li>
		<li><a rel="sidebar" href="p12.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a></li>
		<li><a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a></li>
		<li><a href="p12.php.html#" onClick="scroll(0,9999999); return false"><span>Вниз</span></a></li>
</ul>
</div>


</td>
</tr>
<tr>
<td width="240" valign="top" align="center">

<br>
<noindex>
<!-- SAPE RTB DIV 160x600 -->
<div id="SRTB_733378"></div>
<!-- SAPE RTB END -->
</noindex>



</td>
<td valign="top" align="left" style="padding-left: 5; padding-right: 5" width="780">
<br>
<noindex>
<div align="center">

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507027"></div>
<!-- SAPE RTB END -->

</div>
</noindex>
<br>



<li><a href="p12.php.html#metkadoc2">     Установка     </a></li>
<li><a href="p12.php.html#metkadoc3">      Пакеты MySQL      </a></li>
<li><a href="p12.php.html#metkadoc4">      Настройка после установки      </a></li>
<li><a href="p12.php.html#metkadoc5">      Устранение неисправностей после установки      </a></li>
<li><a href="p12.php.html#metkadoc6">     Администрирование MySQL     </a></li>
<li><a href="p12.php.html#metkadoc7">      Команды      </a></li>
<li><a href="p12.php.html#metkadoc8">      Создание пользователей и наделение их правами доступа      </a></li>
<li><a href="p12.php.html#metkadoc9">      Пароли      </a></li>
<li><a href="p12.php.html#metkadoc10">      Создание базы данных      </a></li>
<li><a href="p12.php.html#metkadoc11">      Типы данных      </a></li>
<li><a href="p12.php.html#metkadoc12">      Создание таблицы      </a></li>
<li><a href="p12.php.html#metkadoc13">      Графические средства      </a></li>
<li><a href="p12.php.html#metkadoc14">     Доступ к данным MySQL из программ на С     </a></li>
<li><a href="p12.php.html#metkadoc15">      Подпрограммы подключения      </a></li>
<li><a href="p12.php.html#metkadoc16">      Обработка ошибок      </a></li>
<li><a href="p12.php.html#metkadoc17">      Выполнение SQL-операторов      </a></li>
<li><a href="p12.php.html#metkadoc18">      Разные функции      </a></li>
<li><a href="p12.php.html#metkadoc19">     Приложение для работы с базой данных компакт-дисков     </a></li>
<li><a href="p12.php.html#metkadoc20">      Создание таблиц      </a></li>
<li><a href="p12.php.html#metkadoc21">      Вставка данных      </a></li>
<li><a href="p12.php.html#metkadoc22">      Доступ к данным приложения из программы на С      </a></li>
<li><a href="p12.php.html#metkadoc23">     Резюме      </a></li>
<a name="metkadoc1"><h1>Глава 8</p>    <p>MySQL</h1></a>       <p>Теперь, когда вы изучили основы управления данными с помощью обычных файлов и затем посредством простой, но очень быстрой базы данных dbm, можно перейти к полнофункциональному средству работы с данными: СУРБД или системе управления реляционной базы данных (Relational Database Management System, RDBMS).</p>    <p>Два самых известных приложения СУРБД с открытым исходным кодом — это PostgreSQL и MySQL, хотя существует и множество других. Есть также много коммерческих СУРБД, таких как Oracle, Sybase и DB2, все они многофункциональны и могут действовать на различных платформах. Работающая только под управлением ОС Windows система Microsoft SQL Server — еще одно популярное средство на коммерческом рынке СУБД. У всех этих программных продуктов есть свои достоинства, но с учетом занимаемого пространства и принадлежности к программному обеспечению с открытым кодом авторы книги сосредоточились исключительно на СУРБД MySQL.</p>    <p>Появление MySQL восходит к 1984 г., а коммерческий вариант был разработан и поддерживается под покровительством компании MySQL АВ в течение последних нескольких лет. Поскольку СУРБД MySQL — это программное обеспечение с открытым исходным кодом, условия его использования часто смешивают с аналогичными условиями в других проектах с открытым программным кодом. Несмотря на то, что в большинстве случаев MySQL может применяться в соответствии с Общедоступной лицензией проекта GNU (GPL), есть обстоятельства, требующие покупки коммерческой лицензии для использования этого продукта. Следует внимательно проверить лицензионные требования на Web-сайте MySQL (<b>www.mysql.com</b>) и определить, какая редакция MySQL соответствует вашим потребностям.</p>    <p>Если вам нужна база данных с открытым программным кодом, а условия применения MySQL в соответствии с требованиями лицензии GPL для вас не приемлемы, и вы не хотите покупать коммерческую лицензию, то можете рассмотреть как альтернативу применение мощной СУРБД PostgreSQL (во время написания книги лицензионные условия использования PostgreSQL были менее строгими). Подробности можно найти на Web-сайте <b>www.postgresql.org.</b></p>    <blockquote>     <b>Примечание</b>     <p>Более подробную информацию о PostgreSQL вы можете найти в нашей книге: Neil Matthew. Beginning Databases with PostgreSQL: From Novice to Professional. Second Edition. — Apress, 2005. (Мэттью H. Базы данных на примере PostgreSQL: от новичка до профессионала. Второе издание).</p>    </blockquote>    <p>В этой главе обсуждаются следующие темы:</p>    <p>&#9633; установка MySQL;</p>    <p>&#9633; команды администрирования, необходимые для работы с MySQL;</p>    <p>&#9633; основные средства и функции MySQL;</p>    <p>&#9633; API для взаимодействия ваших программ на языке С с базами данных MySQL;</p>    <p>&#9633; создание реляционной базы данных, которую вы сможете применять в вашем приложении на языке С для управления коллекцией CD-дисков.</p>          <a name="metkadoc2"><h1>Установка</h1></a>         <p>Какой бы вариант системы Linux вы не предпочли, вероятно, для него существует доступная версия MySQL, заранее откомпилированная и готовая к установке. Например, для Red Hat, SUSE и Ubuntu есть заранее откомпилированные пакеты, включенные в современные дистрибутивы этих ОС. Мы рекомендуем вам, как правило, применять заранее откомпилированные версии, поскольку они предоставляют самый легкий способ быстрых установки и запуска MySQL. Если в вашем дистрибутиве нет пакета MySQL или вы хотите получить самый свежий выпуск программного обеспечения, двоичные и исходные пакеты можно загрузить с Web-сайта MySQL.</p>     <p>В этой главе мы описываем установку только заранее откомпилированных версий MySQL.</p>             <a name="metkadoc3"><h1>Пакеты MySQL</h1></a>     <p>Если по какой-то причине вам вместо стандартной версии нужно загрузить MySQL из Интернета, для подготовки и выполнения примеров из этой книги следует применять сборку Standard общедоступной версии (community edition). Вы увидите, что в нее включены пакеты Мах и Debug. Пакет Max содержит дополнительные средства, такие как поддержка необычных типов файлов для хранения и развитых средств, например кластеризации. Пакеты Debug откомпилированы с дополнительным кодом отладки и отладочной информацией; к счастью, вам не понадобится отладка на столь низком уровне.</p>     <blockquote>      <b>Примечание</b>      <p>Не используйте версии Debug при эксплуатации; производительность снижается из-за дополнительной поддержки отладочных средств.</p>     </blockquote>     <p>Для разработки приложений на базе MySQL вам придется установить не только сервер, но и библиотеки разработки. Как правило, в вашем диспетчере пакетов (package manager) есть вариант MySQL, нужно только убедиться в том, что установлены и библиотеки средств разработки. На рис. 8.1 показан диспетчер пакетов, готовый установить MySQL с дополнительным пакетом средств разработки, выделенным и готовым к установке.</p>     <img src="image023.jpg"/>     <p><b>Рис. 8.1</b> </p>     <br>     <p>В других дистрибутивах организация пакетов немного иная. Например, на рис. 8.2 показан объединенный диспетчер пакетов дистрибутива Ubuntu, готовый к установке MySQL.</p>     <img src="image024.jpg"/>     <p><b>Рис. 8.2</b></p>     <br>     <p>Установка MySQL также создает пользователя "mysql", имя которого по умолчанию применяется как имя процесса-демона сервера MySQL.</p>     <p>После установки пакетов необходимо проверить, запущена ли автоматически СУРБД MySQL. Во время написания книги некоторые дистрибутивы, например, Ubuntu делали это, в то время как другие, такие как Fedora, нет. К счастью, очень легко проверить, работает ли сервер MySQL:</p>     <p><blockquote>$ <b>ps -el | grep mysqld</b></blockquote></p>     <p>Если вы видите один или несколько выполняющихся процессов mysqld, следовательно, сервер стартовал. Во многих системах вы также увидите процесс safe_mysqld, утилиту для запуска реального процесса mysqld с корректным идентификатором пользователя.</p>     <p>Если нужно запустить (или перезапустить либо остановить) сервер MySQL, можно использовать панель управления сервисами GUI (GUI services control panel). Панель настройки сервисов (Service Configuration pane) дистрибутива Fedora показана на рис. 8.3.</p>     <img src="image025.jpg"/>     <p><b>Рис. 8.3</b></p>     <br>     <p>Вам следует применить редактор настройки сервисов для того, чтобы определить, хотите ли вы, чтобы сервер MySQL автоматически стартовал при каждом запуске ОС Linux.</p>             <a name="metkadoc4"><h1>Настройка после установки</h1></a>     <p>Предположим, что все идет как надо, СУБД MySQL установлена и стартовала с общим стандартным набором параметров. Это предположение можно проверить:</p>     <p><blockquote>$ <b>mysql -u root mysql</b></blockquote></p>     <p>Если вы получите сообщение "Welcome to the MySQL monitor" ("Добро пожаловать в монитор MySQL") и затем приглашение <blockquote>mysql&gt;</blockquote>, значит, сервер выполняется. Конечно, любой пользователь вмиг может подключиться к серверу и получить права администратора, но мы рассмотрим это лишь вкратце. Попробуйте ввести <blockquote>\s</blockquote> для получения некоторой дополнительной информации о вашем сервере. Когда насмотритесь, введите <blockquote>quit</blockquote> или <blockquote>\q</blockquote> для выхода из монитора.</p>     <p>Дополнительную информацию можно получить с помощью команды <blockquote>mysql -?</blockquote>, которая выводит еще больше подробностей, касающихся сервера. В выводе есть одна деталь, которую следует проверить. После списка аргументов обычно выводится строка <blockquote>Default options are read from the following files in the given order:</blockquote> (Текущие параметры считаны из следующих файлов в заданном порядке:). Она указывает, где найти файл конфигурации, который следует использовать для настройки вашего сервера MySQL. Стандартный файл конфигурации -— /etc/my.cnf, хотя в некоторых дистрибутивах, например Ubuntu, применяется файл /etc/mysql/my.cnf.</p>     <p>Состояние работающего сервера можно также проверить с помощью команды <blockquote>mysqladmin</blockquote>:</p>     <p><blockquote>$ <b>mysqladmin -u root version</b></blockquote></p>     <p>Вывод не только подтвердит запуск, но и предоставит номер версии используемого вами сервера.</p>     <p>Еще один полезный аспект применения команды <blockquote>mysqladmin</blockquote> — проверка конфигурационных параметров запущенного сервера с помощью опции <blockquote>variables</blockquote>:</p>     <p><blockquote>$ <b>mysqladmin variables</b></blockquote></p>     <p>Эта команда выводит длинный список значений переменных. Пара особенно полезных — переменная <blockquote>datadir</blockquote>, сообщающая о том, где MySQL хранит данные, и переменная <blockquote>have_innodb</blockquote>, обычно равная <blockquote>YES</blockquote> и указывающая на то, что поддерживается универсальный механизм хранения данных (storage engine) InnoDB. MySQL поддерживает ряд механизмов хранения, представляющих собой низкоуровневую реализацию обработчиков для хранения данных. Наиболее популярные (и самые полезные) — InnoDB и MyISAM, но есть и другие, например механизм хранения в оперативной памяти (memory engine), совсем не использующий долговременную память, или CSV-механизм, применяющий файлы с переменными, разделенными запятыми. У разных механизмов хранения различные функции производительности. В настоящее время мы рекомендуем InnoDB как механизм хранения для баз данных общего назначения, представляющий собой компромиссное решение с точки зрения производительности и поддержки заданных связей между различными элементами данных. Если поддержка InnoDB не включена, проверьте файл конфигурации /etc/my.cnf, превратите в комментарий строку <blockquote>skip-innodb</blockquote>, поместив в начало строки знак номера или решетки (<blockquote>#</blockquote>), и воспользуйтесь редактором сервисов для перезапуска MySQL. Если это не поможет, возможно, у вас версия MySQL, откомпилированная без поддержки InnoDB, Поищите на Web-сайте MySQL версию с поддержкой InnoDB, если вам это важно. В примерах данной главы без ущерба можно применить и альтернативный механизм хранения MyISAM, во многих дистрибутивах используемый по умолчанию.</p>     <p>После того как вы убедитесь в том, что в двоичный файл сервера включена поддержка InnoDB, для того чтобы сделать его выбираемым по умолчанию механизмом хранения данных, вы должны задать его таковым в файле /etc/my.cnf, иначе по умолчанию будет применяться механизм хранения MyISAM. Редактирование очень простое: в раздел <blockquote>mysqld</blockquote> вставьте строку <blockquote>default-storage-engine=INNODB</blockquote>. К примеру, начало файла могло бы выглядеть следующим образом:</p>     <p><blockquote>[mysqld]</blockquote></p>     <p><blockquote>default-storage-engine=INNODB</blockquote></p>     <p><blockquote>datadir=/var/lib/mysql</blockquote></p>     <p><blockquote>...</blockquote></p>     <p>В оставшейся части данной главы мы полагаем, что по умолчанию в качества механизма хранения выбран InnoDB.</p>     <p>В процессе эксплуатации вам, как правило, придется также изменять установленное по умолчанию место хранения данных, задаваемое переменной <blockquote>datadir</blockquote>. Делается это тоже с помощью редактирования раздела <blockquote>mysql</blockquote> конфигурационного файла /etc/my.cnf. Например, если вы применяете механизм хранения InnoDB для размещения файлов данных в каталоге /vol02, а файлов регистрации — в каталоге /vol03 плюс задаете начальный размер файла данных 10 Мбайт с возможностью увеличения, можно использовать следующие конфигурационные строки:</p>     <p><blockquote>innodb_data_home_dir = /vol02/mysql/data</blockquote></p>     <p><blockquote>innodb_data_file_path = ibdata1:10M:autoextend</blockquote></p>     <p><blockquote>innodb_log_group_home_dir = /vol03/mysql/logs</blockquote></p>     <p>Более подробную информацию и другие конфигурационные параметры можно найти в интерактивных руководствах на Web-сайте <b>www.mysql.com.</b></p>     <blockquote>      <b>Примечание</b>      <p>Если сервер не запускается или вы не можете подключиться к базе данных после запуска сервера, см. следующий раздел, посвященный неполадкам после вашей установки сервера.</p>     </blockquote>     <p>Помните об имеющейся бреши в системе безопасности, упоминавшейся несколько разделов назад и позволяющей любому подключиться без пароля как пользователь root? Сейчас самое время усовершенствовать защиту. Не дайте сбить себя с толку имени пользователя root, применяемому во время установки MySQL. Между пользователем root СУРБД MySQL и пользователем root операционной системы нет никакой связи; MySQL просто регистрирует пользователя с именем "root" как администратора, что делает и ОС Linux. Пользователи базы данных MySQL и идентификаторы пользователей ОС Linux никак не связаны; у MySQL есть собственная встроенная система управления пользователями и правами доступа. По умолчанию пользователь с учетной записью в. вашей установленной системе Linux может зарегистрироваться на вашем сервере MySQL как администратор этой СУРБД. После того как вы ограничите права пользователя root СУРБД MySQL, например, разрешив только локальному пользователю регистрироваться с именем root и установив пароль для такого доступа, вы можете добавить только тех пользователей и только те права доступа, которые абсолютно необходимы для функционирования вашего приложения.</p>     <p>Установить пароль можно любым возможным способом, но самый простой с помощью команды:</p>     <p><blockquote>$ <b>mysqladmin -u root password newpassword</b></blockquote></p>     <p>Она задает начальный пароль <blockquote>newpassword</blockquote>.</p>     <p>Этот метод порождает проблему, заключающуюся в том, что понятный текстовый пароль остается в протоколе или хронологии (history) вашей командной оболочки и может просматриваться кем угодно с помощью команды <blockquote>ps</blockquote> во время выполнения вашей команды или может быть извлечен из протокола команды. Лучше еще раз применить монитор MySQL на этот раз для отправки нескольких команд на языке SQL, которые изменят ваш пароль.</p>     <p><blockquote>$ <b>mysql -u root</b></blockquote></p>     <p><blockquote>Welcome to the MySQL monitor. Commands end with ; or \g.</blockquote></p>     <p><blockquote>Your MySQL connection id is 4</blockquote></p>     <p><blockquote>Type 'help;' or '\h' for help. Type ' \c' to clear the buffer.</blockquote></p>     <p><blockquote>mysql&gt; <b>SET password=PASSWORD('secretpassword');</b></blockquote></p>     <p><blockquote>Query OK, 0 rows affected (0.00 sec)</blockquote></p>     <p>Конечно же, выберите пароль, известный только вам, а не пример "secretpassword", использованный нами в данном случае для того, чтобы показать, куда вводить ваш собственный пароль. Если вы когда-нибудь захотите удалить пароль, можно просто задать пустую строку на месте "secretpassword", и пароль будет удален.</p>     <blockquote>      <b>Примечание</b>      <p>Обратите внимание на то, что мы завершаем команды на языке SQL точкой с запятой (<blockquote>;</blockquote>). Строго говоря; она не является частью команды SQL, а применяется для того, чтобы сообщить программе-клиенту MySQL о том, что наша команда SQL готова к выполнению. Мы также пользуемся прописными буквами для ввода ключевых слов языка SQL, например, <blockquote>SET</blockquote>. Это не обязательно, потому что действительный синтаксис MySQL допускает ввод ключевых слов как прописными, так и строчными буквами, но мы применяем первый вариант как принятое соглашение в данной книге и в нашей повседневной работе, т.к. считаем, что это облегчает чтение команд SQL.</p>     </blockquote>     <p>Теперь рассмотрим таблицу прав доступа, чтобы убедиться в том, что пароль установлен. Сначала с помощью команды use переключитесь на базу данных mysql и затем запросите внутренние таблицы:</p>     <p><blockquote>mysql&gt;<b> use mysql</b></blockquote></p>     <p><blockquote>mysql&gt; <b>SELECT user, host, password FROM user;</b></blockquote></p>     <p><blockquote>+------+-----------+------------------+</blockquote></p>     <p><blockquote>| user | host      | password         |</blockquote></p>     <p><blockquote>+------+-----------+------------------+</blockquote></p>     <p><blockquote>| root | localhost | 2dxf8e9c23age6ed |</blockquote></p>     <p><blockquote>| root | fc7blp4e  |                  |</blockquote></p>     <p><blockquote>|      | localhost |                  |</blockquote></p>     <p><blockquote>|      | fc7blp4e  |                  |</blockquote></p>     <p><blockquote>+------+-----------+------------------+</blockquote></p>     <p><blockquote>4 rows in set (0.01 sec) mysql&gt;</blockquote></p>     <p>Отметьте, что вы создали пароль для пользователя root, только когда подключились с компьютера <blockquote>localhost</blockquote>. MySQL может хранить права доступа не только для пользователей, но и для классов соединений (connection classes), основанных на имени узла. Следующим шагом в защите вашей установки будет удаление ненужных пользователей, устанавливаемых MySQL по умолчанию. Приведенная далее команда удаляет из таблицы прав доступа всех пользователей с именами, отличающимися от root.</p>     <p><blockquote>mysql&gt; <b>DELETE FROM user WHEREuser != 'root';</b></blockquote></p>     <p><blockquote>Query OK, 2 rows affected (0.01 sec)</blockquote></p>     <p>Следующая команда удаляет все регистрации с машин, отличных от компьютера <blockquote>localhost</blockquote>.</p>     <p><blockquote>mysql&gt; <b>DELETE FROM user WHEREhost != 'localhost';</b></blockquote></p>     <p><blockquote>Query OK, 1 row affected (0.01 sec)</blockquote></p>     <p>И последнее, примените следующую команду для того, чтобы убедиться в отсутствии случайных регистраций:</p>     <p><blockquote>mysql&gt; <b>SELECT user, host, password FROM user;</b></blockquote></p>     <p><blockquote>+------+-----------+------------------+</blockquote></p>     <p><blockquote>| user | host      | password         |</blockquote></p>     <p><blockquote>+------+-----------+------------------+</blockquote></p>     <p><blockquote>| root | localhost | 2dxf8e9c23age6ed |</blockquote></p>     <p><blockquote>+------+-----------+------------------+</blockquote></p>     <p><blockquote>1 row in set (0.00 sec) mysql&gt; <b>exit</b></blockquote></p>     <p>Как видно из предыдущего вывода, теперь у вас есть только один зарегистрированный пользователь, который может подключаться только с машины localhost.</p>     <p>Внимание! Момент истины: можете ли вы в дальнейшем регистрироваться с паролем, который установили? На сей раз вы задаете параметр <blockquote>-p</blockquote>, который сообщает MySQL о необходимости вывести подсказку для ввода пароля:</p>     <p><blockquote>$ <b>mysql -u root -p</b></blockquote></p>     <p><blockquote>Enter password:</blockquote></p>     <p><blockquote>Welcome to the MySQL monitor. Commands end with ; or \g.</blockquote></p>     <p><blockquote>Your MySQL connection id is 7</blockquote></p>     <p><blockquote>Type 'help;' or '\h' for help. Type '\c' to clear the buffer.</blockquote></p>     <p><blockquote>mysql&gt;</blockquote></p>     <p>Теперь у вас есть работающая версия MySQL, заблокированная так, что только пользователь root с паролем, установленным вами, может подключиться к серверу базы данных и только с локальной машины. Подключиться к MySQL и ввести пароль вы можете из командной строки. Делается это с помощью параметра, <blockquote>--password</blockquote>, например, <blockquote>--password=secretpassword</blockquote> или <blockquote>-psecretpassword</blockquote>, но ясно, что это небезопасно, потому что пароль можно увидеть с помощью команды <blockquote>ps</blockquote> или просмотра хронологии команды. Однако ввод пароля в командной строке иногда просто необходим, например, если вы пишете сценарии, которым нужно подключаться к базе данных MySQL.</p>     <p>Следующий шаг — добавление пользователя или пользователей, которые нужны. В случае системы Linux, не следует без крайней необходимости использовать учетную запись root для регистрации в базе данных MySQL, лучше создать обычного пользователя для каждодневного применения.</p>     <p>Как мы отмечали ранее, вы можете создать пользователей с различными правами подключения с разных машин; в примере пользователю root из соображений безопасности разрешено подключаться только с локальной машины. В данной главе создадим нового пользователя широкими правами доступа. Rick сможет подключаться тремя разными способами:</p>     <p>&#9633; он сможет подключаться с локальной машины;</p>     <p>&#9633; он сможет подключаться с любой машины, IP-адрес которой находится в диапазоне от 192.168.0.0 до 192.168.0.255;</p>     <p>&#9633; он сможет подключаться с любой машины, входящей в домен wiley.com.</p>     <p>Самый легкий способ сделать это безопасно — создать трех разных пользователей с тремя разными зонами подключения. У этих пользователей по вашему желанию даже могут быть разные пароли, зависящие от того, с какого адреса они устанавливают соединение.</p>     <p>Создать пользователей и присвоить им полномочия можно с помощью команды <blockquote>grant:</blockquote>. Создадим пользователя с тремя только что перечисленными зонами, подключения. Ключевое слово <blockquote>IDENTIFIED BY</blockquote> — немного странная синтаксическая запись для задания начального пароля. Обратите внимание на способ применения кавычек; важно применять символы одинарных кавычек точно так, как показано, иначе вы не сможете создать пользователей, как намечали.</p>     <p>Подключитесь к MySQL как пользователь root и затем выполните следующие действия.</p>     <p>1. Создайте регистрацию входа с локальной машины (login) для пользователя rick.</p>     <p><blockquote>mysql&gt; <b>GRANT ALL ON *.* TO rick@localhost IDENTIFIED BY 'secretpassword';</b></blockquote></p>     <p><blockquote>Query OK, 0 rows affected (0.03 sec)</blockquote></p>     <p>2. Затем создайте регистрацию входа с любой машины из подсети класса С 192.168.0. Учтите, что следует использовать одинарные кавычки для защиты IP-диапазона и маску /255.255.255.0 для указания диапазона допустимых IP-адресов.</p>     <p><blockquote>mysql&gt; <b>GRANT ALL ON *.* TO rick@'192.168.0.0/255.255.255.0' IDENTIFIED BY 'secretpassword';</b></blockquote></p>     <p><blockquote>Query OK, 0 rows affected (0.00 sec)</blockquote></p>     <p>3. В заключение создайте такую регистрацию входа, чтобы пользователь rick мог зарегистрироваться с любой машины из домена wiley.com (и снова обратите внимание на одинарные кавычки).</p>     <p><blockquote>mysql&gt; <b>GRANT ALL ON *.* ТО rick@'%.wiley.com' IDENTIFIED BY 'secretpassword';</b></blockquote></p>     <p><blockquote>Query OK, 0 rows affected. (0.00 sec)</blockquote></p>     <p>4. Опять просмотрите таблицу пользователей, чтобы еще раз проверить все элементы!</p>     <p><blockquote>mysql&gt; <b>SELECT user, host, password FROM mysql.user;</b></blockquote></p>     <p><blockquote>+------+---------------------------+------------------+</blockquote></p>     <p><blockquote>| user | host                      | password         |</blockquote></p>     <p><blockquote>+------+---------------------------+------------------+</blockquote></p>     <p><blockquote>| root | localhost                 | 2dxf8e8cl7ade6ed |</blockquote></p>     <p><blockquote>| rick | localhost                 | 3742g6348q8378d9 |</blockquote></p>     <p><blockquote>| rick | %.wiley.com               | 3742g6348q8378d9 |</blockquote></p>     <p><blockquote>| rick | 192.168.0.0/255.255.255.0 | 3742g6348q8378d9 |</blockquote></p>     <p><blockquote>+------+---------------------------+------------------+</blockquote></p>     <p><blockquote>4 rows in set (0.00 sec)</blockquote></p>     <p><blockquote>mysql&gt;</blockquote></p>     <p>Естественно, необходимо откорректировать предшествующие команды и пароли в соответствии с вашими локальными настройками. Вы должны были заметить команду <blockquote>GRANT ALL ON *.*</blockquote>, которая, как вы наверное догадались, предоставляет пользователю rick обширные права доступа. Это хорошо для опытного пользователя, но не годится для обычных пользователей. Мы более подробно обсудим команду <blockquote>grant</blockquote> в<i> разд. "Создание пользователей и наделение их правами доступа" далее в этой главе</i>, где среди прочего покажем, как создать пользователя с ограниченными правами доступа.</p>     <p>Теперь, когда вы установили и запустили СУРБД MySQL (если нет, см. следующий раздел), сделали установку более безопасной, и создали пользователя- неадминистратора, готового выполнять кое-какую работу, кратко обсудим поиск и устранение неисправностей после установки, а затем немного вернемся назад и дадим краткий обзор основ администрирования базы данных MySQL.</p>             <a name="metkadoc5"><h1>Устранение неисправностей после установки</h1></a>     <p>Если при использовании mysql нет подключения к базе данных, проверьте с помощью системной команды ps, запущен ли серверный процесс. Если его нет в списке, попробуйте запустить <blockquote>mysql_safed -log</blockquote>. В этом случае в регистрационный каталог MySQL должен быть записан файл с дополнительной информацией. Можно конечно попытаться явно запустить процесс mysqld; используйте команду <blockquote>mysqld --verbose --help</blockquote> для получения полного списка опций командной строки.</p>     <p>Вполне возможно, что сервер функционирует, но просто отвергает ваше подключение. Если так, далее следует проверить наличие базы данных, особенно базы данных стандартных прав доступа MySQL (default permissions database). В дистрибутивах Red Hat она обычно по умолчанию располагается в /var/lib/mysqlis, другие дистрибутивы используют разные каталоги. Проверьте сценарий запуска MySQL (например, в файле /etc/init.d) и конфигурационный файл /etc/my.cnf. В противном случае запустите программу явно с помощью команды <blockquote>mysqld --verbose --help</blockquote> и найдите переменную <blockquote>datadir</blockquote>. После того как вы определили каталог базы данных, проверьте, содержит ли он хотя бы базу данных стандартных прав доступа (с именем mysql) и что именно ее, заданную в файле my.cnf, использует процесс-демон сервера.</p>     <p>Если вы все еще не подключились, воспользуйтесь редактором сервисов (service editor) для остановки сервера, убедитесь в том, что не выполняется ни один процесс mysqld, и затем перезапустите его снова и попробуйте подключиться. Если вы все- таки никуда не попали, можно полностью деинсталлировать MySQL и установить ее с нуля еще раз. Для выяснения некоторых известных только посвященным возможностей очень полезной может оказаться документация MySQL на Web-сайте (более свежая, чем интерактивное руководство на локальной машине, кроме того, в ней есть редактируемые пользователями подсказки, и предложения, и форум).</p>              <a name="metkadoc6"><h1>Администрирование MySQL</h1></a>         <p>Группа программ-утилит, включенных в дистрибутив MySQL, облегчает процесс администрирования базы данных. Самая популярная из них — программа mysqladmin. В следующем разделе мы опишем эту и другие утилиты.</p>             <a name="metkadoc7"><h1>Команды</h1></a>     <p>Все команды MySQL, за исключением <blockquote>mysqlshow</blockquote>, принимают как минимум три стандартных параметра, описанных в табл. 8.1.</p>     <br>     <p><b><i>Таблица 8.1</i></b></p>     <table>      <tr>       <th valign="top">Опция команды</th>       <th valign="top">Параметр</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>-u</blockquote></td>       <td valign="top"><blockquote>username</blockquote></td>       <td valign="top">По умолчанию утилиты mysql будут пытаться использовать то же username MySQL, что и текущее имя пользователя Linux. Применяйте параметр <blockquote>-u</blockquote> для задания другого имени пользователя</td>      </tr>      <tr>       <td valign="top"><blockquote>-р</blockquote></td>       <td valign="top"><blockquote>[password]</blockquote></td>       <td valign="top">Если параметр <blockquote>-р</blockquote> задан, а пароль пропущен, он запрашивается. Если параметра <blockquote>-p</blockquote> нет в командной строке, команды MySQL полагают, что пароль не нужен</td>      </tr>      <tr>       <td valign="top"><blockquote>-h</blockquote></td>       <td valign="top"><blockquote>host</blockquote></td>       <td valign="top">Применяется для подключения к серверу на другой машине (для локальных серверов всегда можно опускать)</td>      </tr>     </table>     <blockquote>      <b>Примечание</b>      <p>И снова не советуем вам помещать пароль в командную строку, поскольку его можно увидеть с помощью команды <blockquote>ps</blockquote>.</p>     </blockquote>     <b><i>myisamchk</i></b>     <p>Утилита <blockquote>myisamchk</blockquote> разработана для проверки и корректировки любых таблиц данных, применяющих стандартный табличный формат MYISAM, исходно поддерживаемый СУРБД MySQL. Обычно утилиту <blockquote>myisamchk</blockquote> следует запускать от имени пользователя mysql, созданного во время установки, из каталога, в котором размещаются таблицы. Для проверки базы данных выполните команду <blockquote>su mysql</blockquote>, измените название каталога в соответствии с именем базы данных и запустите утилиту <blockquote>myisamchk</blockquote> с одной или несколькими опциями, предложенными в табл. 8.2. Например,</p>     <p><blockquote>myisamchk -e -r *.MYI</blockquote></p>     <p>Самые популярные опции команды приведены в табл. 8.2.</p>     <br>     <p><i><b>Таблица 8.2</b></i></p>     <table>      <tr>       <th valign="top">Опция команды</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>-с</blockquote></td>       <td valign="top">Ищет ошибки в таблицах</td>      </tr>      <tr>       <td valign="top"><blockquote>-e</blockquote></td>       <td valign="top">Выполняет расширенную проверку</td>      </tr>      <tr>       <td valign="top"><blockquote>-r</blockquote></td>       <td valign="top">Исправляет найденные ошибки</td>      </tr>     </table>     <p>Дополнительную информацию можно получить, запустив <blockquote>myisamchk</blockquote> без параметров и просмотрев подробные сообщения системы помощи. Данная утилита никак не влияет на таблицы формата InnoDB.</p>     <b><i>mysql</i></b>     <p>Это основное и очень мощное средство командной строки СУРБД MySQL. С его помощью тем или иным способом можно выполнить любую административную или пользовательскую задачу. Запустить монитор <blockquote>mysql</blockquote> можно из командной строки; добавив заключительный дополнительный параметр, имя базы данных, вы сможете в мониторе обойтись без команды <blockquote>use &lt;<i>база_данных</i>&gt;</blockquote>. Далее приведен пример запуска монитора от имени пользователя rick, запроса пароля (обратите внимание на пробел после <blockquote>-p</blockquote>) и применения базы данных <blockquote>foo</blockquote> по умолчанию.</p>     <p><blockquote>$ <b>mysql -u rick -р foo</b></blockquote></p>     <p>Для постраничного просмотра других опций командной строки монитора mysql примените команду <blockquote>mysql --help | less</blockquote>.</p>     <p>Если вы запускаете СУРБД MySQL без указания базы данных, для выбора одной из баз данных можно использовать опцию <blockquote>use &lt;<i>база_данных</i>&gt;</blockquote><i>, </i>приведенную в списке команд в табл. 8.3.</p>     <p>Монитор <blockquote>mysql</blockquote> можно выполнить и в неинтерактивном режиме, собрав команды во входном файле и считывая его из командной строки. В этом случае вы должны задать пароль в командной строке.</p>     <p><blockquote>$<b> mysql -u rick --password=secretpassword foo &lt; sqlcommands.sql</b></blockquote></p>     <p>После считывания и выполнения ваших команд mysql выведет на экран строку приглашения.</p>     <p>Во время подключения программы-клиента mysql к серверу в дополнение к стандартному набору команд SQL92 поддерживается ряд специфических команд, перечисленных в табл. 8.3.</p>     <br>     <p><b><i>Таблица 8.3</i></b></p>     <table>      <tr>       <th valign="top">Команда</th>       <th valign="top">Краткая форма</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>help</blockquote> или <blockquote>?</blockquote></td>       <td valign="top"><blockquote>\h</blockquote> или <blockquote>\?</blockquote></td>       <td valign="top">Отображает список команд</td>      </tr>      <tr>       <td valign="top"><blockquote>edit</blockquote></td>       <td valign="top"><blockquote>\е</blockquote></td>       <td valign="top">Редактирует команду. Применяемый редактор задается переменной окружения <blockquote>$EDITOR</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>exit</blockquote> или <blockquote>quit</blockquote></td>       <td valign="top"><blockquote>\q</blockquote></td>       <td valign="top">Завершает программу-клиент MySQL</td>      </tr>      <tr>       <td valign="top"><blockquote>go</blockquote></td>       <td valign="top"><blockquote>\g</blockquote></td>       <td valign="top">Выполняет команду</td>      </tr>      <tr>       <td valign="top"><blockquote>source &lt;<i>имя_файла</i>&gt;</blockquote></td>       <td valign="top"><blockquote>\.</blockquote></td>       <td valign="top">Выполняет команды SQL из заданного файла</td>      </tr>      <tr>       <td valign="top"><blockquote>status</blockquote></td>       <td valign="top"><blockquote>\s</blockquote></td>       <td valign="top">Отображает информацию о состоянии сервера</td>      </tr>      <tr>       <td valign="top"><blockquote>system &lt;<i>команда</i>&gt;</blockquote></td>       <td valign="top"><blockquote>\!</blockquote></td>       <td valign="top">Выполняет системную команду</td>      </tr>      <tr>       <td valign="top"><blockquote>tee &lt;имя_<i>файла</i>&gt;</blockquote></td>       <td valign="top"><blockquote>\T</blockquote></td>       <td valign="top">Добавляет в конец заданного файла копию всего вывода</td>      </tr>      <tr>       <td valign="top"><blockquote>use &lt;<i>база_данных</i>&gt;</blockquote></td>       <td valign="top"><blockquote>\u</blockquote></td>       <td valign="top">Использует заданную базу данных</td>      </tr>     </table>     <p>Очень важная команда в этом наборе — <blockquote>use</blockquote>. Сервер <blockquote>mysqld</blockquote> предназначен для поддержки множества различных баз данных, обслуживаемых и управляемых одним серверным процессом. Во многих других серверах баз данных, таких как Oracle и Sybase, применяется термин<i> "схема",</i> а в СУРБД MySQL чаще используется термин <i>"база данных".</i> (В обозревателе запросов (Query Browser) MySQL, к примеру, применяется термин<i> "схема".)</i> Каждая база данных (в терминологии MySQL) представляет собой в основном независимый набор таблиц. Это позволяет настраивать разные базы данных для различных целей и назначать разных пользователей различным базам данных, используя для эффективного управления ими один и тот же сервер баз данных. С помощью команды <blockquote>use</blockquote> можно при наличии соответствующих прав переключаться между различными базами данных.</p>     <p>Особая база данных <blockquote>mysql</blockquote>, создаваемая автоматически при каждой установке СУРБД MySQL, применяется как основное хранилище сведений о пользователях и правах доступа.</p>     <blockquote>      <b>Примечание</b>      <p>SQL92 — наиболее часто применяемая версия стандарта ANSI языка SQL. Ее назначение — формирование единообразия способов управления базами данных с применением SQL, обеспечивающего взаимодействие и взаимосвязь баз данных разных производителей.</p>     </blockquote>     <b><i>mysqladmin</i></b>     <p>Эта утилита — основное средство быстрого администрирования базы данных MySQL. В дополнение к обычным параметрам она поддерживает основные команды, перечисленные в табл. 8.4.</p>     <br>     <p><b><i>Таблица 8.4</i></b></p>     <table>      <tr>       <th valign="top">Команда</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>create &lt;<i>база_данных</i>&gt;</blockquote></td>       <td valign="top">Создает новую базу данных</td>      </tr>      <tr>       <td valign="top"><blockquote>drop &lt;<i>база_данных</i>&gt;</blockquote></td>       <td valign="top">Удаляет базу данных</td>      </tr>      <tr>       <td valign="top"><blockquote>password &lt;<i>новый_пароль</i>&gt;</blockquote></td>       <td valign="top">Изменяет пароль (как вы уже видели)</td>      </tr>      <tr>       <td valign="top"><blockquote>ping</blockquote></td>       <td valign="top">Проверяет, работает ли сервер</td>      </tr>      <tr>       <td valign="top"><blockquote>reload</blockquote></td>       <td valign="top">Повторно загружает таблицы полномочий, управляющие правами доступа</td>      </tr>      <tr>       <td valign="top"><blockquote>status</blockquote></td>       <td valign="top">Предоставляет сведения о состоянии сервера</td>      </tr>      <tr>       <td valign="top"><blockquote>shutdown</blockquote></td>       <td valign="top">Выключает сервер</td>      </tr>      <tr>       <td valign="top"><blockquote>variables</blockquote></td>       <td valign="top">Отображает переменные, управляющие работой MySQL, и их текущие значения</td>      </tr>      <tr>       <td valign="top"><blockquote>version</blockquote></td>       <td valign="top">Выводит номер версии сервера и время его работы</td>      </tr>     </table>     <p>Запустите из строки приглашения утилиту <blockquote>mysqladmin</blockquote> без параметров, чтобы увидеть полный список опций. Вам потребуется применить <blockquote>| less</blockquote>.</p>     <b><i>mysqlbug</i></b>     <p>Если чуть повезет, вам никогда не представится шанс применить эту утилиту. Судя по имени, это средство создает отчет об ошибках для отправки в группу технической поддержки MySQL. Перед отправкой есть возможность отредактировать сформированный файл, включив в него дополнительную информацию, которая может оказаться полезной разработчикам.</p>     <b><i>mysqldump</i></b>     <p>Это крайне полезная утилита, позволяющая получить частичный или полный дамп базы данных в виде единого файла с набором команд языка SQL, которые могут быть считаны обратно в MySQL или в другую СУРБД. Она принимает как параметр стандартную информацию о пользователе и пароль, а также имена базы данных и таблиц. Дополнительные опции, приведенные в табл. 8.5, существенно расширяют функциональные возможности этой утилиты.</p>     <br>     <p><b><i>Таблица 8.5</i></b></p>     <table>      <tr>       <th valign="top">Команда</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>--add-drop-table</blockquote></td>       <td valign="top">Вставляет в файл вывода операторы SQL для удаления любых таблиц перед командой их создания</td>      </tr>      <tr>       <td valign="top"><blockquote>-e</blockquote></td>       <td valign="top">Применяет расширенный синтаксис вставки. Это нестандартный язык SQL, но если вы получаете дамп больших объемов информации, это поможет гораздо быстрее повторно загрузить дамп вашей базы в СУРБД MySQL</td>      </tr>      <tr>       <td valign="top"><blockquote>-t</blockquote></td>       <td valign="top">Получает дамп только данных из таблиц, а не информации, необходимой для создания таблиц</td>      </tr>      <tr>       <td valign="top"><blockquote>-d</blockquote></td>       <td valign="top">Получает дамп только структуры таблиц, а не реальных данных</td>      </tr>     </table>     <p>По умолчанию <blockquote>mysqldump</blockquote> посылает эти данные в стандартный вывод, поэтому вам потребуется перенаправление их в файл.</p>     <p>Эта утилита очень удобна для перемещения данных или быстрого создания резервных копий, и благодаря клиент-серверной реализации MySQL ее даже можно использовать для выполнения сложного удаленного резервного копирования с помощью клиента <blockquote>mysqldump</blockquote>, установленного на другой машине. Далее для примера приведена команда подключения пользователя rick и получения дампа базы данных <blockquote>myplaydb</blockquote>:</p>     <p><blockquote>$ <b>mysqldump -u rick -p myplaydb &gt; myplaydb.dump</b></blockquote></p>     <p>Результирующий файл, у которого в нашей системе только одна таблица в базе данных, выглядит следующим образом:</p>     <p><blockquote>-- MySQL dump 10.11</blockquote></p>     <p><blockquote>--</blockquote></p>     <p><blockquote>-- Host: localhost Database: myplaydb</blockquote></p>     <p><blockquote>-- --------------------------------------------------</blockquote></p>     <p><blockquote>-- Server version 5.0.37</blockquote></p>     <p><blockquote>/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;</blockquote></p>     <p><blockquote>/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;</blockquote></p>     <p><blockquote>/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;</blockquote></p>     <p><blockquote>/*!40101 SET NAMES utf8 */;</blockquote></p>     <p><blockquote>/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;</blockquote></p>     <p><blockquote>/*!40103 SET TIME_ZONE='+00:00' */;</blockquote></p>     <p><blockquote>/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;</blockquote></p>     <p><blockquote>/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0*/;</blockquote></p>     <p><blockquote>/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/;</blockquote></p>     <p><blockquote>/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;</blockquote></p>     <p><blockquote>--</blockquote></p>     <p><blockquote>-- Table structure for table 'children'</blockquote></p>     <p><blockquote>--</blockquote></p>     <p><blockquote>DROP TABLE IF EXISTS 'children';</blockquote></p>     <p><blockquote>CREATE TABLE 'children' (</blockquote></p>     <p><blockquote> 'childno' int(11) NOT NULL auto_increment,</blockquote></p>     <p><blockquote> 'fname' varchar(30) default NULL,</blockquote></p>     <p><blockquote> 'age' int(11) default NULL,</blockquote></p>     <p><blockquote> PRIMARY KEY ('childno')</blockquote></p>     <p><blockquote>) ENGINE=InnoDB DEFAULT CHARSET=latin1;</blockquote></p>     <p><blockquote>--</blockquote></p>     <p><blockquote>-- Dumping data for table 'children'</blockquote></p>     <p><blockquote>--</blockquote></p>     <br>     <p><blockquote>LOCK TABLES 'children' WRITE;</blockquote></p>     <p><blockquote>/*!40000 ALTER TABLE 'children'DISABLE KEYS */;</blockquote></p>     <p><blockquote>INSERT INTO 'children' VALUES</blockquote></p>     <p><blockquote>(1,'Jenny',21),(2,'Andrew',17),(3,'Gavin',8), (4,'Duncan',6),(5,'Emma',4),</blockquote></p>     <p><blockquote>(6,'Alex',15),(7,'Adrian',9);</blockquote></p>     <p><blockquote>/*!40000 ALTER TABLE 'children'ENABLE KEYS */;</blockquote></p>     <p><blockquote>UNLOCK TABLES;</blockquote></p>     <p><blockquote>/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;</blockquote></p>     <br>     <p><blockquote>/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;</blockquote></p>     <p><blockquote>/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;</blockquote></p>     <p><blockquote>/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;</blockquote></p>     <p><blockquote>/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;</blockquote></p>     <p><blockquote>/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;</blockquote></p>     <p><blockquote>/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;</blockquote></p>     <p><blockquote>/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;</blockquote></p>     <br>     <p><blockquote>-- Dump completed on 2007-0.6-22 20:11:48</blockquote></p>     <b><i>mysqlimport</i></b>     <p>Команда <blockquote>mysqlimport</blockquote> применяется для загрузки в таблицу большого количества данных. С помощью <blockquote>mysqlimport</blockquote> вы можете считывать из файла ввода большие объемы текстовых данных. Этой команде требуются только имена файла и базы данных; <blockquote>mysqlimport</blockquote> загрузит данные в базу данных, в таблицу с тем же именем, что и имя файла (за исключением расширения файла). Вы должны убедиться в том, что в текстовом файле столько же столбцов данных, сколько их в таблице, заполняемой данными, и типы данных совместимы. По умолчанию данные следует разделять знаком табуляции.</p>     <p>Можно также выполнять команды SQL из текстового файла, просто запустив <blockquote>mysql</blockquote> с перенаправлением ввода из файла, как мы упоминали ранее.</p>     <b><i>mysqlshow</i></b>     <p>Эта маленькая утилита может быстро предоставить информацию о вашей установке MySQL и составляющих ее базах данных.</p>     <p>&#9633; Без параметров она отображает все имеющиеся базы данных.</p>     <p>&#9633; С базой данных в качестве параметра она выводит таблицы этой базы данных.</p>     <p>&#9633; С именами базы данных и таблицы утилита отображает перечень столбцов заданной таблицы.</p>     <p>&#9633; Если заданы база данных, таблица и столбец, утилита выводит подробную информацию о заданном столбце.</p>             <a name="metkadoc8"><h1>Создание пользователей и наделение их правами доступа</h1></a>     <p>В роли администратора MySQL вам чаще всего придется обслуживать пользователей: добавлять, и удалять пользователей СУРБД MySQL и управлять их полномочиями. Начиная с версии MySQL 3.22, правами доступа или полномочиями пользователей управляют в мониторе MySQL с помощью команд <blockquote>grant</blockquote> и <blockquote>revoke</blockquote> — задача, гораздо менее устрашающая, чем непосредственная корректировка таблиц прав доступа, которая требовалась в ранних версиях MySQL.</p>     <b><i>grant</i></b>     <p>Команда MySQL <blockquote>grant</blockquote> почти, хотя и не полностью, соответствует синтаксису стандарта SQL92. Далее приведен общий формат:</p>     <p><blockquote>grant &lt;<i>привилегия</i>&gt; on &lt;<i>объект</i>&gt; to &lt;<i>пользователь</i>&gt; [identified by user-password] [with grant option];</blockquote></p>     <p>В табл. 8.6 перечислено несколько значений прав доступа, которые могут быть предоставлены.</p>     <br>     <p><b><i>Таблица 8.6</i></b></p>     <table>      <tr>       <th valign="top">Значение</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>alter</blockquote></td>       <td valign="top">Изменять таблицы и индексы</td>      </tr>      <tr>       <td valign="top"><blockquote>create</blockquote></td>       <td valign="top">Создавать базы данных и таблицы</td>      </tr>      <tr>       <td valign="top"><blockquote>delete</blockquote></td>       <td valign="top">Удалять данные из базы данных.</td>      </tr>      <tr>       <td valign="top"><blockquote>drop</blockquote></td>       <td valign="top">Удалять базы данных и таблицы</td>      </tr>      <tr>       <td valign="top"><blockquote>index</blockquote></td>       <td valign="top">Управлять индексами</td>      </tr>      <tr>       <td valign="top"><blockquote>insert</blockquote></td>       <td valign="top">Вставлять данные в базу данных</td>      </tr>      <tr>       <td valign="top"><blockquote>lock tables</blockquote></td>       <td valign="top">Разрешает блокировать таблицы</td>      </tr>      <tr>       <td valign="top"><blockquote>select</blockquote></td>       <td valign="top">Извлекать данные</td>      </tr>      <tr>       <td valign="top"><blockquote>update</blockquote></td>       <td valign="top">Изменять данные</td>      </tr>      <tr>       <td valign="top"><blockquote>all</blockquote></td>       <td valign="top">Все вышеперечисленные</td>      </tr>     </table>     <p>У некоторых прав доступа есть дополнительные опции. Например, <blockquote>create view</blockquote> дает пользователю право создавать представления. Для получения полного списка прав доступа обратитесь к документации MySQL, относящейся к вашей версии СУРБД, поскольку эта область расширяется с каждой новой версией MySQL. Существует также несколько специальных административных прав доступа, но здесь мы их не рассматриваем.</p>     <p>Объект, которому вы предоставляете данные права, обозначается как</p>     <p><blockquote>databasename.tablename</blockquote></p>     <p>и в лучших традициях Linux <blockquote>*</blockquote> — ссылка на любое имя, поэтому <blockquote>*.*</blockquote> означает все объекты в каждой базе данных, a <blockquote>foo.*</blockquote> — все таблицы в базе данных <blockquote>foo</blockquote>.</p>     <p>Если заданный пользователь уже существует, права доступа корректируются с учетом вносимых вами изменений. Если такого пользователя нет, он создается с заданными правами доступа. Как вы уже видели, пользователей можно задавать на определенных компьютерах. Пользователя и компьютер следует задавать в одной команде для того, чтобы в полной мере использовать гибкость схемы предоставления прав доступа MySQL.</p>     <p>В синтаксисе языка SQL специальный символ <blockquote>%</blockquote> — символ подстановки, во многом сходный, с символом <blockquote>*</blockquote> в среде командной оболочки. Вы можете формировать отдельные команды для каждого требуемого набора прав доступа, но если, например, вы хотите предоставить доступ пользователю rick с любого компьютера в домене wiley.com, пользователя rick можно описать как</p>     <p><blockquote>rick@'%.wiley.com'</blockquote></p>     <p>Символ подстановки <blockquote>%</blockquote> всегда следует заключать в кавычки для того, чтобы отделить его от остальных текстовых данных.</p>     <p>Вы также можете применять нотацию IP/Netmask (N.N.N.N/M.M.M.M), задающую сетевой адрес для управления доступом.</p>     <p>Также, как раньше вы использовали описание <blockquote>rick@'192.163.0.0/255.255.255.0'</blockquote> для предоставления пользователю rick доступа с любого сетевого компьютера, можно задать <blockquote>rick@'192.168.0.1'</blockquote> для ограничения доступа пользователя rick единственной рабочей станцией или ввести <blockquote>rick@'192.0.0.0/255.0.0.0'</blockquote>, расширив область действия прав до любой машины в сети 192 класса А.</p>     <p>В еще одном примере команда</p>     <p><blockquote>mysql&gt; <b>GRANT ALL ON foo.* TO rick@'%' IDENTIFIED BY 'bar';</b></blockquote></p>     <p>создает пользователя rick с полным набором прав доступа к базе данных <blockquote>foo</blockquote> для подключения с любой машины с начальным паролем <blockquote>bar</blockquote>.</p>     <p>Если базы данных <blockquote>foo</blockquote> до сих пор не существует, у пользователя rick теперь появится право создать ее с помощью команды SQL <blockquote>create database</blockquote>.</p>     <p>Ключевые слова <blockquote>IDENTIFIED BY</blockquote> — не обязательная часть команды, но убедиться в том, что у всех пользователей во время их создания появляются пароли, совсем неплохо.</p>     <p>Следует быть особенно внимательными, имея дело с именами пользователей, компьютеров или баз данных, содержащими знак подчеркивания, поскольку символ <blockquote>_</blockquote> в языке SQL соответствует любому одиночному символу во многом так же, как знак <blockquote>%</blockquote> соответствует любой строке символов. Везде, где это возможно, старайтесь избегать использования символа подчеркивания в именах пользователей и баз данных.</p>     <p>Обычно ключевые слова <blockquote>with grant option</blockquote> применяются только для создания вспомогательного административного пользователя, но они также могут использоваться для разрешения вновь созданному пользователю получить права доступа, предоставляемые ему другими пользователями. Всегда применяйте ключевые слова <blockquote>with grant option</blockquote> обдуманно.</p>     <b><i>revoke</i></b>     <p>Естественно, администратор не может только предоставлять права, но также и лишает прав. Делается это с помощью команды <blockquote>revoke</blockquote>.</p>     <p><blockquote>revoke &lt;<i>привилегия</i>&gt; on &lt;о<i>бъект</i>&gt; from &lt;<i>пользователь</i>&gt;</blockquote></p>     <p>и с применением почти такого же формата, как в команде <blockquote>grant</blockquote>. Например:</p>     <p><blockquote>mysql&gt; <b>REVOKE INSERT ON foo.* FROM rick@'%';</b></blockquote></p>     <p>Но команда <blockquote>revoke</blockquote> не удаляет пользователей. Если вы хотите удалить пользователя окончательно, не просто измените его права доступа, а примените команду <blockquote>revoke</blockquote> для удаления его прав. Затем вы сможете полностью удалить его из таблицы пользователей <blockquote>user</blockquote>, переключившись на внутреннюю базу данных <blockquote>mysql</blockquote> и удалив соответствующие строки из таблицы <blockquote>user</blockquote>.</p>     <p><blockquote>mysql&gt;<b> use mysql</b></blockquote></p>     <p><blockquote>mysql&gt; <b>DELETE FROM user WHERE user = "rick"</b></blockquote></p>     <p><blockquote>mysql&gt;<b> FLUSH PRIVILEGES;</b></blockquote></p>     <p>Отказавшись от указания компьютера, вы обеспечите удаление всех записей, относящихся к пользователю MySQL, в данном случае rick, которого хотите удалить. После этого убедитесь в том, что вы вернулись в вашу базу данных (с помощью команды <blockquote>use</blockquote>), иначе вы можете случайно продолжить работу с собственной внутренней базой данных MySQL.</p>     <blockquote>      <b>Примечание</b>      <p>Имейте в виду, что команда <blockquote>delete</blockquote> не относится к группе команд <blockquote>grant</blockquote> и <blockquote>revoke</blockquote>. Синтаксис SQL делает ее применение необходимым из-за способа обработки прав доступа в MySQL. Вы напрямую обновляете таблицы прав доступа MySQL (поэтому первой применяется команда <blockquote>use mysql</blockquote>) для внесения нужных вам изменений эффективным способом.</p>      <p>После обновления таблиц, как показано в примерах, вы должны применить команду <blockquote>FLUSH PRIVILEGES</blockquote>, чтобы сообщить серверу MySQL о необходимости перезагрузки таблиц с правами доступа.</p>     </blockquote>             <a name="metkadoc9"><h1>Пароли</h1></a>     <p>Если вы хотите задать пароли для уже существующих пользователей, не имевших их до сих пор, или изменить собственный или чей-то пароль, следует подключиться к серверу MySQL как пользователь root и напрямую обновить данные пользователя. Например,</p>     <p><blockquote>mysql&gt; <b>use mysql</b></blockquote></p>     <p><blockquote>mysql&gt; <b>SELECT host, user, password FROM user;</b></blockquote></p>     <p>Вы должны получить перечень, похожий на следующий:</p>     <p><blockquote>+-----------+------+------------------+</blockquote></p>     <p><blockquote>| host      | user | password         |</blockquote></p>     <p><blockquote>+-----------+------+------------------+</blockquote></p>     <p><blockquote>| localhost | root | 67457e226a1a15bd |</blockquote></p>     <p><blockquote>| localhost | foo  |                  |</blockquote></p>     <p><blockquote>+-----------+------+------------------+</blockquote></p>     <p><blockquote>2 rows in set (0.00 sec)</blockquote></p>     <p>Если вы хотите присвоить пароль bar пользователю foo, можно сделать следующее:</p>     <p><blockquote>mysql&gt; <b>UPDATE user SET password = password('bar') WHERE user = 'foo';</b></blockquote></p>     <p>Для проверки выведите снова соответствующие столбцы таблицы пользователей <blockquote>user</blockquote>:</p>     <p><blockquote>mysql&gt; <b>SELECT host, user, password FROM user;</b></blockquote></p>     <p><blockquote>+-----------+------+------------------+</blockquote></p>     <p><blockquote>| host      | user | password         |</blockquote></p>     <p><blockquote>+-----------+------+------------------+</blockquote></p>     <p><blockquote>| localhost | root | 65457e236glalwbq |</blockquote></p>     <p><blockquote>| localhost | foo  | 7c9e0a41222752fa |</blockquote></p>     <p><blockquote>+-----------+------+------------------+</blockquote></p>     <p><blockquote>2 rows in set (0.00 sec) mysql&gt;</blockquote></p>     <p>Теперь наверняка у пользователя foo есть пароль. Не забудьте вернуться в свою исходную базу данных.</p>     <p>Начиная с версии MySQL 4.1, схема формирования паролей обновлена по сравнению с более ранними версиями. Но для обратной совместимости вы все еще можете задавать пароль, применяя старый алгоритм с функцией <blockquote>OLD_PASSWORD('password to set')</blockquote>, если вам это нужно.</p>             <a name="metkadoc10"><h1>Создание базы данных</h1></a>     <p>Следующий ваш шаг — создание базы данных. Предположим, что вам нужна база данных с именем <blockquote>rick</blockquote>. Напоминаем о том, что вы уже создали пользователя с тем же именем. Сначала надо предоставить пользователю rick широкий ряд полномочий, чтобы он мог создавать новые базы данных. В среде разработки это особенно полезно, т. к. обеспечивает больше гибкости.</p>     <p><blockquote>mysql&gt; <b>GRANT ALL ON *.* TO rick@localhost IDENTIFIED BY 'secretpassword';</b></blockquote></p>     <p>Теперь протестируйте набор прав доступа, зарегистрировавшись как rick, и создайте базу данных:</p>     <p><blockquote>$ <b>mysql -u rick -р</b></blockquote></p>     <p><blockquote>Enter password:</blockquote></p>     <p><blockquote>...</blockquote></p>     <p><blockquote>mysql&gt; <b>CREATE DATABASE rick;</b></blockquote></p>     <p><blockquote>Query OK, 1 row affected (0.01 sec).</blockquote></p>     <p><blockquote>mysql&gt;</blockquote></p>     <p>Далее сообщите MySQL о том, что вы хотите переключиться на вашу новую базу данных:</p>     <p><blockquote>mysql&gt; <b>use rick</b></blockquote></p>     <p>Сейчас вы можете ввести в вашу базу данных таблицы и нужные вам данные. Во время последующих регистрации вы сможете задавать базу данных в конце командной строки и избежать применения команды <blockquote>use</blockquote>.</p>     <p><blockquote>$ <b>mysql -u rick -p rick</b></blockquote></p>     <p>Введя после подсказки пароль, вы автоматически, в ходе процесса подключения, переключитесь на использование базы данных rick по умолчанию.</p>             <a name="metkadoc11"><h1>Типы данных</h1></a>     <p>Итак, у вас есть действующий сервер MySQL, безопасная регистрация вашего пользователя и база данных, готовая к применению. Что дальше? Сейчас нужно создать несколько таблиц со столбцами для хранения данных. Но прежде чем вы сможете сделать это, следует узнать о типах данных, поддерживаемых MySQL.</p>     <p>Типы данных MySQL довольно обычны, поэтому мы лишь бегло пробежимся по основным типам, и как всегда более подробную информацию можно найти в руководстве по MySQL на Web-сайте MySQL.</p>     <b>Тип <i>Boolean</i></b>     <p>Столбец логического типа можно определить с помощью ключевого слова <blockquote>BOOL</blockquote>. Как вы и ожидали, в нем могут храниться значения <blockquote>TRUE</blockquote> и <blockquote>FALSE</blockquote>, а также специальное "неопределенное" значение баз данных <blockquote>NULL</blockquote>.</p>     <b>Символьный тип</b>     <p>В табл. 8.7 перечислены все доступные символьные типы. Первые три — стандартные, оставшиеся три специфичны для MySQL. Мы полагаем, что на практике вы будете придерживаться стандартных типов.</p>     <br>     <p><b><i>Таблица 8.7</i></b></p>     <table>      <tr>       <th valign="top">Определение</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>CHAR</blockquote></td>       <td valign="top">Одиночный символ</td>      </tr>      <tr>       <td valign="top"><blockquote>CHAR(<i>N</i>)</blockquote></td>       <td valign="top">Символьная строка длиной точно <blockquote><i>N</i></blockquote> символов, которая будет при необходимости заполняться пробелами. Максимальная длина 255 символов</td>      </tr>      <tr>       <td valign="top"><blockquote>VARCHAR(<i>N</i>)</blockquote></td>       <td valign="top">Массив переменной длины из <blockquote><i>N</i></blockquote> символов. Максимальная длина 255 символов</td>      </tr>      <tr>       <td valign="top"><blockquote>TINYTEXT</blockquote></td>       <td valign="top">Аналогичен <blockquote>VARCHAR(<i>N</i>)</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>MEDIUMTEXT</blockquote></td>       <td valign="top">Текстовая строка длиной до 65 535 символов</td>      </tr>      <tr>       <td valign="top"><blockquote>LONGTEXT</blockquote></td>       <td valign="top">Текстовая строка длиной до 2&#179;&#178;–1 символов</td>      </tr>     </table>     <b>Числовой тип</b>     <p>В табл. 8.8 показано, что числовые типы делятся на целочисленные и типы с плавающей точкой.</p>     <br>     <p><b><i>Таблица 8.8</i></b></p>     <table>      <tr>       <th valign="top">Определение</th>       <th valign="top">Тип</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>TINYINT</blockquote></td>       <td valign="top">Целочисленный</td>       <td valign="top">8-битный тип данных</td>      </tr>      <tr>       <td valign="top"><blockquote>SMALLINT</blockquote></td>       <td valign="top">Целочисленный</td>       <td valign="top">16-битный тип данных</td>      </tr>      <tr>       <td valign="top">MEDIUMINT</td>       <td valign="top"> </td>       <td valign="top">24-битный тип данных</td>      </tr>      <tr>       <td valign="top"><blockquote>INT</blockquote></td>       <td valign="top">Целочисленный</td>       <td valign="top">32-битный тип данных. Это стандартный тип и хороший выбор для данных общего назначения</td>      </tr>      <tr>       <td valign="top"><blockquote>BIGINT</blockquote></td>       <td valign="top">Целочисленный</td>       <td valign="top">64-битный знаковый тип данных</td>      </tr>      <tr>       <td valign="top"><blockquote>FLOAT(P)</blockquote></td>       <td valign="top">С плавающей точкой</td>       <td valign="top">Числа с плавающей точкой с точностью как минимум <blockquote>P</blockquote> знаков</td>      </tr>      <tr>       <td valign="top"><blockquote>DOUBLE(<i>D, N</i>)</blockquote></td>       <td valign="top">С плавающей точкой</td>       <td valign="top">Числа с плавающей точкой и двойной точностью из <blockquote><i>D</i></blockquote> цифр и <blockquote><i>N</i></blockquote> десятичных знаков</td>      </tr>      <tr>       <td valign="top"><blockquote>NUMERIC(<i>P, S</i>)</blockquote></td>       <td valign="top">С плавающей точкой</td>       <td valign="top">Действительные числа длиной <i><blockquote><i>P</i></blockquote></i> разрядов всего с <i><blockquote><i>S</i></blockquote></i> десятичными разрядами из них. В отличие от <blockquote>DOUBLE</blockquote> это точно заданное число (exact number), поэтому оно больше подходит для хранения денежных сумм, но обрабатывается менее эффективно</td>      </tr>      <tr>       <td valign="top"><blockquote>DECIMAL(<i>Р, S</i>)</blockquote></td>       <td valign="top">С плавающей точкой</td>       <td valign="top">Синоним <blockquote>NUMERIC</blockquote></td>      </tr>     </table>     <p>Мы полагаем, что в основном вы будете пользоваться типами <blockquote>INT</blockquote>, <blockquote>DOUBLE</blockquote> и <blockquote>NUMERIC</blockquote>, поскольку они ближе всего к стандартным типам SQL. Остальные типы нестандартные и могут отсутствовать в тех системах управления базами данных, куда вы решите переместить данные когда-либо в будущем.</p>     <b>Временной тип</b>     <p>В табл. 8.9 перечислены пять имеющихся временны&#769;х типов.</p>     <br>     <p><b><i>Таблица 8.9</i></b></p>     <table>      <tr>       <th valign="top">Определение</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>DATE</blockquote></td>       <td valign="top">Хранит даты с 1 января 1000 г. по 31 декабря 9999 г.</td>      </tr>      <tr>       <td valign="top"><blockquote>TIME</blockquote></td>       <td valign="top">Хранит время с -838:59:59 до 838:59:59</td>      </tr>      <tr>       <td valign="top"><blockquote>TIMESTAMP</blockquote></td>       <td valign="top">Хранит метку времени, начиная с 1 января 1970 г. и по 2037 г.</td>      </tr>      <tr>       <td valign="top"><blockquote>DATETIME</blockquote></td>       <td valign="top">Хранит даты с 1 января 1000 г. по последнюю секунду 31 декабря 9999 г.</td>      </tr>      <tr>       <td valign="top"><blockquote>YEAR</blockquote></td>       <td valign="top">Хранит номер года. Будьте осторожны с двузначными величинами, поскольку они неоднозначны и автоматически преобразуются в четырехзначные числа.</td>      </tr>     </table>     <p>Учтите, что следует быть внимательными при сравнении значений типов <blockquote>DATE</blockquote> и <blockquote>DATETIME</blockquote> в отношении способа обработки значения времени; результаты могут оказаться неожиданными. Подробности ищите в руководстве по MySQL, поскольку поведение разных версий СУРБД слегка отличается.</p>             <a name="metkadoc12"><h1>Создание таблицы</h1></a>     <p>Имея действующий сервер базы данных, зная как предоставлять права доступа пользователям и как создавать базу данных, а также ознакомившись с основными типами данных, можно переходить к созданию таблиц.</p>     <p><i>Таблица базы данных</i> — это просто последовательность строк, каждая из которых содержит фиксированный набор столбцов. Она довольно похожа на электронную таблицу за исключением того, что у всех строк должно быть одно и то же число столбцов и одинаковые типы данных и каждая строка каким-то образом должна отличаться от всех остальных строк таблицы.</p>     <p>База данных может, если для этого есть разумные основания, содержать очень много, практически неограниченное количество таблиц. Однако лишь немногим СУРБД требуется более 100 таблиц, а большинству маленьких систем вполне достаточно 25 или около того таблиц.</p>     <p>Синтаксис языка SQL, посвященный созданию объектов баз данных и называемый DDL (data definition language, язык определения данных), невозможно охватить полностью в одной главе; все подробности есть в разделе документации, на Web-сайте MySQL.</p>     <p>Базовый синтаксис для создания таблиц следующий:</p>     <p><blockquote>CREATE TABLE &lt;<i>таблица</i>&gt; {</blockquote></p>     <p><blockquote> column type [NULL | NOT | NULL] [AUTO_INCREMENT] [PRIMARY KEY]</blockquote></p>     <p><blockquote> [, ...]</blockquote></p>     <p><blockquote> [, PRIMARY KEY (столбец [, ...] ) ]</blockquote></p>     <p><blockquote>)</blockquote></p>     <p>Удалять таблицы можно с помощью очень простой синтаксической формулы <blockquote>DROP TABLE</blockquote>.</p>     <p><blockquote>DROP TABLE &lt;<i>таблица</i>&gt;</blockquote></p>     <p>Есть всего лишь небольшое число ключевых слов, приведенных в табл. 8.10, которые вам необходимо знать для того, чтобы быстро создать таблицу.</p>     <br>     <p><b><i>Таблица 8.10</i></b></p>     <table>      <tr>       <th valign="top">Ключевое слово</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>AUTO INCREMENT</blockquote></td>       <td valign="top">Это специальное ключевое слово сообщает MySQL о том, что, когда вы пишете в данный столбец <blockquote>NULL</blockquote>, следует автоматически заполнить столбец данными с помощью автоматически формируемого числа с наращением. Это чрезвычайно полезное средство; оно позволяет применять MySQL для автоматического назначения уникальных номеров строкам ваших таблиц, хотя оно может применяться только в столбцах, являющихся также первичными ключами. В других системах управления базами данных оно часто реализуется порядковым типом или управляется более явно с помощью последовательности</td>      </tr>      <tr>       <td valign="top"><blockquote>NULL</blockquote></td>       <td valign="top">Специальное значение в базе данных, обычно применяемое для обозначения "неизвестной" величины, но может также использоваться для обозначения "неподходящего" значения. Например, если вы заполняете таблицу подробными данными о сотрудниках, у вас может быть столбец с адресом электронной почты. В этом случае вы будете хранить <blockquote>NULL</blockquote> вместо адреса данного сотрудника, чтобы показать, что для конкретного человека эта информация не известна. Запись <blockquote>NOT NULL</blockquote> означает, что в этом столбце нельзя хранить значения <blockquote>NULL</blockquote> и может оказаться полезной для того, чтобы помешать вводу в такие столбцы значений <blockquote>NULL</blockquote>, если, например, значение всегда должно быть известно, как в случае фамилии сотрудника</td>      </tr>      <tr>       <td valign="top"><blockquote>PRIMARY KEY</blockquote></td>       <td valign="top">Указывает на то, что данные в этом столбце будут уникальными и разными во всех строках данной таблицы. У каждой таблицы может быть только один первичный ключ</td>      </tr>     </table>     <p>Выполните упражнение 8.1.</p>     <b>Упражнение 8.1. Создание таблицы и вставка данных</b>     <p>Гораздо легче понять создание таблицы на практике, чем смотреть на базовую синтаксическую запись, поэтому сейчас вы сделаете это, создав таблицу с именем <blockquote>children</blockquote>, в которой будет храниться уникальный номер для каждого ребенка, его имя и возраст. Номер ребенка вы сделаете первичным ключом.</p>     <p>1. Вам нужен следующий оператор языка SQL</p>     <p><blockquote>CREATE TABLE children (</blockquote></p>     <p><blockquote> childno INTEGER AUTO_INCREMENT NOT NULL PRIMARY KEY,</blockquote></p>     <p><blockquote> fname VARCHAR(30),</blockquote></p>     <p><blockquote> age INTEGER</blockquote></p>     <p><blockquote>);</blockquote></p>     <blockquote>      <b>Примечание</b>      <p>Обратите внимание на то, что в отличие от большинства языков программирования имя столбца (<blockquote>childno</blockquote>) указывается перед типом столбца (<blockquote>INTEGER</blockquote><b>).</b></p>     </blockquote>     <p>2. Вы также можете определить первичный ключ отдельно в определении столбца. Далее приведен пример интерактивного сеанса, в котором показан альтернативный синтаксис:</p>     <p><blockquote>mysql&gt; <b>use rick</b></blockquote></p>     <p><blockquote>Database changed</blockquote></p>     <p><blockquote>mysql&gt; <b>CREATE table children (</b></blockquote></p>     <p><blockquote>    -&gt; <b>childno INTEGER AUTO_INCREMENT NOT NULL,</b></blockquote></p>     <p><blockquote> -&gt; <b>fname varchar(30),</b></blockquote></p>     <p><blockquote> -&gt; <b>age INTEGER,</b></blockquote></p>     <p><blockquote> -&gt; <b>PRIMARY KEY(childno)</b></blockquote></p>     <p><blockquote> -&gt; <b>);</b></blockquote></p>     <p><blockquote>Query OK, 0 rows affected (0.04 sec)</blockquote></p>     <p><blockquote>mysql&gt;</blockquote></p>     <p>Вы можете записать команду или оператор SQL в нескольких строках, и монитор <blockquote>mysql</blockquote> применит подсказку <blockquote>-&gt;</blockquote>, чтобы показать, что вы находитесь в строке продолжения. Как упоминалось ранее, команда SQL завершается точкой с запятой, чтобы показать, что вы закончили и готовы к обработке вашего запроса сервером базы данных.</p>     <p>Если вы допустили ошибку, MySQL разрешит вернуться назад к предыдущим командам, откорректировать и повторно ввести их простым нажатием клавиши &lt;Enter&gt;.</p>     <p>3. Теперь у вас есть таблица, в которую можно вводить данные. Данные добавляются с помощью SQL-команды <blockquote>INSERT</blockquote>. Поскольку вы определили столбец <blockquote>childno</blockquote> как <blockquote>AUTO_INCREMENT</blockquote>, в него не вводятся данные, вы просто разрешаете MySQL разместить в нем уникальный номер.</p>     <p><blockquote>mysql&gt; <b>INSERT INTO children(fname, age) VALUES("Jenny", 21);</b></blockquote></p>     <p><blockquote>Query OK, 1 row affected (0.00 sec)</blockquote></p>     <p><blockquote>mysql&gt; <b>INSERT INTO children(fname, age) VALUES("Andrew", 17);</b></blockquote></p>     <p><blockquote>Query OK, 1 row affected (0.00 sec)</blockquote></p>     <p>Для того чтобы убедиться в том, что данные введены корректно, можно снова извлечь их. Выбираются данные из таблицы командой <blockquote>SELECT</blockquote>:</p>     <p><blockquote>mysql&gt; <b>SELECT childno, fname, age FROM children;</b></blockquote></p>     <p><blockquote>+---------+--------+-----+</blockquote></p>     <p><blockquote>| childno | fname  | age |</blockquote></p>     <p><blockquote>+---------+--------+-----+</blockquote></p>     <p><blockquote>| 1       | Jenny  | 21  |</blockquote></p>     <p><blockquote>| 2       | Andrew | 17  |</blockquote></p>     <p><blockquote>2 rows in set (0.00 sec) mysql&gt;</blockquote></p>     <p>Вместо явного перечисления столбцов для выборки вы могли бы применить для указания столбцов звездочку (*), которая перечислит все столбцы в названной таблице. Это очень удобно в интерактивном режиме, но в рабочем программном коде всегда следует явно называть столбец или столбцы, предназначенные для выборки.</p>     <p><b>Как это работает</b></p>     <p>Вы открыли интерактивный сеанс подключения к серверу базы данных и переключились на базу данных <blockquote>rick</blockquote>. Затем вы ввели команду SQL для создания вашей таблицы, используя нужное количество строк для ввода команды. Как только вы завершили команду с помощью знака <blockquote>;</blockquote>, MySQL создала вашу таблицу. Затем вы применили команду <blockquote>INSERT</blockquote> для ввода данных в вашу новую таблицу, позволив в столбце <blockquote>childno</blockquote> автоматически размещать числа. В заключение вы применили команду <blockquote>SELECT</blockquote> для вывода данных вашей таблицы.</p>     <p>Объем данной главы не позволяет дать полное описание языка SQL и тем более принципов проектирования баз данных. Дополнительную информацию см. на Web-сайте <b>www.mysql.com.</b></p>             <a name="metkadoc13"><h1>Графические средства</h1></a>     <p>Работа с таблицами и данными в командной строке хороша и удобна во всех отношениях, но в наши дни большинство людей предпочитает графические средства.</p>     <p>У СУРБД MySQL два основных графических средства: MySQL Administrator и MySQL Query Browser. Точное имя пакета с этими средствами зависит от используемого вами дистрибутива; например, в дистрибутивах Red Hat ищите mysql-gui-tools и mysql-administrator. В дистрибутиве Ubuntu вам, возможно, сначала придется переключиться на универсальный ("Universe") репозитарий, а затем искать mysql-admin.</p>     <b>MySQL Query Browser</b>     <p>Обозреватель запросов (query browser) довольно простое, но эффективное средство. После установки его можно запустить из меню GUI (graphical user interface, графический интерфейс пользователя). Запустив обозреватель, вы увидите начальный экран, запрашивающий подробности подключения (рис. 8.4).</p>     <img src="image026.jpg"/>     <p><b>Рис. 8.4</b></p>     <br>     <p>Если вы запустили обозреватель на той же машине, что и сервер, просто используйте имя локального компьютера как имя сервера.</p>     <p>После подключения вы получаете простой GUI (рис. 8.5), который позволяет выполнять запросы в графической оболочке, предоставляя все преимущества редактирования в графическом режиме заодно с графическим способом редактирования данных в таблице и несколькими экранами помощи с синтаксисом языка SQL.</p>     <img src="image027.jpg"/>     <p><b>Рис. 8.5</b></p>     <br>     <b>MySQL Administrator</b>     <p>Мы очень надеемся на то, что вы познакомитесь с MySQL Administrator. Это мощный, стабильный и легкий в использовании графический интерфейс для СУРБД MySQL, заранее откомпилированная версия которого существует как для ОС Linux, так и для Windows (даже исходный код доступен, если он вам нужен). MySQL Administrator позволяет управлять сервером MySQL и выполнять команды SQL через графический интерфейс пользователя.</p>     <p>При запуске MySQL Administrator выводится экран подключения, очень похожий на экран подключения MySQL Query Browser. После ввода некоторых подробностей у вас появится главная страница управления (рис. 8.6).</p>     <img src="image028.jpg"/>     <p><b>Рис. 8.6</b></p>     <br>     <p>Если вы хотите управлять сервером MySQL из программы-клиента в ОС Windows, можно загрузить Windows-версию MySQL Administrator из раздела Web-сайта MySQL, посвященного средствам GUI. Когда писалась эта книга, в загрузку были включены администратор, обозреватель запросов и утилита переноса базы данных. На рис. 8.7 показан экран состояния, как видите, он почти идентичен версии Linux,</p>     <blockquote>      <b>Примечание</b>      <p>Напоминаем, что если вы до сих пор следовали инструкциям, то защитили свой сервер MySQL так, что пользователь root может подключиться к нему только с локальной машины и ни с какой другой машины в сети.</p>     </blockquote>     <p>После запуска MySQL Administrator вы сможете провести наблюдения при разной настройке и отслеживаемых параметрах. Это очень легкое в использовании средство, но у нас нет возможности в этой единственной главе вдаваться в подробности.</p>     <img src="image029.jpg"/>     <p><b>Рис. 8.7</b> </p>     <br>              <a name="metkadoc14"><h1>Доступ к данным MySQL из программ на С</h1></a>         <p>Теперь, когда основы СУРБД MySQL остались в стороне, давайте рассмотрим, как, не применяя графические средства или программу-клиент mysql, получить доступ к СУРБД MySQL из вашего приложения.</p>     <p>К MySQL можно получить доступ из программ на разных языках, включая следующие:</p>     <p>&#9633; С;</p>     <p>&#9633; Eiffel;</p>     <p>&#9633; С++;</p>     <p>&#9633; Tcl;</p>     <p>&#9633; Java;</p>     <p>&#9633; Ruby;</p>     <p>&#9633; Perl;</p>     <p>&#9633; Python;</p>     <p>&#9633; PHP.</p>     <p>Есть и драйвер ODBC для доступа к MySQL из приложений ОС Windows, таких как Access. Существует даже драйвер ODBC для ОС Linux, но в его применении мало смысла.</p>     <p>В этой главе мы ограничились интерфейсом языка С, потому что в первую очередь этому языку программирования посвящена книга и потому что одни и те же библиотеки обеспечивают подключение из ряда других языков.</p>             <a name="metkadoc15"><h1>Подпрограммы подключения</h1></a>     <p>Подключение к базе данных MySQL из программы на языке С состоит из двух шагов:</p>     <p>&#9633; инициализации структуры идентификации подключения или дескриптора подключения;</p>     <p>&#9633; выполнения физического подключения.</p>     <p>Сначала примените <blockquote>mysql_init</blockquote> для инициализации дескриптора вашего подключения:</p>     <p><blockquote><b>#include &lt;mysql.h&gt;</b></blockquote></p>     <p><blockquote><b>MYSQL *mysql_init(MYSQL*);</b></blockquote></p>     <p>Обычно в подпрограмму передается <blockquote>NULL</blockquote> и возвращается указатель на вновь выделяемую память для структуры дескриптора подключения. Если вы пересылаете указатель на существующую структуру, она инициализируется заново. В случае ошибки возвращается <blockquote>NULL</blockquote>.</p>     <p>К этому моменту вы просто выделили память и инициализировали структуру дескриптора. Но вы еще должны предложить параметры подключения с помощью подпрограммы <blockquote>mysql_real_connect</blockquote>:</p>     <p><b><blockquote><b>MYSQL *mysql_real_connect(MYSQL *connection, </b></blockquote></b></p>     <p><b><blockquote><b> const char *server host, const char *sql_user_name,</b></blockquote></b></p>     <p><b><blockquote><b> const char *sql_password, const char *db_name,</b></blockquote></b></p>     <p><b><blockquote><b> unsigned int port_number, const char *unix_socket_name,</b></blockquote></b></p>     <p><b><blockquote><b> unsigned int<b> flags)</b>;</b></blockquote></b></p>     <p>Указатель подключения должен указывать на структуру дескриптора, уже инициализированную подпрограммой <blockquote>mysql_init</blockquote>. Параметры в большинстве своем очевидны; но следует отметить, что <blockquote>server_host</blockquote> может задаваться именем компьютера или IP-адресом. При подключении только к локальной машине вы можете оптимизировать тип подключения, указав в качестве этого параметра <blockquote>localhost</blockquote>.</p>     <p>Параметры <blockquote>sql_user_name</blockquote> и <blockquote>sql_password</blockquote> соответствуют своим именам. Если регистрационное имя равно <blockquote>NULL</blockquote>, предполагается идентификатор текущего пользователя ОС Linux. Если пароль — <blockquote>NULL</blockquote>, вы сможете обратиться к данным только на том сервере, который доступен без пароля. Перед отправкой по сети пароль шифруется.</p>     <p>Параметры <blockquote>port_number</blockquote> и <blockquote>unix_socket_name</blockquote> должны быть равны 0 и <blockquote>NULL</blockquote> соответственно, если вы не меняли стандартных настроек в вашей установке MySQL. Эти параметры примут соответствующие значения по умолчанию.</p>     <p>И наконец, параметр <blockquote>flags</blockquote> позволяет с помощью операции <blockquote>OR</blockquote> объединить несколько определений битовых масок, изменяя тем самым определенные характеристики применяемого протокола. Ни один из этих флагов не важен в данной вводной главе; все они подробно описаны в руководстве.</p>     <p>Если подключиться невозможно, возвращается <blockquote>NULL</blockquote>. В этом случае полезную информацию может предоставить подпрограмма <blockquote>mysql_error</blockquote>.</p>     <p>Когда вы прекращаете использовать подключение, обычно при завершении программы, вызовите подпрограмму <blockquote>mysql_close</blockquote>, как показано далее:</p>     <p><blockquote><b>void mysql_close(MYSQL * connection);</b></blockquote></p>     <p>Эта подпрограмма разорвет соединение с сервером. Если подключение устанавливалось с помощью <blockquote>mysql_init</blockquote>, память, отведенная под структуру дескриптора, освободится. Указатель станет неопределенным, и его нельзя будет применять в дальнейшем. Открытое ненужное подключение означает расточительное использование ресурсов, но повторное открытие подключения сопряжено с дополнительными накладными расходами, поэтому решайте сами, когда применять описанные подпрограммы.</p>     <p>Подпрограмма <blockquote>mysql_options</blockquote> (которую можно вызвать только между вызовами <blockquote>mysql_init</blockquote> и <blockquote>mysql_real_connect</blockquote>) позволит настроить некоторые параметры.</p>     <p><blockquote><b>int mysql_options(MYSQL* connection, enum option_to_set, const char *argument);</b></blockquote></p>     <p>Поскольку при каждом вызове <blockquote>mysql_options</blockquote> способна настроить только один параметр, ее следует вызывать отдельно для каждого параметра, который нужно задать. Вы можете применять эту подпрограмму необходимое количество раз, но все вызовы должны находиться между вызовами подпрограмм <blockquote>mysql_init</blockquote> и <blockquote>mysql_real_connect</blockquote>. Не все параметры подпрограммы имеют тип <blockquote>char</blockquote>, который следует приводить как <blockquote>const char*</blockquote>. Три самых часто используемых параметра приведены в табл. 8.11. И как всегда в расширенном интерактивном руководстве приведен полный список параметров.</p>     <br>     <p><b><i>Таблица 8.11</i></b></p>     <table>      <tr>       <th valign="top"><blockquote>Enum</blockquote>-параметр</th>       <th valign="top">Действительный тип аргумента</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>MYSQL_ОРТ_CONNECT_TIMEOUT</blockquote></td>       <td valign="top"><blockquote>const unsigned int*</blockquote></td>       <td valign="top">Количество секунд ожидания перед закрытием подключения из-за простоя</td>      </tr>      <tr>       <td valign="top"><blockquote>MYSQL_ОРТ_COMPRESS</blockquote></td>       <td valign="top">Нет, используйте <blockquote>NULL</blockquote></td>       <td valign="top">Применять сжатие при сетевом подключении</td>      </tr>      <tr>       <td valign="top"><blockquote>MYSQL_INIT_COMMAND</blockquote></td>       <td valign="top"><blockquote>const char*</blockquote></td>       <td valign="top">Команда, отправляемая при каждом установлении подключения</td>      </tr>     </table>     <p>Успешный вызов возвращает ноль. Поскольку эта подпрограмма предназначена для установки флагов, аварийное завершение всегда означает использование неверного параметра.</p>     <p>Для задания времени ожидания, равного семи секундам, используйте следующий фрагмент программного кода:</p>     <p><blockquote>unsigned int timeout = 7;</blockquote></p>     <p><blockquote>...</blockquote></p>     <p><blockquote>connection = mysql_init(NULL);</blockquote></p>     <p><blockquote>ret = mysql_options(connection, MYSQL_OPT_CONNECT_TIMEOUT, (const char *)&amp;timeout);</blockquote></p>     <p><blockquote>if (ret) {</blockquote></p>     <p><blockquote> /* Обработка ошибки */</blockquote></p>     <p><blockquote> ...</blockquote></p>     <p><blockquote>}</blockquote></p>     <p><blockquote>connection = mysql_real_connect(connection ...)</blockquote></p>     <p>Теперь, когда вы научились устанавливать, и закрывать ваше подключение, попробуем с помощью короткой программы проверить полученные знания на практике.</p>     <p>Начните с задания нового пароля для пользователя (в приведенном далее коде <blockquote>rick</blockquote> на <blockquote>localhost</blockquote>) и затем создайте базу данных <blockquote>foo</blockquote>, к которой будете подключаться. Вы все это уже знаете, поэтому мы просто приводим последовательность действий:</p>     <p><blockquote>$ <b>mysql -u root -р</b></blockquote></p>     <p><blockquote>Enter password:</blockquote></p>     <p><blockquote>Welcome to the MySQL monitor. Commands end with ; or \g.</blockquote></p>     <p><blockquote>mysql&gt; <b>GRANT ALL ON *.* TO rick@localhost IDENTIFIED BY 'secret';</b></blockquote></p>     <p><blockquote>Query OK, 0 rows affected (0.01 sec)</blockquote></p>     <p><blockquote>mysql&gt; <b>\q</b></blockquote></p>     <p><blockquote>Bye</blockquote></p>     <p><blockquote>$ <b>mysql -u rick -p</b></blockquote></p>     <p><blockquote>Enter password:</blockquote></p>     <p><blockquote>Welcome to the MySQL monitor. Commands end with ; or \g.</blockquote></p>     <p><blockquote>mysql&gt; <b>CREATE DATABASE foo;</b></blockquote></p>     <p><blockquote>Query OK, 1 row affected (0.01 sec)</blockquote></p>     <p><blockquote>mysql&gt; <b>\q</b></blockquote></p>     <p>Вы создали новую базу данных. Вместо ввода подробностей создания таблицы и вставки команд непосредственно в командную строку монитора mysql, что сопряжено с ошибками и не слишком продуктивно при необходимости повторного ввода, вы создадите файл со всеми нужными вам командами.</p>     <p>Далее приведен файл create_children.sql:</p>     <p><blockquote>--</blockquote></p>     <p><blockquote>-- Create the table children</blockquote></p>     <p><blockquote>--</blockquote></p>     <p><blockquote>CREATE TABLE children (</blockquote></p>     <p><blockquote> childno int(11) NOT NULL auto_increment,</blockquote></p>     <p><blockquote> fname varchar(30),</blockquote></p>     <p><blockquote> age int(11),</blockquote></p>     <p><blockquote> PRIMARY KEY (childno)</blockquote></p>     <p><blockquote>);</blockquote></p>     <p><blockquote>--</blockquote></p>     <p><blockquote>--Populate the table 'children'</blockquote></p>     <p><blockquote>--</blockquote></p>     <p><blockquote>INSERT INTO children(childno, fname, age) VALUES (1,'Jenny',21);</blockquote></p>     <p><blockquote>INSERT INTO children(childno, fname, age) VALUES (2,'Andrew',17);</blockquote></p>     <p><blockquote>INSERT INTO children(childno, fname, age) VALUES (3,'Gavin',8);</blockquote></p>     <p><blockquote>INSERT INTO children(childno, fname, age) VALUES (4,'Duncan', 6);</blockquote></p>     <p><blockquote>INSERT INTO children(childno, fname, age) VALUES (5,'Emma',4);</blockquote></p>     <p><blockquote>INSERT INTO children(childno, fname, age) VALUES (6,'Alex',15);</blockquote></p>     <p><blockquote>INSERT INTO children(childno, fname, age) VALUES (7,'Adrian',9);</blockquote></p>     <p>Теперь вы можете снова зарегистрироваться в MySQL, выбрав базу данных foo, и выполнить данный файл. Для краткости и как пример для включения при желании в сценарий мы поместили пароль в командную строку:</p>     <p><blockquote>$ <b>mysql -u rick --password=secret foo</b></blockquote></p>     <p><blockquote>Welcome to the MySQL monitor. Commands end with ; or \g.</blockquote></p>     <p><blockquote>mysql&gt; <b>\. create_children.sql</b></blockquote></p>     <p><blockquote>Query OK, 0 rows affected (0.01 sec)</blockquote></p>     <p><blockquote>Query OK, 1 row affected (0.00 sec)</blockquote></p>     <p>Мы убрали из вывода множество дублирующихся строк, например, строки, созданные в базе данных. Теперь, имея пользователя, базу данных и таблицу с хранящимися данными, самое время посмотреть, как обращаться к данным из программы.</p>     <p>Далее приведен файл connect1.с, который подключается от имени пользователя rick с паролем <blockquote>secret</blockquote> к серверу на локальной машине и базе данных <blockquote>foo</blockquote>.</p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include "mysql.h"</blockquote></p>     <br>     <p><blockquote>int main(int argc, char *argv[]) {</blockquote></p>     <p><blockquote> MYSQL *conn_ptr;</blockquote></p>     <p><blockquote> conn_ptr = mysqlinit(NULL);</blockquote></p>     <p><blockquote> if (!conn_ptr) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "mysql_init failed\n");</blockquote></p>     <p><blockquote>  return EXIT_FAILURE;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> conn_ptr = mysql_real_connect(conn_ptr, "localhost", "rick", "secret",</blockquote></p>     <p><blockquote>  "foo", 0, NULL, 0);</blockquote></p>     <p><blockquote> if (conn_ptr) {</blockquote></p>     <p><blockquote>  printf("Connection success\n");</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  printf ("Connection failed\n");</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> mysql_close(conn_ptr);</blockquote></p>     <p><blockquote> return EXIT_SUCCESS;</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Теперь откомпилируйте программу и посмотрите, как вы это сделали. Возможно, придется вставить путь к файлам <blockquote>include</blockquote> и путь к библиотекам, а также указать, что файл нуждается в компоновке с библиотечным модулем <blockquote>mysqlclient</blockquote>. В некоторых системах может понадобиться опция <blockquote>-lz</blockquote> для компоновки с библиотекой упаковки (compression library). В системе авторов требуемая строка компиляции выглядит следующим образом:</p>     <p><blockquote>$ <b>gcc -I/usr/include/mysql connect1.с -L/usr/lib/mysql -lmysqlclient -о connect1</b></blockquote></p>     <p>Вам, возможно, придется проверить, установлены ли пакеты клиентской части и место их установки, зависящее от применяемого вами дистрибутива, и откорректировать, соответственно, приведенную строку компиляции.</p>     <p>Когда вы запустите программу, должно появиться сообщение об успешном подключении:</p>     <p><blockquote>$ <b>./connect1</b></blockquote></p>     <p><blockquote>Connection success $</blockquote></p>     <p>В<i> главе 9</i> мы покажем, как создать make-файл и автоматизировать процесс подключения.</p>     <p>Как видите, подключиться к базе данных MySQL очень легко.</p>             <a name="metkadoc16"><h1>Обработка ошибок</h1></a>     <p>Прежде чем мы перейдем к более сложным программам, полезно взглянуть на то, как MySQL обрабатывает ошибки. СУРБД MySQL использует ряд возвращаемых числовых кодов, предоставляемых дескриптором подключения. К двум обязательным подпрограммам относятся следующие:</p>     <p><blockquote><b>unsigned int mysql_errno(MYSQL *connection);</b></blockquote></p>     <p>и</p>     <p><blockquote><b>char *mysql_error(MYSQL *connection);</b></blockquote></p>     <p>Вы можете получить код ошибки, обычно любое ненулевое значение, вызвав подпрограмму <blockquote>mysql_errno</blockquote> и передав ей дескриптор подключения. Если никакой код ошибки не установлен, возвращается ноль. Поскольку код обновляется при каждом вызове библиотечной функции, можно извлечь код только последней выполненной команды, за исключением двух подпрограмм обработки ошибок, которые не приводят к обновлению кода ошибки.</p>     <p>Возвращаемое значение — в действительности код ошибки, коды ошибок определены в файле <blockquote>include</blockquote> с именем errmsg.h или в файле mysqld_error.h. Оба файла можно найти в каталоге MySQL с именем include. Первый сообщает об ошибках клиентской стороны, а второй — об ошибках сервера.</p>     <p>Если вы предпочитаете текстовое сообщение об ошибке, можно вызвать подпрограмму <blockquote>mysql_error</blockquote>, которая вместо кода предоставляет осмысленное текстовое сообщение. Текст сообщения пишется в некоторую внутреннюю область статической памяти, поэтому для сохранения текста ошибки его следует скопировать куда- нибудь.</p>     <p>Вы можете вставить элементарную обработку ошибок в вашу программу для того, чтобы увидеть все это в действии. Возможно, вы уже заметили, что можно столкнуться с проблемой, поскольку подпрограмма <blockquote>mysql_real_connect</blockquote> в случае сбоя возвращает указатель <blockquote>NULL</blockquote>, лишая вас кода ошибки. Если дескриптор подключения сделать переменной, его все же можно получить при аварийном завершении <blockquote>mysql_real_connect</blockquote>.</p>     <p>Далее приведен файл connect2.c, демонстрирующий, как применять структуру дескриптора подключения без динамического выделения памяти для нее, а также как написать некоторый базовый программный код обработки ошибок. Внесенные изменения выделены цветом.</p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include "mysql.h"</blockquote></p>     <br>     <p><blockquote>int main(int argc, char *argv[]) {</blockquote></p>     <p><blockquote><i> MYSQL my_connection;</i></blockquote></p>     <p><blockquote><i> mysql_init(&amp;my_connection);</i></blockquote></p>     <p><blockquote><i> if (mysql_real_connect(&amp;my_connection, "localhost", "rick",</i></blockquote></p>     <p><blockquote><i>  "I do not know", "foo", 0, NULL, 0)) {</i></blockquote></p>     <p><blockquote>  printf("Connection success\n");</blockquote></p>     <p><blockquote>  mysql_close(&amp;my_connection);</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Connection failed\n");</blockquote></p>     <p><blockquote><i>  if (mysql_errno(&amp;my_connection)) {</i></blockquote></p>     <p><blockquote><i>   fprintf(stderr, "Connection error %d: %s\n",</i></blockquote></p>     <p><blockquote><i>    mysql_errno(&amp;my_connection), mysql_error(&amp;my_connection));</i></blockquote></p>     <p><blockquote><i>  }</i></blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return EXIT_SUCCESS;</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Вы смогли легко решить проблему, устранив перезапись вашего дескриптора подключения результатом, возвращаемым при аварийном завершении <blockquote>mysql_real_connect</blockquote>. И кроме того, это отличный пример еще одного способа применения структур дескрипторов подключения. Вы можете вызвать ошибку, выбрав некорректное имя пользователя или пароль, и получите код ошибки, подобный предлагаемому монитором <blockquote>mysql</blockquote>:</p>     <p><blockquote>$ <b>./connect2</b></blockquote></p>     <p><blockquote>Connection failed</blockquote></p>     <p><blockquote>Connection error 1045: Access denied for user: 'rick@localhost' (Using password: YES)</blockquote></p>     <p><blockquote>$</blockquote></p>             <a name="metkadoc17"><h1>Выполнение SQL-операторов</h1></a>     <p>Теперь, когда вы можете подключаться к вашей базе данных и корректно обрабатывать ошибки, самое время дать вашей программе реальную работу. У основной функции API, предназначенной для выполнения операторов языка SQL, подходящее имя.</p>     <p><blockquote><b>int mysql_query(MYSQL *connection, const char *query);</b></blockquote></p>     <p>He слишком сложная? Эта подпрограмма принимает указатель на дескриптор подключения и несколько, хочется надеяться, корректных SQL-операторов в виде текстовой строки (без завершения каждого из них точкой с запятой, как в мониторе <blockquote>mysql</blockquote>). В случае удачного завершения возвращается ноль. Вторую подпрограмму <blockquote>mysql_real_query</blockquote> можно применять при запросе двоичных данных, но в этой главе мы используем только подпрограмму <blockquote>mysql_query</blockquote>.</p>     <b>SQL-операторы, не возвращающие данных</b>     <p>Для простоты начнем с рассмотрения нескольких SQL-операторов, которые не возвращают данные: <blockquote>UPDATE</blockquote>, <blockquote>DELETE</blockquote> и <blockquote>INSERT</blockquote>.</p>     <p>Еще одна важная функция, которую мы рассмотрим, проверяет количество строк, затронутых запросом:</p>     <p><blockquote><b>my_ulonglong mysql_affected_rows(MYSQL *connection);</b></blockquote></p>     <p>Первое, что вы, вероятно, заметили в этой функции, — очень необычный тип возвращаемых данных. Из соображений переносимости применяется беззнаковый (unsigned) тип. Когда используется функция <blockquote>printf</blockquote>, рекомендуется приводить его к типу <blockquote>unsigned long</blockquote> (длинное беззнаковое) со спецификатором формата <blockquote>%lu</blockquote>. Эта функция возвращает количество строк, измененных предварительно выполненным запросом <blockquote>UPDATE</blockquote>, <blockquote>INSERT</blockquote> или <blockquote>DELETE</blockquote>. Возвращаемое значение, используемое в MySQL, может вас, озадачить, если у вас есть опыт работы с другими базами данных SQL. СУРБД MySQL возвращает количество строк, действительно измененных обновлением, в то время как многие другие СУБД будут считать запись измененной просто потому, что она соответствует одному из условий <blockquote>WHERE</blockquote>.</p>     <p>В основном в случае функций <blockquote>mysql_</blockquote> возврат 0 означает отсутствие измененных строк, а положительное значение указывает на реальный результат, обычно количество строк, затронутых оператором.</p>     <p>Сначала следует создать таблицу <blockquote>children</blockquote> в вашей базе данных <blockquote>foo</blockquote>, если вы еще не сделали этого. Удалите (с помощью команды <blockquote>drop</blockquote>) любую существующую таблицу, чтобы быть уверенным в том, что вы имеете дело с чистым определением таблицы, и повторно отправьте идентификаторы, применяемые в столбце <blockquote>AUTO_INCREMENT</blockquote>.</p>     <p><blockquote>$ <b>mysql -u rick -p foo</b></blockquote></p>     <p><blockquote>Enter password:</blockquote></p>     <p><blockquote>Welcome to the MySQL monitor. Commands end with ; or \g.</blockquote></p>     <p><blockquote>mysql&gt; <b>DROP TABLE children;</b></blockquote></p>     <p><blockquote>Query OK, 0 rows affected (0.58 sec)</blockquote></p>     <p><blockquote>mysql&gt; <b>CREATE TABLE children (</b></blockquote></p>     <p><blockquote>    -&gt; <b>childno int(11) AUTO_INCREMENT NOT NULL PRIMARY KEY,</b></blockquote></p>     <p><blockquote>    -&gt; <b>fname varchar(30),</b></blockquote></p>     <p><blockquote>    -&gt; <b>age int</b></blockquote></p>     <p><blockquote>    -&gt; <b>);</b></blockquote></p>     <p><blockquote>Query OK, 0 rows affected (0.09 sec)</blockquote></p>     <p><blockquote>mysql&gt;</blockquote></p>     <p>Теперь добавьте программный код в файл connect2.c, для того чтобы вставить новую строку в вашу таблицу. Назовите эту новую программу insert1.с. Учтите, что разбиение оператора на несколько строк объясняется физической шириной страницы; обычно вы не должны разбивать реальный SQL-оператор, если он не слишком длинный, в этом случае можно применить символ <blockquote>/</blockquote> в конце строки для переноса оставшейся части SQL-оператора на следующую строку.</p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include "mysql.h"</blockquote></p>     <br>     <p><blockquote>int main(int argc, char *argv[]) {</blockquote></p>     <p><blockquote> MYSQL my_connection;</blockquote></p>     <p><blockquote><i> int res;</i></blockquote></p>     <p><blockquote> mysql_init(&amp;my_connection);</blockquote></p>     <p><blockquote> if (mysql_real_connect(&amp;my_connection, "localhost",</blockquote></p>     <p><blockquote>  "rick", "secret", "foo", 0, NULL, 0)) {</blockquote></p>     <p><blockquote>  printf("Connection success\n");</blockquote></p>     <p><blockquote><i>  res = mysql_query(&amp;my_connection,</i></blockquote></p>     <p><blockquote><i>   "INSERT INTO children(fname, age) VALUES('Ann', 3)");</i></blockquote></p>     <p><blockquote><i>  if (!res) {</i></blockquote></p>     <p><blockquote><i>   printf("Inserted %lu rows\n",</i></blockquote></p>     <p><blockquote><i>    (unsigned long)mysql_affected_rows(&amp;my_connection));</i></blockquote></p>     <p><blockquote><i>  } else {</i></blockquote></p>     <p><blockquote><i>   fprintf(stderr, "Insert error %d: %s\n",</i></blockquote></p>     <p><blockquote><i>    mysql_errno(&amp;my_connection), &amp;mysql_error(&amp;my_connection));</i></blockquote></p>     <p><blockquote><i>  }</i></blockquote></p>     <p><blockquote>  mysql_close(&amp;my_connection);</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Connection failed\n");</blockquote></p>     <p><blockquote>  if (mysql_errno(&amp;my_connection)) {</blockquote></p>     <p><blockquote>   printf(stderr, "Connection error %d: %s\n",</blockquote></p>     <p><blockquote>    mysql_errno(&amp;my_connection), mysql_error(&amp;my_connection));</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return EXIT_SUCCESS;</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Как и ожидалось, одна строка добавлена.</p>     <p>Теперь измените код, чтобы включить <blockquote>UPDATE</blockquote> вместо <blockquote>INSERT</blockquote>, и посмотрите на сообщение об измененных строках.</p>     <p><blockquote>  mysql_errno(&amp;my_connection), mysql_error(&amp;my_connection));</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote>}</blockquote></p>     <p><blockquote><i>res = mysql_query(&amp;my_connection,</i></blockquote></p>     <p><blockquote><i> "UPDATE children SET AGE = 4 WHERE fname = 'Ann'");</i></blockquote></p>     <p><blockquote>if (!res) {</blockquote></p>     <p><blockquote> printf("Updated %lu rows\n",</blockquote></p>     <p><blockquote>  (unsigned long)mysql_affected_rows(&amp;my_connection));</blockquote></p>     <p><blockquote>} else {</blockquote></p>     <p><blockquote> fprintf (stderr, "Update error %d: %s\n",</blockquote></p>     <p><blockquote>  mysql_errno(&amp;my_connection), mysql_error(&amp;my_connection));</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Назовите эту программу update1.c. Она пытается задать возраст 4 года для всех детей с именем Ann.</p>     <p>Предположим, что ваша таблица <blockquote>children</blockquote> содержит следующие данные:</p>     <p><blockquote>mysql&gt; <b>SELECT * from CHILDREN;</b></blockquote></p>     <p><blockquote>+---------+--------+-----+</blockquote></p>     <p><blockquote>| childno | fname  | age |</blockquote></p>     <p><blockquote>+---------+--------+-----+</blockquote></p>     <p><blockquote>|       1 | Jenny  |  21 |</blockquote></p>     <p><blockquote>|       2 | Andrew |  17 |</blockquote></p>     <p><blockquote>|       3 |  Gavin |   9 |</blockquote></p>     <p><blockquote>|       4 | Duncan |   6 |</blockquote></p>     <p><blockquote>|       5 |   Emma |   4 |</blockquote></p>     <p><blockquote>|       6 |   Alex |  15 |</blockquote></p>     <p><blockquote>|       7 | Adrian |   9 |</blockquote></p>     <p><blockquote>|       8 |    Ann |   3 |</blockquote></p>     <p><blockquote>|       9 |    Ann |   4 |</blockquote></p>     <p><blockquote>|      10 |    Ann |   3 |</blockquote></p>     <p><blockquote>|      11 |    Ann |   4 |</blockquote></p>     <p><blockquote>+---------+--------+-----+</blockquote></p>     <p><blockquote>11 rows in set (0.00 sec)</blockquote></p>     <p>В вашей таблице есть четыре ребенка с именем Ann. Вы можете рассчитывать на то, что при выполнении программы update1 количество измененных строк будет равно четырем, т.е. числу строк, отбираемых по условию <blockquote>WHERE</blockquote>. Но если вы выполните программу, то увидите отчет программы об изменении только двух строк, поскольку учитываются только те строки, данные которых действительно нуждались в корректировке. Можно выбрать более традиционный вариант отчета, используя флаг <blockquote>CLIENT_FOUND_ROWS</blockquote> в функции <blockquote>mysql_real_connect</blockquote>:</p>     <p><blockquote>if (mysql_real_connect(&amp;my_connection, "localhost",</blockquote></p>     <p><blockquote> "rick", "secret", "foo", 0, NULL, CLIENT_FOUND_ROWS)) {</blockquote></p>     <p>Если восстановить данные в вашей базе данных и затем выполнить программу с приведенным изменением, она сообщит о четырех измененных строках.</p>     <p>Последняя странность функции <blockquote>mysql_affected_rows</blockquote> проявляется при удалении информации из базы данных. Если вы удаляете данные с помощью условия <blockquote>WHERE</blockquote>, <blockquote>mysql_affected_rows</blockquote> вернет ожидаемое вами количество удаленных строк. Но если в операторе <blockquote>DELETE</blockquote> нет условия <blockquote>WHERE</blockquote>, будут удалены все строки, но в сообщении программы о количестве строк, затронутых запросом, будет указан ноль. Это происходит потому, что MySQL оптимизирует удаление всех строк, заменяя многократные построчные удаления.</p>     <p>На подобное поведение не влияет флаг <blockquote>CLIENT_FOUND_ROWS</blockquote>.</p>     <b>Что же вы вставили?</b>     <p>Существует небольшая, но важная особенность вставки данных. Ранее мы упоминали столбец типа <blockquote>AUTO_INCREMENT</blockquote>, в который MySQL автоматически вставляет идентификаторы. Это свойство весьма полезно, особенно при наличии нескольких пользователей.</p>     <p>Рассмотрим определение таблицы еще раз:</p>     <p><blockquote>CREATE TABLE children (</blockquote></p>     <p><blockquote> childno INTEGER AUTO_INCREMENT NOT NULL PRIMARY KEY,</blockquote></p>     <p><blockquote> fname VARCHAR(30),</blockquote></p>     <p><blockquote> age INTEGER</blockquote></p>     <p><blockquote>);</blockquote></p>     <p>Как видите, столбец <blockquote>childno</blockquote>— поле типа <blockquote>AUTO_INCREMENT</blockquote>. Это замечательно, но когда вы вставили строку, как узнать, какой номер присвоен ребенку, чье имя вы только что вставили?</p>     <p>Можно выполнить оператор <blockquote>SELECT</blockquote> для того чтобы извлечь данные, отобранные по имени ребенка. Но это очень неэффективный способ и не гарантирующий уникальности выбора: допустим, что у вас есть два ребенка с одним и тем же именем. Или несколько пользователей могли быстро вставить данные, и появились другие добавленные строки между вашим оператором обновления и оператором <blockquote>SELECT</blockquote>. Поскольку выяснение значения столбца типа <blockquote>AUTO_INCREMENT</blockquote> — столь распространенная проблема, MySQL предлагает специальное решение в виде функции <blockquote>LAST_INSERT_ID()</blockquote>.</p>     <p>Когда MySQL вставляет данные в столбец типа <blockquote>AUTO_INCREMENT</blockquote>, она отслеживает для каждого пользователя последнее присвоенное ею значение. Программы пользователей могут узнать его, просто используя в операторе <blockquote>SELECT</blockquote> специальную функцию <blockquote>LAST_INSERT_ID()</blockquote>, которая действует немного похоже на псевдостолбец.</p>     <p>Выполните упражнение 8.2.</p>     <b>Упражнение 8.2. Извлечение ID, сгенерированного в столбце типа <blockquote>AUTO_INCREMENT</blockquote></b>     <p>Вы сможете увидеть, как это работает, вставив несколько значений в вашу таблицу и затем применив функцию <blockquote>LAST_INSERT_ID()</blockquote>.</p>     <p><blockquote>mysql&gt; <b>INSERT INTO children(fname, age) VALUES('Tom', 13); </b></blockquote></p>     <p><blockquote>Query OK, 1 row affected (0.06 sec)</blockquote></p>     <p><blockquote>mysql&gt; <b>SELECT LAST_INSERT_ID();</b></blockquote></p>     <p><blockquote>+------------------+</blockquote></p>     <p><blockquote>| last_insert_id() |</blockquote></p>     <p><blockquote>+------------------+</blockquote></p>     <p><blockquote>|               14 |</blockquote></p>     <p><blockquote>+------------------+</blockquote></p>     <p><blockquote>1 row in set (0.01 sec)</blockquote></p>     <p><blockquote>mysql&gt; <b>INSERT INTO children(fname, age) VALUES('Harry', 17);</b></blockquote></p>     <p><blockquote>Query OK, 1 row affected (0.02 sec)</blockquote></p>     <p><blockquote>mysql&gt; <b>SELECT LAST_INSERT_ID();</b></blockquote></p>     <p><blockquote>+------------------+</blockquote></p>     <p><blockquote>| last_insert_id() |</blockquote></p>     <p><blockquote>+------------------+</blockquote></p>     <p><blockquote>|               15 |</blockquote></p>     <p><blockquote>+------------------+</blockquote></p>     <p><blockquote>1 row in set (0.00 sec)</blockquote></p>     <p><blockquote>mysql&gt;</blockquote></p>     <p><b>Как это работает</b></p>     <p>При каждой вставке строки MySQL выделяет новое значение для столбца <blockquote>id</blockquote> и запоминает его, поэтому вы сможете узнать это значение с помощью функции <blockquote>LAST_INSERT_ID()</blockquote>.</p>     <p>Если хотите поэкспериментировать, чтобы убедиться в уникальности возвращаемого номера в вашем сеансе, откройте еще один сеанс и вставьте другую строку. В исходном сеансе повторите выполнение оператора <blockquote>SELECT LAST_INSERT_ID();</blockquote>. Вы увидите, что номер не изменился, поскольку возвращаемый номер — последний, добавленный в текущем сеансе. Но если вы выполните оператор <blockquote>SELECT * FROM children</blockquote>, то увидите, что в другом сеансе действительно были вставлены данные.</p>     <p>Выполните упражнение 8.3.</p>     <b>Упражнение 8.3. Использование автоматически формируемых ID в программе на С</b>     <p>В этом примере вы измените вашу программу insert1.c, чтобы посмотреть, как она работает на С. Ключевые изменения выделены цветом. Назовите откорректированную программу insert2.c.</p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include "mysql.h"</blockquote></p>     <br>     <p><blockquote>int main(int argc, char *argv[]) {</blockquote></p>     <p><blockquote> MYSQL my_connection;</blockquote></p>     <p><blockquote><i> MYSQL_RES* res_ptr;</i></blockquote></p>     <p><blockquote><i> MYSQL_ROW sqlrow;</i></blockquote></p>     <p><blockquote> int res;</blockquote></p>     <p><blockquote> mysql_init(&amp;myconnection);</blockquote></p>     <p><blockquote> if (mysql_real_connect(&amp;my_connection, "localhost",</blockquote></p>     <p><blockquote>  "rick", "bar", "rick", 0, NULL, 0)) {</blockquote></p>     <p><blockquote>  printf("Connection success\n");</blockquote></p>     <p><blockquote>  res = mysql_query(&amp;my_connection,</blockquote></p>     <p><blockquote>   "INSERT INTO children(fname, age) VALUES('Robert', 7)");</blockquote></p>     <p><blockquote>  if (!res) {</blockquote></p>     <p><blockquote>   printf("Inserted %lu rows\n",</blockquote></p>     <p><blockquote>    (unsigned long)mysql_affected_rows(&amp;my_connection));</blockquote></p>     <p><blockquote>  } else {</blockquote></p>     <p><blockquote>   fprintf(stderr, "Insert error %d: %s\n",</blockquote></p>     <p><blockquote>    mysql_errno(&amp;myconnection), mysql_error(&amp;my_connection));</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote><i>  res = mysql_query(&amp;my_connection, "SELECT LAST INSERT ID()");</i></blockquote></p>     <p><blockquote><i>  if (res) {</i></blockquote></p>     <p><blockquote><i>   printf("SELECT error %s\n", mysql_error(&amp;my_connection);</i></blockquote></p>     <p><blockquote><i>  } else {</i></blockquote></p>     <p><blockquote><i>   res_ptr= mysql_use_result(&amp;my_connection);</i></blockquote></p>     <p><blockquote><i>   if (res_ptr) {</i></blockquote></p>     <p><blockquote><i>    while ((sqlrow = mysql_fetch_row(res_ptr))) {</i></blockquote></p>     <p><blockquote><i>     printf("We inserted childno %s\n", sqlrow[0]);</i></blockquote></p>     <p><blockquote><i>    }</i></blockquote></p>     <p><blockquote><i>    mysql_free_result(res_ptr);</i></blockquote></p>     <p><blockquote><i>   }</i></blockquote></p>     <p><blockquote><i>  }</i></blockquote></p>     <p><blockquote>  mysql_close(&amp;my_connection);</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Connection failed\n");</blockquote></p>     <p><blockquote>  if (mysql_errno(&amp;my_connection)) {</blockquote></p>     <p><blockquote>   fprintf(stderr, "Connection error %d: %s\n",</blockquote></p>     <p><blockquote>    mysql_errno(&amp;my_connection), mysql_error(&amp;my_connection));</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return EXIT_SUCCESS;</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Далее приведен вывод:</p>     <p><blockquote>$ <b>gcc -I/usr/include/mysql insert2.c -L/usr/lib/mysql -lmysqlclient -o insert2</b></blockquote></p>     <p><blockquote>$ <b>./insert2</b></blockquote></p>     <p><blockquote>Connection success</blockquote></p>     <p><blockquote>Inserted 1 rows</blockquote></p>     <p><blockquote>We inserted childno 6</blockquote></p>     <p><blockquote>$ <b>./insert2</b></blockquote></p>     <p><blockquote>Connection success</blockquote></p>     <p><blockquote>Inserted 1 rows</blockquote></p>     <p><blockquote>We inserted childno 7</blockquote></p>     <p><b>Как это работает</b></p>     <p>После вставки строки вы извлекаете выделенный ID, применив функцию <blockquote>LAST_INSERT_ID()</blockquote> в обычном операторе <blockquote>SELECT</blockquote>. Затем вы использовали функцию <blockquote>mysql_use_result()</blockquote>, которую мы вскоре поясним, для извлечения данных из выполненного вами оператора <blockquote>SELECT</blockquote> и вывели их на экран. Сейчас не задумывайтесь всерьез о механизме извлечения значений, на следующих нескольких страницах мы дадим нужные пояснения.</p>     <b>Операторы, возвращающие данные</b>     <p>Основное назначение языка — конечно, извлечение данных, а не их добавление или обновление. Данные извлекаются с помощью оператора <blockquote>SELECT</blockquote>.</p>     <blockquote>      <b>Примечание</b>      <p>MySQL также поддерживает SQL-операторы <blockquote>SHOW</blockquote>, <blockquote>DESCRIBE</blockquote> и <blockquote>EXPLAIN</blockquote>, предназначенные для возврата результатов, но мы не собираемся рассматривать их в данной книге. Как обычно, в руководстве можно найти описание этих операторов.</p>     </blockquote>     <p>Получение данных в вашем приложении на языке С обычно будет включать четыре шага:</p>     <p>1. Выполнение запроса.</p>     <p>2. Извлечение данных.</p>     <p>3. Обработка этих данных.</p>     <p>4. Наведение порядка при необходимости.</p>     <p>Так же, как в случае операторов <blockquote>INSERT</blockquote> и <blockquote>DELETE</blockquote>, вы воспользуетесь функцией <blockquote>mysql_query</blockquote> для отправки SQL-запроса. Далее вы извлечете данные о помощью функций <blockquote>mysql_store_result</blockquote> или <blockquote>mysql_use_result</blockquote> в зависимости от того, как хотите получить данные. Затем будет применена последовательность вызовов функции <blockquote>mysql_fetch_row</blockquote> для обработки данных. И наконец, вы используете функцию <blockquote>mysql_free_result</blockquote> для очистки памяти, которая применялась для выполнения вашего запроса.</p>     <p>Разница между функциями <blockquote>mysql_use_result</blockquote> и <blockquote>mysql_store_result</blockquote> в основном определяется тем, хотите ли вы получать данные построчно или весь набор за один шаг. Последний вариант больше подходит в том случае, когда вы рассчитываете на не слишком большой результирующий набор.</p>     <b>Функции для извлечения всех данных сразу</b>     <p>Вы сможете извлечь в единственном вызове все данные из оператора <blockquote>SELECT</blockquote> (или другого оператора, возвращающего данные), применяя функцию <blockquote>mysql_store_result</blockquote>:</p>     <p><b><blockquote><b>MYSQL_RES *mysql_store_result(MYSQL* connection);</b></blockquote></b></p>     <p>Ясно, что вам понадобится эта функция после успешного вызова функции <blockquote>mysql_query</blockquote>. Она немедленно сохранит все возвращенные данные в клиентской части. Функция вернет указатель на новую структуру, называемую структурой результирующего набора, или <blockquote>NULL</blockquote>, если оператор завершился аварийно.</p>     <p>В случае успеха вы далее вызываете функцию <blockquote>mysql_num_rows</blockquote> для определения количества возвращенных записей, которое, мы надеемся, будет положительным числом, но может быть и 0, если ни одной строки не возвращено.</p>     <p><blockquote><b>my_ulonglong mysql_num_rows(MYSQL_RES* result);</b></blockquote></p>     <p>Эта функция принимает в качестве параметра структуру с результатом, возвращенную <blockquote>mysql_store_result</blockquote>, и возвращает количество строк в данном результирующем наборе. Если функция <blockquote>mysql_store_result</blockquote> завершилась успешно, функция <blockquote>mysql_num_rows</blockquote> также завершится успешно.</p>     <p>Данная комбинация функций — легкий способ извлечь нужные вам данные. На этом этапе все данные локальны для программы-клиента и вам не нужно больше поддерживать подключение, связанное с возможностью возникновения ошибок в сети или базе данных. Получив количество возвращенных строк, вы упростите последующий программный код.</p>     <p>Если окажется, что вы должны работать с особенно большим набором данных, лучше извлекать меньшие по объему, более управляемые порции данных. В этом случае приложению быстрее передается управление, и использование сетевых ресурсов будет более щадящим. Мы рассмотрим этот вариант подробнее при обсуждении функции <blockquote>mysql_use_result</blockquote>.</p>     <p>Теперь, когда у вас есть данные, можно обработать их с помощью функции <blockquote>mysql_fetch_row</blockquote> и перемещаться по набору, используя функции <blockquote>mysql_data_seek</blockquote>, <blockquote>mysql_row_seek</blockquote> и <blockquote>mysql_row_tell</blockquote>. Давайте рассмотрим их.</p>     <p>&#9633; Функция <blockquote>mysql_fetch_row</blockquote> извлекает одну строку из структуры типа <blockquote>result</blockquote>, которую вы получили с помощью функции <blockquote>mysql_store_result</blockquote>, и помещает ее структуру <blockquote>row</blockquote>. Когда данные иссякли или возникла ошибка, возвращается <blockquote>NULL</blockquote>. В следующем разделе мы вернемся к обработке данных в структуре типа <blockquote>row</blockquote>.</p>     <p><blockquote><b>MYSQL_ROW mysql_fetch_row(MYSQL_RES *result);</b></blockquote></p>     <p>&#9633; Функция <blockquote>mysql_data_seek</blockquote> позволяет перемещаться в результирующем наборе, задавая строку, которая будет возвращена при следующем вызове функции <blockquote>mysql_fetch_row</blockquote>. Значение <blockquote>offset</blockquote> — номер строки в диапазоне от нуля до общего количества строк в результирующем наборе, уменьшенного на единицу. Передача нулевого значения вызовет возврат первой строки при следующем вызове функции <blockquote>mysql_fetch_row</blockquote>.</p>     <p><blockquote><b>void mysql_data_seek(MYSQL_RES *result, my_ulonglong offset);</b></blockquote></p>     <p>&#9633; Функция <blockquote>mysql_row_tell</blockquote> возвращает величину смещения, обозначая текущую позицию в результирующем наборе. Это не номер строки и его нельзя использовать в функции <blockquote>mysql_data_seek</blockquote>.</p>     <p><blockquote><b>MSSQL_ROW_OFFSET mysql_row_tell(MYSQL_RES *result);</b></blockquote></p>     <p>Но ее можно применять с функцией</p>     <p><blockquote><b>MYSQL_ROW_OFFSET mysql_row_seek(MYSQL_RES *result,</b></blockquote></p>     <p><blockquote><b> MYSQL_ROW_OFFSET offset);</b></blockquote></p>     <p>которая перемещает текущую позицию в результирующем наборе и возвращает предыдущую позицию.</p>     <blockquote>      <b>Примечание</b>      <p>Эта пара функций очень полезна для перемещения между известными записями в результирующем наборе. Будьте внимательны и не путайте величину смещения, используемую функциями <blockquote>row_tell</blockquote> и <blockquote>row_seek</blockquote> со значением смещения, применяемым в функции <blockquote>data_seek</blockquote>. Иначе ваши результаты будут непредсказуемыми.</p>     </blockquote>     <p>После того как вы сделаете с вашими данными все, что нужно, вы должны явно применить функцию <blockquote>mysql_free_result</blockquote>, позволяющую библиотеке MySQL навести после себя порядок.</p>     <p><blockquote><b>void mysql_free_result(MYSQL_RES *result);</b></blockquote></p>     <p>Когда с результирующим набором будет покончено, обязательно нужно вызвать эту. функцию и позволить библиотеке MySQL уничтожить объекты, которым она выделила память.</p>     <b>Извлечение данных</b>     <p>Теперь вы можете написать свое первое приложение с выборкой данных. Вы. хотите выбрать все записи, в которых возраст ребенка более 5 лет. Пока вы еще не знаете, как обработать эти данные, поэтому начнем с простого их извлечения. Важный фрагмент, в котором вы считываете результирующий набор и выводите в цикле полученные данные, выделен цветом. Далее приведена программа select1.с.</p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include "mysql.h"</blockquote></p>     <br>     <p><blockquote>MYSQL my_connection;</blockquote></p>     <p><blockquote>MYSQL_RES *res_ptr;</blockquote></p>     <p><blockquote>MYSQL_ROW sqlrow;</blockquote></p>     <p><blockquote>int main(int argc, char *argv[]) {</blockquote></p>     <p><blockquote> int res;</blockquote></p>     <p><blockquote> mysql_init(&amp;my_connection);</blockquote></p>     <p><blockquote> if (mysql_real_connect(&amp;my_connection, "localhost", "rick",</blockquote></p>     <p><blockquote>  "secret", "foo", 0, NULL, 0)) {</blockquote></p>     <p><blockquote>  printf("Connection success\n");</blockquote></p>     <p><blockquote>  res = mysql_query(&amp;my_connection,</blockquote></p>     <p><blockquote>   "SELECT childno, fname, age FROM children WHERE age &gt; 5");</blockquote></p>     <p><blockquote>  if (res) {</blockquote></p>     <p><blockquote>   printf("SELECT error: %s\n", mysql_error(&amp;my_connection));</blockquote></p>     <p><blockquote>  } else {</blockquote></p>     <p><blockquote><i>   res_ptr = mysql_store_result(&amp;my_connection);</i></blockquote></p>     <p><blockquote><i>   if (res_ptr) {</i></blockquote></p>     <p><blockquote><i>    printf("Retrieved %lu rows\n",</i></blockquote></p>     <p><blockquote><i>     (unsigned long)mysql_num_rows(res_ptr));</i></blockquote></p>     <p><blockquote><i>    while ((sqlrow = mysql_fetch_row(res_ptr))) {</i></blockquote></p>     <p><blockquote><i>     printf("Fetched data...\n");</i></blockquote></p>     <p><blockquote><i>    }</i></blockquote></p>     <p><blockquote>    if (mysql_errno(&amp;my_connection)) {</blockquote></p>     <p><blockquote>     fprintf(stderr, "Retrieve error: %s\n",</blockquote></p>     <p><blockquote>      mysql_error(&amp;my_connection));</blockquote></p>     <p><blockquote>    }</blockquote></p>     <p><blockquote>    mysql_free_result(res_ptr);</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  mysql_close(&amp;my_connection);</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Connection failed\n');</blockquote></p>     <p><blockquote>  if (mysql_errno(&amp;my_connection)) {</blockquote></p>     <p><blockquote>   fprintf(stderr, "Connection error %d: %s\n",</blockquote></p>     <p><blockquote>    mysql_errno(&amp;my_connection), mysql_error(&amp;my_connection));</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return EXIT_SUCCESS;</blockquote></p>     <p><blockquote>}</blockquote></p>     <b>Построчное извлечение данных</b>     <p>Для извлечения данных строка за строкой, если вы действительно хотите этого, пользуйтесь функцией <blockquote>mysql_use_result</blockquote> вместо функции <blockquote>mysql_store_result</blockquote>.</p>     <p><blockquote><b>MYSQL_RES *mysql_use_result(MYSQL *connection);</b></blockquote></p>     <p>Как и <blockquote>mysql_store_result</blockquote>, функция <blockquote>mysql_use_result</blockquote> в случае ошибки возвращает <blockquote>NULL</blockquote>; если она выполняется успешно, то возвращает указатель на объект с результирующим набором. Но эта функция отличается тем, что не считывает никаких данных в результирующий набор, который инициализировала.</p>     <blockquote>      <b>Примечание</b>      <p>Для того чтобы действительно получить данные, следует многократно применять функцию <blockquote>mysql_fetch_row</blockquote> до тех пор, пока все данные не будут извлечены. Если вы не получите все данные от функции <blockquote>mysql_use_result</blockquote>, последующие операции в вашей программе, направленные на извлечение данных, могут вернуть поврежденную информацию.</p>     </blockquote>     <p>В чем же выигрыш от вызова функции <blockquote>mysql_use_result</blockquote> по сравнению с вызовом функции <blockquote>mysql_store_result</blockquote>? У первой из названных функций есть ряд существенных преимуществ, касающихся управления ресурсами; но ее нельзя применять с функциями <blockquote>mysql_data_seek</blockquote>, <blockquote>mysql_row_seek</blockquote> или <blockquote>mysql_row_tell</blockquote> и польза от применения <blockquote>mysql_num_rows</blockquote> ограничена, поскольку она не может нормально функционировать до тех пор, пока не будут извлечены все данные.</p>     <p>Вы также увеличьте время ожидания в вашей программе, т.к. запрос каждой строки должен пройти по сети и также должны быть отправлены обратно результаты. Еще одна возможность — разрыв сетевого соединения в середине операции, оставляющий вас с неполным набором данных.</p>     <p>Но ни один из перечисленных недостатков никак не уменьшает достоинств, упомянутых ранее: лучше сбалансированная сетевая загрузка и меньшие непроизводительные потери памяти в случае возможных очень больших наборов данных.</p>     <p>Замена программы select1.c на программу select2.c, использующую метод <blockquote>mysql_use_result</blockquote>, проста, поэтому далее мы приводим измененный фрагмент в виде закрашенных серым цветом строк:</p>     <p><blockquote>if (res) {</blockquote></p>     <p><blockquote> printf("SELECT error: %s\n", mysql_error(&amp;my_connection));</blockquote></p>     <p><blockquote>} else {</blockquote></p>     <p><blockquote> res_ptr = mysql_use_result(&amp;my_connection);</blockquote></p>     <p><blockquote><i> if (res_ptr) {</i></blockquote></p>     <p><blockquote><i>  while ((sqlrow = mysql_fetch_row(res_ptr))) {</i></blockquote></p>     <p><blockquote><i>   printf("Fetched data...\n");</i></blockquote></p>     <p><blockquote><i>  }</i></blockquote></p>     <p><blockquote>  if (mysql_errno(&amp;my_connection)) {</blockquote></p>     <p><blockquote>   printf("Retrieve error: %s\n", mysql_error(&amp;my_connection));</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  mysql_free_result(res_ptr);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Учтите, что вы не можете получить количество строк до тех пор, пока не будет извлечен последний результат. Но проверяя ошибки как можно раньше и чаще, вы облегчите применение функции <blockquote>mysql_use_result</blockquote>. Разрабатывая программу таким образом, можно уберечься от головной боли при последующих ее модификациях.</p>     <b>Обработка полученных данных</b>     <p>Зная, как извлекать строки, можно перейти к рассмотрению обработки полученных реальных данных.</p>     <p>MySQL, как большинство баз данных SQL, возвращает два вида данных:</p>     <p>&#9633; данные, извлеченные из таблицы и называемые<i> данными столбцов;</i></p>     <p>&#9633; данные о данных, так называемые<i> метаданные,</i> например, имена столбцов и их типы.</p>     <p>Сначала сосредоточимся на получении данных, как таковых, в пригодном к использованию виде.</p>     <p>Функция <blockquote>mysql_field_count</blockquote> предоставляет некоторую базовую информацию о результате запроса. Она принимает ваше подключение как объект и возвращает количество полей (столбцов) в результирующем наборе.</p>     <p><blockquote><b>unsigned int mysql_field_count(MYSQL * connection);</b></blockquote></p>     <p>Помимо этого вы можете использовать <blockquote>mysql_field_count</blockquote> и в других случаях, таких как определение причины аварийного завершения вызова функции <blockquote>mysql_store_result</blockquote>. Если <blockquote>mysql_store_result</blockquote> возвращает <blockquote>NULL</blockquote>, а функция <blockquote>mysql_field_count</blockquote> — положительное число, можно предположить ошибку извлечения. Если же функция <blockquote>mysql_field_count</blockquote> возвращает 0, нет извлекаемых столбцов, что объясняет сбой при попытке сохранить результат. Естественно ожидать, что вы знаете, сколько предполагаемых столбцов должно быть получено в конкретном запросе. Таким образом, эта функция особенно полезна в компонентах общей обработки запросов и в любой ситуации, когда запросы формируются на лету.</p>     <blockquote>      <b>Примечание</b>      <p>В программах, написанных для более ранних версий MySQL, вы можете встретить функцию <blockquote>mysql_num_fields</blockquote>. Она может принимать в качестве параметра указатель на структуру дескриптора подключения или структуру результата запроса и возвращает количество столбцов.</p>     </blockquote>     <p>Если оставить в стороне заботы о форматировании, вы уже знаете, как немедленно вывести данные. Добавьте простую функцию <blockquote>display_row</blockquote> в программу select2.c.</p>     <blockquote>      <b>Примечание</b>      <p>Обратите внимание на то, что для упрощения примера данные о подключении, результате и строке, полученные из функции <blockquote>mysql_fetch_row</blockquote>, все сделаны глобальными. В рабочей программе мы не рекомендуем делать это.</p>     </blockquote>     <p>1. Далее приведена очень простая подпрограмма для вывода данных:</p>     <p><blockquote><i>void display_row() {</i></blockquote></p>     <p><blockquote><i> unsigned int field_count;</i></blockquote></p>     <p><blockquote><i> field_count = 0;</i></blockquote></p>     <p><blockquote><i> while (field_count &lt; mysql_field_count(&amp;my_commection)) {</i></blockquote></p>     <p><blockquote><i>  printf("%s ", sqlrow[field_count]);</i></blockquote></p>     <p><blockquote><i>  field_count++;</i></blockquote></p>     <p><blockquote><i> }</i></blockquote></p>     <p><blockquote><i> printf("\n");</i></blockquote></p>     <p><blockquote><i>}</i></blockquote></p>     <p>2. Вставьте ее в конец файла select2.c и добавьте объявление и вызов функции:</p>     <p><blockquote><i>void display_row();</i></blockquote></p>     <br>     <p><blockquote>int main(int argc, char *argv[]) {</blockquote></p>     <p><blockquote> int res;</blockquote></p>     <p><blockquote> mysql_init(&amp;my_connection);</blockquote></p>     <p><blockquote> if (mysql_real_connect(&amp;my_connection, "localhost", "rick",</blockquote></p>     <p><blockquote>  "bar", "rick", 0, NULL, 0)) {</blockquote></p>     <p><blockquote>  printf("Connection success\n");</blockquote></p>     <p><blockquote>  res = mysql_query(&amp;my_connection,</blockquote></p>     <p><blockquote>   "SELECT childno, fname, age FROM children WHERE age &gt; 5");</blockquote></p>     <p><blockquote>  if (res) {</blockquote></p>     <p><blockquote>   printf("SELECT error: %s\n", mysql_error(&amp;my_connection));</blockquote></p>     <p><blockquote>  } else {</blockquote></p>     <p><blockquote>   res_ptr = mysql_use_result(&amp;my_connection);</blockquote></p>     <p><blockquote>   if (res_ptr) {</blockquote></p>     <p><blockquote>    while ((sqlrow = mysql_fetch_row(res_ptr))) {</blockquote></p>     <p><blockquote>     printf("Fetched data...\n");</blockquote></p>     <p><blockquote>     display_row();</blockquote></p>     <p><blockquote>    }</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>3. Теперь сохраните законченный проект с именем select3.c. В заключение откомпилируйте и выполните select3, как показано далее:</p>     <p><blockquote>$ <b>gcc -I/usr/include/mysql select3. с -L/usr/lib/mysql -lmysqlclient -о select3</b></blockquote></p>     <p><blockquote>$ <b>./select3</b></blockquote></p>     <p><blockquote>Connection success</blockquote></p>     <p><blockquote>Fetched data...</blockquote></p>     <p><blockquote>1 Jenny 21</blockquote></p>     <p><blockquote>Fetched data...</blockquote></p>     <p><blockquote>2 Andrew 17</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Итак, программа работает, несмотря на не слишком эстетически привлекательный вывод. Но вы не смогли учесть в результате возможные значения <blockquote>NULL</blockquote>. Если вы хотите вывести более искусно отформатированные (в виде таблицы, например) данные, следует получить из MySQL данные и метаданные. Одновременно считать как данные, так и метаданные в новую структуру вы можете с помощью функции <blockquote>mysql_fetch_field</blockquote>.</p>     <p><blockquote><b>MYSQL_FIELD *mysql_fetch_field(MYSQL_RES *result);</b></blockquote></p>     <p>Вызывать эту функцию следует многократно, до тех пор, пока не будет возвращено значение <blockquote>NULL</blockquote>, которое сигнализирует о том, что данные закончились. Далее вы можете использовать указатель на структуру данных о поле для получения сведений о столбце. Структура типа <blockquote>MYSQL_FIELD</blockquote> определена в файле mysql.h, как показано в табл. 8.12.</p>     <br>     <p><b><i>Таблица 8.12</i></b></p>     <table>      <tr>       <th valign="top">Поле в структуре типа <blockquote>MYSQL_FIELD</blockquote></th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>char *name;</blockquote></td>       <td valign="top">Имя столбца в виде строки</td>      </tr>      <tr>       <td valign="top"><blockquote>char *table;</blockquote></td>       <td valign="top">Имя таблицы, из которой получен столбец. Оно особенно полезно в запросе с использованием нескольких таблиц. Имейте в виду, что вычисляемое значение в результате, такое как <blockquote>MAX</blockquote>, будет иметь пустую строку для имени таблицы</td>      </tr>      <tr>       <td valign="top"><blockquote>char *def;</blockquote></td>       <td valign="top">При вызове функции <blockquote>mysql_list_fields</blockquote> (которую мы не обсуждаем) это поле содержит значение в столбце по умолчанию</td>      </tr>      <tr>       <td valign="top"><blockquote>enum enum_field_types type;</blockquote></td>       <td valign="top">Тип столбца. См. пояснения сразу после таблицы</td>      </tr>      <tr>       <td valign="top"><blockquote>unsigned int length;</blockquote></td>       <td valign="top">Ширина столбца, заданная при определении таблицы</td>      </tr>      <tr>       <td valign="top"><blockquote>unsigned int max_length;</blockquote></td>       <td valign="top">Если применяется функция <blockquote>mysql_store_result</blockquote>, это поле содержит длину в байтах самого длинного извлеченного значения столбца. Если применяется функция <blockquote>mysql_use_result</blockquote>, поле не задается</td>      </tr>      <tr>       <td valign="top"><blockquote>unsigned int flags;</blockquote></td>       <td valign="top">Флаги содержат информацию об определении столбца, а не о найденных данных. у распространенных флагов очевидные значения: <blockquote>NOT_NULL_FLAG</blockquote>, <blockquote>PRI_KEY_FLAG</blockquote>, <blockquote>UNSIGNED_FLAG</blockquote>, <blockquote>AUTO_INCREMENT_FLAG</blockquote> и <blockquote>BINARY_FLAG</blockquote>. Полный список флагов можно найти в документации MySQL</td>      </tr>      <tr>       <td valign="top"><blockquote>unsigned int decimals;</blockquote></td>       <td valign="top">Количество знаков после десятичной точки. Справедливо только для числовых полей</td>      </tr>     </table>     <p>Типов столбца огромное множество. Полный перечень можно найти в файле mysql_com.h и в документации.</p>     <p>К самым распространенным относятся следующие:</p>     <p><blockquote>FIELD_TYPE_DECIMAL</blockquote></p>     <p><blockquote>FIELD_TYPE_LONG</blockquote></p>     <p><blockquote>FIELD_TYPE_STRING</blockquote></p>     <p><blockquote>FIELD_TYPE_VAR_STRING</blockquote></p>     <p>Далее приведен особенно полезный макрос <blockquote>IS_NUM</blockquote>, возвращающий значение <blockquote>true</blockquote>, если тип поля числовой:</p>     <p><blockquote>if (IS_NUM(myslq_field_ptr-&gt;type)) printf("Numeric type field\n");</blockquote></p>     <p>Прежде чем обновлять вашу программу, следует упомянуть еще одну функцию:</p>     <p><blockquote><b>MYSQL_FIELD_OFFSET mysql_field_seek(MYSQL_RES* result,</b></blockquote></p>     <p><blockquote><b> MYSQL_FIELD_OFFSET offset);</b></blockquote></p>     <p>Ее можно использовать для переопределения текущего номера поля, который автоматически увеличивается при каждом вызове <blockquote>mysql_fetch_field</blockquote>. Если передать нулевое смещение, вы вернетесь назад к первому столбцу.</p>     <p>Теперь, имея всю необходимую информацию для написания программы выборки, покажите все дополнительные данные, относящиеся к заданному столбцу.</p>     <p>Далее приведена программа select4.c, которую мы воспроизводим полностью, чтобы у вас был полный пример для изучения. В программе нет расширенного анализа типов столбцов, в ней только демонстрируются требуемые основные правила.</p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include "mysql.h"</blockquote></p>     <br>     <p><blockquote>MYSQL my_connection;</blockquote></p>     <p><blockquote>MYSQL_RES *res_ptr;</blockquote></p>     <p><blockquote>MYSQL_ROW sqlrow;</blockquote></p>     <br>     <p><blockquote>void display_header();</blockquote></p>     <p><blockquote>void display_row();</blockquote></p>     <br>     <p><blockquote>int main(int argc, char *argv[]) {</blockquote></p>     <p><blockquote> int res;</blockquote></p>     <p><blockquote> int first_row = 1; /* Применяется для гарантии того,</blockquote></p>     <p><blockquote>                       что мы выводим заголовок строки точно один раз,</blockquote></p>     <p><blockquote>                       когда данные успешно извлечены */</blockquote></p>     <p><blockquote> mysql_init(&amp;my_connection);</blockquote></p>     <p><blockquote> if (mysql_real_connect(&amp;my_connection, "localhost", "rick",</blockquote></p>     <p><blockquote>  "secret", "foo", 0, NULL, 0)) {</blockquote></p>     <p><blockquote>  printf("Connection success\n");</blockquote></p>     <p><blockquote>  res = mysql_query(&amp;my_connection,</blockquote></p>     <p><blockquote>   "SELECT childno, fname, age FROM children WHERE age &gt; 5");</blockquote></p>     <p><blockquote>  if (res) {</blockquote></p>     <p><blockquote>   fprintf(stderr, "SELECT error: %s\n", mysql_error(&amp;my_connection));</blockquote></p>     <p><blockquote>  } else {</blockquote></p>     <p><blockquote>   res_ptr = mysql_use_result(&amp;my_connection);</blockquote></p>     <p><blockquote>   if (res_ptr) {</blockquote></p>     <p><blockquote>    while ((sqlrow = mysql_fetch_row(res_ptr))) {</blockquote></p>     <p><blockquote>     if (first_row) {</blockquote></p>     <p><blockquote>      display_header();</blockquote></p>     <p><blockquote>      first_row = 0;</blockquote></p>     <p><blockquote>     }</blockquote></p>     <p><blockquote>     display_row();</blockquote></p>     <p><blockquote>    }</blockquote></p>     <p><blockquote>    if (mysql_errno(&amp;my_connection)) {</blockquote></p>     <p><blockquote>     fprintf(stderr, "Retrieve error: %s\n", mysql_error(&amp;my_connection));</blockquote></p>     <p><blockquote>    }</blockquote></p>     <p><blockquote>    mysql_free_result(res_ptr);</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  mysql_close(&amp;my_connection);</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Connection failed\n");</blockquote></p>     <p><blockquote>  if (mysql_errno(&amp;my_connection)) {</blockquote></p>     <p><blockquote>   fprintf(stderr, "Connection error %d: %s\n",</blockquote></p>     <p><blockquote>    mysql_errno(&amp;my_connection), mysql_error(&amp;my_connection))</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return EXIT_SUCCESS;</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote>void display_header() {</blockquote></p>     <p><blockquote> MYSQL_FIELD *field_ptr;</blockquote></p>     <p><blockquote> printf("Column details:\n");</blockquote></p>     <p><blockquote> while ((field_ptr = mysql_fetch_field(res_ptr)) != NULL) {</blockquote></p>     <p><blockquote>  printf("\t Name: %s\n", field_ptr-&gt;name);</blockquote></p>     <p><blockquote>  printf("\t Type: ");</blockquote></p>     <p><blockquote>  if (IS_NUM(field_ptr-&gt;type)) {</blockquote></p>     <p><blockquote>   printf("Numeric field\n");</blockquote></p>     <p><blockquote>  } else {</blockquote></p>     <p><blockquote>   switch(field_ptr-&gt;type) {</blockquote></p>     <p><blockquote>   case FIELD_TYPE_VAR_STRING:</blockquote></p>     <p><blockquote>    printf("VARCHAR\n");</blockquote></p>     <p><blockquote>    break;</blockquote></p>     <p><blockquote>   case FIELD_TYPE_LONG:</blockquote></p>     <p><blockquote>    printf("LONG\n");</blockquote></p>     <p><blockquote>    break;</blockquote></p>     <p><blockquote>   default:</blockquote></p>     <p><blockquote>    printf("Type is %d, check in mysql_com.h\n", field_ptr-&gt;type);</blockquote></p>     <p><blockquote>   } /* switch */</blockquote></p>     <p><blockquote>  } /* else */</blockquote></p>     <p><blockquote>  printf("\t Max width %ld\n", field_ptr-&gt;length);</blockquote></p>     <p><blockquote>  if (field_ptr-&gt;flags &amp; AUTO_INCREMENT_FLAG)</blockquote></p>     <p><blockquote>   printf("\t Auto increments\n");</blockquote></p>     <p><blockquote>  printf("\n");</blockquote></p>     <p><blockquote> } /* while */</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote>void display_row() {</blockquote></p>     <p><blockquote> unsigned int field_count;</blockquote></p>     <p><blockquote> field_count = 0;</blockquote></p>     <p><blockquote> while (field_count &lt; mysql_field_count(&amp;my_connection)) {</blockquote></p>     <p><blockquote>  if (sqlrow[field_count]) printf("%s ", sqlrow[field_count]);</blockquote></p>     <p><blockquote>  else printf("NULL");</blockquote></p>     <p><blockquote>  field_count++;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> printf("\n");</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Когда вы откомпилируете и выполните программу, то получите следующий вывод:</p>     <p><blockquote>$ <b>./select4</b></blockquote></p>     <p><blockquote>Connection success</blockquote></p>     <p><blockquote>Column details:</blockquote></p>     <p><blockquote>      Name: childno</blockquote></p>     <p><blockquote>      Type: Numeric field</blockquote></p>     <p><blockquote>      Max width 11</blockquote></p>     <p><blockquote>      Auto increments</blockquote></p>     <br>     <p><blockquote>      Name: fname</blockquote></p>     <p><blockquote>      Type: VARCHAR</blockquote></p>     <p><blockquote>      Max width 30</blockquote></p>     <br>     <p><blockquote>      Name: age</blockquote></p>     <p><blockquote>      Type: Numeric field</blockquote></p>     <p><blockquote>      Max width 11</blockquote></p>     <br>     <p><blockquote>Column details:</blockquote></p>     <p><blockquote>1 Jenny 21</blockquote></p>     <p><blockquote>2 Andrew 17</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Вывод все еще не слишком привлекателен, но он демонстрирует, как можно обрабатывать и данные, и метаданные, что позволяет более эффективно работать с вашей информацией.</p>     <p>Есть и другие функции, позволяющие извлекать массивы полей и переходить от столбца к столбцу. Как правило, приведенные здесь подпрограммы — все, что вам потребуется; любознательный читатель сможет найти более подробную информацию в руководстве по MySQL.</p>             <a name="metkadoc18"><h1>Разные функции</h1></a>     <p>Есть несколько приведенных в табл. 8.13 дополнительных функций API, которые мы рекомендуем изучить. В основном того, что обсуждалось до сих пор, достаточно для создания функциональной программы, но этот частичный перечень нам кажется полезным.</p>     <br>     <p><b><i>Таблица 8.13</i></b></p>     <table>      <tr>       <th valign="top">Пример API-вызова</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>char *mysql_get_client_info(void);</blockquote></td>       <td valign="top">Возвращает данные о версии библиотеки, используемой клиентской программой</td>      </tr>      <tr>       <td valign="top"><blockquote>char *mysql_get_host_info(MYSQL *connection);</blockquote></td>       <td valign="top">Возвращает информацию о подключении к серверу</td>      </tr>      <tr>       <td valign="top"><blockquote>char *mysql_get_server_info(MYSQL *connection);</blockquote></td>       <td valign="top">Возвращает информацию о сервере, к которому вы в данный момент подключены</td>      </tr>      <tr>       <td valign="top"><blockquote>char *mysql_info(MYSQL* connection);</blockquote></td>       <td valign="top">Возвращает информацию о самом последнем выполненном запросе, но работает только с запросами нескольких типов — обычно с операторами <blockquote>INSERT</blockquote> и <blockquote>UPDATE</blockquote>. В противном случае возвращает <blockquote>NULL</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>int mysql_select_db(MYSQL *connection, const char *dbname);</blockquote></td>       <td valign="top">Заменяет базу данных, применяемую по умолчанию, на заданную в качестве параметра, при условии, что у пользователя есть соответствующие права доступа. В случае успеха возвращает ноль</td>      </tr>      <tr>       <td valign="top"><blockquote>int mysql_shutdown(MYSQL* connection, enum mysql_enum_shutdown level);</blockquote></td>       <td valign="top">Если у вас есть соответствующие права, завершает работу сервера базы данных, к которому вы подключены. В этот момент уровень останова следует задать равным <blockquote>SHUTDOWN_DEFAULT</blockquote>. В случае успеха возвращает ноль</td>      </tr>     </table>              <a name="metkadoc19"><h1>Приложение для работы с базой данных компакт-дисков</h1></a>         <p>Сейчас мы покажем, как вы можете создать простую базу данных для хранения информации о ваших компакт-дисках и затем разработать программу для доступа к этим данным. Для простоты вы ограничитесь тремя таблицами в базе данных с очень простыми связями между ними.</p>     <p>Начните с создания новой базы данных и затем сделайте ее текущей базой данных.</p>     <p><blockquote>mysql&gt; <b>create database blpcd;</b></blockquote></p>     <p><blockquote>Query OK, 1 row affected (0.00 sec)</blockquote></p>     <p><blockquote>mysql&gt;<b> use blpcd</b></blockquote></p>     <p><blockquote>Connection id: 10</blockquote></p>     <p><blockquote>Current database: blpcd</blockquote></p>     <p><blockquote>mysql&gt;</blockquote></p>     <p>Теперь вы готовы к проектированию и созданию необходимых вам таблиц.</p>     <p>Эта версия немного сложнее предыдущей, потому что вы выделите три отдельных элемента компакт-диска: исполнителя (или группу), элемент главного каталога и дорожки. Если вы подумаете о коллекции компакт-дисков и компонентах, ее составляющих, то поймете, что каждый компакт-диск состоит из ряда разных дорожек, но различные компакт-диски связаны друг с другом многими параметрами: исполнителем или группой, компанией, производящей их, представленным музыкальным стилем и т.д.</p>     <p>Вы могли бы сделать базу данных очень сложной, попытавшись сохранить все эти разные параметры, но в данном примере ограничьте себя только двумя самыми важными связями.</p>     <p>Во-первых, каждый компакт-диск состоит из переменного количества дорожек, поэтому вы будете хранить данные о дорожке в таблице, отделенной от остальных данных компакт-диска. Во-вторых, у каждого исполнителя (или группы) часто несколько альбомов, поэтому было бы удобно сохранять сведения об исполнителе один раз, а затем отдельно извлекать все компакт-диски, записанные этим исполнителем. Вы не будете пытаться разбить группы на разных исполнителей, которые, возможно, выпустили сольные альбомы, или работать со сборными компакт-дисками — вы будете стараться сохранять структуру вашей коллекции простой!</p>     <p>Связи тоже сохраняйте очень простыми — каждый исполнитель (им может быть название группы) выпустил один или несколько компакт-дисков и каждый компакт-диск состоит из одной или нескольких дорожек. Связи или отношения в вашей базе данных представлены на рис. 8.8.</p>     <img src="image030.jpg"/>     <p><b>Рис. 8.8</b></p>             <a name="metkadoc20"><h1>Создание таблиц</h1></a>     <p>Сейчас вы должны определить реальную структуру таблиц. Начните с основной таблицы — таблицы компакт-дисков (<blockquote>cd</blockquote>), в которой хранится большая часть информации. Вам нужно сохранять идентификационный номер (<blockquote>id</blockquote>) компакт-диска, номер каталога, название и, возможно, ваши собственные заметки. Вам также понадобится ID-номер из таблицы исполнителей, чтобы знать, какой исполнитель выпустил альбом.</p>     <p>Таблица исполнителей (<blockquote>artist</blockquote>) очень проста; сохраните в ней только имя исполнителя и уникальный идентификационный номер (id) исполнителя. Таблица дорожек (<blockquote>track</blockquote>) также чрезвычайно проста; вам нужен только ID компакт-диска, чтобы знать, к какому CD относится дорожка, номер дорожки и название дорожки.</p>     <p>Сначала таблица компакт-диска:</p>     <p><blockquote>CREATE TABLE cd (</blockquote></p>     <p><blockquote> id INTEGER AUTO_INCREMENT NOT NULL PRIMARY KEY,</blockquote></p>     <p><blockquote> title VARCHAR(70) NOT NULL,</blockquote></p>     <p><blockquote> artist_id INTEGER NOT NULL,</blockquote></p>     <p><blockquote> catalogue VARCHAR(30) NOT NULL,</blockquote></p>     <p><blockquote> notes VARCHAR(100)</blockquote></p>     <p><blockquote>);</blockquote></p>     <p>Приведенный программный код создает таблицу с именем <blockquote>cd</blockquote> со следующими столбцами:</p>     <p>&#9633; столбец <blockquote>id</blockquote>, содержащий целое число, которое автоматически увеличивается и представляет собой первичный ключ таблицы;</p>     <p>&#9633; столбец <blockquote>title</blockquote> длиной до 70 символов;</p>     <p>&#9633; столбец <blockquote>artist_id</blockquote> — целое число, которое будет использоваться в таблице <blockquote>artist</blockquote>;</p>     <p>&#9633; столбец <blockquote>catalogue</blockquote> — номер длиной до 30 символов;</p>     <p>&#9633; столбец <blockquote>notes</blockquote> до 100 символов.</p>     <p>Учтите, что только столбец <blockquote>notes</blockquote> может быть <blockquote>NULL</blockquote>; у всех остальных должны быть значения.</p>     <p>Теперь таблица <blockquote>artist</blockquote>:</p>     <p><blockquote>CREATE TABLE artist (</blockquote></p>     <p><blockquote> id INTEGER AUTO_INCREMENT NOT NULL PRIMARY KEY,</blockquote></p>     <p><blockquote> name VARCHAR(100) NOT NULL</blockquote></p>     <p><blockquote>);</blockquote></p>     <p>И снова у вас столбец <blockquote>id</blockquote> и еще один для имени исполнителя.</p>     <p>И наконец, таблица <blockquote>track</blockquote>:</p>     <p><blockquote>CREATE TABLE track (</blockquote></p>     <p><blockquote> cd_id INTEGER NOT NULL,</blockquote></p>     <p><blockquote> track_id INTEGER NOT NULL,</blockquote></p>     <p><blockquote> title VARCHAR(70),</blockquote></p>     <p><blockquote> PRIMARY KEY(cd_id, track_id)</blockquote></p>     <p><blockquote>);</blockquote></p>     <p>Обратите внимание на то, что на этот раз вы объявили первичный ключ несколько иначе. Таблица <blockquote>track</blockquote> необычна тем, что ID каждого компакт-диска будет появляться несколько раз, ID любой заданной дорожки, скажем, дорожки 1, также будет появляться несколько раз в разных компакт-дисках. Но их комбинация всегда будет уникальной, поэтому объявите ваш первичный ключ как комбинацию двух столбцов. Такой ключ называют<i> составным</i>, поскольку он состоит из нескольких столбцов, участвующих в комбинации.</p>     <p>Сохраните эти SQL-операторы в текущем каталоге, в файле, названном create_tables.sql, и затем двигайтесь дальше и создайте базу данных и таблицы в ней. Готовый пример сценария содержит дополнительные строки, по умолчанию помеченные как комментарий, в них удаляются эти таблицы, если они уже существуют.</p>     <p><blockquote>$ <b>mysql -u rick -р</b></blockquote></p>     <p><blockquote>Enter password:</blockquote></p>     <p><blockquote>Welcome to the MySQL monitor. Commands end with ; or \g.</blockquote></p>     <p><blockquote>mysql&gt; <b>use blpcd;</b></blockquote></p>     <p><blockquote>Database changed</blockquote></p>     <p><blockquote>mysql&gt; <b>\. create_tables.sql</b></blockquote></p>     <p><blockquote>Query OK, 0 rows affected (6.04 sec)</blockquote></p>     <p><blockquote>Query OK, 0 rows affected (0.10 sec)</blockquote></p>     <p><blockquote>Query OK, 0 rows affected (0.00. sec)</blockquote></p>     <p><blockquote>mysql&gt;</blockquote></p>     <p>Обратите внимание на применение команды <blockquote>\.</blockquote> для получения ввода из файла create_tables.sql.</p>     <p>Вы могли бы создать таблицы, выполнив операторы SQL или просто набирая данные с помощью обозревателя запросов MySQL Query Browser.</p>     <p>После того как таблицы созданы, их можно просмотреть, используя MySQL Administrator (рис. 8.9), в котором вы проверяете таблицу индексов базы данных <blockquote>blpcd</blockquote> (или схему, если вы предпочитаете этот термин).</p>     <p>Выбрав редактирование таблицы (щелчок правой кнопкой мыши или двойной щелчок мышью имени таблицы на вкладке<b> Tables</b> (Таблицы)) позволит увидеть дополнительные сведения о столбцах (рис. 8.10).</p>     <img src="image031.jpg"/>     <p><b>Рис. 8.9</b></p>     <br>     <img src="image032.jpg"/>     <p><b>Рис. 8.10</b> </p>     <br>     <p>Вы заметили два значка ключа рядом со столбцами <blockquote>cd_id</blockquote> и <blockquote>track_id</blockquote> на рис. 8.10? Это означает, что они оба участвуют в формировании составного первичного ключа. Разрешив названию дорожки быть равным <blockquote>NULL</blockquote> (условие <blockquote>NOT NULL</blockquote> не проверяется), вы допускаете наличие нетипичной, но иногда встречающейся дорожки компакт-диска, не имеющей названия.</p>             <a name="metkadoc21"><h1>Вставка данных</h1></a>     <p>Теперь вам нужно вставить какие-нибудь данные. Лучший способ проверки любого проекта базы данных — вставка контрольных данных и проверка работоспособности проекта.</p>     <p>Далее мы продемонстрируем пример импорта тестовых данных, что не важно для понимания происходящего, т. к. все операции импорта в основном похожи — они загружают разные таблицы. Есть два важных аспекта, на которые здесь следует обратить внимание.</p>     <p>&#9633; Сценарий удаляет любые имеющиеся данные, чтобы начать с "чистого листа".</p>     <p>&#9633; В поля <blockquote>id</blockquote> вставляются значения вместо использования функции <blockquote>AUTO_INCREMENT</blockquote>. В данном случае это безопаснее, поскольку при вставках необходимо знать, какие значения применялись, чтобы убедиться в полной корректности отношений между разными данными, поэтому лучше ввести значения, чем разрешить средству <blockquote>AUTO_INCREMENT</blockquote> автоматически сгенерировать их.</p>     <p>Этот файл назван insert_data.sql и может быть выполнен с помощью команды <blockquote>\.</blockquote>, которую вы уже видели:</p>     <p><blockquote>-- Удаляются существующие данные</blockquote></p>     <p><blockquote>delete from track;</blockquote></p>     <p><blockquote>delete from cd;</blockquote></p>     <p><blockquote>delete from artist;</blockquote></p>     <p><blockquote>-- Теперь данные вставляются</blockquote></p>     <p><blockquote>-- Сначала таблица artist (исполнители или группы)</blockquote></p>     <p><blockquote>insert into artist(id, name) values(1, 'Pink Floyd');</blockquote></p>     <p><blockquote>insert into artist(id, name) values(2, 'Genesis');</blockquote></p>     <p><blockquote>insert into artist(id, name) values(3, 'Einaudi');</blockquote></p>     <p><blockquote>insert into artist(id, name) values(4, 'Melanie C');</blockquote></p>     <p><blockquote>-- Затем таблица cd</blockquote></p>     <p><blockquote>insert into cd(id, title, artist_id, catalogue) values(1, 'Dark Side of the Moon', 1, 'B000024D4P');</blockquote></p>     <p><blockquote>insert into cd(id, title, artist_id, catalogue) values(2, 'Wish You Were Here', 1, 'B000024D4S');</blockquote></p>     <p><blockquote>insert into cd(id, title, artist_id, catalogue) values(3, 'A Trick of the Tail', 2, 'B000024EXM');</blockquote></p>     <p><blockquote>insert into cd(id, title, artist_id, catalogue) values(4, 'Selling England By the Pound', 2, 'B000024E9M');</blockquote></p>     <p><blockquote>insert into cd(id, title, artist_id, catalogue) values(5, 'I Giorni', 3, 'B000071WEV');</blockquote></p>     <p><blockquote>insert into cd(id, title, artist_id, catalogue) values(6, 'Northern Star', 4, 'B00004YMST');</blockquote></p>     <p><blockquote>--- Заполнение дорожек</blockquote></p>     <p><blockquote>insert into track(cd_id, track_id, title) values(1, 1, 'Speak to me');</blockquote></p>     <p><blockquote>insert into track(cd_id, track_id, title) values(1, 2, 'Breathe');</blockquote></p>     <p>и оставшиеся дорожки этого альбома и следующий альбом:</p>     <p><blockquote>insert into track(cd_id, track_id, title) values(2, 1, 'Shine on you crazy diamond');</blockquote></p>     <p><blockquote>insert into track(cd_id, track_id, title) values(2, 2, 'Welcome to the machine');</blockquote></p>     <p><blockquote>insert into track(cd_id, track_id, title) values(2, 3, 'Have a cigar');</blockquote></p>     <p><blockquote>insert into track(cd_id, track_id, title) values(2, 4, 'Wish you were here');</blockquote></p>     <p><blockquote>insert into track(cd_id, track_id, title) values(2, 5, 'Shine on you crazy diamond pt.2');</blockquote></p>     <p>и т.д.</p>     <p><blockquote>insert into track(cd_id, track_id, title) values(5, 1, 'Melodia Africana (part 1)';</blockquote></p>     <p><blockquote>insert into track(cd_id, track_id, title) values(5, 2, 'I due fiumi');</blockquote></p>     <p><blockquote>insert into track(cd_id, track_id, title) values(5, 3, 'In un\'altra vita');</blockquote></p>     <p>…до финальных дорожек:</p>     <p><blockquote>insert into track(cd_id, track_id, title) values(6, 11, 'Closer');</blockquote></p>     <p><blockquote>insert into track(cd_id, track_id, title) values(6, 12, 'Feel The Sun');</blockquote></p>     <p>Далее сохраните это в файле pop_tables.sql и выполните его, как и раньше, из командной строки монитора mysql с помощью команды <blockquote>\.</blockquote>.</p>     <blockquote>      <b>Примечание</b>      <p>Обратите внимание на то, что в <blockquote>cd_id=5</blockquote> ("I Giorni") с <blockquote>track</blockquote>=3 название <blockquote>In un'altra vita</blockquote> содержит апостроф. Для вставки его в базу данных вы должны использовать обратный слэш (<blockquote>\</blockquote>).</p>     </blockquote>     <p>Теперь самое время убедиться в том, что ваши данные выглядят осмысленно. Для этого можно применить программу-клиент mysql в режиме командной строки и SQL-операторы. Начните с выбора двух первых дорожек из каждого альбома в вашей базе данных.</p>     <p><blockquote>SELECT artist.name, cd.title AS "CD Title", track.track_id, track.title AS "Track" FROM artist, cd, track WHERE artist.id = cd.artist_id AND track.cd_id = cd.id AND track.track_id &lt; 3</blockquote></p>     <p>Если вы выполните этот оператор в MySQL Query Browser, то увидите, что данные выглядят нормально (рис. 8.11).</p>     <p>SQL-оператор на первый взгляд сложноват, но это можно исправить, рассматривая его последовательно по частям.</p>     <p>Если игнорировать части <blockquote>AS</blockquote> в операторе <blockquote>SELECT</blockquote>, его первая часть такова:</p>     <p><blockquote>SELECT artist.name, cd.title, track.track_id, track.title</blockquote></p>     <p>Она просто сообщает о том, какие столбцы вы хотите отобразить, используя форму записи<i> имя_таблицы.имя_столбца.</i><b>Рис. 8.11</b> </p>     <img src="image033.jpg"/>     <br>     <p>Части <blockquote>AS</blockquote> оператора SELECT</p>     <p><blockquote>SELECT artist.name, cd.title AS "CD Title", track.track_id, and track.title AS "Track"</blockquote></p>     <p>просто переименовывают столбцы в отображаемом выводе. Таким образом, заголовок столбца <blockquote>title</blockquote> из таблицы <blockquote>cd</blockquote> (<blockquote>cd.title</blockquote>) называется "CD Title", а столбец <blockquote>track.track.id</blockquote> — "Track". Подобное использование ключевого слова <blockquote>AS</blockquote> обеспечивает более дружественный по отношению к пользователю вывод. Вы практически никогда не будете применять эти имена при вызове SQL-операторов из другого языка программирования, но ключевое слово as полезно при работе с SQL-операторами из командной строки.</p>     <p>Следующая часть тоже понятна: она сообщает серверу имена таблиц, которые вы используете:</p>     <p><blockquote>FROM artist, cd, track</blockquote></p>     <p>Часть <blockquote>WHERE</blockquote> слегка мудреная:</p>     <p><blockquote>WHERE artist.id = cd.artist_id AND track.cd_id = cd.id AND track.track_id &lt; 3</blockquote></p>     <p>Первый фрагмент сообщает серверу о том, что <blockquote>id</blockquote> в таблице <blockquote>artist</blockquote> такой же, как номер в столбце <blockquote>artist_id</blockquote> таблицы <blockquote>cd</blockquote>. Напоминаем, что вы сохраняете имя исполнителя один раз и используете <blockquote>id</blockquote> для ссылки на этого исполнителя в таблице <blockquote>cd</blockquote>. Следующий фрагмент, <blockquote>track.cd_id = cd.id</blockquote>, проделывает то же самое для таблиц <blockquote>track</blockquote> и <blockquote>cd</blockquote>, извещая сервер о том, что столбец <blockquote>cd_id</blockquote> таблицы <blockquote>track</blockquote> такой же, как столбец <blockquote>id</blockquote> таблицы <blockquote>cd</blockquote>. Третий фрагмент, <blockquote>track.track_id &lt; 3</blockquote>, ограничивает объем возвращаемых данных так, что вы получаете только дорожки 1 и 2 из каждого компакт-диска. Последнее, но не по значимости, объединение этих трех условий с помощью операции <blockquote>AND</blockquote>, т.к. вы хотите, чтобы все три условия были истинными.</p>             <a name="metkadoc22"><h1>Доступ к данным приложения из программы на С</h1></a>     <p>В этой главе вы не готовы писать законченное приложение, применяющее интерфейс GUI. Прежде надо сконцентрироваться на написании файла интерфейса, позволяющего сравнительно просто получить доступ, к вашим данным из программы на языке С. Общая проблема при написании подобного программного кода — неизвестные объем данных, которые могут быть возвращены, и способ передачи их между программой-клиентом и программой, обращающейся к базе данных. В данном приложении, для того чтобы сохранить его простоту и сосредоточиться на интерфейсе базы данных, очень важной части программного кода, будут применяться структуры фиксированного размера. В реальном приложении этот вариант может оказаться неприемлемым. Универсальное решение, также облегчающее сетевой трафик, — всегда извлекать данные построчно с помощью функций <blockquote>mysql_use_result</blockquote> и <blockquote>mysql_fetch_row</blockquote>, как было показано ранее в этой главе.</p>     <b>Определение интерфейса</b>     <p>Начните с заголовочного файла app_mysql.h, в котором определяются структуры и функции.</p>     <p>Сначала несколько структур:</p>     <p><blockquote>/* Упрощенная структура для представления компакт-диска</blockquote></p>     <p><blockquote>   за исключением информации о дорожке */</blockquote></p>     <p><blockquote>struct current_cd_st {</blockquote></p>     <p><blockquote> int artist_id;</blockquote></p>     <p><blockquote> int cd_id;</blockquote></p>     <p><blockquote> char artist_name[100];</blockquote></p>     <p><blockquote> char title[100];</blockquote></p>     <p><blockquote> char catalogue[100];</blockquote></p>     <p><blockquote>};</blockquote></p>     <br>     <p><blockquote>/* Упрощенная структура сведений о дорожке */</blockquote></p>     <p><blockquote>struct current_tracks_st {</blockquote></p>     <p><blockquote> int cd_id;</blockquote></p>     <p><blockquote> char track[20][100];</blockquote></p>     <p><blockquote>};</blockquote></p>     <br>     <p><blockquote>#define MAX_CD_RESULT 10</blockquote></p>     <p><blockquote>struct cd_search_st {</blockquote></p>     <p><blockquote> int cd_id[MAX_CD_RESULT];</blockquote></p>     <p><blockquote>};</blockquote></p>     <p>Далее пара функций для подключения к серверу и отключения от него:</p>     <p><blockquote>/* Серверные функции базы данных */</blockquote></p>     <p><blockquote>int database_start(char *name, char *password);</blockquote></p>     <p><blockquote>void database_end();</blockquote></p>     <p>Теперь перейдем к функциям манипулирования данными. Обратите внимание на отсутствие функций создания и удаления исполнителей. Вы реализуете их за кадром, создавая необходимые записи об исполнителях и затем удаляя их, когда их упоминания не остается ни в одном альбоме.</p>     <p><blockquote>/* Функции для добавления компакт-диска */</blockquote></p>     <p><blockquote>int add_cd(char *artist, char *title, char *catalogue, int *cd_id);</blockquote></p>     <p><blockquote>int add_tracks(struct current_tracks_st *tracks);</blockquote></p>     <br>     <p><blockquote>/* Функции поиска и извлечения компакт-диска */</blockquote></p>     <p><blockquote>int find_cds(char *search_str, struct cd_search_st *results);</blockquote></p>     <p><blockquote>int get_cd(int cd_id, struct current_cd_st *dest);</blockquote></p>     <p><blockquote>int get_cd_tracks(int cd_id, struct current_tracks_st *dest);</blockquote></p>     <br>     <p><blockquote>/* Функция для удаления элементов */</blockquote></p>     <p><blockquote>int delete_cd(int cd_id);</blockquote></p>     <p>Функция поиска очень обобщенная: вы передаете строку, и она ищет эту строку в элементах "исполнитель", "название" или "каталог".</p>     <b>Тестирование интерфейса приложения</b>     <p>Перед реализацией вашего интерфейса следует написать программный код, использующий его. Это может показаться странным, но зачастую это хороший способ подробно проанализировать поведение интерфейса, прежде чем принимать решение о его реализации.</p>     <p>Далее приведена программа app_test.c. Сначала несколько файлов include и типов structs:</p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <p><blockquote>#include "app_mysql.h"</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> struct current_cd_st cd;</blockquote></p>     <p><blockquote> struct cd_search_st cd_res;</blockquote></p>     <p><blockquote> struct current_tracks_st ct;</blockquote></p>     <p><blockquote> int cd_id;</blockquote></p>     <p><blockquote> int res, i;</blockquote></p>     <p>Первое, что всегда должно делать ваше приложение, — инициализация подключения к базе данных, предоставляющая корректные имя пользователя и пароль (убедитесь, что вы заменили их своими):</p>     <p><blockquote> database_start("rick", "secret");</blockquote></p>     <p>Далее тестируется добавление компакт-диска:</p>     <p><blockquote> res = add_cd("Mahler", "Symphony No 1", "4596102", &amp;cd_id);</blockquote></p>     <p><blockquote> printf("Result of adding a cd was %d, cd_id is %d\n", res, cd_id);</blockquote></p>     <p><blockquote> memset(&amp;ct, 0, sizeof(ct));</blockquote></p>     <p><blockquote> ct.cd_id = cd_id;</blockquote></p>     <p><blockquote> strcpy(ct.track[0], "Langsam Schleppend");</blockquote></p>     <p><blockquote> strcpy(ct.track[1], "Kraftig bewegt");</blockquote></p>     <p><blockquote> strcpy(ct.track[2], "Feierlich und gemessen");</blockquote></p>     <p><blockquote> strcpy(ct.track[3], "St&#252;rmisch bewegt");</blockquote></p>     <p><blockquote> add_tracks(set);</blockquote></p>     <p>Теперь поищите компакт-диск и извлеките информацию из первого найденного CD:</p>     <p><blockquote> res = find_cds("Symphony", &amp;cd_res);</blockquote></p>     <p><blockquote> printf("Found %d cds, first has ID %d\n", res, cd_res.cd_id[0]);</blockquote></p>     <p><blockquote> res = get_cd(cd_res.cd_id[0], &amp;cd);</blockquote></p>     <p><blockquote> printf("get_cd returned %d\n", res);</blockquote></p>     <p><blockquote> memset(&amp;ct, 0, sizeof(ct));</blockquote></p>     <p><blockquote> res = get_cd_tracks(cd_res.cd_id[0], set);</blockquote></p>     <p><blockquote> printf("get_cd_tracks returned %d\n", res);</blockquote></p>     <p><blockquote> printf("Title: %s\n", cd.title);</blockquote></p>     <p><blockquote> i = 0;</blockquote></p>     <p><blockquote> while (i &lt; res) {</blockquote></p>     <p><blockquote>  printf("\ttrack %d is %s\n", i, ct.track[i]);</blockquote></p>     <p><blockquote>  i++;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p>В заключение удалите компакт-диск:</p>     <p><blockquote> res = delete_cd(cd_res.cd_id[0]);</blockquote></p>     <p><blockquote> printf("Delete_cd returned %d\n", res);</blockquote></p>     <p>Затем отключитесь и завершите работу программы:</p>     <p><blockquote> database_end();</blockquote></p>     <p><blockquote> return EXIT_SUCCESS;</blockquote></p>     <p><blockquote>}</blockquote></p>     <b>Реализация интерфейса</b>     <p>Теперь более трудная часть — реализация интерфейса, описанного вами. Вся она хранится в файле app_mysql.с.</p>     <p>Начните с основных файлов <blockquote>include</blockquote>, глобальной структуры подключения, которая понадобится, и флага <blockquote>dbconnected</blockquote>, который будет применяться для того, чтобы приложения не пытались получить доступ к данным, если у них нет подключения. Вы также используете внутреннюю функцию <blockquote>get_artist_id</blockquote>, для улучшения структуры программы:</p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <p><blockquote>#include "mysql.h"</blockquote></p>     <p><blockquote>#include "app_mysql.h"</blockquote></p>     <br>     <p><blockquote>static MYSQL my_connection;</blockquote></p>     <p><blockquote>static int dbconnected = 0;</blockquote></p>     <p><blockquote>static int get_artist_id(char *artist);</blockquote></p>     <p>Как вы видели ранее в этой главе, подключиться к базе данных очень просто, а отключиться от нее и того проще:</p>     <p><blockquote>int database_start(char *name, char *pwd) {</blockquote></p>     <p><blockquote> if (dbconnected) return 1;</blockquote></p>     <p><blockquote> mysql_init(&amp;my_connection);</blockquote></p>     <p><blockquote> if (!mysql_real_connect(&amp;my_connection, "localhost",</blockquote></p>     <p><blockquote>  name, pwd, "blpcd", 0, NULL, 0)) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Database connection failure: %d, %s\n",</blockquote></p>     <p><blockquote>   mysql_errno(&amp;my_connection), mysql_error(&amp;my_connection));</blockquote></p>     <p><blockquote>  return 0;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> dbconnected = 1;</blockquote></p>     <p><blockquote> return 1;</blockquote></p>     <p><blockquote>} /* database_start */</blockquote></p>     <br>     <p><blockquote>void database_end() {</blockquote></p>     <p><blockquote> if (dbconnected) mysql_close(&amp;my_connection);</blockquote></p>     <p><blockquote> dbconnected = 0;</blockquote></p>     <p><blockquote>} /* database_end */</blockquote></p>     <p>Начинается реальная работа благодаря функции <blockquote>add_cd</blockquote>. Вам нужны сначала несколько объявлений и санитарная проверка, Чтобы убедиться в наличии подключения к базе данных. Вы увидите ее во всех написанных функциях, доступных извне.</p>     <p>Напоминаем о том, что программа будет отслеживать имена исполнителей автоматически:</p>     <p><blockquote>int add_cd(char *artist, char *title, char* catalogue, int *cd_id) {</blockquote></p>     <p><blockquote> MYSQL_RES *res_ptr;</blockquote></p>     <p><blockquote> MYSQL_ROW mysqlrow;</blockquote></p>     <p><blockquote> int res;</blockquote></p>     <p><blockquote> char is[250];</blockquote></p>     <p><blockquote> char es[250];</blockquote></p>     <p><blockquote> int artist_id = -1;</blockquote></p>     <p><blockquote> int new_cd_id = -1;</blockquote></p>     <p><blockquote> if (!dbconnected) return 0;</blockquote></p>     <p>Далее нужно проверить, существует ли уже исполнитель, если нет, то создать его. Обо всем этом заботится функция <blockquote>get_artist_id</blockquote>, которую вы скоро увидите:</p>     <p><blockquote> artist_id = get_artist_id(artist);</blockquote></p>     <p>Теперь, имея <blockquote>artist_id</blockquote>, вы можете вставлять главную запись компакт-диска. Обратите внимание на применение функции <blockquote>mysql_escape_string</blockquote>, не допускающей специальных символов в названии компакт-диска.</p>     <p><blockquote> mysql_escape_string(es, title, strlen(title));</blockquote></p>     <p><blockquote> sprintf(is,</blockquote></p>     <p><blockquote>  "INSERT INTO cd(title, artist_id, catalogue) VALUES('%s', %d, '%s')",</blockquote></p>     <p><blockquote>  es, artist_id, catalogue);</blockquote></p>     <p><blockquote> res = mysql_query(&amp;my_connection, is);</blockquote></p>     <p><blockquote> if (res) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Insert error %d: %s\n",</blockquote></p>     <p><blockquote>   mysql_errno(&amp;my_connection), mysql_error(&amp;my_connection));</blockquote></p>     <p><blockquote>  return 0;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p>Когда вы дойдете до вставки дорожек для данного компакт-диска, вам потребуется знать ID, который использовался при вставке записи о компакт-диске. Вы сделали поле автоматически наращиваемым, поэтому база данных автоматически присвоила ID, но вам нужно явно извлечь это значение. Как было показано ранее в этой главе, сделать это можно с помощью функции <blockquote>LAST_INSERT_ID</blockquote>.</p>     <p><blockquote> res = mysql_query(&amp;my_connection, "SELECT LAST_INSERT_ID()");</blockquote></p>     <p><blockquote> if (res) {</blockquote></p>     <p><blockquote>  printf("SELECT error: %s\n", mysql_error(&amp;my_connection));</blockquote></p>     <p><blockquote>  return 0;</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  res_ptr = mysql_use_result(&amp;my_connection);</blockquote></p>     <p><blockquote>  if (res_ptr) {</blockquote></p>     <p><blockquote>   if ((mysqlrow = mysql_fetch_row(res_ptr))) {</blockquote></p>     <p><blockquote>    sscanf(mysqlrow[0], "%d", &amp;new_cd_id);</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>   mysql_free_result(res_ptr);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p>He стоит беспокоиться о других программах-клиентах, вставляющих компакт-диски в это же время, и о возможной путанице поступающих номеров ID; СУРБД MySQL запоминает присвоенный ID для каждого подключения, поэтому, даже если другое приложение вставило компакт-диск прежде, чем вы извлекли ID, вы все равно получите номер, соответствующий вашей строке, а не строке, добавленной другим приложением.</p>     <p>И последнее, но не по степени важности, установите ID вновь добавленной строки и верните код успешного или аварийного завершения:</p>     <p><blockquote>  *cd_id = new_cd_id;</blockquote></p>     <p><blockquote>  if (new_cd_id != -1) return 1;</blockquote></p>     <p><blockquote>  return 0;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote>} /* add_cd */</blockquote></p>     <p>Теперь посмотрите реализацию функции <blockquote>get_artist_id</blockquote>; процесс очень похож на вставку записи о компакт-диске:</p>     <p><blockquote>/* Поиск или создание artist_id для заданной строки */</blockquote></p>     <p><blockquote>static int get_artist_id(char *artist) {</blockquote></p>     <p><blockquote> MYSQL_RES *res_ptr;</blockquote></p>     <p><blockquote> MYSQL_ROW mysqlrow;</blockquote></p>     <p><blockquote> int res;</blockquote></p>     <p><blockquote> char qs[250];</blockquote></p>     <p><blockquote> char is[250];</blockquote></p>     <p><blockquote> char es[250];</blockquote></p>     <p><blockquote> int artist_id = -1;</blockquote></p>     <p><blockquote> /* Он уже существует? */</blockquote></p>     <p><blockquote> mysql_escape string(es, artist, strlen(artist));</blockquote></p>     <p><blockquote> sprintf(qs, "SELECT id FROM artist WHERE name = '%s'", es);</blockquote></p>     <p><blockquote> res = mysql_query(&amp;my_connection, qs);</blockquote></p>     <p><blockquote> if (res) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "SELECT error: %s\n", mysql_error(&amp;my_connection));</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  res_ptr = mysql_store_result(&amp;my_connection);</blockquote></p>     <p><blockquote>  if (res_ptr) {</blockquote></p>     <p><blockquote>   if (mysqr_num_rows(res_ptr) &gt; 0) {</blockquote></p>     <p><blockquote>    if (mysqlrow = mysql_fetch_row(res_ptr)) {</blockquote></p>     <p><blockquote>     sscanf(mysqlrow[0], "%d", &amp;artist_id);</blockquote></p>     <p><blockquote>    }</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>   mysql_free_result(res_ptr);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> if (artist_id != -1) return artist_id;</blockquote></p>     <p><blockquote> sprintf(is, "INSERT INTO artist(name) VALUES ('%s')", es);</blockquote></p>     <p><blockquote> res = mysql_query(&amp;my_connection, is);</blockquote></p>     <p><blockquote> if (res) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Insert error %d: %s\n",</blockquote></p>     <p><blockquote>   mysql_errno(&amp;my_connection), mysql_error(&amp;my_connection));</blockquote></p>     <p><blockquote>  return 0;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> res = mysql_query(&amp;my_connection, "SELECT LAST_INSERT_ID()");</blockquote></p>     <p><blockquote> if (res) {</blockquote></p>     <p><blockquote>  printf("SELECT error: %s\n", mysql_error(&amp;my_connection));</blockquote></p>     <p><blockquote>  return 0;</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  res_ptr = mysql_use_result(&amp;my_connection);</blockquote></p>     <p><blockquote>  if (res_ptr) {</blockquote></p>     <p><blockquote>   if ((mysqlrow = mysql_fetch_row(res_ptr))) {</blockquote></p>     <p><blockquote>    sscanf(mysqlrow[0], "%d", &amp;artist_id);</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>   mysql_free_result(res_ptr);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return artist_id;</blockquote></p>     <p><blockquote>} /* get_artist_id */</blockquote></p>     <p>Переходите к вставке информации о дорожках для вашего компакт-диска. И снова защититесь от специальных символов в названиях дорожек:</p>     <p><blockquote>int add_tracks(struct current_tracks_st *tracks) {</blockquote></p>     <p><blockquote> int res;</blockquote></p>     <p><blockquote> char is[250];</blockquote></p>     <p><blockquote> char es[250];</blockquote></p>     <p><blockquote> int i;</blockquote></p>     <p><blockquote> if (!dbconnected) return 0;</blockquote></p>     <p><blockquote> i = 0;</blockquote></p>     <p><blockquote> while (tracks-&gt;track[i][0]) {</blockquote></p>     <p><blockquote>  mysql_escape_string(es, tracks-&gt;track[i], strlen(tracks-&gt;track[i]));</blockquote></p>     <p><blockquote>  sprintf(is,</blockquote></p>     <p><blockquote>   "INSERT INTO track(cd_id, track_id, title) VALUES(%d, %d, '%s')",</blockquote></p>     <p><blockquote>  tracks-&gt;cd_id, i + 1, es);</blockquote></p>     <p><blockquote>  res = mysql_query(&amp;my_connection, is);</blockquote></p>     <p><blockquote>  if (res) {</blockquote></p>     <p><blockquote>   fprintf(stderr, "Insert error %d: %s\n",</blockquote></p>     <p><blockquote>   mysql_errno(&amp;my_connection), mysql_error(&amp;my_connection));</blockquote></p>     <p><blockquote>   return 0;</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  i++;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return 1;</blockquote></p>     <p><blockquote>} /* add tracks */</blockquote></p>     <p>Теперь переходите к извлечению информации о компакт-диске с заданным значением его ID. Будет применена операция объединения базы данных для извлечения ID исполнителя во время получения данных об ID диска. Это обычно хороший подход: системы управления базами данных отлично знают, как эффективно выполнять сложные запросы, поэтому никогда не пишите прикладной программный код для того, что вы можете просто попросить сделать СУРБД, передав ей запрос на языке SQL. Есть шанс сберечь собственные силы, не тратя их на написание дополнительного программного кода, и получить приложение, работающее более эффективно, разрешив СУРБД выполнить максимально возможный объем работы.</p>     <p><blockquote>int get_cd(int cd_id, struct current_cd_st *dest) {</blockquote></p>     <p><blockquote> MYSQL_RES *res_ptr;</blockquote></p>     <p><blockquote> MYSQL_ROW mysqlrow;</blockquote></p>     <p><blockquote> int res;</blockquote></p>     <p><blockquote> char qs[250];</blockquote></p>     <p><blockquote> if (!dbconnected) return 0;</blockquote></p>     <p><blockquote> memset(dest, 0, sizeof(*dest));</blockquote></p>     <p><blockquote> dest-&gt;artist_id = -1;</blockquote></p>     <p><blockquote> sprintf(qs, "SELECT artist.id, cd.id, artist.name, cd.title, cd.catalogue \</blockquote></p>     <p><blockquote>  FROM artist, cd WHERE artist.id = cd.artist_id and cd.id = %d", cd_id);</blockquote></p>     <p><blockquote> res = mysql_query(&amp;my_cormection, qs);</blockquote></p>     <p><blockquote> if (res) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "SELECT error: %s\n", mysql_error(&amp;my_connection));</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  res_ptr = mysql_store_result(&amp;my_connection);</blockquote></p>     <p><blockquote>  if (res_ptr) {</blockquote></p>     <p><blockquote>   if (mysql_num_rows(res_ptr) &gt; 0) {</blockquote></p>     <p><blockquote>    if (mysqlrow = mysql_fetch_row(res_ptr)) {</blockquote></p>     <p><blockquote>     sscanf(mysqlrow[0], "%d", &amp;dest-&gt;artist_id);</blockquote></p>     <p><blockquote>     sscanf(mysqlrow[1], "%d", &amp;dest-&gt;cd_id);</blockquote></p>     <p><blockquote>     strcpy(dest-&gt;artist_name, mysqlrow[2]);</blockquote></p>     <p><blockquote>     strcpy(dest-&gt;title, mysqlrow[3]);</blockquote></p>     <p><blockquote>     strcpy(dest-&gt;catalogue, mysqlrow[4]);</blockquote></p>     <p><blockquote>    }</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>   mysql_free_result(res_ptr);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> if (dest-&gt;artist_id != -1) return 1;</blockquote></p>     <p><blockquote> return 0;</blockquote></p>     <p><blockquote>} /* get_cd */</blockquote></p>     <p>Далее вы реализуете извлечение информации о дорожках. В SQL-операторе вы задаете ключевые слова <blockquote>ORDER BY</blockquote>, для того чтобы возвращать дорожки в подходящей последовательности. И опять это позволит СУРБД выполнить нужную работу более эффективно, чем если бы вы извлекли дорожки в произвольном порядке, а затем написали собственный программный код для их сортировки.</p>     <p><blockquote>int get_cd_tracks(int cd_id, struct current_tracks_st *dest) {</blockquote></p>     <p><blockquote> MYSQL_RES *res_ptr;</blockquote></p>     <p><blockquote> MYSQL_ROW mysqlrow;</blockquote></p>     <p><blockquote> int res;</blockquote></p>     <p><blockquote> char qs[250];</blockquote></p>     <p><blockquote> int i = 0, num_tracks = 0;</blockquote></p>     <p><blockquote> if (!dbconnected) return 0;</blockquote></p>     <p><blockquote> memset(dest, 0, sizeof(*dest));</blockquote></p>     <p><blockquote> dest-&gt;cd_id = -1;</blockquote></p>     <p><blockquote> sprintf(qs, "SELECT track_id, title FROM track WHERE track.cd_id = %d \</blockquote></p>     <p><blockquote>  ORDER BY track_id", cd_id);</blockquote></p>     <p><blockquote> res = mysql_query(&amp;my_connection, qs);</blockquote></p>     <p><blockquote> if (res) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "SELECT error: %s\n", mysql_error(&amp;my_connection));</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  res_ptr = mysql_store_result(&amp;my_connection);</blockquote></p>     <p><blockquote>  if (res_ptr) {</blockquote></p>     <p><blockquote>   if ((num_tracks = mysql_num_rows(res_ptr)) &gt; 0) {</blockquote></p>     <p><blockquote>    while (mysqlrow = mysql_fetch_row(res_ptr)) {</blockquote></p>     <p><blockquote>     strcpy(dest-&gt;track[i], mysqlrow[1]);</blockquote></p>     <p><blockquote>     i++;</blockquote></p>     <p><blockquote>    }</blockquote></p>     <p><blockquote>    dest-&gt;cd_id = cd_id;</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>   mysql_free_result(res_ptr);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return num_tracks;</blockquote></p>     <p><blockquote>} /* get_cd_tracks */</blockquote></p>     <p>До сих пор вы добавляли и извлекали информацию о компакт-дисках. Вы добились простоты интерфейса, ограничив число результатов, которые могут быть возвращены, но вам все же нужна собственная функция, сообщающая о том, сколько строк в результирующем наборе, даже если их больше, чем вы можете извлечь.</p>     <p><blockquote>int find_cds(char *search_str, struct cd_search_st *dest) {</blockquote></p>     <p><blockquote> MYSQL_RES *res_ptr;</blockquote></p>     <p><blockquote> MYSQL_ROW mysqlrow;</blockquote></p>     <p><blockquote> int res;</blockquote></p>     <p><blockquote> char qs[500];</blockquote></p>     <p><blockquote> int i = 0;</blockquote></p>     <p><blockquote> char ss[250];</blockquote></p>     <p><blockquote> int num_rows = 0;</blockquote></p>     <p><blockquote> if (!dbconnected) return 0;</blockquote></p>     <p>Очистите структуру, хранящую результат, и защитите ее от специальных символов в строке запроса:</p>     <p><blockquote> memset(dest, -1, sizeof(*dest));</blockquote></p>     <p><blockquote> mysql_escape_string(ss, search_str, strlen(search_str));</blockquote></p>     <p>Далее вы формируете строку запроса. Обратите внимание на необходимость применения большого количества символов <blockquote>%</blockquote>, т.к. знак <blockquote>%</blockquote> — это и символ, который необходимо включить в SQL-оператор для указания соответствия любой строке и специальный символ в функции <blockquote>sprintf</blockquote>:</p>     <p><blockquote> sprintf(qs, "SELECT DISTINCT artist.id, cd.id FROM artist, cd WHERE artist.id = cd.artist_id and (artist.name LIKE '%%%s%%' OR cd.title LIKE '%%%s%%' OR cd.catalogue LIKE<i> '%%%s%%')",</i> ss, ss, ss);</blockquote></p>     <p>Сейчас можно выполнить запрос:</p>     <p><blockquote> res = mysql_query(&amp;my_connection, qs);</blockquote></p>     <p><blockquote> if (res) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "SELECT error: %s\n", mysql_error(&amp;my_connection));</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  res_ptr = mysql_store_result(&amp;my_connection);</blockquote></p>     <p><blockquote>  if (res_ptr) {</blockquote></p>     <p><blockquote>   num_rows = mysql_num_rows(res_ptr);</blockquote></p>     <p><blockquote>   if (num_rows &gt; 0) {</blockquote></p>     <p><blockquote>    while ((mysqlrow = mysql_fetch_row(res_ptr)) &amp;&amp; i &lt; MAX_CD_RESULT) {</blockquote></p>     <p><blockquote>     sscanf(mysqlrow[1], "%d", &amp;dest-&gt;cd_id[i]);</blockquote></p>     <p><blockquote>     i++;</blockquote></p>     <p><blockquote>    }</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>   mysql_free_result(res_ptr);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return num_rows;</blockquote></p>     <p><blockquote>} /* find_cds */</blockquote></p>     <p>Последнее, но не по значимости, — ваша реализация способа удаления компакт-дисков. В соответствии с политикой скрытого управления элементами таблицы исполнителей вы будете удалять исполнителя заданного компакт-диска, если нет других дисков с той же самой строкой исполнителя. Удивительно, но в языке SQL нет средств описания удаления из нескольких таблиц, поэтому вы должны удалять данные из каждой таблицы по очереди:</p>     <p><blockquote>int delete_cd(int cd_id) {</blockquote></p>     <p><blockquote> int res;</blockquote></p>     <p><blockquote> char qs[250];</blockquote></p>     <p><blockquote> int artist_id, num_rows;</blockquote></p>     <p><blockquote> MYSQL_RES *res_ptr;</blockquote></p>     <p><blockquote> MYSQL_ROW mysqlrow;</blockquote></p>     <p><blockquote> if (!dbconnected) return 0;</blockquote></p>     <p><blockquote> artist_id = -1;</blockquote></p>     <p><blockquote> sprintf(qs, "SELECT artist_id FROM cd WHERE artist_id = \</blockquote></p>     <p><blockquote>(SELECT artist_id FROM cd WHERE id = '%d')", cd_id);</blockquote></p>     <p><blockquote> res = mysql_query(&amp;my_connection, qs);</blockquote></p>     <p><blockquote> if (res) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "SELECT error: %s\n", mysql_error(&amp;my_connection));</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  res_ptr = mysql_store_result(&amp;my_connection);</blockquote></p>     <p><blockquote>  if (res_ptr) {</blockquote></p>     <p><blockquote>   num_rows = mysql_num_rows(res_ptr);</blockquote></p>     <p><blockquote>   if (num_rows == 1) {</blockquote></p>     <p><blockquote>    /* Исполнитель не упоминается в других CD */</blockquote></p>     <p><blockquote>    mysqlrow = mysql_fetch_row(res_ptr);</blockquote></p>     <p><blockquote>    sscanf(mysqlrow[0], "%d", &amp;artist_id);</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>   mysql_free_result(res_ptr);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> sprintf(qs, "DELETE FROM track WHERE cd_id = '%d'", cd_id);</blockquote></p>     <p><blockquote> res = mysql_query(&amp;my_connection, qs);</blockquote></p>     <p><blockquote> if (res) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Delete error (track) %d: %s\n",</blockquote></p>     <p><blockquote>   mysql_errno(&amp;my_connection), mysql_error(&amp;my_connection));</blockquote></p>     <p><blockquote>  return 0;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> sprintf(qs, "DELETE FROM cd WHERE id = '%d'", cd_id);</blockquote></p>     <p><blockquote> res = mysql_query(&amp;my_connection, qs);</blockquote></p>     <p><blockquote> if (res) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Delete error (cd) %d: %s\n",</blockquote></p>     <p><blockquote>   mysql_errno(&amp;my_connection), mysql_error(&amp;my_connection));</blockquote></p>     <p><blockquote>  return 0;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> if (artist_id != -1) {</blockquote></p>     <p><blockquote>  /* Теперь элемент artist не связан ни с одним CD, удалите его */</blockquote></p>     <p><blockquote>  sprintf(qs, "DELETE FROM artist WHERE id = '%d'", artist_id);</blockquote></p>     <p><blockquote>  res = mysqlquery(&amp;my_connection, qs);</blockquote></p>     <p><blockquote>  if (res) {</blockquote></p>     <p><blockquote>   fprintf(stderr, "Delete error (artist) %d: %s\n",</blockquote></p>     <p><blockquote>    mysql_errno(&amp;my_connection), mysql_error(&amp;my_connection));</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return 1;</blockquote></p>     <p><blockquote>} /* delete_cd */</blockquote></p>     <p>На этом программный код завершается.</p>     <p>Для законченности и облегчения жизни добавьте файл Makefile. Возможно, вам придется откорректировать в нем путь к файлам <blockquote>include</blockquote>, зависящий от установки СУРБД MySQL в вашей системе.</p>     <p><blockquote>all: арр</blockquote></p>     <br>     <p><blockquote>арр: app_mysql.с app_test.с app_mysql.h</blockquote></p>     <p><blockquote> gcc -о app -I/usr/include/mysql appmysql.с app_test.с -lmysqlclient -L/usr/lib/mysql</blockquote></p>     <p>В последующих главах вы увидите применение этого интерфейса с реальным интерфейсом GUI. Сейчас, если вы хотите увидеть изменения в базе данных по мере выполнения программы, мы предлагаем в одном окне выполнить программу по шагам с помощью отладчика gdb, а в другом следить за изменениями в базе данных. Если вы будете использовать MySQL Query Browser, не забудьте о необходимости обновлять отображаемые данные для отслеживания текущих изменений.</p>              <a name="metkadoc23"><h1>Резюме </h1></a>    <p>В этой главе мы кратко рассмотрели СУРБД MySQL. Более опытные пользователи обнаружат, что многие сложные средства не обсуждались в данной главе, например, ограничения внешнего ключа и триггеры.</p>    <p>Вы получили основные сведения об установке MySQL и узнали об основах администрирования баз данных MySQL с помощью утилит-клиентов. Мы рассмотрели API языка С, который наряду с другими языками программирования может применяться с СУРБД MySQL. Вы также познакомились с некоторыми операторами языка SQL в действии.</p>    <p>Мы надеемся, что эта глава вдохновит вас на использование баз данных на основе SQL для хранения ваших данных и заставит искать дополнительную информацию об этих мощных средствах управления базами данных.</p>    <p>И как напоминание, основной информационный ресурс MySQL — исходная страница MySQL на сайте<b> www.mysql.com.</b> </p>     <br><br>
<center><div align="center"><a href="index.php.html">Оглавление</a></div></center>




<br>
<script type="text/javascript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="https://www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script><br>

<noindex>
<div align="center">
<center>

<!-- SAPE RTB DIV 600x340 -->
<div id="SRTB_507029"></div>
<!-- SAPE RTB END -->

</center>
</div>
</noindex>

</td>
<td width="240" valign="top">

<br>

<div id="menu3">
<ul>
<li><a href="../../alternativnaja_medicina/index.html"><span>Альтернативная медицина</span></a></li>
<li><a href="../../astronomija_i_kosmos/index.html"><span>Астрономия и Космос</span></a></li>
<li><a href="../../biologija/index.html"><span>Биология</span></a></li>
<li><a href="../../voennaja_istorija/index.html"><span>Военная история</span></a></li>
<li><a href="../../geologija_i_geografija/index.html"><span>Геология и география</span></a></li>
<li><a href="../../gosudarstvo_i_pravo/index.html"><span>Государство и право</span></a></li>
<li><a href="../../delovaja_literatura/index.html"><span>Деловая литература</span></a></li>
<li><a href="../../domashnie_zhivotnye/index.html"><span>Домашние животные</span></a></li>
<li><a href="../../domovodstvo/index.html"><span>Домоводство</span></a></li>
<li><a href="../../zdorove/index.html"><span>Здоровье</span></a></li>
<li><a href="../../istorija/index.html"><span>История</span></a></li>
<li><a href="../index.html"><span>Компьютеры и Интернет</span></a></li>
<li><a href="../../kulinarija/index.html"><span>Кулинария</span></a></li>
<li><a href="../../kulturologija/index.html"><span>Культурология</span></a></li>
<li><a href="../../literaturovedenie/index.html"><span>Литературоведение</span></a></li>
<li><a href="../../matematika/index.html"><span>Математика</span></a></li>
<li><a href="../../medicina/index.html"><span>Медицина</span></a></li>
<li><a href="../../nauchnaja_literatura_prochee/index.html"><span>Науч. литер. - прочее</span></a></li>
<li><a href="../../pedagogika/index.html"><span>Педагогика</span></a></li>
<li><a href="../../politika/index.html"><span>Политика</span></a></li>
<li><a href="../../psihologija/index.html"><span>Психология</span></a></li>
<li><a href="../../religiovedenie/index.html"><span>Религиоведение</span></a></li>
<li><a href="../../sad_i_ogorod/index.html"><span>Сад и огород</span></a></li>
<li><a href="../../samosovershenstvovanie/index.html"><span>Самосовершенствование</span></a></li>
<li><a href="../../sdelai_sam/index.html"><span>Сделай сам</span></a></li>
<li><a href="../../sport/index.html"><span>Спорт</span></a></li>
<li><a href="../../tehnicheskie_nauki/index.html"><span>Технические науки</span></a></li>
<li><a href="../../transport_i_aviacija/index.html"><span>Транспорт и авиация</span></a></li>
<li><a href="../../uchebniki/index.html"><span>Учебники</span></a></li>
<li><a href="../../fizika/index.html"><span>Физика</span></a></li>
<li><a href="../../filosofija/index.html"><span>Философия</span></a></li>
<li><a href="../../himija/index.html"><span>Химия</span></a></li>
<li><a href="../../hobbi_i_remesla/index.html"><span>Хобби и ремесла</span></a></li>
<li><a href="../../shpargalki/index.html"><span>Шпаргалки</span></a></li>
<li><a href="../../yezoterika/index.html"><span>Эзотерика</span></a></li>
<li><a href="../../yurisprudencija/index.html"><span>Юриспруденция</span></a></li>
<li><a href="../../jazykoznanie/index.html"><span>Языкознание</span></a></li>
</ul>
</div>

<br>
<div align="center">
<center>
<noindex>

<!-- SAPE RTB DIV 240x400 -->
<div id="SRTB_507028"></div>
<!-- SAPE RTB END -->

</noindex>
</center>
</div>

</td>
</tr>
<tr>
<td colspan="3" align="center">


<hr>
<a href="../../index.html"><span>Главная</span></a> | 
<a rel="sidebar" href="p12.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a> | 
<a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a> | 
<a href="p12.php.html#" onClick="scroll(0,0); return false" title="наверх">Наверх</a>
</td>
</tr>
<tr>
<td colspan="3" valign="top" align="left">
<br>

 



</td>
</tr>
</table>

<noindex>
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter21717787 = new Ya.Metrika({id:21717787,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="http://mc.yandex.ru/watch/21717787" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

</noindex>
</center>
</div></body>
</html>