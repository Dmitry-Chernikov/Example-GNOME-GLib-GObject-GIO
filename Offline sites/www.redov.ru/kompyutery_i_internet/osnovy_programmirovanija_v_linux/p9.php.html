<html>
<head>
<meta http-equiv="Content-Language" content="ru">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<link href="../../0img/style.css" rel="stylesheet" type="text/css" />
<link rel="SHORTCUT ICON" href="http://www.redov.ru/0img/favicon.ico" type="image/x-icon"> 
<title>Глава 5 Терминалы / Основы программирования в Linux</title>
</head>
<body>
<div align="center">
<center>
<table border="0" cellpadding="0" cellspacing="0" width="1260">
<tr>
<td colspan="3" valign="top" align="left" height="100">
<table border="0" cellpadding="0" cellspacing="0" width="1260" height="100">
<tr>
<td valign="middle" align="center" width="350">
<a href="../../index.html"><img src="../../0img/logo.jpg" width="350" height="100" title="Онлайн библиотека redov.ru"/></a>
</td>
<td valign="middle" align="center" width="910">

<noindex>

<!-- SAPE RTB JS -->
<script
    async="async"
    src="http://cdn-rtb.sape.ru/rtb-b/js/393/2/106393.js"
    type="text/javascript">
</script>
<!-- SAPE RTB END -->

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507025"></div>
<!-- SAPE RTB END -->

</noindex>

</td>
</tr>
</table>
</td>
</tr>
<tr>
<td colspan="3" valign="middle" align="left">

<div id="menu">
<ul>
		<li><a href="../../index.html"><span>Главная</span></a></li>
		<li><a rel="sidebar" href="p9.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a></li>
		<li><a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a></li>
		<li><a href="p9.php.html#" onClick="scroll(0,9999999); return false"><span>Вниз</span></a></li>
</ul>
</div>


</td>
</tr>
<tr>
<td width="240" valign="top" align="center">

<br>
<noindex>
<!-- SAPE RTB DIV 160x600 -->
<div id="SRTB_733378"></div>
<!-- SAPE RTB END -->
</noindex>



</td>
<td valign="top" align="left" style="padding-left: 5; padding-right: 5" width="780">
<br>
<noindex>
<div align="center">

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507027"></div>
<!-- SAPE RTB END -->

</div>
</noindex>
<br>



<li><a href="p9.php.html#metkadoc2">     Чтение с терминала и запись на терминал     </a></li>
<li><a href="p9.php.html#metkadoc3">      Сравнение канонического и неканонического режимов      </a></li>
<li><a href="p9.php.html#metkadoc4">      Обработка перенаправленного вывода      </a></li>
<li><a href="p9.php.html#metkadoc5">     Диалог с терминалом     </a></li>
<li><a href="p9.php.html#metkadoc6">     Драйвер терминала A и общий терминальный интерфейс     </a></li>
<li><a href="p9.php.html#metkadoc7">      Обзор      </a></li>
<li><a href="p9.php.html#metkadoc8">      Аппаратная модель      </a></li>
<li><a href="p9.php.html#metkadoc9">     Структура типа<i> termios</i>     </a></li>
<li><a href="p9.php.html#metkadoc10">      Режимы ввода      </a></li>
<li><a href="p9.php.html#metkadoc11">      Режимы вывода      </a></li>
<li><a href="p9.php.html#metkadoc12">      Режимы управления      </a></li>
<li><a href="p9.php.html#metkadoc13">      Локальные режимы      </a></li>
<li><a href="p9.php.html#metkadoc14">      Специальные управляющие символы      </a></li>
<li><a href="p9.php.html#metkadoc15">      Скорость терминала      </a></li>
<li><a href="p9.php.html#metkadoc16">      Дополнительные функции      </a></li>
<li><a href="p9.php.html#metkadoc17">     Вывод терминала     </a></li>
<li><a href="p9.php.html#metkadoc18">      Тип терминала      </a></li>
<li><a href="p9.php.html#metkadoc19">      Установите тип вашего терминала      </a></li>
<li><a href="p9.php.html#metkadoc20">      Применение характеристик terminfo      </a></li>
<li><a href="p9.php.html#metkadoc21">     Обнаружение нажатий клавиш     </a></li>
<li><a href="p9.php.html#metkadoc22">      Виртуальные консоли      </a></li>
<li><a href="p9.php.html#metkadoc23">      Псевдотерминалы      </a></li>
<li><a href="p9.php.html#metkadoc24">     Резюме      </a></li>
<a name="metkadoc1"><h1>Глава 5</p>    <p>Терминалы</h1></a>       <p>В этой главе вы познакомитесь с некоторыми улучшениями, которые вам, возможно, захочется внести в базовое приложение из<i> главы 2.</i> Его, быть может, самый очевидный недостаток — пользовательский интерфейс; он достаточно функционален, но не слишком элегантен. Теперь вы узнаете, как сделать более управляемым терминал пользователя, т. е. ввод с клавиатуры и вывод на экран. Помимо этого вы научитесь обеспечивать написанным вами программам возможность получения вводимых данных от пользователя даже при наличии перенаправления ввода и гарантировать вывод данных в нужное место на экране.</p>    <p>Несмотря на то, что заново реализованное приложение для управления базой данных компакт-дисков не увидит свет до конца<i> главы</i> 7, его основы вы заложите в этой главе.<i> Глава 6</i> посвящена curses, которые представляют собой вовсе не древнее проклятие, а библиотеку функций, предлагающих программный код высокого уровня для управления отображением на экране терминала. Попутно вы узнаете чуть больше о размышлениях прежних профи UNIX, познакомившись с основными принципами систем Linux и UNIX и понятием терминала. Низкоуровневый доступ, представленный в этой главе, быть может именно то, что вам нужно. Большая часть того, о чем мы пишем здесь, хорошо подходит для программ, выполняющихся в окне консоли, таких как эмуляторы терминала KDE's Konsole, GNOME's gnome-terminal или стандартный X11 xterm.</p>    <p>В этой главе вы, в частности, узнаете о:</p>    <p>&#9633; чтении с терминала и записи на терминал;</p>    <p>&#9633; драйверах терминала и общем терминальном интерфейсе (General Terminal Interface, GTI);</p>    <p>&#9633; структуре типа <blockquote>termios</blockquote>;</p>    <p>&#9633; выводе терминала и базе данных <blockquote>terminfo</blockquote>;</p>    <p>&#9633; обнаружении нажатия клавиш.</p>          <a name="metkadoc2"><h1>Чтение с терминала и запись на терминал</h1></a>         <p>В<i> главе 3</i> вы узнали, что, когда программа запускается из командной строки, оболочка обеспечивает присоединение к ней стандартных потоков ввода и вывода. Вы получаете возможность взаимодействия с пользователем простым применением подпрограмм <blockquote>getchar</blockquote> и <blockquote>printf</blockquote> для чтения из стандартного потока ввода и записи в стандартный поток вывода.</p>     <p>В упражнении 5.1 в программе menu1.c вы попытаетесь переписать на языке С подпрограммы формирования меню, использующие только эти две функции.</p>     <b>Упражнение 5.1. Подпрограммы формирования меню на языке C</b>     <p>1. Начните со следующих строк, определяющих массив, который будет использоваться как меню, и прототип (описание) функции <blockquote>getchoice</blockquote>:</p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <br>     <p><blockquote>char *menu[] = {</blockquote></p>     <p><blockquote> "a — add new record", "d — delete record", "q - quit", NULL,</blockquote></p>     <p><blockquote>};</blockquote></p>     <br>     <p><blockquote>int getchoice(char *greet, char *choices[]);</blockquote></p>     <p>2. Функция <blockquote>main</blockquote> вызывает функцию <blockquote>getchoice</blockquote> с образцом пунктов меню <blockquote>menu</blockquote>:</p>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int choice = 0;</blockquote></p>     <p><blockquote> do {</blockquote></p>     <p><blockquote>  choice = getchoice("Please select an action", menu);</blockquote></p>     <p><blockquote>  printf("You have chosen: %c\n", choice);</blockquote></p>     <p><blockquote> } while (choice != 'q');</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>3. Теперь важный фрагмент кода — функция, которая и выводит на экран меню и считывает ввод пользователя:</p>     <p><blockquote>int getchoice(char *greet, char *choices[]) {</blockquote></p>     <p><blockquote> int chosen = 0;</blockquote></p>     <p><blockquote> int selected;</blockquote></p>     <p><blockquote> char **option;</blockquote></p>     <p><blockquote> do {</blockquote></p>     <p><blockquote>  printf("Choice: %s\n", greet);</blockquote></p>     <p><blockquote>  option = choices;</blockquote></p>     <p><blockquote>  while (*option) {</blockquote></p>     <p><blockquote>   printf("%s\n", *option);</blockquote></p>     <p><blockquote>   option++;</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  selected = getchar();</blockquote></p>     <p><blockquote>  option = choices;</blockquote></p>     <p><blockquote>  while (*option) {</blockquote></p>     <p><blockquote>   if (selected == *option[0]) {</blockquote></p>     <p><blockquote>    chosen = 1;</blockquote></p>     <p><blockquote>    break;</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>   option++;</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  if (!chosen) {</blockquote></p>     <p><blockquote>   printf("Incorrect choice, select again\n");</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> } while (!chosen);</blockquote></p>     <p><blockquote> return selected;</blockquote></p>     <p><blockquote>}</blockquote></p>     <p><b>Как это работает</b></p>     <p>Функция <blockquote>getchoice</blockquote> выводит на экран приглашение для ввода <blockquote>greet</blockquote> и меню <blockquote>choices</blockquote> и просит пользователя ввести первый символ выбранного пункта. Далее выполняется цикл до тех пор, пока функция <blockquote>getchar</blockquote> не вернет символ, совпадающий с первой буквой одного из элементов массива option.</p>     <p>Когда вы откомпилируете и выполните программу, то обнаружите, что она ведет себя не так, как ожидалось. Для того чтобы продемонстрировать возникающую проблему, далее приведен вариант диалога на экране терминала.</p>     <p><blockquote>$ <b>./menu1</b></blockquote></p>     <p><blockquote>Choice: Please select an action</blockquote></p>     <p><blockquote>a — add new record</blockquote></p>     <p><blockquote>d — delete record</blockquote></p>     <p><blockquote>q — quit</blockquote></p>     <p><blockquote><b>a</b></blockquote></p>     <p><blockquote>You have chosen: a</blockquote></p>     <p><blockquote>Choice: Please select an action</blockquote></p>     <p><blockquote>a — add new record</blockquote></p>     <p><blockquote>d — delete record</blockquote></p>     <p><blockquote>q — quit</blockquote></p>     <p><blockquote>Incorrect choice, select again</blockquote></p>     <p><blockquote>Choice: Please select an action</blockquote></p>     <p><blockquote>а — add new record</blockquote></p>     <p><blockquote>d — delete record</blockquote></p>     <p><blockquote>q — quit</blockquote></p>     <p><blockquote><b>q</b></blockquote></p>     <p><blockquote>You have chosen: q $</blockquote></p>     <p>Для того чтобы сделать выбор, пользователь должен последовательно нажать клавиши &lt;А&gt;, &lt;Enter&gt;, &lt;Q&gt;, &lt;Enter&gt;. Здесь возникают, как минимум, две проблемы; самая серьезная заключается в том, что вы получаете сообщение "Incorrect choice" ("Неверный выбор") после каждого корректного выбора. Кроме того, вы еще должны нажать клавишу &lt;Enter&gt; (или &lt;Return&gt;), прежде чем программа считает введенные данные.</p>             <a name="metkadoc3"><h1>Сравнение канонического и неканонического режимов</h1></a>     <p>Обе эти проблемы тесно связаны. По умолчанию ввод терминала не доступен программе до тех пор, пока пользователь не нажмет клавишу &lt;Enter&gt; или &lt;Return&gt;. В большинстве случаев это достоинство, поскольку данный способ позволяет пользователю корректировать ошибки набора с помощью клавиш &lt;Backspace&gt; или &lt;Delete&gt;. Только когда он остается доволен увиденным на экране, пользователь нажимает клавишу &lt;Enter&gt;, чтобы ввод стал доступен программе.</p>     <p>Такое поведение называется<i> каноническим</i> или<i> стандартным</i> режимом. Весь ввод обрабатывается как последовательность строк. Пока строка ввода не завершена (обычно с помощью нажатия клавиши &lt;Enter&gt;), интерфейс терминала управляет всеми нажатыми клавишами, включая &lt;Backspace&gt;, и приложение не может считать ни одного символа.</p>     <p>Прямая противоположность —<i> неканонический</i> режим, в котором приложение получает больше возможностей контроля над обработкой вводимых символов. Мы еще вернемся к этим двум режимам немного позже в этой главе.</p>     <p>Помимо всего прочего, обработчик терминала в ОС Linux помогает превращать символы прерываний в сигналы (например, останавливающие выполнение программы, когда вы нажмете комбинацию клавиш &lt;Ctrl&gt;+&lt;C&gt;), он также может автоматически выполнить обработку нажатых клавиш &lt;Backspace&gt; и &lt;Delete&gt; и вам не придется реализовывать ее в каждой написанной вами программе. О сигналах вы узнаете больше в<i> главе 11.</i></p>     <p>Итак, что же происходит в данной программе? ОС Linux сохраняет ввод до тех пор, пока пользователь не нажмет клавишу &lt;Enter&gt;, и затем передает в программу символ выбранного пункта меню и следом за ним код клавиши &lt;Enter&gt;. Каждый раз, когда вы вводите символ пункта меню, программа вызывает функцию <blockquote>getchar</blockquote>, обрабатывает символ и снова вызывает <blockquote>getchar</blockquote>, немедленно возвращающую символ клавиши &lt;Enter&gt;.</p>     <p>Символ, который на самом деле видит программа, — это не символ ASCII возврата каретки CR (десятичный код 13, шестнадцатеричный 0D), а символ перевода строки LF (десятичный код 10, шестнадцатеричный 0A). Так происходит потому, что на внутреннем уровне ОС Linux (как и UNIX) всегда применяет перевод строки для завершения текстовых строк, т. е. в отличие от других ОС, таких как MS-DOS, использующих комбинацию символов возврата каретки и перевода строки, ОС UNIX применяет, для обозначения новой строки только символ перевода строки. Если вводное или выводное устройство посылает или запрашивает и символ возврата каретки, в ОС Linux об этом заботится обработчик терминала. Если вы привыкли работать в MS-DOS или других системах, это может показаться странным, но одно из существенных преимуществ заключается в отсутствии в ОС Linux реальной разницы между текстовыми и бинарными файлами. Символы возврата каретки обрабатываются, только когда вы вводите или выводите их на терминал или некоторые принтеры и плоттеры.</p>     <p>Вы можете откорректировать основной недостаток вашей подпрограммы меню, просто игнорируя дополнительный символ перевода строки с помощью программного кода, подобного приведенному далее:</p>     <p><blockquote>do {</blockquote></p>     <p><blockquote> selected = getchar();</blockquote></p>     <p><blockquote>} while (selected == '\n');</blockquote></p>     <p>Он решает непосредственно возникшую проблему, и вы увидите вывод, подобный приведенному далее:</p>     <p><blockquote>$ <b>./menu1</b></blockquote></p>     <p><blockquote>Choice: Please select an action</blockquote></p>     <p><blockquote>a — add new record</blockquote></p>     <p><blockquote>d — delete record</blockquote></p>     <p><blockquote>q — quit</blockquote></p>     <p><blockquote><b>a</b></blockquote></p>     <p><blockquote>You have chosen: a</blockquote></p>     <p><blockquote>Choice: Please select an action</blockquote></p>     <p><blockquote>a — add new record</blockquote></p>     <p><blockquote>d — delete record</blockquote></p>     <p><blockquote>q — quit</blockquote></p>     <p><blockquote><b>q</b></blockquote></p>     <p><blockquote>You have chosen: q $</blockquote></p>     <p>Мы вернемся позже ко второй проблеме, связанной с необходимостью нажимать клавишу &lt;Enter&gt;, и более элегантному решению для обработки символа перевода строки.</p>             <a name="metkadoc4"><h1>Обработка перенаправленного вывода</h1></a>     <p>Для программ, выполняющихся в ОС Linux, даже интерактивных, характерно перенаправление своего ввода и вывода как в файлы, так и в другие программы. Давайте рассмотрим поведение вашей программы при перенаправлении ее вывода в файл.</p>     <p><blockquote>$ <b>./menu1 &gt; file</b></blockquote></p>     <p><blockquote><b>a</b></blockquote></p>     <p><blockquote><b>q</b></blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Такой результат можно было бы считать успешным, потому что вывод перенаправлен в файл вместо терминала. Однако бывают случаи, когда нужно помешать такому исходу событий или отделить приглашения или подсказки, которые пользователь должен видеть, от остального вывода, благополучно перенаправляемого в файл.</p>     <p>О перенаправлении стандартного вывода можно судить по наличию низкоуровневого дескриптора файла, ассоциированного с терминалом. Эту проверку выполняет системный вызов <blockquote>isatty</blockquote>. Вы просто передаете ему корректный дескриптор файла, и он проверяет, связан ли этот дескриптор в данный момент с терминалом.</p>     <p><blockquote><b>#include &lt;unistd.h&gt;</b></blockquote></p>     <p><blockquote><b>int isatty(int fd);</b></blockquote></p>     <p>Системный вызов <blockquote>isatty</blockquote> возвращает 1, если открытый дескриптор файла <blockquote>fd</blockquote> связан с терминалом, и 0 в противном случае.</p>     <p>В данной программе используются файловые потоки, но <blockquote>isatty</blockquote> оперирует только дескрипторами файлов. Для выполнения необходимого преобразования вам придется сочетать вызов <blockquote>isatty</blockquote> с подпрограммой <blockquote>fileno</blockquote>, обсуждавшейся в<i> главе 3.</i></p>     <p>Что вы собираетесь делать, если стандартный вывод <blockquote>stdout</blockquote> перенаправлен? Просто завершить программу — не слишком хорошо, потому что у пользователя нет возможности выяснить, почему программа аварийно завершила выполнение. Вывод сообщения в <blockquote>stdout</blockquote> тоже не поможет, поскольку оно будет перенаправлено с терминала. Единственное решение — записать сообщение в стандартный поток ошибок <blockquote>stderr</blockquote>, который не перенаправляется командой оболочки <blockquote>&gt; file</blockquote> (упражнение 5.2).</p>     <b>Упражнение 5.2. Проверка для выявления перенаправления вывода</b>     <p>Внесите следующие изменения в директивы включения заголовочных файлов и функцию main программы menu1.с из упражнения 5.1. Назовите новый файл menu2.c.</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>...</blockquote></p>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int choice = 0;</blockquote></p>     <p><blockquote> if (!isatty(fileno(stdout))) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "You are not a terminal!\n");</blockquote></p>     <p><blockquote>  exit(1);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> do {</blockquote></p>     <p><blockquote>  choice = getchoice("Please select an action", menu);</blockquote></p>     <p><blockquote>  printf("You have chosen: %c\n", choice);</blockquote></p>     <p><blockquote> } while (choice != 'q');</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Теперь посмотрите на следующий пример вывода:</p>     <p><blockquote>$ <b>./menu2</b></blockquote></p>     <p><blockquote>Choice: Please select an action</blockquote></p>     <p><blockquote>a — add new record</blockquote></p>     <p><blockquote>d — delete record</blockquote></p>     <p><blockquote>q — quit</blockquote></p>     <p><blockquote><b>q</b></blockquote></p>     <p><blockquote>You have chosen: q $ <b>./menu2 &gt; file</b></blockquote></p>     <p><blockquote>You are not a terminal! $</blockquote></p>     <p><b>Как это работает</b></p>     <p>В новом фрагменте программного кода функция <blockquote>isatty</blockquote> применяется для проверки связи стандартного вывода с терминалом и прекращения выполнения программы при отсутствии этой связи. Это тот же самый тест, который командная оболочка использует для решения, нужно ли выводить строки приглашения. Возможно и довольно обычно перенаправление и <blockquote>stdout</blockquote>, и <blockquote>stderr</blockquote> с терминала на другое устройство. Вы можете направить поток ошибок в другой файл:</p>     <p><blockquote>$ <b>./menu2 &gt;file 2&gt;file.error</b></blockquote></p>     <p><blockquote>$</blockquote></p>     <p>или объединить оба выводных потока в одном файле:</p>     <p><blockquote>$ <b>./menu2 &gt;file 2&gt;&amp;1</b></blockquote></p>     <p><blockquote>$</blockquote></p>     <p>(Если вы не знакомы с перенаправлением вывода, прочтите еще раз<i> главу 2,</i> в которой мы более подробно рассматриваем синтаксические правила, связанные с ним.) В данном случае вам нужно отправить сообщение непосредственно на терминал пользователя.</p>              <a name="metkadoc5"><h1>Диалог с терминалом</h1></a>    <p>Если нужно защитить части вашей программы, взаимодействующие с пользователем, от перенаправления, но разрешить его для других входных и выходных данных, вы должны отделить общение с пользователем от потоков <blockquote>stdout</blockquote> и <blockquote>stderr</blockquote>. Это можно сделать, непосредственно считывая данные с терминала и прямо записывая данные на терминал. Поскольку ОС Linux с самого начала создавалась, как многопользовательская система, включающая, как правило, множество терминалов, как непосредственно подсоединенных, так и подключенных по сети, как вы сможете определить тот терминал, который следует использовать?</p>    <p>К счастью, Linux и UNIX облегчают жизнь, предоставляя специальное устройство /dev/tty, которое всегда является текущим терминалом или сеансом работы в системе (login session). Поскольку ОС Linux все интерпретирует как файлы, вы можете выполнять обычные файловые операции для чтения с устройства /dev/tty и записи на него.</p>    <p>В упражнении 5.3 вы исправите программу выбора пункта меню так, чтобы можно было передавать параметры в подпрограмму <blockquote>getchoice</blockquote> и благодаря этому лучше управлять выводом. Назовите ее menu3.c.</p>    <b>Упражнение 5.3. Применение /dev/tty</b>    <p>Загрузите файл menu2.c и измените программный код так, чтобы входные и выходные данные приходили с устройства /dev/tty и направлялись на это устройство.</p>    <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>    <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>    <br>    <p><blockquote>char *menu[] = {</blockquote></p>    <p><blockquote> "a — add new record", "d — delete record", "q - quit", NULL,</blockquote></p>    <p><blockquote>};</blockquote></p>    <p><blockquote><i>int getchoice(char* greet, char* choices[], FILE* in, FILE* out);</i></blockquote></p>    <br>    <p><blockquote>int main() {</blockquote></p>    <p><blockquote> int choice = 0;</blockquote></p>    <p><blockquote><i> FILE* input;</i></blockquote></p>    <p><blockquote><i> FILE* output;</i></blockquote></p>    <p><blockquote> if (!isatty(fileno(stdout))) {</blockquote></p>    <p><blockquote><i>  fprintf(stderr, "You are not a terminal, OK.\n");</i></blockquote></p>    <p><blockquote> }</blockquote></p>    <p><blockquote><i> input = fopen("/dev/tty", "r");</i></blockquote></p>    <p><blockquote><i> output = fopen("/dev/tty", "w");</i></blockquote></p>    <p><blockquote><i> if (!input || !output) {</i></blockquote></p>    <p><blockquote><i>  fprintf(stderr, "Unable to open /dev/tty\n");</i></blockquote></p>    <p><blockquote><i>  exit(1);</i></blockquote></p>    <p><blockquote><i> }</i></blockquote></p>    <p><blockquote> do {</blockquote></p>    <p><blockquote><i>  choice = getchoice("Please select an action", menu, input, output);</i></blockquote></p>    <p><blockquote>  printf("You have chosen: %c\n", choice);</blockquote></p>    <p><blockquote> } while (choice != 'q');</blockquote></p>    <p><blockquote> exit(0);</blockquote></p>    <p><blockquote>}</blockquote></p>    <br>    <p><blockquote><i>int getchoice(char* greet, char *choices[], FILE* in, FILE *out) {</i></blockquote></p>    <p><blockquote> int chosen = 0;</blockquote></p>    <p><blockquote> int selected;</blockquote></p>    <p><blockquote> char **option;</blockquote></p>    <p><blockquote> do {</blockquote></p>    <p><blockquote><i>  fprintf(out, "Choice: %s\n", greet);</i></blockquote></p>    <p><blockquote>  option = choices;</blockquote></p>    <p><blockquote>  while (*option) {</blockquote></p>    <p><blockquote><i>   fprintf(out, "%s\n", *option);</i></blockquote></p>    <p><blockquote>   option++;</blockquote></p>    <p><blockquote>  }</blockquote></p>    <p><blockquote><i>  do {</i></blockquote></p>    <p><blockquote><i>   selected = fgetc(in);</i></blockquote></p>    <p><blockquote><i>  } while(selected == '\n');</i></blockquote></p>    <p><blockquote>  option = choices;</blockquote></p>    <p><blockquote>  while (*option) {</blockquote></p>    <p><blockquote>   if (selected == *option[0]) {</blockquote></p>    <p><blockquote>    chosen = 1;</blockquote></p>    <p><blockquote>    break;</blockquote></p>    <p><blockquote>   }</blockquote></p>    <p><blockquote>   option++;</blockquote></p>    <p><blockquote>  }</blockquote></p>    <p><blockquote>  if (!chosen) {</blockquote></p>    <p><blockquote><i>   fprintf(out, "Incorrect choice, select again\n");</i></blockquote></p>    <p><blockquote>  }</blockquote></p>    <p><blockquote> } while (!chosen);</blockquote></p>    <p><blockquote> return selected;</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Теперь, когда вы выполните программу с перенаправленным выводом, вы сможете увидеть строки приглашения, а стандартный вывод программы (обозначающий выбранные пункты меню) перенаправляется в файл, который можно просмотреть позже:</p>    <p><blockquote>$ <b>./menu3 &gt; file</b></blockquote></p>    <p><blockquote>You are not a terminal, OK.</blockquote></p>    <p><blockquote>Choice: Please select an action</blockquote></p>    <p><blockquote>a — add new record</blockquote></p>    <p><blockquote>d — delete record</blockquote></p>    <p><blockquote>q — quit</blockquote></p>    <p><blockquote><b>d</b></blockquote></p>    <p><blockquote>Choice: Please select an action</blockquote></p>    <p><blockquote>a — add new record</blockquote></p>    <p><blockquote>d - delete record</blockquote></p>    <p><blockquote>q — quit</blockquote></p>    <p><blockquote><b>q</b></blockquote></p>    <p><blockquote>$ <b>cat file</b></blockquote></p>    <p><blockquote>You have chosen: d</blockquote></p>    <p><blockquote>You have chosen: q</blockquote></p>          <a name="metkadoc6"><h1>Драйвер терминала A и общий терминальный интерфейс</h1></a>         <p>Иногда программе нужно более мощные средства управления терминалами, чем простые файловые операции. ОС Linux предоставляет ряд интерфейсов, позволяющих управлять поведением драйвера терминала и обеспечивающих больше возможностей управления вводом и выводом терминала.</p>             <a name="metkadoc7"><h1>Обзор</h1></a>     <p>Как показано на рис. 5.1, вы можете управлять терминалом с помощью вызовов набора функций общего терминального интерфейса (General Terminal Interface, GTI), разделяя их на применяемые для чтения и для записи. Такой подход сохраняет ясность интерфейса данных (чтение/запись), позволяя при этом искусно управлять поведением терминала. Нельзя сказать, что терминальный интерфейс ввода/вывода очень понятен — он вынужден иметь дело с множеством разнообразных физических устройств.</p>     <img src="image010.jpg"/>     <p><b>Рис. 5.1</b> </p>     <br>     <p>В терминологии UNIX управляющий интерфейс устанавливает "порядок обслуживания линий", обеспечивающий программе ощутимую гибкость в задании поведения драйвера терминала.</p>     <p>К основным функциям, которыми вы можете управлять, относятся следующие:</p>     <p>&#9633; редактирование строки — применение для редактирования клавиши &lt;Backspace&gt;;</p>     <p>&#9633; буферизация — считывание символов сразу или после настраиваемой задержки;</p>     <p>&#9633; отображение — управление отображением так же, как при считывании паролей;</p>     <p>&#9633; CR/LF — отображение для ввода и вывода: что происходит при выводе символа перевода строки (\n);</p>     <p>&#9633; скорости передачи данных по линии — редко применяется для консоли ПК, эти скорости очень важны для модемов и терминалов на линиях последовательной передачи.</p>             <a name="metkadoc8"><h1>Аппаратная модель</h1></a>     <p>Перед тем как подробно рассматривать общий терминальный интерфейс, очень важно проанализировать аппаратную модель, предназначенную для управления.</p>     <p>Концептуальная схема (физическая модель на некоторых старых узлах UNIX подобна данной) включает машину с ОС UNIX, подключенную через последовательный порт с модемом и далее по телефонной линии с другим модемом к удаленному терминалу (рис. 5.2). На деле это просто вариант установки, применявшийся некоторыми малыми провайдерами интернет-услуг "на заре туманной юности" Интернета. Эта модель отдаленно напоминает организацию "клиент — сервер", при использовании которой программа выполняется на большом компьютере, а пользователи работают на терминалах ввода/вывода.</p>     <img src="image011.jpg"/>     <p><b>Рис. 5.2</b></p>     <br>     <p>Если вы работаете на ПК под управлением ОС Linux, эта модель может показаться чересчур сложной. Однако, поскольку у обоих авторов есть модемы, мы можем при желании использовать программу эмуляции терминала, например, minicom для запуска удаленного сеанса работы в системе на любой другой машине, подобной этой, с помощью пары модемов и телефонной линии связи. Конечно, сегодня быстрый широкополосный доступ вытеснил из потребления эту рабочую модель, но она до сих пор не лишена некоторых достоинств.</p>     <p>Преимущество применения этой аппаратной модели заключается в том, что в большинстве реальных ситуаций возникает потребность в некотором сокращенном варианте этого наиболее сложного случая. Удовлетворить эти потребности будет гораздо легче, если приведенная модель сохранит подобные функциональные возможности.</p>              <a name="metkadoc9"><h1>Структура типа<i> termios</i></h1></a>         <p>Тип <blockquote>termios</blockquote> — стандартный интерфейс, заданный стандартом POSIX и похожий на интерфейс <blockquote>termio</blockquote> системы System V. Интерфейс терминала управляется значениями в структуре типа <blockquote>termios</blockquote> и использует небольшой набор вызовов функций. И то и другое определено в заголовочном файле termios.h.</p>     <blockquote>      <b>Примечание</b>      <p>Программы, применяющие вызовы функций, определенных в файле termios.h, нуждаются в компоновке с соответствующей библиотекой функций. Ею может быть в зависимости от установленной у вас системы просто стандартная библиотека С или библиотека curses. При необходимости во время компиляции примеров этой главы добавьте аргумент <blockquote>-lcurses</blockquote> в конец строки команды компиляции. В некоторых более старых системах Linux библиотека curses представлена в версии, известной под названием "new curses". В этих случаях имя библиотеки и аргумент компоновки становятся <blockquote>ncurses</blockquote> и <blockquote>-lncurses</blockquote> соответственно.</p>     </blockquote>     <p>Значения, которые можно изменять для управления терминалом, разделены на группы, относящиеся к следующим режимам:</p>     <p>&#9633; ввод;</p>     <p>&#9633; вывод;</p>     <p>&#9633; управление;</p>     <p>&#9633; локальный;</p>     <p>&#9633; специальные управляющие символы.</p>     <p>Минимальная структура типа <blockquote>termios</blockquote> обычно объявляется следующим образом (хотя в стандарте X/Open разрешено включение дополнительных полей):</p>     <p><blockquote><b>#include &lt;termios.h&gt;</b></blockquote></p>     <p><blockquote><b>struct termios {</b></blockquote></p>     <p><blockquote><b> tcflag_t c_iflag;</b></blockquote></p>     <p><blockquote><b> tcflag_t c_oflag;</b></blockquote></p>     <p><blockquote><b> tcflag_t c_cflag;</b></blockquote></p>     <p><blockquote><b> tcflag_t c_lflag;</b></blockquote></p>     <p><blockquote><b> cc_t c_cc[NCCS];</b></blockquote></p>     <p><blockquote><b>};</b></blockquote></p>     <p>Имена элементов структуры соответствуют пяти типам параметров из предыдущего перечня.</p>     <p>Инициализировать структуру типа <blockquote>termios</blockquote> для терминала можно, вызвав функцию <blockquote>tcgetattr</blockquote> со следующим прототипом или описанием:</p>     <p><blockquote><b>#include &lt;termios.h&gt;</b></blockquote></p>     <p><blockquote><b>int tcgetattr(int fd, struct termios *termios_p);</b></blockquote></p>     <p>Этот вызов записывает текущие значения переменных интерфейса терминала в структуру, на которую указывает параметр <blockquote>termios_p</blockquote>. Если впоследствии эти значения будут изменены, вы сможете перенастроить интерфейс терминала с помощью функции <blockquote>tcsetattr</blockquote> следующим образом:</p>     <p><blockquote><b>#include &lt;termios.h&gt;</b></blockquote></p>     <p><blockquote><b>int tcsetattr(int fd, int actions, const struct termios *termios_p);</b></blockquote></p>     <p>Поле <blockquote>actions</blockquote> функции <blockquote>tcsetattr</blockquote> управляет способом внесения изменений. Есть три варианта:</p>     <p>&#9633; <blockquote>TCSANOW</blockquote> — изменяет значения сразу;</p>     <p>&#9633; <blockquote>TSCADRAIN</blockquote> — изменяет значения, когда текущий вывод завершен;</p>     <p>&#9633; <blockquote>TCSAFLUSH</blockquote> — изменяет значения, когда текущий вывод завершен, но отбрасывает любой ввод, доступный в текущий момент и все еще не возвращенный вызовом <blockquote>read</blockquote>.</p>     <blockquote>      <b>Примечание</b>      <p>Учтите, что для программ очень важно восстановить настройки терминала, действующие до начала выполнения программы. За первоначальное сохранение значений и их восстановление после завершения выполнения всегда отвечает программа.</p>     </blockquote>     <p>Теперь рассмотрим более подробно режимы и связанные с ними вызовы функций. Некоторые характеристики режимов довольно специализированные и редко применяются, поэтому мы остановимся только на основных. Если вы хотите знать больше, просмотрите страницы интерактивного справочного руководства вашей системы либо скопируйте стандарт POSIX или X/Open.</p>     <p>Наиболее важный режим, который следует принять во внимание при первом прочтении, — локальный (local). Канонический и неканонический режимы — решение второй проблемы в вашем первом приложении: пользователь должен нажимать клавишу &lt;Enter&gt; или &lt;Return&gt; для чтения программой входных данных. Вам следует заставить программу ждать всю строку ввода или набрасываться на ввод, как только он набран на клавиатуре.</p>             <a name="metkadoc10"><h1>Режимы ввода</h1></a>     <p>Режимы ввода управляют тем, как обрабатывается ввод (символы, полученные драйвером терминала от последовательного порта или клавиатуры) до передачи его в программу. Вы управляете вводом, устанавливая флаги в элементе <blockquote>c_iflag</blockquote> структуры <blockquote>termios</blockquote>. Все флаги определены как макросы и могут комбинироваться с помощью поразрядной операции <blockquote>OR</blockquote><b>.</b> Это свойственно всем режимам терминала.</p>     <p>В элементе <blockquote>c_iflag</blockquote> могут применяться следующие макросы:</p>     <p>&#9633; <blockquote>BRKINT</blockquote> — генерирует прерывание, когда в линии связи обнаруживается разрыв (потеря соединения);</p>     <p>&#9633; <blockquote>IGNBRK</blockquote> — игнорирует разрывы соединения в линии связи;</p>     <p>&#9633; <blockquote>ICRNL</blockquote> — преобразует полученный символ возврата каретки в символ перехода на новую строку;</p>     <p>&#9633; <blockquote>IGNCR</blockquote> — игнорирует полученные символы возврата каретки;</p>     <p>&#9633; <blockquote>INLCR</blockquote> — преобразует полученные символы перехода на новую строку в символы возврата каретки;</p>     <p>&#9633; <blockquote>IGNPAR</blockquote> — игнорирует символы с ошибками четности;</p>     <p>&#9633; <blockquote>INCPK</blockquote> — выполняет контроль четности у полученных символов;</p>     <p>&#9633; <blockquote>PARMRK</blockquote> — помечает ошибки четности;</p>     <p>&#9633; <blockquote>ISTRIP</blockquote> — обрезает (до семи битов) все входные символы;</p>     <p>&#9633; <blockquote>IXOFF</blockquote> — включает программное управление потоком при вводе;</p>     <p>&#9633; <blockquote>IXON</blockquote> — включает программное управление потоком при выводе.</p>     <blockquote>      <b>Примечание</b>      <p>Если флаги <blockquote>BRKINT</blockquote> и <blockquote>IGNBRK</blockquote> не установлены, сбой на линии связи считывается как символ <blockquote>NULL</blockquote> (0x00).</p>     </blockquote>     <p>Вам не придется часто изменять режимы ввода, поскольку обычно стандартные значения — наиболее подходящие, и поэтому мы больше не будем их обсуждать.</p>             <a name="metkadoc11"><h1>Режимы вывода</h1></a>     <p>Эти режимы управляют способом обработки выводимых символов, т.е. тем, как символы, полученные от программы, обрабатываются перед передачей на последовательный порт или экран. Как и следовало ожидать, многие из них — оборотная сторона режимов ввода. Есть несколько дополнительных флагов, которые связаны в основном с разрешениями для медленных терминалов, которым требуется время для обработки таких символов, как возвраты каретки. Почти все они либо избыточны (поскольку терминалы стали быстрее) или лучше обрабатываются с помощью базы данных характеристик терминала <blockquote>terminfo</blockquote>, которую вы примените позже в этой главе.</p>     <p>Вы управляете режимами вывода, устанавливая флаги элемента <blockquote>c_oflag</blockquote> структуры типа <blockquote>termios</blockquote>. В элементе <blockquote>c_oflag</blockquote> могут применяться следующие макросы:</p>     <p>&#9633; <blockquote>OPOST</blockquote> — включает обработку вывода;</p>     <p>&#9633; <blockquote>ONLCR</blockquote> — преобразует в символ перевода строки пару символов возврат каретки/перевод строки;</p>     <p>&#9633; <blockquote>OCRNL</blockquote> — преобразует любой символ возврата каретки в выводе в символ перевода строки;</p>     <p>&#9633; <blockquote>ONOCR</blockquote> — не выводит символ возврата каретки в столбце 0;</p>     <p>&#9633; <blockquote>ONLRET</blockquote> — символ перехода на новую строку выполняет возврат каретки;</p>     <p>&#9633; <blockquote>OFILL</blockquote> — посылает символы заполнения для формирования задержки;</p>     <p>&#9633; <blockquote>OFDEL</blockquote> — применяет символ <blockquote>DEL</blockquote> как заполнитель вместо символа <blockquote>NULL</blockquote>;</p>     <p>&#9633; <blockquote>NLDLY</blockquote> — выбор задержки для символа перехода на новую строку;</p>     <p>&#9633; <blockquote>CRDLY</blockquote> — выбор задержки для символа возврата каретки;</p>     <p>&#9633; <blockquote>TABDLY</blockquote> — выбор задержки для символа табуляции;</p>     <p>&#9633; <blockquote>BSDLY</blockquote> — выбор задержки для символа <blockquote>Backspace</blockquote>;</p>     <p>&#9633; <blockquote>VTDLY</blockquote> — выбор задержки для символа вертикальной табуляции;</p>     <p>&#9633; <blockquote>FFDLY</blockquote> — выбор задержки для символа прокрутки страницы.</p>     <blockquote>      <b>Примечание</b>      <p>Если флаг <blockquote>OPOST</blockquote> не установлен, все остальные флаги игнорируются.</p>     </blockquote>     <p>Режимы вывода тоже обычно не используются, поэтому мы не будем их обсуждать в дальнейшем.</p>             <a name="metkadoc12"><h1>Режимы управления</h1></a>     <p>Эти режимы управляют аппаратными характеристиками терминала. Вы задаете режимы управления, устанавливая флаги элемента <blockquote>c_cflag</blockquote> структуры типа <blockquote>termios</blockquote>, включающие следующие макросы:</p>     <p>&#9633; <blockquote>CLOCAL</blockquote> — игнорирует управление линиями с помощью модема;</p>     <p>&#9633; <blockquote>CREAD</blockquote> — включает прием символов;</p>     <p>&#9633; <blockquote>CS5</blockquote> — использует пять битов в отправляемых и принимаемых символах;</p>     <p>&#9633; <blockquote>CS6</blockquote> — использует шесть битов в отправляемых и принимаемых символах;</p>     <p>&#9633; <blockquote>CS7</blockquote> — использует семь битов в отправляемых и принимаемых символах;</p>     <p>&#9633; <blockquote>CS8</blockquote> — использует восемь битов в отправляемых и принимаемых символах;</p>     <p>&#9633; <blockquote>CSTOPB</blockquote> — устанавливает два стоповых бита вместо одного;</p>     <p>&#9633; <blockquote>HUPCL</blockquote> — выключает управление линиями модема при закрытии;</p>     <p>&#9633; <blockquote>PARENB</blockquote> — включает генерацию и проверку четности;</p>     <p>&#9633; <blockquote>PARODD</blockquote> — применяет контроль нечетности вместо контроля четности.</p>     <blockquote>      <b>Примечание</b>      <p>Если драйвер терминала обнаруживает, что последний дескриптор файла, ссылающийся на терминал, закрыт и при этом флаг <blockquote>HUPCL</blockquote> установлен, он устанавливает линии управления модема в состояние останова (hang-up).</p>     </blockquote>     <p>Режимы управления применяются в основном при подключении к модему последовательной линии связи, хотя их можно использовать и при диалоге с терминалом. Обычно легче изменить настройку терминала, чем изменять стандартное поведение линий связи с помощью режимов управления структуры <blockquote>termios</blockquote>.</p>             <a name="metkadoc13"><h1>Локальные режимы</h1></a>     <p>Эти режимы управляют разнообразными характеристиками терминала. Вы можете задать локальный режим, устанавливая флаги элемента <blockquote>c_iflag</blockquote> структуры <blockquote>termios</blockquote> с помощью следующих макросов:</p>     <p>&#9633; <blockquote>ECHO</blockquote> — включает локальное отображение вводимых символов;</p>     <p>&#9633; <blockquote>ECHOE</blockquote> — выполняет комбинацию <blockquote>Backspace</blockquote>, <blockquote>Space</blockquote>, <blockquote>Backspace</blockquote> при получении символа <blockquote>ERASE</blockquote> (стереть);</p>     <p>&#9633; <blockquote>ECHOK</blockquote> — стирает строку при получении символа <blockquote>KILL</blockquote>;</p>     <p>&#9633; <blockquote>ECHONL</blockquote> — отображает символы перехода на новую строку;</p>     <p>&#9633; <blockquote>ICANON</blockquote> — включает стандартную обработку ввода (см. текст, следующий за данным перечнем);</p>     <p>&#9633; <blockquote>IEXTEN</blockquote> — включает функции, зависящие от реализации;</p>     <p>&#9633; <blockquote>ISIG</blockquote> — включает генерацию сигналов;</p>     <p>&#9633; <blockquote>NOFLSH</blockquote> — отключает немедленную запись очередей;</p>     <p>&#9633; <blockquote>TOSTOP</blockquote> — посылает сигнал фоновым процессам при попытке записи.</p>     <p>Два самых важных флага в этой группе — <blockquote>ECHO</blockquote>, позволяющий подавлять отображение вводимых символов, и <blockquote>ICANON</blockquote>, переключающий терминал в один из двух различных режимов обработки принимаемых символов. Если установлен флаг <blockquote>ICANON</blockquote>, говорится, что строка в каноническом режиме, если нет, то строка в неканоническом режиме.</p>             <a name="metkadoc14"><h1>Специальные управляющие символы</h1></a>     <p>Специальные управляющие символы — это коллекция символов подобных символам от комбинации клавиш &lt;Ctrl&gt;+&lt;C&gt;, действующих особым образом, когда пользователь вводит их. В элементе <blockquote>c_cc</blockquote> структуры <blockquote>termios</blockquote> содержатся символы, отображенные на поддерживаемые функции. Позиция каждого символа (его номер в массиве) определяется макросом, других ограничений для управляющих символов не задано.</p>     <p>Массив <blockquote>c_cc</blockquote> используется двумя очень разными способами, зависящими от того, установлен для терминала канонический режим (т.е. установлен флаг <blockquote>ICANON</blockquote> в элементе <blockquote>c_lflag</blockquote> структуры <blockquote>termios</blockquote>) или нет.</p>     <p>Важно понять, что в двух разных режимах есть некоторое взаимное наложение при применении номеров элементов массива. По этой причине никогда не следует смешивать значения для этих двух режимов.</p>     <p>Для канонического режима применяются следующие индексы:</p>     <p>&#9633; <blockquote>VEOF</blockquote> — символ <blockquote>EOF</blockquote>;</p>     <p>&#9633; <blockquote>VEOL</blockquote> — дополнительный символ конца строки <blockquote>EOL</blockquote>;</p>     <p>&#9633; <blockquote>VERASE</blockquote> — символ <blockquote>ERASE</blockquote>;</p>     <p>&#9633; <blockquote>VINTR</blockquote> — символ прерывания <blockquote>INTR</blockquote>;</p>     <p>&#9633; <blockquote>VKILL</blockquote> — символ уничтожения <blockquote>KILL</blockquote>;</p>     <p>&#9633; <blockquote>VQUIT</blockquote> — символ завершения <blockquote>QUIT</blockquote>;</p>     <p>&#9633; <blockquote>VSUSP</blockquote> — символ приостанова <blockquote>SUSP</blockquote>;</p>     <p>&#9633; <blockquote>VSTART</blockquote> — символ запуска <blockquote>START</blockquote>;</p>     <p>&#9633; <blockquote>VSTOP</blockquote> — символ останова <blockquote>STOP</blockquote>.</p>     <p>Для канонического режима применяются следующие индексы:</p>     <p>&#9633; <blockquote>VINTR</blockquote> — символ <blockquote>INTR</blockquote>;</p>     <p>&#9633; <blockquote>VMIN</blockquote> — минимальное значение <blockquote>MIN</blockquote>;</p>     <p>&#9633; <blockquote>VQUIT</blockquote> — символ <blockquote>QUIT</blockquote>;</p>     <p>&#9633; <blockquote>VSUSP</blockquote> — символ <blockquote>SUSP</blockquote>;</p>     <p>&#9633; <blockquote>VTIME</blockquote> — время ожидания <blockquote>TIME</blockquote>;</p>     <p>&#9633; <blockquote>VSTART</blockquote> — символ <blockquote>START</blockquote>;</p>     <p>&#9633; <blockquote>VSTOP</blockquote> — символ <blockquote>STOP</blockquote>.</p>     <b>Символы</b>     <p>Поскольку для более сложной обработки вводимых символов специальные символы и неканонические значения очень важны, мы описываем их в табл. 5.1.</p>     <br>     <p><b><i>Таблица 5.1</i></b></p>     <table>      <tr>       <th valign="top">Символ</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>INTR</blockquote></td>       <td valign="top">Заставляет драйвер терминала отправить сигнал <blockquote>SIGINT</blockquote> процессам, подключенным к терминалу. Мы обсудим сигналы более подробно в<i> главе 11</i></td>      </tr>      <tr>       <td valign="top"><blockquote>QUIT</blockquote></td>       <td valign="top">Заставляет драйвер терминала отправить сигнал <blockquote>SIGQUIT</blockquote> процессам, подключенным к терминалу</td>      </tr>      <tr>       <td valign="top"><blockquote>ERASE</blockquote></td>       <td valign="top">Заставляет драйвер терминала удалить последний символ в строке</td>      </tr>      <tr>       <td valign="top"><blockquote>KILL</blockquote></td>       <td valign="top">Заставляет драйвер терминала удалить всю строку</td>      </tr>      <tr>       <td valign="top"><blockquote>EOF</blockquote></td>       <td valign="top">Заставляет драйвер терминала передать все символы строки во ввод, считываемый приложением. Если строка пустая, вызов <blockquote>read</blockquote> вернет ноль символов, как будто он встретил на конец файла</td>      </tr>      <tr>       <td valign="top"><blockquote>EOL</blockquote></td>       <td valign="top">Действует как ограничитель строки в дополнение к более привычному символу перехода на новую строку</td>      </tr>      <tr>       <td valign="top"><blockquote>SUSP</blockquote></td>       <td valign="top">Заставляет драйвер терминала послать сигнал <blockquote>SIGSUSP</blockquote> процессам, подключенным к терминалу. Если ваша система UNIX поддерживает управление заданиями, текущее приложение будет приостановлено</td>      </tr>      <tr>       <td valign="top"><blockquote>STOP</blockquote></td>       <td valign="top">Действует как "прерыватель потока", т. е. прекращает дальнейший вывод на терминал. Применяется для поддержки управления потоком XON/XOFF и обычно задается как ASCII-символ <blockquote>XOFF</blockquote> (&lt;Ctrl&gt;+&lt;S&gt;)</td>      </tr>      <tr>       <td valign="top"><blockquote>START</blockquote></td>       <td valign="top">Возобновляет вывод после символа <blockquote>STOP</blockquote>, часто ASCII-символ <blockquote>XON</blockquote></td>      </tr>     </table>     <b>Значения<i> TIME</i> и<i> MIN</i></b>     <p>Значения <blockquote>TIME</blockquote> и <blockquote>MIN</blockquote> применяются только в неканоническом режиме и действуют вместе для управления считыванием входных данных. Вместе они управляют действиями при попытке программы прочесть дескриптор файла, ассоциированный с терминалом.</p>     <p>Возможны четыре варианта.</p>     <p>&#9633; <blockquote>MIN = 0</blockquote> и <blockquote>TIME = 0</blockquote>. В этом случае вызов <blockquote>read</blockquote> всегда завершается сразу же. Если какие-то символы доступны, они будут возвращены, если нет, то <blockquote>read</blockquote> вернет ноль, и никакие символы не будут считаны.</p>     <p>&#9633; <blockquote>MIN = 0</blockquote> и <blockquote>TIME &gt; 0</blockquote>. В этом случае вызов <blockquote>read</blockquote> завершится, когда все доступные символы будут считаны или когда пройдет <blockquote>TIME</blockquote> десятых долей секунды. Если нет прочитанных символов из-за превышения отпущенного времени, <blockquote>read</blockquote> вернет 0. В противном случае он вернет количество прочитанных символов.</p>     <p>&#9633; <blockquote>MIN &gt; 0</blockquote> и <blockquote>TIME = 0</blockquote>. В этом случае вызов <blockquote>read</blockquote> будет ждать до тех пор, пока можно будет считать <blockquote>MIN</blockquote> символов, и затем вернет это количество символов. В случае конца файла возвращается 0.</p>     <p>&#9633; <blockquote>MIN &gt; 0</blockquote> и <blockquote>TIME &gt; 0</blockquote>. Это самый сложный случай. После вызова <blockquote>read</blockquote> ждет получения символа. Когда первый символ получен, каждый раз при получении последующего символа запускается межсимвольный таймер (или перезапускается, если он уже был запущен). Вызов <blockquote>read</blockquote> завершится, когда либо можно будет считать <blockquote>MIN</blockquote> символов, либо межсимвольное время превысит <blockquote>TIME</blockquote> десятых долей секунды. Это может пригодиться для подсчета разницы между единственным нажатием клавиши &lt;Esc&gt; и запуском функциональной клавиатурной escape-последовательности. Тем не менее следует знать, что сетевые соединения или высокая загрузка процессора могут полностью стереть такие полезные сведения о времени.</p>     <p>Установив неканонический режим и используя значения <blockquote>MIN</blockquote> и <blockquote>TIME</blockquote>, программы могут выполнять посимвольную обработку ввода.</p>     <b>Доступ к режимам терминала из командной оболочки</b>     <p>Если вы хотите просмотреть параметры <blockquote>termios</blockquote>, находясь в командной оболочке, примените следующую команду для получения их списка:</p>     <p><blockquote>$ <b>stty -a</b></blockquote></p>     <p>На установленных у авторов системах Linux, обладающих структурами <blockquote>termios</blockquote> с некоторыми расширениями по сравнению со стандартными, получен следующий вывод:</p>     <p><blockquote>speed 38400 baud; rows 24; columns 80; line = 0;</blockquote></p>     <p><blockquote>intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = &lt;undef&gt;;</blockquote></p>     <p><blockquote>eol2 = &lt;undef&gt;; swtch = &lt;undef&gt;; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R;</blockquote></p>     <p><blockquote>werase = ^W; lnext = ^V; flush = ^O, min = 1; time = 0;</blockquote></p>     <p><blockquote>-parenb -parodd cs8 -hupcl -cstopb cread -clocal -crtscts</blockquote></p>     <p><blockquote>-ignbrk -brkint -ignpar -parmirk -inpck -istrip -inlcr -igncr icrnl -ixon -ixoff</blockquote></p>     <p><blockquote>-iuclc -ixany -imaxbe1 iutf8</blockquote></p>     <p><blockquote>opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel n10 cr0 tab0 bs0 vt0 ff0</blockquote></p>     <p><blockquote>isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt</blockquote></p>     <p><blockquote>echoctl echoke</blockquote></p>     <p>Среди прочего, как видите, символ <blockquote>EOF</blockquote> — это &lt;Ctrl&gt;+&lt;D&gt;, и включено отображение. Экспериментируя с установками терминала, легко получить в результате терминал в нестандартном режиме, что затруднит его дальнейшее использование. Есть несколько способов справиться с этой трудностью.</p>     <p>&#9633; Первый способ — применить следующую команду, если ваша версия <blockquote>stty</blockquote> поддерживает ее:</p>     <p><blockquote>$ <b>stty sane</b></blockquote></p>     <p>Если вы потеряли преобразование клавиши возврата каретки в символ перехода на новую строку (который завершает строку), возможно, потребуется ввести <blockquote>stty sane</blockquote>, но вместо нажатия клавиши &lt;Enter&gt; нажать комбинацию клавиш &lt;Ctrl&gt;+&lt;J&gt; (которая обозначает переход на новую строку).</p>     <p>&#9633; Второй способ — применить команду <blockquote>stty -g</blockquote> и записать текущие установки <blockquote>stty</blockquote> в форму, готовую к повторному считыванию. В командной строке вы можете набрать следующее:</p>     <p><blockquote>$ <b>stty -g &gt; save_stty</b></blockquote></p>     <p><blockquote>...</blockquote></p>     <p><blockquote>&lt;<i>эксперименты с параметрами</i>&gt;</blockquote></p>     <p><blockquote>...</blockquote></p>     <p><blockquote>$ <b>stty $(cat save_stty)</b></blockquote></p>     <p>В финальной команде <blockquote>stty</blockquote> вам все еще придется использовать комбинацию клавиш &lt;Ctrl&gt;+&lt;J&gt; вместо клавиши &lt;Enter&gt;. Ту же самую методику можно применить и в сценариях командной оболочки.</p>     <p><blockquote>save_stty="$(stty -g)"</blockquote></p>     <p><blockquote>&lt;<i>изменение stty-параметров</i>&gt;</blockquote></p>     <p><blockquote>stty $save_stty</blockquote></p>     <p>&#9633; Если вы все еще в тупике, третий способ — перейти на другой терминал, применить команду <blockquote>ps</blockquote> для поиска оболочки, которую вы сделали непригодной, и затем использовать команду <blockquote>kill hup &lt;<i>id процесса</i>&gt;</blockquote> для принудительного завершения этой командной оболочки. Поскольку перед выводом регистрационного приглашения параметры <blockquote>stty</blockquote> всегда восстанавливаются, у вас появится возможность нормально зарегистрироваться в системе еще раз.</p>     <b>Задание режимов терминала из командной строки</b>     <p>Вы также можете применять команду <blockquote>stty</blockquote> для установки режимов терминалов непосредственно из командной строки.</p>     <p>Для установки режима, в котором ваш сценарий командной оболочки сможет выполнять посимвольное считывание, вы должны отключить канонический режим и задать 1 и 0. Команда будет выглядеть следующим образом:</p>     <p><blockquote>$ <b>stty -icanon min 1 time 0</b></blockquote></p>     <p>Теперь терминал будет считывать символы немедленно, вы можете попробовать выполнить еще раз первую программу menu1. Вы увидите, что она работает, как первоначально и предполагалось.</p>     <p>Вы также могли бы улучшить вашу попытку проверки пароля<i> (см. главу 2),</i> отключив отображение перед приглашением ввести пароль. Команда, выполняющая это действие, должна быть следующей:</p>     <p><blockquote>$ <b>stty -echo</b></blockquote></p>     <blockquote>      <b>Примечание</b>      <p>Не забудьте применить команду <blockquote>stty echo</blockquote> для возврата отображения после ваших экспериментов!</p>     </blockquote>             <a name="metkadoc15"><h1>Скорость терминала</h1></a>     <p>Последняя функция, обслуживаемая структурой <blockquote>termios</blockquote>, — манипулирование скоростью линии передачи. Для этой скорости не определен отдельный элемент структуры; она управляется вызовами функций. Скорости ввода и вывода обрабатываются отдельно.</p>     <p>Далее приведены четыре прототипа вызовов:</p>     <p><blockquote><b>#include &lt;termios.h&gt; </b></blockquote></p>     <p><blockquote><b>speed_t cfgetispeed(const struct termios *);</b></blockquote></p>     <p><blockquote><b>speed_t cfgetospeed(const struct termios *);</b></blockquote></p>     <p><blockquote><b>int cfsetispeed(struct termios *, speed_t speed);</b></blockquote></p>     <p><blockquote><b>int cfsetospeed(struct termios *, speed_t speed);</b></blockquote></p>     <p>Обратите внимание на то, что они воздействуют на структуру <blockquote>termios</blockquote>, а не непосредственно на порт. Это означает, что для установки новой скорости вы должны считать текущие установки с помощью функции <blockquote>tcgetattr</blockquote>, задать скорость, применив приведенные вызовы, и затем записать структуру <blockquote>termios</blockquote> обратно с помощью функции <blockquote>tcsetattr</blockquote>. Скорость линии передачи изменится только после вызова <blockquote>tcsetattr</blockquote>.</p>     <p>В вызовах перечисленных функций допускается задание разных значений скорости <blockquote>speed</blockquote>, но к основным относятся следующие константы:</p>     <p>&#9633; <blockquote>B0</blockquote> — отключение терминала;</p>     <p>&#9633; <blockquote>B1200</blockquote> — 1200 бод;</p>     <p>&#9633; <blockquote>B2400</blockquote>— 2400 бод;</p>     <p>&#9633; <blockquote>B9600</blockquote> — 9600 бод;</p>     <p>&#9633; <blockquote>B19200</blockquote> — 19 200 бод;</p>     <p>&#9633; <blockquote>B38400</blockquote> — 38 400 бод.</p>     <p>Не существует скоростей выше 38 400 бод, задаваемых стандартом, и стандартного метода обслуживания последовательных портов на более высоких скоростях.</p>     <blockquote>      <b>Примечание</b>      <p>В некоторых системах, включая Linux, для выбора более высоких скоростей определены константы <blockquote>В57600</blockquote>, <blockquote>B115200</blockquote> и <blockquote>В230400</blockquote>. Если вы пользуетесь более старой версией ОС Linux и эти константы недоступны, можно применить команду <blockquote>setserial</blockquote> для получения нестандартных скоростей 57 600 и 115 200. В этом случае указанные скорости будут использоваться при выборе константы B38400. Оба эти метода непереносимы, поэтому применяйте их с осторожностью.</p>     </blockquote>             <a name="metkadoc16"><h1>Дополнительные функции</h1></a>     <p>Есть небольшое число дополнительных функций для управления терминалами. Они работают непосредственно с дескрипторами файлов без необходимости считывания и записывания структур типа <blockquote>termios</blockquote>.</p>     <p><blockquote><b>#include &lt;termios.h&gt;</b></blockquote></p>     <p><blockquote><b>int tcdrain(int fd);</b></blockquote></p>     <p><blockquote><b>int tcflow(int fd, int flowtype);</b></blockquote></p>     <p><blockquote><b>int tcflush(int fd, int in_out_selector);</b></blockquote></p>     <p>Функции предназначены для следующих целей:</p>     <p>&#9633; <blockquote>tcdrain</blockquote> — заставляет вызвавшую программу ждать до тех пор, пока не будет отправлен весь поставленный в очередь вывод;</p>     <p>&#9633; <blockquote>tcflow</blockquote> — применяется для приостановки или возобновления вывода;</p>     <p>&#9633; <blockquote>tcflush</blockquote> — может применяться для отказа от входных или выходных данных либо и тех, и других.</p>     <p>Теперь, когда мы уделили довольно много внимания структуре <blockquote>termios</blockquote>, давайте рассмотрим несколько практических примеров. Возможно, самый простой из них — отключение отображения при чтении пароля (упражнение 5.4). Это делается сбрасыванием флага <blockquote>echo</blockquote>.</p>     <b>Упражнение 5.4. Программа ввода пароля с применение <blockquote>termios</blockquote></b>     <p>1. Начните вашу программу password.с со следующих определений:</p>     <p><blockquote>#include &lt;termios.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#define PASSWORD_LEN 8</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> struct termios initialrsettings, newrsettings;</blockquote></p>     <p><blockquote> char password[PASSWORD_LEN + 1];</blockquote></p>     <p>2. Далее добавьте строку, считывающую текущие установки из стандартного ввода и копирующую их в только что созданную вами структуру типа <blockquote>termios</blockquote>:</p>     <p><blockquote> tcgetattr(fileno(stdin), &amp;initialrsettings);</blockquote></p>     <p>3. Создайте копию исходных установок, чтобы восстановить их в конце. Сбросьте флаг <blockquote>ECHO</blockquote> в переменной <blockquote>newrsettings</blockquote> и запросите у пользователя его пароль:</p>     <p><blockquote> newrsettings = initialrsettings;</blockquote></p>     <p><blockquote> newrsettings.с_lflag &amp;= ~ЕСНО;</blockquote></p>     <p><blockquote> printf("Enter password: ");</blockquote></p>     <p>4. Далее установите атрибуты терминала в newrsettings и считайте пароль. И наконец, восстановите первоначальные значения атрибутов терминала и выведите пароль на экран, чтобы свести на нет все предыдущие усилия по обеспечению безопасности:</p>     <p><blockquote> if (tcsetattr(fileno(stdin), TCSAFLUSH, &amp;newrsettings) != 0) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Could not set attributes\n");</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  fgets(password, PASSWORD_LEN, stdin);</blockquote></p>     <p><blockquote>  tcsetattr(fileno(stdin), TCSANOW, &amp;initialrsettings);</blockquote></p>     <p><blockquote>  fprintf(stdout, "\nYou entered %s\n", password);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Когда вы выполните программу, то увидите следующее:</p>     <p><blockquote>$ <b>./password</b></blockquote></p>     <p><blockquote>Enter password: You entered hello</blockquote></p>     <p><blockquote>$</blockquote> </p>     <p><b>Как это работает</b></p>     <p>В этом примере слово <blockquote>hello</blockquote> набирается на клавиатуре, но не отображается на экране в строке приглашения <blockquote>Enter password:</blockquote>. Никакого вывода нет до тех пор, пока пользователь не нажмет клавишу &lt;Enter&gt;.</p>     <p>Будьте осторожны и изменяйте с помощью конструкции <blockquote>X&amp;=~FLAG</blockquote> (которая очищает бит, определенный флагом <blockquote>FLAG</blockquote> в переменной <blockquote>X</blockquote>) только те флаги, которые вам нужно изменить. При необходимости можно воспользоваться конструкцией <blockquote>X|=FLAG</blockquote> для установки одиночного бита, определяемого <blockquote>FLAG</blockquote>, хотя в предыдущем примере она не понадобилась.</p>     <p>Для установки атрибутов применяется действие <blockquote>TCSAFLUSH</blockquote> для очистки буфера клавиатуры, символов, которые пользователи вводили до того, как программа подготовилась к их считыванию. Это хороший способ заставить пользователей не начинать ввод своего пароля, пока не отключено отображение. Перед завершением программы вы также восстанавливаете первоначальные установки.</p>     <p>Другой распространенный пример использования структуры <blockquote>termios</blockquote> — перевод терминала в состояние, позволяющее вам считывать каждый набранный символ (упражнение 5.5). Для этого отключается канонический режим и используются параметры <blockquote>MIN</blockquote> и <blockquote>TIME</blockquote>.</p>     <b>Упражнение 5.5. Считывание каждого символа</b>     <p>Применяя только что полученные знания, вы можете изменить программу menu. Приведенная далее программа menu4.c базируется на программе menu3.c и использует большую часть кода из файла password.с, включенного в нее. Внесенные изменения выделены цветом и объясняются в пунктах описания.</p>     <p>1. Прежде всего, вам следует, включить новый заголовочный файл в начало программы:</p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote><i>#include &lt;termios.h&gt;</i></blockquote></p>     <br>     <p><blockquote>char *menu[] = {</blockquote></p>     <p><blockquote> "a — add new record",</blockquote></p>     <p><blockquote> "d — delete record",</blockquote></p>     <p><blockquote> "q - quit",</blockquote></p>     <p><blockquote> NULL,</blockquote></p>     <p><blockquote>};</blockquote></p>     <p>2. Затем нужно объявить пару новых переменных в функции <blockquote>main</blockquote>:</p>     <p><blockquote>int getchoice(char *greet, char *choices[], FILE *in, FILE *out);</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int choice = 0;</blockquote></p>     <p><blockquote> FILE *input;</blockquote></p>     <p><blockquote> FILE *output;</blockquote></p>     <p><blockquote><i> struct termios initial_settengs, new_settings;</i></blockquote></p>     <p>3. Перед вызовом функции <blockquote>getchoice</blockquote> вам следует изменить характеристики терминала, этим определяется место следующих строк:</p>     <p><blockquote> if (!isatty(fileno(stdout))) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "You are not a terminal, OK.\n");</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> input = fopen("/dev/tty", "r");</blockquote></p>     <p><blockquote> output = fopen("/dev/tty", "w");</blockquote></p>     <p><blockquote> if (!input || !output) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Unable to open /dev/tty\n");</blockquote></p>     <p><blockquote>  exit(1);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote><i> tcgetattr(fileno(input), &amp;initial_settings);</i></blockquote></p>     <p><blockquote><i> new_settings = initial_settings;</i></blockquote></p>     <p><blockquote><i> new_settings.c_lfag &amp;= ~ICANON;</i></blockquote></p>     <p><blockquote><i> new_settings.c_lflag &amp;= ~ECHO;</i></blockquote></p>     <p><blockquote><i> new_settings.c_cc[VMIN] = 1;</i></blockquote></p>     <p><blockquote><i> new_settings.c_cc[VTIME] = 0;</i></blockquote></p>     <p><blockquote><i> new_settings.c_lflag &amp;= ~ISIG;</i></blockquote></p>     <p><blockquote><i> if (tcsetattr(fileno(input), TCSANOW, &amp;new_settings) != 0) {</i></blockquote></p>     <p><blockquote><i>  fprintf(stderr, "could not set attributes\n");</i></blockquote></p>     <p><blockquote><i> }</i></blockquote></p>     <p>4. Перед завершением вы также должны вернуть первоначальные значения:</p>     <p><blockquote> do {</blockquote></p>     <p><blockquote>  choice = getchoice("Please select an action", menu, input, output);</blockquote></p>     <p><blockquote>  printf("You have chosen: %c\n", choice);</blockquote></p>     <p><blockquote> } while (choice != 'q');</blockquote></p>     <p><blockquote> tcsetattr(fileno(input), TCSANOW, &amp;initial_settings);</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>5. Теперь, когда вы в неканоническом режиме, необходимо проверить на соответствие возвраты каретки, поскольку стандартное преобразование CR (возврат каретки) в LF (переход на новую строку) больше не выполняется:</p>     <p><blockquote>int getchoice (char *greet, char *choices[], FILE *in, FILE *out) {</blockquote></p>     <p><blockquote> int chosen = 0;</blockquote></p>     <p><blockquote> int selected;</blockquote></p>     <p><blockquote> char **option;</blockquote></p>     <p><blockquote> do {</blockquote></p>     <p><blockquote>  fprintf(out, "Choice: %s\n", greet);</blockquote></p>     <p><blockquote>  option = choices;</blockquote></p>     <p><blockquote>  while (*option) {</blockquote></p>     <p><blockquote>   fprintf(but, "%s\n", *option);</blockquote></p>     <p><blockquote>   option++;</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  do {</blockquote></p>     <p><blockquote>   selected = fgetc(in);</blockquote></p>     <p><blockquote><i>  } while (selected == '\n' || selected == '\r');</i></blockquote></p>     <p><blockquote>  option = choices;</blockquote></p>     <p><blockquote>  while (*option) {</blockquote></p>     <p><blockquote>   if (selected == *option[0]) {</blockquote></p>     <p><blockquote>    chosen = 1;</blockquote></p>     <p><blockquote>    break;</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>   option++;</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  if (!chosen) {</blockquote></p>     <p><blockquote>   fprintf(out, "Incorrect choice, select again\n");</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> } while(!chosen);</blockquote></p>     <p><blockquote> return selected;</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Пока вы не устроите все иначе, теперь, если пользователь нажмет в вашей программе комбинацию клавиш &lt;Ctrl&gt;+&lt;C&gt;, программа завершится. Вы можете отключить обработку этих специальных символов, очистив флаг <blockquote>ISIG</blockquote> в локальных режимах. Для этого в функцию <blockquote>main</blockquote> включается следующая строка:</p>     <p><blockquote><i>new_settings.c_lflag &amp;= ~ISIG;</i></blockquote></p>     <p>Если вы внесете эти изменения в вашу программу меню, то будете получать немедленный отклик, и вводимый вами символ не будет отображаться на экране.</p>     <p><blockquote>$ <b>./menu4</b></blockquote></p>     <p><blockquote>Choice: Please select an action</blockquote></p>     <p><blockquote>a — add new record</blockquote></p>     <p><blockquote>d — delete record</blockquote></p>     <p><blockquote>q — quit</blockquote></p>     <p><blockquote>You have chosen: a</blockquote></p>     <p><blockquote>Choice: Please select an action</blockquote></p>     <p><blockquote>a — add new record</blockquote></p>     <p><blockquote>d — delete record</blockquote></p>     <p><blockquote>q — quit</blockquote></p>     <p><blockquote>You have chosen: q $</blockquote></p>     <p>Если вы нажмете комбинацию клавиш &lt;Ctrl&gt;+&lt;C&gt;, символ будет передан прямо в программу и будет истолкован, как неверный выбор.</p>              <a name="metkadoc17"><h1>Вывод терминала</h1></a>         <p>С помощью структуры типа <blockquote>termios</blockquote> вы управляли вводом с клавиатуры, но было бы хорошо иметь такой же уровень управления выходными данными, отображаемыми на экране терминала. В начале главы вы применяли функцию <blockquote>printf</blockquote> для вывода символов на экран, не имея при этом возможности помещать их в определенное место экрана.</p>             <a name="metkadoc18"><h1>Тип терминала</h1></a>     <p>Во многих системах UNIX применяются терминалы, несмотря на то, что сегодня во многих случаях "терминал" может на самом деле быть ПК, выполняющим программу эмуляции терминала или терминальным приложением в оконной среде, таким как xterm в графической оболочке X11.</p>     <p>Исторически существовало очень большое число аппаратных терминалов разных производителей. Несмотря на то, что почти все они применяют escape-последовательности (строки символов, начинающиеся с escape-символа) для управления положением курсора и другими атрибутами, такими как жирное начертание или мерцание, способы реализации управления при этом слабо стандартизованы. У некоторых старых моделей терминалов также разные характеристики прокрутки экрана, который может очищаться или не очищаться, когда посылается символ <blockquote>Backspace</blockquote>, и т.д.</p>     <blockquote>      <b>Примечание</b>      <p>Существует стандарт ANSI для набора escape-последовательностей (в основном базирующихся на последовательностях, применяемых в серии VT-терминалов компании Digital Equipment Corporation, но не идентичных им). Многие терминальные программы обеспечивают эмуляцию стандартного аппаратного терминала, часто VT100, VT220 или ANSI, а иногда и других типов.</p>     </blockquote>     <p>Такое разнообразие аппаратных моделей терминалов было бы огромной проблемой для программистов, пытающихся написать программы управления экраном, выполняющиеся на терминалах разных типов. Например, терминал ANSI применяет последовательность символов <blockquote>Escape, [, A</blockquote> для перемещения курсора вверх на одну строку. Терминал ADM-За (очень распространенный несколько лет назад) использует один управляющий символ от комбинации клавиш &lt;Ctrl&gt;+&lt;K&gt;.</p>     <p>Написание программы, имеющей дело с терминалами разнообразных типов, которые могут быть подключены в системе UNIX, кажется крайне устрашающей задачей. Такой программе понадобится разный программный код для терминала каждого типа.</p>     <p>Как ни странно, решение существует в пакете, известном как terminfo. Вместо необходимости обслуживания любого типа терминала в каждой программе, ей достаточно просмотреть базу данных типов терминалов для получения корректной информации. В большинстве современных систем UNIX, включая Linux, эта база данных объединена с другим пакетом, названным curses, о котором вы узнаете в следующей главе.</p>     <p>Для применения функций terminfo вы, как правило, должны подключить заголовочный файл curses.h пакета curses и собственный заголовочный файл term.h пакета terminfo. В некоторых системах Linux вам, возможно, придется применять реализацию curses, известную как ncurses, и включить файл ncurses.h для предоставления прототипов вашим функциям terminfo.</p>             <a name="metkadoc19"><h1>Установите тип вашего терминала</h1></a>     <p>Окружение ОС Linux содержит переменную <blockquote>TERM</blockquote>, которая хранит тип используемого терминала. Обычно она устанавливается системой автоматически во время регистрации в системе. Системный администратор может задать тип терминала по умолчанию для каждого непосредственно подключенного терминала и может сформировать подсказку с типом терминала для удаленных сетевых пользователей. Значение <blockquote>TERM</blockquote> может быть передано <blockquote>rlogin</blockquote> через telnet.</p>     <p>Пользователь может запросить командную оболочку о соображениях системы по поводу используемого им или ею терминала:</p>     <p><blockquote>$ <b>echo $TERM</b></blockquote></p>     <p><blockquote>xterm</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>В данном случае оболочка выполняется из программы, называемой xterm — эмулятора терминала для графической оболочки X Window System, или программы, обеспечивающей "такие же функциональные возможности, как KDE's Konsole или GNOME's gnome-terminal.</p>     <p>Пакет terminfo содержит базу данных характеристик и управляющих escape-последовательностей для большого числа терминалов и предоставляет единообразный программный интерфейс для их использования. Отдельная программа, таким образом, сможет извлечь выгоду от применения новых моделей терминалов по мере расширения базы данных и не заботиться о поддержке множества разных терминалов.</p>     <p>Характеристики терминалов в terminfo описываются с помощью атрибутов. Они хранятся в наборе откомпилированных файлов terminfo, которые обычно находятся в каталогах /usr/lib/terminfo или /usr/share/terminfo. Для каждого терминала (и многих принтеров, которые тоже могут быть заданы в terminfo) есть файл, в котором определены характеристики терминала и способ доступа к его функциям. Для того чтобы не создавать слишком большого каталога, реальные файлы хранятся в подкаталогах, имена которых — первый символ типа терминала. Так определение терминала VT100 можно найти в файле …terminfo/v/vt100.</p>     <p>Файлы terminfo пишутся по одному на каждый тип терминала в исходном формате, пригодном (или почти пригодном!) для чтения, который затем компилируется командой <blockquote>tic</blockquote> в более компактный и эффективный формат, используемый прикладными программами. Странно, стандарт X/Open ссылается на описания исходного и откомпилированного формата, но не упоминает команду <blockquote>tic</blockquote>, необходимую для реального преобразования исходного формата в откомпилированный. Для вывода пригодной для чтения версии откомпилированного элемента набора terminfo можно использовать программу infocmp.</p>     <p>Далее приведен пример файла terminfo для терминала VT100<b>:</b></p>     <p><blockquote>$ infocmp vt100</blockquote></p>     <p><blockquote>vt100|vt100-am|dec vt100 (w/advanced video),</blockquote></p>     <p><blockquote> am, mir, msgr, xenl, xon, cols#80, it#8, lines#24, vt#3,</blockquote></p>     <p><blockquote> acsc=``aaffggjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,</blockquote></p>     <p><blockquote> bel=^G, blink=\E[5m$&lt;2&gt;, bold=\E[1m$&lt;2&gt;,</blockquote></p>     <p><blockquote> clear=\E[H\E[J$&lt;50&gt;, cr=\r, csr=\E[%i%p1%d;%p2%dr,</blockquote></p>     <p><blockquote> cub=\E[%p1%dD, cub1=\b, cud=\E[%p1%dB, cud1=\n,</blockquote></p>     <p><blockquote> cuf=\E[%p1%dC, cuf1=\E[C$&lt;2&gt;,</blockquote></p>     <p><blockquote> cup=\E[%i%p1%d; %p2%dH$&lt;5&gt;, cuu=\E[%p1%dA,</blockquote></p>     <p><blockquote> cuu1=\E[A$&lt;2&gt;, ed=\E[J$&lt;50&gt;, el=\E[K$&lt;3&gt;,</blockquote></p>     <p><blockquote> el1=\E[1K$&lt;3&gt;, enacs=\E(B\E)0, home=\E[H, ht=\t,</blockquote></p>     <p><blockquote> hts=\EH, ind=\n, ka1=\EOq, ka3=\EOs, kb2=\EOr, kbs=\b,</blockquote></p>     <p><blockquote> kc1=\EOp, kc3=\EOn, kcub1=\EOD, kcud1=\EOB,</blockquote></p>     <p><blockquote> kcuf1=\EOC, kcuu1=\EOA, kent=\EOM, kf0=\EOy, kf1=\EOP,</blockquote></p>     <p><blockquote> kf10=\EOx, kf2=\EOQ, kf3=\EOR, kf4=\EOS, kf5=\EOt,</blockquote></p>     <p><blockquote> kf6=\EOu, kf7=\EOv, kf8=\EOl, kf9=\EOw, rc=\E8,</blockquote></p>     <p><blockquote> rev=\E[7m$&lt;2&gt;, ri=\EM$&lt;5&gt;, rmacs=^O, rmkx=\E[?11\E&gt;,</blockquote></p>     <p><blockquote> rmso=\E[m$&lt;2&gt;, rmul=\E[m$&lt;2&gt;,</blockquote></p>     <p><blockquote> rs2=\E&gt;\E[?31\E[?41\E[?51\E[?7h\E[?8h, sc=\E7,</blockquote></p>     <p><blockquote> sgr=\E[0%?%p1%p6%|%t;1%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;m%?%p9%t^N%e^O%;,</blockquote></p>     <p><blockquote> sgr0=\E[m^0$&lt;2&gt;, smacs=^N, smkx=\E[?1h\E=,</blockquote></p>     <p><blockquote> smso=\E[1;7m$&lt;2&gt;; smul=\E[4m$&lt;2&gt;, tbc=\E[3g,</blockquote></p>     <p>Каждое определение в <blockquote>terminfo</blockquote> состоит из трех типов элементов. Каждый элемент называется <blockquote>capname</blockquote> (имя характеристики) и определяет характеристику терминала.</p>     <p>Булевы или логические характеристики просто обозначают наличие или отсутствие поддержки терминалом конкретного свойства. Например, булева характеристика <blockquote>xon</blockquote> присутствует, если терминал поддерживает управление потоком <blockquote>XON/XOFF</blockquote>.</p>     <p>Числовые характеристики определяют размеры или объемы, например <blockquote>lines</blockquote> — это количество строк на экране, a <blockquote>cols</blockquote> — количество столбцов. Число отделяется от имени характеристики символом <blockquote>#</blockquote>. Для описания терминала с 80 столбцами и 24 строками следует написать <blockquote>cols#80, lines#24</blockquote>.</p>     <p>Строковые характеристики немного сложнее. Они применяются для двух разных типов характеристик: определения строк вывода, необходимых для доступа к функциям терминала, и определения строк ввода, которые будут получены, когда пользователь нажмет определенные клавиши, обычно функциональные или специальные клавиши на цифровой клавиатуре. Некоторые строковые параметры очень просты, например <blockquote>el</blockquote>, что означает "стереть до конца строки". Для того чтобы сделать это на терминале VT100, потребуется escape-последовательность <blockquote>Esc, [, K</blockquote>. В исходном формате terminfo это записывается как <blockquote>еl=\Е[K</blockquote>.</p>     <p>Специальные клавиши определены аналогичным образом. Например, функциональная клавиша &lt;F1&gt; на терминале VT100 посылает последовательность <blockquote>Esc, O, P</blockquote>, которая определяется как <blockquote>kf1=\EOP</blockquote>.</p>     <p>Все несколько усложняется, если escape-последовательности требуются какие-либо параметры. Большинство терминалов могут перемещать курсор в заданные строку и столбец. Ясно, что неразумно хранить отдельную характеристику для каждой точки экрана, в которую можно переместить курсор, поэтому применяется общая строковая характеристика с параметрами, определяющими значения, которые вставляются при использовании характеристики. Например, терминал VT100 использует последовательность <blockquote>Esc, [, &lt;row&gt;, &lt;col&gt;, H</blockquote> для перемещения курсора в заданную позицию. В исходном формате terminfo это записывается довольно устрашающе: <blockquote>cup=\E[%i%p1%d;%p2%dH$&lt;5&gt;</blockquote>.</p>     <p>Эта строка означает следующее:</p>     <p>&#9633; <blockquote>\E</blockquote> — послать escape-символ;</p>     <p>&#9633; <blockquote>[</blockquote> — послать символ <blockquote>[</blockquote>;</p>     <p>&#9633; <blockquote>%i</blockquote> — дать приращение аргументам;</p>     <p>&#9633; <blockquote>%p1</blockquote> — поместить первый аргумент в стек;</p>     <p>&#9633; <blockquote>%d</blockquote> — вывести число из стека как десятичное;</p>     <p>&#9633; <blockquote>;</blockquote> — послать символ <blockquote>;</blockquote>;</p>     <p>&#9633; <blockquote>%р2</blockquote> — поместить второй аргумент в стек;</p>     <p>&#9633; <blockquote>%d</blockquote> — вывести число из стека как десятичное;</p>     <p>&#9633; <blockquote>H</blockquote> —послать символ <blockquote>H</blockquote>.</p>     <p>Данная запись кажется сложной, но позволяет задавать параметры в строгом порядке, не зависящем от порядка, в котором терминал ожидает их появления в финальной escape-последовательности. Приращение аргументов <blockquote>%i</blockquote> необходимо, поскольку стандартная адресация курсора задается, начиная от верхнего левого угла экрана (0, 0), а терминал VT100 обозначает начальную позицию курсора как (1, 1). Заключительные символы <blockquote>$&lt;5&gt;</blockquote> означают, что для обработки терминалом перемещения курсора требуется задержка, эквивалентная времени вывода пяти символов.</p>     <blockquote>      <b>Примечание</b>      <p>Мы могли бы описывать огромное множество характеристик, но, к счастью, в основном системы UNIX и Linux приходят с большинством предопределенных терминалов. Если нужно добавить новую модель терминала, вы можете найти полный список характеристик на странице интерактивного справочного руководства, посвященной terminfo. Лучше всего начать с поиска включенного в базу данных терминала, похожего на ваш новый, и затем создания описания новой модели как вариации существующего, т. е. осуществить последовательный просмотр характеристик, одну за другой, и исправление нуждающихся в корректировке.</p>     </blockquote>             <a name="metkadoc20"><h1>Применение характеристик terminfo</h1></a>     <p>Теперь, когда вы знаете, как определить характеристики терминала, нужно научиться обращаться к ним. Когда используется terminfo, прежде всего вам нужно задать тип терминала, вызвав функцию <blockquote>setupterm</blockquote>. Она инициализирует структуру <blockquote>TERMINAL</blockquote> для текущего типа терминала. После этого вы сможете запрашивать характеристики терминала и применять его функциональные возможности. Делается это с помощью вызова <blockquote>setupterm</blockquote>, подобного приведенному далее:</p>     <p><blockquote><b>#include &lt;term.h&gt;</b></blockquote></p>     <p><blockquote><b>int setupterm(char *term, int fd, int *errret);</b></blockquote></p>     <p>Библиотечная функция <blockquote>setupterm</blockquote> задает текущий тип терминала в соответствии с заданным параметром <blockquote>term</blockquote>. Если <blockquote>term</blockquote> — пустой указатель, применяется переменная окружения <blockquote>TERM</blockquote>. Открытый дескриптор файла, предназначенный для записи на терминал, должен передаваться в параметре <blockquote>fd</blockquote>. Результат функции хранится в целой переменной, на которую указывает <blockquote>errret</blockquote>, если это не пустой указатель. Могут быть записаны следующие значения:</p>     <p>&#9633; -1 — нет базы данных terminfo;</p>     <p>&#9633; 0 — нет совпадающего элемента в базе данных terminfo;</p>     <p>&#9633; 1 — успешное завершение.</p>     <p>Функция <blockquote>setupterm</blockquote> возвращает константу <blockquote>OK</blockquote> в случае успешного завершения и <blockquote>ERR</blockquote> в случае сбоя. Если на параметр <blockquote>errret</blockquote> установлен как пустой указатель, <blockquote>setupterm</blockquote> выведет диагностическое сообщение и завершит программу в случае своего аварийного завершения, как в следующем примере:</p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;term.h&gt;</blockquote></p>     <p><blockquote>#include &lt;curses.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> setupterm("unlisted", fileno(stdout), (int *)0);</blockquote></p>     <p><blockquote> printf("Done.\n");</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Результат выполнения этой программы в вашей системе может не быть точной копией приведенного далее, но его смысл будет вполне понятен. "<blockquote>Done.</blockquote>" не выводится, поскольку функция <blockquote>setupterm</blockquote> после своего аварийного завершения вызвала завершение программы:</p>     <p><blockquote>$ <b>cc -о badterm badterm.с -lncurses</b></blockquote></p>     <p><blockquote>$ <b>./badterm</b></blockquote></p>     <p><blockquote>'unlisted': unknown terminal type.</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Обратите внимание на строку компиляции в примере: в этой системе Linux мы используем реализацию ncurses библиотеки curses со стандартным заголовочным файлом, находящимся в стандартном каталоге. В таких системах вы можете просто включить файл curses.h и задать <blockquote>-lncurses</blockquote> для библиотеки.</p>     <p>В функции выбора пункта меню хорошо было бы иметь возможность очищать экран, перемещать курсор по экрану и записывать его положение на экране. После вызова функции <blockquote>setupterm</blockquote> вы можете обращаться к характеристикам базы данных terminfo с помощью вызовов трех функций, по одной на каждый тип характеристики:</p>     <p><blockquote><b>#include &lt;term.h&gt;</b></blockquote></p>     <p><blockquote><b>int tigetflag(char *capname);</b></blockquote></p>     <p><blockquote><b>int tigetnum(char *capname);</b></blockquote></p>     <p><blockquote><b>char *tigetstr(char *capname);</b></blockquote></p>     <p>Функции <blockquote>tigetflag</blockquote>, <blockquote>tigetnum</blockquote> и <blockquote>tigetstr</blockquote> возвращают значения характеристик terminfo булева или логического, числового и строкового типов соответственно. В случае сбоя (например, характеристика не представлена) <blockquote>tigetflag</blockquote> вернет -1, <blockquote>tigetnum</blockquote> — -2, a <blockquote>tigetstr</blockquote> — (char*)-1.</p>     <p>Вы можете применять базу данных terminfo для определения размера экрана терминала, извлекая характеристики <blockquote>cols</blockquote> и <blockquote>lines</blockquote> с помощью следующей программы sizeterm.c:</p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;term.h&gt;</blockquote></p>     <p><blockquote>#include &lt;curses.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int nrows, ncolumns;</blockquote></p>     <p><blockquote> setupterm(NULL, fileno(stdout), (int *)0);</blockquote></p>     <p><blockquote> nrows = tigetnum("lines");</blockquote></p>     <p><blockquote> ncolumns = tigetnum("cols");</blockquote></p>     <p><blockquote> printf("This terminal has %d columns and %d rows\n", ncolumns, nrows);</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote>$ <b>echo $TERM</b></blockquote></p>     <p><blockquote>vt100</blockquote></p>     <p><blockquote>$ <b>./sizeterm</b></blockquote></p>     <p><blockquote>This terminal has 80 columns and 24 rows</blockquote></p>     <p>Если запустить эту программу в окне рабочей станции, вы получите результат, отражающий размер текущего окна:</p>     <p><blockquote>$ <b>echo $TERM</b></blockquote></p>     <p><blockquote>xterm</blockquote></p>     <p><blockquote>$ <b>./sizeterm</b></blockquote></p>     <p><blockquote>This terminal has 88 columns and 40 rows</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Если применить функцию <blockquote>tigetstr</blockquote> для получения характеристики перемещения курсора (<blockquote>cup</blockquote>) терминала типа xterm, вы получите параметризованный ответ: <blockquote>\Е[%p1%d;%p2%dH</blockquote>.</p>     <p>Этой характеристике требуются два параметра: номер строки и номер столбца, в которые перемещается курсор. Обе координаты измеряются, начиная от нулевого значения в левом верхнем углу экрана.</p>     <p>Вы можете заменить параметры в характеристике реальными значениями с помощью функции <blockquote>tparm</blockquote>. До девяти параметров можно заменить значениями и получить в результате применяемую escape-последовательность символов.</p>     <p><blockquote><b>#include &lt;term.h&gt;</b></blockquote></p>     <p><blockquote><b>char *tparm(char *cap, long p1, long p2, ..., long p9);</b></blockquote></p>     <p>После формирования escape-последовательности с помощью <blockquote>tparm</blockquote>, ее нужно отправить на терминал. Для корректной обработки этой последовательности не следует пересылать строку на терминал с помощью функции <blockquote>printf</blockquote>. Вместо нее примените одну из специальных функций, обеспечивающих корректную обработку любых задержек, необходимых для завершения операции, выполняемой терминалом. К ним относятся следующие:</p>     <p><blockquote><b>#include &lt;term.h&gt;</b></blockquote></p>     <p><blockquote><b>int putp(char *const str);</b></blockquote></p>     <p><blockquote><b>int tputs(char *const str, int affcnt, int (*putfunc)(int));</b></blockquote></p>     <p>В случае успешного завершения функция <blockquote>putp</blockquote> вернет константу <blockquote>OK</blockquote>,в противном случае — <blockquote>ERR</blockquote>. Эта функция принимает управляющую строку терминала и посылает ее в стандартный вывод stdout.</p>     <p>Итак, для перемещения в строку 5 и столбец 30 на экране можно применить блок программного кода, подобный приведенному далее:</p>     <p><blockquote>char *cursor;</blockquote></p>     <p><blockquote>char *esc_sequence;</blockquote></p>     <p><blockquote>cursor = tigetstr("cup");</blockquote></p>     <p><blockquote>esc_sequence = tparm(cursor, 5, 30);</blockquote></p>     <p><blockquote>putp(esc_sequence);</blockquote></p>     <p>Функция <blockquote>tputs</blockquote> предназначена для ситуаций, в которых терминал не доступен через стандартный вывод <blockquote>stdout</blockquote>, и позволяет задать функцию, применяемую для вывода символов. Она возвращает результат заданной пользователем функции <blockquote>putfunc</blockquote>. Параметр <blockquote>affcnt</blockquote> предназначен для обозначения количества строк, подвергшихся изменению. Обычно он устанавливается равным 1. Функция, используемая для вывода строки, должна иметь те же параметры и возвращать тип значения как у функции <blockquote>putfunc</blockquote>. В действительности <blockquote>putp(string)</blockquote> эквивалентна вызову <blockquote>tputs (string, 1, putchar)</blockquote>. В следующем примере вы увидите применение функции <blockquote>tputs</blockquote>, используемой с функцией вывода, определенной пользователем.</p>     <p>Имейте в виду, что в некоторых старых дистрибутивах Linux последний параметр функции <blockquote>tputs</blockquote> определен как <blockquote>int (*putfunc)(char)</blockquote>, что заставит вас изменить определение функции <blockquote>char_to_terminal</blockquote> из упражнения 5.6.</p>     <blockquote>      <b>Примечание</b>      <p>Если вы обратитесь к страницам интерактивного справочного руководства за информацией о функции <blockquote>tparm</blockquote> и характеристиках терминалов, то можете встретить функцию <blockquote>tgoto</blockquote>. Причина, по которой мы не используем эту функцию, хотя она, очевидно, предлагает более легкий способ перемещения курсора, заключается в том, что она не включена в стандарт X/Open (Single UNIX Specification Version 2) по данным издания 1997 г. Следовательно, мы не рекомендуем применять любую из этих функций в ваших новых программах.</p>     </blockquote>     <p>Вы почти готовы добавить обработку экрана в вашу функцию выбора пункта меню. Единственно, что осталось, — очистить экран просто с помощью свойства <blockquote>clear</blockquote>. Некоторые терминалы не поддерживают характеристику <blockquote>clear</blockquote>, которая помещает курсор в левый верхний угол экрана. В этом случае вы можете поместить курсор в левый верхний угол и применить команду <blockquote>ed</blockquote> — удалить до конца экрана.</p>     <p>Для того чтобы собрать всю полученную информацию вместе, напишем окончательную версию примера программы выбора пункта меню screenmenu.c, в которой вы "нарисуете" варианты пунктов меню на экране для того, чтобы пользователь выбрал нужный пункт (упражнение 5.6).</p>     <b>Упражнение 5.6. Полное управление терминалом</b>     <p>Вы можете переписать функцию <blockquote>getchoice</blockquote> из программы menu4.c для предоставления полного управления терминалом. В этом листинге функция <blockquote>main</blockquote> пропущена, потому что она не меняется. Другие отличия от программы menu4.c выделены цветом.</p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;termios.h&gt;</blockquote></p>     <p><blockquote><i>#include &lt;term.h&gt;</i></blockquote></p>     <p><blockquote><i>#include &lt;curses.h&gt;</i></blockquote></p>     <br>     <p><blockquote><i>static FILE* output_stream = (FILE *)0;</i></blockquote></p>     <p><blockquote>char *menu[] = {</blockquote></p>     <p><blockquote> "a — add new record",</blockquote></p>     <p><blockquote> "d — delete record",</blockquote></p>     <p><blockquote> "q - quit",</blockquote></p>     <p><blockquote> NULL,</blockquote></p>     <p><blockquote>};</blockquote></p>     <br>     <p><blockquote>int getchoice(char *greet, char *choices[], FILE *in, FILE *out);</blockquote></p>     <p><blockquote><i>int char_to_terminal(int_char_to_write);</i></blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> ...</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote><i>int getchoice(char *greet, char* choices[], FILE[]* in, FILE* out) {</i></blockquote></p>     <p><blockquote><i> int chosen = 0;</i></blockquote></p>     <p><blockquote><i> int selected;</i></blockquote></p>     <p><blockquote><i> int screenrow, screencol = 10;</i></blockquote></p>     <p><blockquote><i> char **option;</i></blockquote></p>     <p><blockquote><i> char* cursor, *clear;</i></blockquote></p>     <p><blockquote><i> output_stream = out;</i></blockquote></p>     <p><blockquote><i> setupterm(NULL, fileno(out), (int*)0);</i></blockquote></p>     <p><blockquote><i> cursor = tigetstr("cup");</i></blockquote></p>     <p><blockquote><i> clear = tigetstr("clear");</i></blockquote></p>     <p><blockquote><i> screenrow =4;</i></blockquote></p>     <p><blockquote><i> tputs(clear, 1, (int*)char_to_terminal);</i></blockquote></p>     <p><blockquote><i> tputs(tparm(cursor, screenrow, screencol), 1, char_to_terminal);</i></blockquote></p>     <p><blockquote><i> fprintf(out, "Choice: %s", greet);</i></blockquote></p>     <p><blockquote><i> screenrow += 2;</i></blockquote></p>     <p><blockquote><i> option = choices;</i></blockquote></p>     <p><blockquote><i> while (*option) {</i></blockquote></p>     <p><blockquote><i>  ftputs(tparm(cursor, screenrow, screencol), 1, char_to_terminal);</i></blockquote></p>     <p><blockquote><i>  fprintf(out, "%s", *option);</i></blockquote></p>     <p><blockquote><i>  screenrow++;</i></blockquote></p>     <p><blockquote><i>  option++</i></blockquote></p>     <p><blockquote><i> }</i></blockquote></p>     <p><blockquote><i> fprintf(out, "\n");</i></blockquote></p>     <p><blockquote><i> do {</i></blockquote></p>     <p><blockquote><i>  fflush(out);</i></blockquote></p>     <p><blockquote><i>  selected = fgetc(in);</i></blockquote></p>     <p><blockquote><i>  option = choices;</i></blockquote></p>     <p><blockquote><i>  while (*option) {</i></blockquote></p>     <p><blockquote><i>   if (selected == *option[0]) {</i></blockquote></p>     <p><blockquote><i>    chosen = 1;</i></blockquote></p>     <p><blockquote><i>    break;</i></blockquote></p>     <p><blockquote><i>   }</i></blockquote></p>     <p><blockquote><i>   option++;</i></blockquote></p>     <p><blockquote><i>  }</i></blockquote></p>     <p><blockquote><i>  if (!chosen) {</i></blockquote></p>     <p><blockquote><i>   tputs(tparm(cursor, screenrow, screencol), 1, char_to_terminal);</i></blockquote></p>     <p><blockquote><i>   fprintf(out, "Incorrect choice, select again\n");</i></blockquote></p>     <p><blockquote><i>  }</i></blockquote></p>     <p><blockquote><i> } while (!chosen);</i></blockquote></p>     <p><blockquote><i> tputs(clear, 1, char_to_terminal);</i></blockquote></p>     <p><blockquote><i> return selected;</i></blockquote></p>     <p><blockquote><i>}</i></blockquote></p>     <br>     <p><blockquote><i>int char_to_terminal(int char_to_write) {</i></blockquote></p>     <p><blockquote><i> if (output_stream) putc(char_to_write, output_stream);</i></blockquote></p>     <p><blockquote><i> return 0;</i></blockquote></p>     <p><blockquote><i>}</i></blockquote></p>     <p>Сохраните эту программу как menu5.с.</p>     <p><b>Как это работает</b></p>     <p>Переписанная функция <blockquote>getchoice</blockquote> выводит то же меню, что и в предыдущих примерах, но подпрограммы вывода изменены так, чтобы можно было воспользоваться характеристиками из базы данных <blockquote>terminfo</blockquote>. Если вы хотите видеть на экране сообщение "You have chosen:" дольше, чем одно мгновение перед очисткой экрана и подготовкой его к следующему выбору пункта меню, добавьте в функцию <blockquote>main</blockquote> вызов <blockquote>sleep</blockquote>:</p>     <p><blockquote>do {</blockquote></p>     <p><blockquote> choice = getchoice("Please select an action", menu, input, output);</blockquote></p>     <p><blockquote> printf("\nYou have chosen: %c\n", choice);</blockquote></p>     <p><blockquote><i> sleep(1);</i></blockquote></p>     <p><blockquote>} while (choice != 'q');</blockquote></p>     <p>Последняя функция в этой программе <blockquote>char_to_terminal</blockquote> включает в себя вызов функции <blockquote>putc</blockquote>, которую мы упоминали в<i> главе 3.</i></p>     <p>В завершение этой главы бегло рассмотрим пример определения нажатий клавиш.</p>              <a name="metkadoc21"><h1>Обнаружение нажатий клавиш</h1></a>         <p>Пользователи, программировавшие в ОС MS-DOS, часто ищут в ОС Linux эквивалент функции <blockquote>kbhit</blockquote>, которая определяет, была ли нажата клавиша, без реального ее считывания. К сожалению, их поиски оказываются безуспешными, поскольку прямого аналога нет. Программисты в среде UNIX не ощущают этого отсутствия, т.к. UNIX запрограммирована так, что программы очень редко (если когда-либо вообще) озабочены ожиданием события. Поскольку это обычный способ применения <blockquote>kbhit</blockquote>, ее нехватка редко ощущается в системах UNIX и Linux.</p>     <p>Однако, когда вы переносите программы из MS-DOS, часто удобно эмулировать функцию <blockquote>kbhit</blockquote>, которую можно применять на деле в неканоническом режиме ввода (упражнение 5.7).</p>     <b>Упражнение 5.7. Исключительно ваша собственная <blockquote>kbhit</blockquote></b>     <p>1. Начните со стандартной заголовочной информации и пары структур для установки параметров терминала. <blockquote>peek_character</blockquote> применяется для проверки нажатия клавиши. Далее описываются функции, которые будут использоваться позже:</p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;termios.h&gt;</blockquote></p>     <p><blockquote>#include &lt;term.h&gt;</blockquote></p>     <p><blockquote>#include &lt;curses.h&gt;</blockquote></p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <br>     <p><blockquote>static struct termios initial_settings, new_settings;</blockquote></p>     <p><blockquote>static int peek_character = -1;</blockquote></p>     <p><blockquote>void init_keyboard();</blockquote></p>     <p><blockquote>void close_keyboard();</blockquote></p>     <p><blockquote>int kbhit();</blockquote></p>     <p><blockquote>int readch();</blockquote></p>     <p>2. Функция main вызывает функцию <blockquote>init_keyboard</blockquote> для настройки терминала, затем выполняет цикл один раз в секунду, каждый раз вызывая в нем функцию <blockquote>kbhit</blockquote>. Если нажата клавиша &lt;q&gt;, функция <blockquote>close_keyboard</blockquote> восстанавливает нормальный режим и программа завершается:</p>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int ch = 0;</blockquote></p>     <p><blockquote> init_keyboard();</blockquote></p>     <p><blockquote> while (ch != 'q') {</blockquote></p>     <p><blockquote>  printf("looping\n");</blockquote></p>     <p><blockquote>  sleep(1);</blockquote></p>     <p><blockquote>  if (kbhit()) {</blockquote></p>     <p><blockquote>   ch = readch();</blockquote></p>     <p><blockquote>   printf("you hit %c\n", ch);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> close_keyboard();</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>3. Функции <blockquote>init_keyboard</blockquote> и <blockquote>close_keyboard</blockquote> настраивают терминал в начале и конце программы:</p>     <p><blockquote>void init_keyboard() {</blockquote></p>     <p><blockquote> tcgetattr(0, &amp;initial_settings);</blockquote></p>     <p><blockquote> new_settings = initial_settings;</blockquote></p>     <p><blockquote> new_settings.c_lflag &amp;= ~ICANON;</blockquote></p>     <p><blockquote> new_settings.c_lflag &amp;= ~ECHO;</blockquote></p>     <p><blockquote> new_settings.c_lflag &amp;= ~ISIG;</blockquote></p>     <p><blockquote> new_settings.c_cc[VMIN] = 1;</blockquote></p>     <p><blockquote> new_settings.c_cc[VTIME] = 0;</blockquote></p>     <p><blockquote> tcsetattr(0, TCSANOW, &amp;new_settings);</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote>void close_keyboard() {</blockquote></p>     <p><blockquote> tcsetattr(0, TCSANOW, &amp;initial_settings);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>4. Теперь функция, проверяющая нажатие клавиши:</p>     <p><blockquote>int kbhit() {</blockquote></p>     <p><blockquote> char ch;</blockquote></p>     <p><blockquote> int nread;</blockquote></p>     <p><blockquote> if (peek_character != -1) return 1;</blockquote></p>     <p><blockquote> new_settings.c_cc[VMIN] = 0;</blockquote></p>     <p><blockquote> tcsetattr(0, TCSANOW, &amp;new_settings);</blockquote></p>     <p><blockquote> nread = read(0, sch, 1);</blockquote></p>     <p><blockquote> newrsettings.c_cc[VMIN] = 1;</blockquote></p>     <p><blockquote> tcsetattr(0, TCSANOW, &amp;new_settings);</blockquote></p>     <p><blockquote> if (nread == 1) {</blockquote></p>     <p><blockquote>  peek_character = ch;</blockquote></p>     <p><blockquote>  return 1;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return 0;</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>5. Нажатый символ считывается следующей функцией <blockquote>readch</blockquote>, которая затем восстанавливает значение -1 переменной <blockquote>peek_character</blockquote> для выполнения следующего цикла:</p>     <p><blockquote>int readch() {</blockquote></p>     <p><blockquote> char ch;</blockquote></p>     <p><blockquote> if (peek_character != -1) {</blockquote></p>     <p><blockquote>  ch = peek_character;</blockquote></p>     <p><blockquote>  peek_character = -1;</blockquote></p>     <p><blockquote>  return ch;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> read(0, &amp;ch, 1);</blockquote></p>     <p><blockquote> return ch;</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Когда вы выполните программу (kbhit.c), то получите следующий вывод:</p>     <p><blockquote>$ <b>./kbhit</b></blockquote></p>     <p><blockquote>looping</blockquote></p>     <p><blockquote>looping</blockquote></p>     <p><blockquote>looping</blockquote></p>     <p><blockquote>you hit h</blockquote></p>     <p><blockquote>looping</blockquote></p>     <p><blockquote>looping</blockquote></p>     <p><blockquote>looping</blockquote></p>     <p><blockquote>you hit d</blockquote></p>     <p><blockquote>looping</blockquote></p>     <p><blockquote>you hit q</blockquote></p>     <p><blockquote>$</blockquote></p>     <p><b>Как это работает</b></p>     <p>Терминал настраивается в функции <blockquote>init_keyboard</blockquote> на считывание одного символа (<blockquote>MIN=1, TIME=0</blockquote>). Функция <blockquote>kbhit</blockquote> изменяет это поведение на проверку ввода и его немедленный возврат (<blockquote>MIN=0, TIME=0</blockquote>) и затем восстанавливает исходные установки перед завершением.</p>     <p>Обратите внимание на то, что вы должны считать символ нажатой клавиши, но сохраняете его локально, готовые вернуть символ в вызывающую программу по ее требованию.</p>             <a name="metkadoc22"><h1>Виртуальные консоли</h1></a>     <p>ОС Linux предоставляет средство, называемое<i> виртуальными консолями.</i> Экран, клавиатуру и мышь одного ПК может использовать ряд терминальных устройств, доступных на этом компьютере. Обычно установка ОС Linux рассчитана на использование от 8 до 12 виртуальных консолей. Виртуальные консоли становятся доступными благодаря символьным устройствам /dev/tty<i>N</i>, где <i>N</i> — номер, начинающийся с 1.</p>     <p>Если вы регистрируетесь в вашей системе Linux в текстовом режиме, как только система активизируется, вам будет предложено регистрационное приглашение. Далее вы регистрируетесь с помощью имени пользователя и пароля. В этот момент используемое вами устройство — первая виртуальная консоль, терминальное устройство /dev/tty1.</p>     <p>С помощью команд <blockquote>who</blockquote> и <blockquote>ps</blockquote> вы можете увидеть, кто зарегистрировался и какие командная оболочка и программы выполняются на этой виртуальной консоли:</p>     <p><blockquote>$ <b>who</b></blockquote></p>     <p><blockquote>neil tty1 Mar 8 18:27</blockquote></p>     <p><blockquote>$ <b>ps -e</b></blockquote></p>     <p><blockquote> PID TTY      TIME CMD</blockquote></p>     <p><blockquote>1092 tty1 00:00:00 login</blockquote></p>     <p><blockquote>1414 tty1 00:00:00 bash</blockquote></p>     <p><blockquote>1431 tty1 00:00:00 emacs</blockquote></p>     <p>Из этого укороченного вывода видно, что пользователь neil зарегистрировался и запустил редактор Emacs на консоли ПК, устройстве /dev/tty1.</p>     <p>Обычно ОС Linux запускается с процессом <blockquote>getty</blockquote>, выполняющимся на первых шести виртуальных консолях, поэтому есть возможность зарегистрироваться шесть раз, используя одни и те же экран, клавиатуру и мышь. Увидеть эти процессы можно с помощью и команды <blockquote>ps</blockquote>:</p>     <p><blockquote>$ <b>ps -а</b></blockquote></p>     <p><blockquote> PID TTY      TIME CMD</blockquote></p>     <p><blockquote>1092 tty1 00:00:00 login</blockquote></p>     <p><blockquote>1093 tty2 00:00:00 mingetty</blockquote></p>     <p><blockquote>1094 tty3 00:00:00 mingetty</blockquote></p>     <p><blockquote>1095 tty4 00:00:00 mingetty</blockquote></p>     <p><blockquote>1096 tty5 00:00:00 mingetty</blockquote></p>     <p><blockquote>1097 tty6 00:00:00 mingetty</blockquote></p>     <p>В этом выводе представлен стандартный вариант программы getty для обслуживания консоли в системе SUSE, mingetty, выполняющийся на пяти следующих виртуальных консолях и ожидающий регистрации пользователя.</p>     <p>Переключаться между виртуальными консолями можно с помощью комбинации клавиш &lt;Ctrl&gt;+&lt;Alt&gt;+&lt;F<i>N</i>&gt;, где <i>N</i> — номер виртуальной консоли, на которую вы хотите переключиться. Таким образом, для того чтобы перейти на вторую виртуальную консоль, нажмите &lt;Ctrl&gt;+&lt;Alt&gt;+&lt;F2&gt;, и &lt;Ctrl&gt;+&lt;Alt&gt;+&lt;F1&gt;, чтобы вернуться на первую консоль. (При переключении из регистрации в текстовом режиме, а не графическом, также работает комбинация клавиш &lt;Ctrl&gt;+&lt;F<i>N</i>&gt;.)</p>     <p>Если в Linux запущена регистрация в графическом режиме, либо с помощью программы startx илн менеджера экранов xdm, на первой свободной консоли, обычно /dev/tty7, стартует графическая оболочка X Window System. Переключиться с нее на текстовую, консоль вы сможете с помощью комбинации клавиш &lt;Ctrl&gt;+&lt;Alt&gt;+&lt;F<i>N</i>&gt;, а вернуться с помощью &lt;Ctrl&gt;+&lt;Alt&gt;+&lt;F7&gt;.</p>     <p>В ОС Linux можно запустить более одного сеанса X. Если вы сделаете это, скажем, с помощью следующей команды</p>     <p><blockquote>$ <b>startx -- :1</b></blockquote></p>     <p>Linux запустит сервер X на следующей свободной виртуальной консоли, в данном случае на /dev/tty8, и переключаться между ними вы сможете с помощью комбинаций клавиш &lt;Ctrl&gt;+&lt;Alt&gt;+&lt;F8&gt; и &lt;Ctrl&gt;+&lt;Alt&gt;+&lt;F7&gt;.</p>     <p>Во всех остальных отношениях виртуальные консоли ведут себя как обычные терминалы, описанные в этой главе. Если процесс обладает достаточными правами, виртуальные консоли можно открывать, считывать с них данные, писать на них информацию точно так же, как в случае обычного терминала.</p>             <a name="metkadoc23"><h1>Псевдотерминалы</h1></a>     <p>У многих UNIX-подобных систем, включая Linux, есть средство, именуемое<i> псевдотерминалом</i>. Это устройства, очень похожие на терминалы, которые мы использовали в данной главе, за исключением того, что у них нет связанного с ними оборудования. Они могут применяться для предоставления терминалоподобного интерфейса другим программам.</p>     <p>Например, с помощью псевдотерминалов возможно создание двух программ, играющих друг с другом в шахматы, не взирая на тот факт, что сами по себе программы проектировались для взаимодействия посредством терминала с человеком-игроком. Приложение, действующее как посредник, передает ходы одной программы другой и обратно. Оно применяет псевдотерминалы, чтобы обмануть программы и заставить их вести себя нормально при отсутствии терминала.</p>     <p>Одно время реализация псевдотерминалов (если вообще существовала) сильно зависела от конкретной системы. Сейчас они включены в стандарт Single UNIX Specification (единый стандарт UNIX) как UNIX98 Pseudo-Terminals (псевдотерминалы стандарта UNIX98) или PTY.</p>              <a name="metkadoc24"><h1>Резюме </h1></a>    <p>В этой главе вы узнали о трех аспектах управления терминалом. В начале главы рассказывалось об обнаружении перенаправления и способах прямого диалога с терминалом в случае перенаправления дескрипторов стандартных файлов. Вы посмотрели на аппаратную модель терминала и немного познакомились с его историей. Затем вы узнали об общем терминальном интерфейсе и структуре termios, предоставляющей в ОС Linux возможность тонкого управления и манипулирования терминалом. Вы также увидели, как применять базу данных terminfo и связанные с ней функции для управления в аппаратно-независимом стиле выводом на экран, и познакомились с приемами мгновенного обнаружения нажатий клавиш. В заключение вы узнали о виртуальных консолях и псевдотерминалах. </p>     <br><br>
<center><div align="center"><a href="index.php.html">Оглавление</a></div></center>




<br>
<script type="text/javascript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="https://www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script><br>

<noindex>
<div align="center">
<center>

<!-- SAPE RTB DIV 600x340 -->
<div id="SRTB_507029"></div>
<!-- SAPE RTB END -->

</center>
</div>
</noindex>

</td>
<td width="240" valign="top">

<br>

<div id="menu3">
<ul>
<li><a href="../../alternativnaja_medicina/index.html"><span>Альтернативная медицина</span></a></li>
<li><a href="../../astronomija_i_kosmos/index.html"><span>Астрономия и Космос</span></a></li>
<li><a href="../../biologija/index.html"><span>Биология</span></a></li>
<li><a href="../../voennaja_istorija/index.html"><span>Военная история</span></a></li>
<li><a href="../../geologija_i_geografija/index.html"><span>Геология и география</span></a></li>
<li><a href="../../gosudarstvo_i_pravo/index.html"><span>Государство и право</span></a></li>
<li><a href="../../delovaja_literatura/index.html"><span>Деловая литература</span></a></li>
<li><a href="../../domashnie_zhivotnye/index.html"><span>Домашние животные</span></a></li>
<li><a href="../../domovodstvo/index.html"><span>Домоводство</span></a></li>
<li><a href="../../zdorove/index.html"><span>Здоровье</span></a></li>
<li><a href="../../istorija/index.html"><span>История</span></a></li>
<li><a href="../index.html"><span>Компьютеры и Интернет</span></a></li>
<li><a href="../../kulinarija/index.html"><span>Кулинария</span></a></li>
<li><a href="../../kulturologija/index.html"><span>Культурология</span></a></li>
<li><a href="../../literaturovedenie/index.html"><span>Литературоведение</span></a></li>
<li><a href="../../matematika/index.html"><span>Математика</span></a></li>
<li><a href="../../medicina/index.html"><span>Медицина</span></a></li>
<li><a href="../../nauchnaja_literatura_prochee/index.html"><span>Науч. литер. - прочее</span></a></li>
<li><a href="../../pedagogika/index.html"><span>Педагогика</span></a></li>
<li><a href="../../politika/index.html"><span>Политика</span></a></li>
<li><a href="../../psihologija/index.html"><span>Психология</span></a></li>
<li><a href="../../religiovedenie/index.html"><span>Религиоведение</span></a></li>
<li><a href="../../sad_i_ogorod/index.html"><span>Сад и огород</span></a></li>
<li><a href="../../samosovershenstvovanie/index.html"><span>Самосовершенствование</span></a></li>
<li><a href="../../sdelai_sam/index.html"><span>Сделай сам</span></a></li>
<li><a href="../../sport/index.html"><span>Спорт</span></a></li>
<li><a href="../../tehnicheskie_nauki/index.html"><span>Технические науки</span></a></li>
<li><a href="../../transport_i_aviacija/index.html"><span>Транспорт и авиация</span></a></li>
<li><a href="../../uchebniki/index.html"><span>Учебники</span></a></li>
<li><a href="../../fizika/index.html"><span>Физика</span></a></li>
<li><a href="../../filosofija/index.html"><span>Философия</span></a></li>
<li><a href="../../himija/index.html"><span>Химия</span></a></li>
<li><a href="../../hobbi_i_remesla/index.html"><span>Хобби и ремесла</span></a></li>
<li><a href="../../shpargalki/index.html"><span>Шпаргалки</span></a></li>
<li><a href="../../yezoterika/index.html"><span>Эзотерика</span></a></li>
<li><a href="../../yurisprudencija/index.html"><span>Юриспруденция</span></a></li>
<li><a href="../../jazykoznanie/index.html"><span>Языкознание</span></a></li>
</ul>
</div>

<br>
<div align="center">
<center>
<noindex>

<!-- SAPE RTB DIV 240x400 -->
<div id="SRTB_507028"></div>
<!-- SAPE RTB END -->

</noindex>
</center>
</div>

</td>
</tr>
<tr>
<td colspan="3" align="center">


<hr>
<a href="../../index.html"><span>Главная</span></a> | 
<a rel="sidebar" href="p9.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a> | 
<a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a> | 
<a href="p9.php.html#" onClick="scroll(0,0); return false" title="наверх">Наверх</a>
</td>
</tr>
<tr>
<td colspan="3" valign="top" align="left">
<br>

 



</td>
</tr>
</table>

<noindex>
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter21717787 = new Ya.Metrika({id:21717787,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="http://mc.yandex.ru/watch/21717787" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

</noindex>
</center>
</div></body>
</html>