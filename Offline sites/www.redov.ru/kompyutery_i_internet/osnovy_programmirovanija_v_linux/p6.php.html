<html>
<head>
<meta http-equiv="Content-Language" content="ru">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<link href="../../0img/style.css" rel="stylesheet" type="text/css" />
<link rel="SHORTCUT ICON" href="http://www.redov.ru/0img/favicon.ico" type="image/x-icon"> 
<title>Глава 2 Программирование средствами командной оболочки / Основы программирования в Linux</title>
</head>
<body>
<div align="center">
<center>
<table border="0" cellpadding="0" cellspacing="0" width="1260">
<tr>
<td colspan="3" valign="top" align="left" height="100">
<table border="0" cellpadding="0" cellspacing="0" width="1260" height="100">
<tr>
<td valign="middle" align="center" width="350">
<a href="../../index.html"><img src="../../0img/logo.jpg" width="350" height="100" title="Онлайн библиотека redov.ru"/></a>
</td>
<td valign="middle" align="center" width="910">

<noindex>

<!-- SAPE RTB JS -->
<script
    async="async"
    src="http://cdn-rtb.sape.ru/rtb-b/js/393/2/106393.js"
    type="text/javascript">
</script>
<!-- SAPE RTB END -->

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507025"></div>
<!-- SAPE RTB END -->

</noindex>

</td>
</tr>
</table>
</td>
</tr>
<tr>
<td colspan="3" valign="middle" align="left">

<div id="menu">
<ul>
		<li><a href="../../index.html"><span>Главная</span></a></li>
		<li><a rel="sidebar" href="p6.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a></li>
		<li><a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a></li>
		<li><a href="p6.php.html#" onClick="scroll(0,9999999); return false"><span>Вниз</span></a></li>
</ul>
</div>


</td>
</tr>
<tr>
<td width="240" valign="top" align="center">

<br>
<noindex>
<!-- SAPE RTB DIV 160x600 -->
<div id="SRTB_733378"></div>
<!-- SAPE RTB END -->
</noindex>



</td>
<td valign="top" align="left" style="padding-left: 5; padding-right: 5" width="780">
<br>
<noindex>
<div align="center">

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507027"></div>
<!-- SAPE RTB END -->

</div>
</noindex>
<br>



<li><a href="p6.php.html#metkadoc2">     Почему программа в командной оболочке?     </a></li>
<li><a href="p6.php.html#metkadoc3">     Немного теории     </a></li>
<li><a href="p6.php.html#metkadoc4">     Что такое командная оболочка?     </a></li>
<li><a href="p6.php.html#metkadoc5">     Каналы и перенаправление     </a></li>
<li><a href="p6.php.html#metkadoc6">      Перенаправление вывода      </a></li>
<li><a href="p6.php.html#metkadoc7">      Перенаправление ввода      </a></li>
<li><a href="p6.php.html#metkadoc8">      Каналы       </a></li>
<li><a href="p6.php.html#metkadoc9">     Командная оболочка как язык программирования     </a></li>
<li><a href="p6.php.html#metkadoc10">      Интерактивные программы      </a></li>
<li><a href="p6.php.html#metkadoc11">      Создание сценария      </a></li>
<li><a href="p6.php.html#metkadoc12">      Превращение сценария в исполняемый файл      </a></li>
<li><a href="p6.php.html#metkadoc13">     Синтаксис командной оболочки     </a></li>
<li><a href="p6.php.html#metkadoc14">      Переменные      </a></li>
<li><a href="p6.php.html#metkadoc15">      Условия      </a></li>
<li><a href="p6.php.html#metkadoc16">      Управляющие структуры      </a></li>
<li><a href="p6.php.html#metkadoc17">      Функции      </a></li>
<li><a href="p6.php.html#metkadoc18">      Команды      </a></li>
<li><a href="p6.php.html#metkadoc19">      Выполнение команд      </a></li>
<li><a href="p6.php.html#metkadoc20">      Встроенные документы      </a></li>
<li><a href="p6.php.html#metkadoc21">      Отладка сценариев      </a></li>
<li><a href="p6.php.html#metkadoc22">     По направлению к графическому режиму — утилита<i> dialog</i>     </a></li>
<li><a href="p6.php.html#metkadoc23">     Соединяем все вместе     </a></li>
<li><a href="p6.php.html#metkadoc24">      Требования      </a></li>
<li><a href="p6.php.html#metkadoc25">      Проектирование      </a></li>
<li><a href="p6.php.html#metkadoc26">     Резюме      </a></li>
<a name="metkadoc1"><h1>Глава 2</p>    <p>Программирование средствами командной оболочки</h1></a>       <p>Начав книгу с программирования в ОС Linux на языке С, теперь мы сделаем отступление и остановимся на написании программ в командной оболочке. Почему? ОС Linux не относится к системам, у которых интерфейс командной строки — запоздалое детище графического интерфейса. У систем UNIX, прообраза Linux, первоначально вообще не было графического интерфейса; все выполнялось из командной строки. Поэтому оболочка командной строки UNIX все время развивалась и превратилась в очень мощный инструмент. Эти свойства перекочевали и в Linux, и некоторые самые серьезные задачи вы можете выполнить наиболее легким способом именно из командной оболочки. Поскольку она так важна для ОС Linux и столь полезна для автоматизации простых задач, программирование средствами командной оболочки рассматривается прежде всего.</p>    <p>В этой главе мы познакомим вас с синтаксисом, структурами и командами, доступными при программировании в командной оболочке, как правило, используя интерактивные (основанные на экранах) примеры. Они помогут продемонстрировать функциональные возможности командной оболочки и собственные действия. Мы также бросим беглый взгляд на пару особенно полезных утилит режима командной строки, часто вызываемых из командной оболочки: grep и find. Рассматривая утилиту grep, мы познакомимся с основными положениями, касающимися регулярных выражений, которые появляются в утилитах ОС Linux и языках программирования, таких как Perl, Ruby и PHP. В конце главы вы узнаете, как писать настоящие сценарии, которые будут перепрограммироваться и расширяться на языке С на протяжении всей книги. В этой главе рассматриваются следующие темы:</p>    <p>&#9633; что такое командная оболочка;</p>    <p>&#9633; теоретические основы;</p>    <p>&#9633; тонкости синтаксиса: переменные, условия и управление программой;</p>    <p>&#9633; списки;</p>    <p>&#9633; функции;</p>    <p>&#9633; команды и их выполнение;</p>    <p>&#9633; встроенные (here) документы;</p>    <p>&#9633; отладка;</p>    <p>&#9633; утилита grep и регулярные выражения;</p>    <p>&#9633; утилита find.</p>    <p>Если вы столкнулись со сложным сценарием командной оболочки при администрировании системы, хотите смоделировать вашу последнюю грандиозную (но удивительно простую) идею или просто повысить производительность какой-либо итеративной задачи, эта глава вам будет полезна.</p>          <a name="metkadoc2"><h1>Почему программа в командной оболочке?</h1></a>    <p>Одна из причин применения командной оболочки — возможность быстрого и простого программирования. Более того, командная оболочка всегда есть даже в самых упрощенных установках ОС Linux, поэтому благодаря простому моделированию вы сможете понять, работает ли ваша идея. Командная оболочка очень удобна и для небольших утилит, выполняющих относительно простую задачу, для которой производительность менее важна, чем простые настройка, сопровождение и переносимость. Вы можете применять оболочку для управления процессами, обеспечивая выполнение команд в заданном порядке, зависящем от успешного завершения каждого этапа выполнения.</p>    <p>Хотя внешне командная оболочка очень похожа на режим командной строки в ОС Windows, она гораздо мощнее и способна выполнять самостоятельно очень сложные программы. Вы можете не только выполнять команды и вызывать утилиты ОС Linux; но и разрабатывать их. Командная оболочка выполняет программы оболочки, часто называемые<i> сценариями</i> или<i> скриптами,</i> которые интерпретируются во время выполнения. Такой подход облегчает отладку, потому что вы легко можете выполнять программу построчно и не тратить время на перекомпиляцию. Но для задач, которым важно время выполнения или необходимо интенсивное использование процессора, командная оболочка оказывается неподходящей средой.</p>          <a name="metkadoc3"><h1>Немного теории</h1></a>    <p>Вот мы и добрались до теоретических основ UNIX и, конечно, Linux. ОС UNIX основана на интенсивном многократном применении кода и зависит от него. Вы разработали маленькую простую утилиту, и пользователи применяют ее как одну из ссылок в строке, формирующей команду. Одно из наслаждений, доставляемых ОС Linux, — разнообразие имеющихся отличных средств. Примером может служить следующая команда:</p>    <p><blockquote>$ <b>ls -al | more</b></blockquote></p>    <p>Эта команда применяет утилиты <blockquote>ls</blockquote> и <blockquote>more</blockquote> и передает вывод списка файлов для поэкранного отображения. Каждая утилита — это отдельный блок. Зачастую вы можете применять множество мелких утилит для создания больших и сложных комплексов программ.</p>    <p>Например, если вы хотите напечатать контрольную копию справочного руководства оболочки bash, примените следующую команду:</p>    <p><blockquote>$ <b>man bash | col -b | lpr</b></blockquote></p>    <p>Более того, благодаря автоматической обработке типов файлов пользователям этих утилит обычно не нужно знать, на каком языке данные программы написаны. Если необходимо ускорить выполнение утилиты, как правило, ее сначала моделируют в командной оболочке и затем, когда работоспособность утилиты проверена, реализуют ее на языке С или С++, Perl, Python или каком-либо другом, обеспечивающем более быстрое выполнение. В противном случае, если в командной оболочке утилита действует адекватно, вы вполне можете оставить ее в покое.</p>    <p>Необходимость переделки сценария зависит от того, нуждается ли он в оптимизации, должен ли он быть переносимым, необходимо ли обеспечить легкую модификацию и не перерос ли он (как это обычно случается) первоначально поставленную задачу.</p>    <blockquote>     <b>Примечание</b>     <p>Для удовлетворения вашего любопытства в вашу ОС Linux уже загружены многочисленные примеры сценариев, включая инсталляторы пакетов, <blockquote>.xinitrc</blockquote> и <blockquote>startx</blockquote>, и сценарии в каталоге /etc/rc.d, предназначенные для настройки системы в процессе загрузки.</p>    </blockquote>          <a name="metkadoc4"><h1>Что такое командная оболочка?</h1></a>    <p>Прежде чем переходить к обсуждению того, как программа использует оболочку, давайте рассмотрим, как функционирует оболочка и какие оболочки есть в Linux-подобных системах.<i> Командная оболочка</i> — это программа, которая действует как интерфейс между вами и ОС Linux, позволяя вам вводить команды, которые должна выполнить операционная система. В этом смысле она похожа на командную строку в ОС Windows, но, как уже упоминалось, командные оболочки Linux гораздо мощнее. Например, ввод и вывод можно перенаправить с помощью символов <blockquote>&lt;</blockquote> и <blockquote>&gt;</blockquote>, передавать данные между двумя одновременно выполняющимися программами с помощью символа <blockquote>|</blockquote>, а перехватывать вывод подпроцесса с помощью конструкции <blockquote>$(...)</blockquote>. В ОС Linux вполне может сосуществовать несколько установленных командных оболочек, и разные пользователи могут выбрать ту, которая им больше нравится. На рис. 2.1 показано, как командная оболочка (на самом деле, две командные оболочки: bash и csh) и другие программы располагаются вокруг ядра Linux.</p>    <img src="image002.jpg"/>    <p><b>Рис. 2.1</b></p>    <p>Поскольку ОС Linux — модульная система, вы можете вставить и применять одну из множества различных стандартных командных оболочек, хотя большинство из них — потомки первоначальной оболочки Bourne. В Linux стандартная командная оболочка, всегда устанавливаемая как /bin/sh и входящая в комплект средств проекта GNU, называется bash (GNU Bourne-Again SHell). Именно ее мы будем применять, т. к. это отличная командная оболочка, всегда устанавливаемая в системах Linux, со свободно распространяемым программным кодом и переносимая почти на все варианты UNIX-систем. В данной главе используется оболочка bash версии 3, и в большинстве случаев применяются ее функциональные возможности, общие для всех командных оболочек, удовлетворяющих требованиям стандарта POSIX. Мы полагаем, что командная оболочка, установленная как /bin/sh и для вашей учетной записи, считается командной оболочкой по умолчанию. В большинстве дистрибутивов Linux программа /bin/sh, командная оболочка по умолчанию, — это ссылка на программу /bin/bash.</p>    <p>Вы можете определить используемую в вашей системе версию bash с помощью следующей команды:</p>    <p><blockquote>$ <b>/bin/bash --version</b></blockquote></p>    <p><blockquote>GNU bash, version 3.2.9(1)-release (i686-pc-linux-gnu)</blockquote></p>    <p><blockquote>Copyright (C) 2005 Free Software Foundation, Inc.</blockquote></p>    <blockquote>     <b>Примечание</b>     <p>Для перехода на другую командную оболочку, если в вашей системе по умолчанию установлена не bash, просто выполните программу нужной вам командной оболочки (т.е. /bin/bash) для запуска новой оболочки и смены приглашения в командной строке. Если вы используете ОС UNIX, и командная оболочка bash не установлена, вы можете бесплатно загрузить ее с Web-сайта <b>www.gnu.org.</b> Исходный код обладает высокой степенью переносимости, и велика вероятность, что он откомпилируется в вашей версии UNIX прямо в готовую к использованию программу.</p>    </blockquote>    <p>Когда создаются учетные записи пользователей ОС Linux, вы можете задать командную оболочку, которой они будут пользоваться, в момент создания учетной записи пользователя или позже, откорректировав ее параметры. На рис. 2.2 показан выбор командной оболочки для пользователя дистрибутива Fedora.</p>    <img src="image003.jpg"/>    <p><b>Рис. 2.2</b></p>    <br>    <p>Существует много других командных оболочек, распространяемых свободно или на коммерческой основе. В табл. 2.1 предлагается краткая сводка некоторых самых распространенных командных оболочек.</p>    <br>    <p><b><i>Таблица 2.1</i></b></p>    <table>     <tr>      <th valign="top">Название командной оболочки</th>      <th valign="top">Краткие исторические сведения</th>     </tr>     <tr>      <td valign="top">sh (Bourne)</td>      <td valign="top">Первоначальная оболочка в ранних версиях ОС UNIX</td>     </tr>     <tr>      <td valign="top">csh, tcsh, zsh</td>      <td valign="top">Командная оболочка C-shell (и ее производные), первоначально созданная Биллом Джойем (Bill Joy) для систем Berkeley UNIX. C-shell, возможно, третья по популярности командная оболочка после оболочек bash и Korn</td>     </tr>     <tr>      <td valign="top">ksh, pdksh</td>      <td valign="top">Командная оболочка Korn и ее безлицензионный родственник. Написанная Дэвидом Корном (David Korn) эта оболочка применяется по умолчанию во многих коммерческих версиях UNIX</td>     </tr>     <tr>      <td valign="top">bash</td>      <td valign="top">Основная командная оболочка ОС Linux из проекта GNU или Bourne Again SHell со свободно распространяемым программным кодом. Если в настоящий момент она не выполняется в вашей системе UNIX, вероятно, есть вариант оболочки, перенесенный на вашу систему. У bash много сходств с оболочкой Korn</td>     </tr>    </table>    <p>За исключением оболочки C-shell и небольшого числа ее производных все перечисленные оболочки очень похожи и очень близки к оболочке, определенной в спецификациях Х/Оpen 4.2 и POSIX 1003.2. В спецификации POSIX 1003.2 задан минимум, необходимый для создания командной оболочки, а в спецификации Х/Open представлена более дружественная и мощная оболочка.</p>          <a name="metkadoc5"><h1>Каналы и перенаправление</h1></a>         <p>Прежде чем заняться подробностями программ командной оболочки, необходимо сказать несколько слов о возможностях перенаправления ввода и вывода программ (не только программ командной оболочки) в ОС Linux.</p>             <a name="metkadoc6"><h1>Перенаправление вывода</h1></a>     <p>Возможно, вы уже знакомы с некоторыми видами перенаправления, например, таким как:</p>     <p><blockquote>$<b> ls -l &gt; lsoutput.txt</b></blockquote></p>     <p>сохраняющим вывод команды ls в файле с именем lsoutput.txt.</p>     <p>Однако перенаправление позволяет сделать гораздо больше, чем демонстрирует этот простой пример. В<i> главе 3</i> вы узнаете больше о дескрипторах стандартных файлов, а сейчас вам нужно знать только то, что дескриптор файла 0 соответствует стандартному вводу программы, дескриптор файла 1 — стандартному выводу, а дескриптор файла 2 — стандартному потоку ошибок. Каждый из этих файлов можно перенаправлять независимо друг от друга. На самом деле можно перенаправлять и другие дескрипторы файлов, но, как правило, нет нужды перенаправлять любые другие дескрипторы, кроме стандартных: 0, 1 и 2.</p>     <p>В предыдущем примере стандартный вывод перенаправлен в файл с помощью оператора <blockquote>&gt;</blockquote>. По умолчанию, если файл с заданным именем уже есть, он будет перезаписан. Если вы хотите изменить поведение по умолчанию, можно применить команду <blockquote>set -о noclobber</blockquote> (или <blockquote>set -С</blockquote>), которая устанавливает опцию <blockquote>noclobber</blockquote>, чтобы помешать перезаписи при перенаправлении. Отменить эту опцию можно с помощью команды <blockquote>set +о noclobber</blockquote>. Позже в этой главе будут приведены другие опции команды <blockquote>set</blockquote>.</p>     <p>Для дозаписи в конец файла используйте оператор <blockquote>&gt;&gt;</blockquote>. Например, команда</p>     <p><blockquote>$ <b>ps &gt;&gt; lsoutput.txt</b></blockquote></p>     <p>добавит вывод команды <blockquote>ps</blockquote> в конец заданного файла.</p>     <p>Для перенаправления стандартного потока ошибок перед оператором <blockquote>&gt;</blockquote> вставьте номер дескриптора файла, который хотите перенаправить. Поскольку у стандартного потока ошибок дескриптор файла 2, укажите оператор <blockquote>2&gt;</blockquote>. Часто бывает полезно скрывать стандартный поток ошибок, запрещая вывод его на экран.</p>     <p>Предположим, что вы хотите применить команду <blockquote>kill</blockquote> для завершения процесса из сценария. Всегда существует небольшой риск, что процесс закончится до того, как выполнится команда <blockquote>kill</blockquote>. Если это произойдет, команда kill выведет сообщение об ошибке в стандартный поток ошибок, который по умолчанию появится на экране. Перенаправив стандартный вывод команды и ошибку, вы сможете помешать команде <blockquote>kill</blockquote> выводить какой бы то ни было текст на экран.</p>     <p>Команда</p>     <p><blockquote>$ <b>kill -HUP 1234 &gt;killout. txt 2&gt;killer.txt</b></blockquote></p>     <p>поместит вывод и информацию об ошибке в разные файлы.</p>     <p>Если вы предпочитаете собрать оба набора выводимых данных в одном файле, можно применить оператор <blockquote>&gt;&amp;</blockquote> для соединения двух выводных потоков. Таким образом, команда</p>     <p><blockquote>$ <b>kill -1 1234 &gt;killerr.txt 2&gt;&amp;1</b></blockquote></p>     <p>поместит свой вывод и стандартный поток ошибок в один и тот же файл. Обратите внимание на порядок следования операторов. Приведенный пример читается как "перенаправить стандартный вывод в файл killerr.txt, а затем перенаправить стандартный поток ошибок туда же, куда и стандартный вывод". Если вы нарушите порядок, перенаправление выполнится не так, как вы ожидаете.</p>     <p>Поскольку обнаружить результат выполнения команды <blockquote>kill</blockquote> можно с помощью кода завершения (который будет подробно обсуждаться далее в этой главе), часто вам не потребуется сохранять какой бы то ни было стандартный вывод или стандартный поток ошибок. Для того чтобы полностью отбросить любой вывод, вы можете использовать универсальную "мусорную корзину" Linux, /dev/null, следующим образом:</p>     <p><blockquote>$ <b>kill -l 1234 &gt;/dev/null 2&gt;&amp;1</b></blockquote></p>             <a name="metkadoc7"><h1>Перенаправление ввода</h1></a>     <p>Также как вывод вы можете перенаправить ввод. Например,</p>     <p><blockquote>$ <b>more &lt; killout.txt</b></blockquote></p>     <p>Понятно, что это тривиальнейший пример для ОС Linux; команда <blockquote>more</blockquote> в системе Linux в отличие от своего эквивалента командной строки в ОС Windows с радостью принимает имена файлов в качестве параметров.</p>             <a name="metkadoc8"><h1>Каналы </h1></a>     <p>Вы можете соединять процессы с помощью оператора канала (<blockquote>|</blockquote>). В ОС Linux, в отличие от MS-DOS, процессы, соединенные каналами, могут выполняться одновременно и автоматически переупорядочиваться в соответствии с потоками данных между ними. Как пример, можно применить команду <blockquote>sort</blockquote> для сортировки вывода команды <blockquote>ps</blockquote>.</p>     <p>Если не применять каналы, придется использовать несколько шагов, подобных следующим:</p>     <p><blockquote>$ <b>ps &gt; psout.txt</b></blockquote></p>     <p><blockquote>$ <b>sort psout.txt &gt; pssort.out</b></blockquote></p>     <p>Соединение процессов каналом даст более элегантное решение:</p>     <p><blockquote>$ <b>ps | sort &gt; pssort.out</b></blockquote></p>     <p>Поскольку вы, вероятно, захотите увидеть на экране вывод, разделенный на страницы, можно подсоединить третий процесс, <blockquote>more</blockquote>, и все это в одной командной строке:</p>     <p><blockquote>$ <b>ps | sort | more</b></blockquote></p>     <p>Практически нет ограничений на допустимое количество процессов. Предположим, что вы хотите видеть все имена выполняющихся процессов, за исключением командных оболочек. Можно применить следующую командную строку:</p>     <p><blockquote>$ <b>ps -хо соmm | sort | uniq | grep -v sh | more</b></blockquote></p>     <p>В ней берется вывод команды <blockquote>ps</blockquote>, сортируется в алфавитном порядке, из него извлекаются процессы с помощью команды <blockquote>uniq</blockquote>, применяется утилита <blockquote>grep -v sh</blockquote> для удаления процесса с именем <blockquote>sh</blockquote> и в завершение полученный список постранично выводится на экран.</p>     <p>Как видите, это гораздо более элегантное решение, чем строка из отдельных команд, каждая со своими временными файлами. Но в этом случае имейте в виду следующее. Если строка состоит из команд, файл вывода создается или записывается сразу, как только сформирован набор команд, поэтому в строке из нескольких команд никогда не используйте дважды одно и то же имя файла. Если вы попытаетесь сделать что-то подобное:</p>     <p><blockquote><b>cat mydata.txt | sort | uniq &gt; mydata.txt</b></blockquote></p>     <p>то в результате получите пустой файл, т.к. вы перезапишете файл mydata.txt, прежде чем прочтете его.</p>              <a name="metkadoc9"><h1>Командная оболочка как язык программирования</h1></a>         <p>Теперь, когда вы увидели некоторые базовые операции командной оболочки, самое время перейти к реальным программам оболочки. Есть два способа написания таких программ. Вы можете ввести последовательность команд и разрешить командной оболочке выполнить их в интерактивном режиме или сохранить эти команды в файле и затем запускать его как программу.</p>             <a name="metkadoc10"><h1>Интерактивные программы</h1></a>     <p>Легкий и очень полезный во время обучения или тестирования способ проверить работу небольших фрагментов кода — просто набрать с клавиатуры в командной строке сценарий командной оболочки.</p>     <p>Предположим, что у вас большое количество файлов на языке С, и вы хотите проверить наличие в них строки <blockquote>POSIX</blockquote>. Вместо того чтобы искать в файлах строку с помощью команды <blockquote>grep</blockquote> и затем выводить на экран отдельно каждый файл, вы можете выполнить всю операцию в интерактивном сценарии, похожем на следующий:</p>     <p><blockquote>$ <b>for file in *</b></blockquote></p>     <p><blockquote>&gt; <b>do</b></blockquote></p>     <p><blockquote>&gt; <b>if grep -l POSIX $file</b></blockquote></p>     <p><blockquote>&gt; <b>then</b></blockquote></p>     <p><blockquote>&gt; <b>more $file</b></blockquote></p>     <p><blockquote>&gt; <b>fi</b></blockquote></p>     <p><blockquote>&gt; <b>done</b></blockquote></p>     <p><blockquote>posix</blockquote></p>     <p><blockquote>This is a file with POSIX in it - treat it well</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Обратите внимание на то, как меняется знак <blockquote>$</blockquote>, стандартная подсказка или приглашение командной оболочки, на символ <blockquote>&gt;</blockquote>, когда оболочка ожидает очередной ввод. Вы можете продолжить набор, дав оболочке понять, когда закончите, и сценарий немедленно выполнится.</p>     <p>В этом примере команда <blockquote>grep</blockquote> выводит на экран найденные ею имена файлов, содержащих строку <blockquote>POSIX</blockquote>, а затем команда <blockquote>more</blockquote> отображает на экране содержимое файла. В конце на экран возвращается приглашение командной оболочки. Обратите внимание также на то, что вы ввели переменную командной оболочки, которая обрабатывает каждый файл для самодокументирования сценария. С таким же успехом вы могли бы использовать переменную <blockquote>i</blockquote>, но имя <blockquote>file</blockquote> более информативно с точки зрения пользователей.</p>     <p>Командная оболочка также обрабатывает групповые символы или метасимволы (часто называемые<i> знаками подстановки</i>). Вы почти наверняка знаете о применении символа <blockquote>*</blockquote> как знака подстановки, соответствующего строке символов. Но вы можете не знать о существовании односимвольного знака подстановки, <blockquote>?</blockquote>, а конструкция <blockquote>[set]</blockquote> позволяет проверить любое количество одиночных символов, <blockquote>[^set]</blockquote> — применяет логическую операцию "НЕ" к множеству, т.е. включает все, кроме того, что вы задали. Подстановочный шаблон из фигурных скобок <blockquote>{}</blockquote> (доступен в некоторых командных оболочках, включая bash) позволяет формировать множество из произвольных строк, которое командная оболочка раскроет. Например, команда</p>     <p><blockquote>$ <b>ls my_{finger, toe}s</b></blockquote></p>     <p>будет выводить файлы my_fingers и my_toes. Эта команда использует оболочку для проверки всех файлов в текущем каталоге. Мы вернемся к этим правилам соответствия шаблонам в конце главы, когда будем более подробно рассматривать утилиту <blockquote>grep</blockquote> и возможности регулярных выражений.</p>     <p>Опытные пользователи ОС Linux, вероятно, выполнят эту операцию более эффективным способом, возможно, с помощью следующей команды:</p>     <p><blockquote>$ <b>more `grep -l POSIX *`</b></blockquote></p>     <p>или синонимической конструкции</p>     <p><blockquote>$<b> more $(grep -l POSIX *)</b></blockquote></p>     <p>В дополнение команда</p>     <p><blockquote>$ <b>grep -l POSIX * | more</b></blockquote></p>     <p>выведет на экран имя файла, содержащего строку <blockquote>POSIX</blockquote>. В этом сценарии мы видим, что командная оболочка для выполнения трудной работы привлекает другие команды, например, <blockquote>grep</blockquote> и <blockquote>more</blockquote>. Оболочка просто позволяет собрать вместе несколько имеющихся команд новыми оригинальными способами. В следующих сценариях вы увидите использование знаков подстановки неоднократно. Мы подробно рассмотрим целую область подстановок, когда будем знакомиться с регулярными выражениями в разделе, посвященном команде <blockquote>grep</blockquote>.</p>     <p>Заниматься этой канителью каждый раз, когда хочешь выполнить последовательность команд, утомительно. Нужно сохранить команды в файле, который принято называть<i> сценарием</i> или<i> скриптом</i> командной оболочки, а затем вы можете выполнять эти файлы, когда захотите.</p>             <a name="metkadoc11"><h1>Создание сценария</h1></a>     <p>С помощью любого текстового редактора необходимо создать файл, содержащий команды. Создайте файл с именем first с таким содержимым:</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote># first</blockquote></p>     <p><blockquote># Этот файл просматривает все файлы в текущем каталоге</blockquote></p>     <p><blockquote># для поиска строки POSIX, а затем выводит имена</blockquote></p>     <p><blockquote># найденных файлов в стандартный вывод.</blockquote></p>     <br>     <p><blockquote>for file in *</blockquote></p>     <p><blockquote>do</blockquote></p>     <p><blockquote> if grep -q POSIX $file</blockquote></p>     <p><blockquote> then</blockquote></p>     <p><blockquote>  echo $file</blockquote></p>     <p><blockquote> fi</blockquote></p>     <p><blockquote>done</blockquote></p>     <br>     <p><blockquote>exit 0</blockquote></p>     <p>Комментарий начинается со знака <blockquote>#</blockquote> и продолжается до конца строки. Принято знак <blockquote>#</blockquote> ставить в первой символьной позиции строки. Сделав такое общее заявление, далее отметим, что первая строка <blockquote>#!/bin/sh</blockquote> — это особая форма комментария; символы <blockquote>#!</blockquote> сообщают системе о том, что следующий за ними аргумент — программа, применяемая для выполнения данного файла. В данном случае программа <blockquote>/bin/sh</blockquote> — командная оболочка, применяемая по умолчанию. </p>     <blockquote>      <b>Примечание</b>      <p>Обратите внимание на абсолютный путь, заданный в комментарии. Принято сохранять его длиной не более 32 символов для обратной совместимости, поскольку некоторые старые версии ОС UNIX могут использовать только такое ограниченное количество символов в комментарии <blockquote>#!</blockquote>, хотя у ОС Linux обычно нет подобного ограничения.</p>     </blockquote>     <p>Поскольку сценарий по существу обрабатывается как стандартный ввод командной оболочки, он может содержать любые команды ОС Linux, на которые ссылается переменная окружения <blockquote>PATH</blockquote>.</p>     <p>Команда <blockquote>exit</blockquote> гарантирует, что сценарий вернет осмысленный код завершения (подробнее об этом чуть позже в данной главе). Он редко проверяется при интерактивном выполнении программ, но если вы хотите запускать данный сценарий из другого сценария и проверять, успешно ли он завершился, возврат соответствующего кода завершения очень важен. Даже если вы не намерены разрешать вашему сценарию запускаться из другого сценария, все равно следует завершать его с подходящим кодом. Верьте в полезность своего сценария: вдруг когда-нибудь он потребуется для многократного использования как часть другого сценария.</p>     <p>В программировании средствами командной оболочки ноль означает успех. Поскольку представленный вариант сценария не может обнаружить какие-либо ошибки, он всегда возвращает код успешного завершения. Мы вернемся к причинам использования нулевого кода завершения для обозначения успешного выполнения программы позже в этой главе, когда будем более подробно обсуждать команду <blockquote>exit</blockquote>.</p>     <p>В сценарии не используются никакие расширения и суффиксы имен файлов; ОС Linux и UNIX, как правило, редко применяют при именовании файлов расширения для указания типа файла. Вы могли бы использовать расширение sh или любое другое, командную оболочку это не волнует. У большинства предустановленных сценариев нет никакого расширения в именах файлов и лучший способ проверить, сценарий это или нет применить <blockquote>команду</blockquote> <blockquote>file</blockquote>, например, <blockquote>file first</blockquote> или <blockquote>file /bin/bash</blockquote>. Пользуйтесь любыми правилами, принятыми в вашей организации или удобными для вас.</p>             <a name="metkadoc12"><h1>Превращение сценария в исполняемый файл</h1></a>     <p>Теперь, когда у вас есть файл сценария, его можно выполнить двумя способами. Более простой путь — запустить оболочку с именем файла сценария как параметром:</p>     <p><blockquote>$ <b>/bin/sh first</b> </blockquote></p>     <p>Этот вариант будет работать, но гораздо лучше запускать сценарий, введя его имя и тем самым присвоив ему статус других команд Linux. Сделаем это с помощью команды chmod, изменив режим файла (file mode) и сделав его исполняемым для всех пользователей:</p>     <p><blockquote>$ <b>chmod +х first</b></blockquote> </p>     <blockquote>      <b>Примечание</b>      <p>Конечно, превращение файла в исполняемый — это не единственный вариант применения команды <blockquote>chmod</blockquote>. Для того чтобы узнать больше о восьмеричных аргументах и других опциях команды, наберите <blockquote>man chmod</blockquote>.</p>     </blockquote>     <p>После этого вы можете выполнять файл с помощью команды</p>     <p><blockquote>$ <b>first</b></blockquote></p>     <p>При этом может появиться сообщение об ошибке, говорящее о том, что команда не найдена. Почти наверняка причина в том, что в переменной <blockquote>PATH</blockquote> не задан текущий каталог для поиска выполняемых команд. Исправить это можно либо введя с клавиатуры в командной строке <blockquote>PATH=$PATH:.</blockquote>, либо добавив данную команду в конец файла .bash_profile. Затем выйдите из системы и зарегистрируйтесь снова. В противном случае введите <blockquote>./first</blockquote> в каталог, содержащий сценарий, чтобы задать командной оболочке полный относительный путь к файлу.</p>     <p>Указание пути, начинающегося с символов <blockquote>./</blockquote>, дает еще одно преимущество: в этом случае вы случайно не сможете выполнить другую команду с тем же именем, что и у вашего файла сценария.</p>     <blockquote>      <b>Примечание</b>      <p>Не следует вносить подобные изменения в переменную <blockquote>PATH</blockquote> для суперпользователя, как правило, с именем root. Это лазейка в системе безопасности, т.к. системного администратора, зарегистрировавшегося как root, обманным путём могут заставить запустить фиктивную версию стандартной команды. Один из авторов однажды разрешил сделать это — конечно только для того, чтобы поставить перед системным администратором вопрос о безопасности! В случае обычных учетных записей включение текущего каталога в полный путь сопряжено с очень небольшим риском, поэтому, если вам это нужно, примите за правило добавление комбинации символов <blockquote>./</blockquote> перед всеми командами, находящимися в локальном каталоге.</p>     </blockquote>     <p>После того как вы убедитесь в корректной работе вашего сценария, можете переместить его в более подходящее место, чем текущий каталог. Если команда предназначена только для собственных нужд, можете создать каталог bin в своем исходном каталоге и добавить его в свой путь. Если вы хотите, чтобы сценарий выполняли другие пользователи, можно использовать каталог /usr/local/bin или другой системный каталог как удобное, хранилище для вновь созданных программ. Если в вашей системе у вас нет прав суперпользователя, можно попросить системного администратора скопировать ваш файл для вас, хотя сначала, возможно, придется убедить его в неоспоримых достоинствах вашего файла. Для того чтобы установить владельца и права доступа к файлу, администратору придется задать такую последовательность команд:</p>     <p><blockquote># <b>ср first /usr/local/bin</b></blockquote></p>     <p><blockquote># <b>chown root /usr/local/bin/first</b></blockquote></p>     <p><blockquote># <b>chgrp root /usr/local/bin/first</b></blockquote></p>     <p><blockquote># <b>chmod 755 /usr/local/bin/first</b></blockquote></p>     <p>Обратите внимание на то, что в данном случае вместо изменения определенной части флагов прав доступа вы используете абсолютную форму команды chmod, потому что точно знаете, какие требуются права доступа.</p>     <p>Если захотите, можно применить более длинную, но более понятную форму команды <blockquote>chmod</blockquote>:</p>     <p><blockquote># <b>chmod u=rwx, go=rx /usr/local/bin/first</b></blockquote></p>     <p>Более подробную информацию можно найти в справочном руководстве команды <blockquote>chmod</blockquote>.</p>     <blockquote>      <b>Примечание</b>      <p>В ОС Linux вы можете удалить файл, если у вас есть право записи в каталог, содержащий этот файл. Для безопасности убедитесь в том, что право записи в каталоги, содержащие файлы, которые вы хотели бы защитить, есть только у суперпользователя. В этом есть смысл, потому что каталог — это всего лишь еще один файл, и наличие права записи в файл каталога позволяет пользователям добавлять и удалять имена.</p>     </blockquote>              <a name="metkadoc13"><h1>Синтаксис командной оболочки</h1></a>         <p>Теперь, когда мы рассмотрели пример простой программы командной оболочки, пришло время углубиться в функциональные возможности программирования средствами командной оболочки. Командная оболочка — довольно легкий для изучения язык программирования, в немалой степени потому, что легко проверить в интерактивном режиме работу небольших фрагментов программы, прежде чем собирать их в большие сценарии. Командную оболочку bash можно использовать для создания довольно больших структурированных программ. В нескольких последующих разделах мы обсудим такие темы:</p>     <p>&#9633; переменные: строки, числа, переменные окружения и параметры;</p>     <p>&#9633; условия: булевы или логические выражения (Booleans);</p>     <p>&#9633; управление выполнением программы: <blockquote>if</blockquote>, <blockquote>elif</blockquote>, <blockquote>for</blockquote>, <blockquote>while</blockquote>, <blockquote>until</blockquote>, <blockquote>case</blockquote>;</p>     <p>&#9633; списки;</p>     <p>&#9633; функции;</p>     <p>&#9633; команды, встроенные в командную оболочку;</p>     <p>&#9633; получение результата выполнения команды;</p>     <p>&#9633; встроенные (here) документы.</p>             <a name="metkadoc14"><h1>Переменные</h1></a>     <p>В командной оболочке переменные перед применением обычно не объявляются. Вместо этого вы создаете их, просто используя (например, когда присваиваете им начальное значение). По умолчанию все переменные считаются строками и хранятся как строки, даже когда им присваиваются числовые значения. Командная оболочка и некоторые утилиты преобразуют строки, содержащие числа, в числовые значения, когда нужно их обработать должным образом. Linux — система, чувствительная к регистру символов, поэтому командная оболочка считает <blockquote>foo</blockquote> и <blockquote>Foo</blockquote> двумя разными переменными, отличающимися от третьей переменной <blockquote>FOO</blockquote>.</p>     <p>В командной оболочке можно получить доступ к содержимому переменной, если перед ее именем ввести знак <blockquote>$</blockquote>. Каждый раз, когда вы извлекаете содержимое переменной, вы должны к началу ее имени добавить знак <blockquote>$</blockquote>. Когда вы присваиваете переменной значение, просто используйте имя переменной, которая при необходимости будет создана динамически. Легко проверить содержимое переменной, выведя ее на терминал с помощью команды <blockquote>echo</blockquote> и указав перед именем переменной знак <blockquote>$</blockquote>.</p>     <p>Вы можете увидеть это в действии, если в командной строке будете задавать и проверять разные значения переменной <blockquote>salutation</blockquote>:</p>     <p><blockquote>$ <b>salutation=Hello</b></blockquote></p>     <p><blockquote>$ <b>echo $salutation</b></blockquote></p>     <p><blockquote>Hello</blockquote></p>     <p><blockquote>$ <b>salutation="Yes Dear"</b></blockquote></p>     <p><blockquote>$ <b>echo $salutation</b></blockquote></p>     <p><blockquote>Yes Dear</blockquote></p>     <p><blockquote>$<b> salutation=7+5</b></blockquote></p>     <p><blockquote>$ <b>echo $salutation</b></blockquote></p>     <p><blockquote>7+5</blockquote></p>     <blockquote>      <b>Примечание</b>      <p>Обратите внимание на то, что при наличии пробелов в содержимом переменной ее заключают в кавычки. Кроме того, не может быть пробелов справа и слева от знака равенства.</p>     </blockquote>     <p>Вы можете присвоить переменной пользовательский ввод с помощью команды <blockquote>read</blockquote>. Она принимает один параметр — имя переменной, в которую будут считываться данные, и затем ждет, пока пользователь введет какой-либо текст. Команда <blockquote>read</blockquote> обычно завершается после нажатия пользователем клавиши &lt;Enter&gt;. При чтении переменной с терминала, как правило, заключать ее значения в кавычки не требуется:</p>     <p><blockquote>$ <b>read salutation</b></blockquote></p>     <p><blockquote>Wie geht's?</blockquote></p>     <p><blockquote>$ <b>echo $salutation</b></blockquote></p>     <p><blockquote>Wie geht's?</blockquote></p>     <b>Заключение в кавычки</b>     <p>Прежде чем двигаться дальше, вам следует уяснить одно правило командной оболочки: использование кавычек.</p>     <p>Обычно параметры в сценариях отделяются неотображаемыми символами или знаками форматирования (например, пробелом, знаком табуляции или символом перехода на новую строку). Если вы хотите, чтобы параметр содержал один или несколько неотображаемых символов, его следует заключить в кавычки.</p>     <p>Поведение переменных, таких как <blockquote>$foo</blockquote>, заключенных в кавычки, зависит от вида используемых кавычек. Если вы заключаете в<i> двойные кавычки</i> <blockquote>$</blockquote>-представление переменной, оно во время выполнения командной строки заменяется значением переменной. Если вы заключаете его в<i> одинарные кавычки</i> или<i> апострофы,</i> никакой замены не происходит. Вы также можете отменить специальное назначение символа <blockquote>$</blockquote>, вставив перед ним символ <blockquote>\</blockquote> (обратный слэш).</p>     <p>Выполним упражнение 2.1.</p>     <b>Упражнение 2.1. Игра с переменными</b>     <p>В этом упражнении показано, как кавычки влияют на вывод переменной:</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <p><blockquote>myvar="Hi there"</blockquote></p>     <p><blockquote>echo $myvar</blockquote></p>     <p><blockquote>echo "$myvar"</blockquote></p>     <p><blockquote>echo '$myvar'</blockquote></p>     <p><blockquote>echo \$myvar</blockquote></p>     <br>     <p><blockquote>echo Enter some text</blockquote></p>     <p><blockquote>read myvar</blockquote></p>     <br>     <p><blockquote>echo '$myvar' now equals $myvar</blockquote></p>     <p><blockquote>exit 0</blockquote></p>     <p>Данный сценарий ведет себя следующим образом:</p>     <p><blockquote>$ <b>./variable</b></blockquote></p>     <p><blockquote>Hi there</blockquote></p>     <p><blockquote>Hi there</blockquote></p>     <p><blockquote>$myvar</blockquote></p>     <p><blockquote>$myvar</blockquote></p>     <p><blockquote>Enter some text</blockquote></p>     <p><blockquote><b>Hello World</b></blockquote></p>     <p><blockquote>$myvar now equals Hello World</blockquote></p>     <p><b>Как это работает</b></p>     <p>Создается переменная <blockquote>myvar</blockquote>, и ей присваивается строка <blockquote>Hi there</blockquote>. Содержимое переменной выводится на экран с помощью команды <blockquote>echo</blockquote>, демонстрирующей, как символ <blockquote>$</blockquote> раскрывает содержимое переменной. Вы видите, что применение двойных кавычек не влияет на раскрытие содержимого переменной, а одинарные кавычки и обратный слэш влияют. Вы также применяете команду <blockquote>read</blockquote> для получения строки от пользователя.</p>     <b>Переменные окружения</b>     <p>Когда стартует сценарий командной оболочки, некоторым переменным присваиваются начальные значения из окружения или рабочей среды. Обычно такие переменные обозначают прописными буквами, чтобы отличать их в сценариях от определенных пользователем переменных (командной оболочки), которые принято обозначать строчными буквами. Формируемые переменные зависят от ваших персональных настроек. Многие из них перечислены на страницах справочных руководств, а основные приведены в табл. 2.2.</p>     <br>     <p><b><i>Таблица 2.2</i></b></p>     <table>      <tr>       <th valign="top">Переменная окружения</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>$НОМЕ</blockquote></td>       <td valign="top">Исходный каталог текущего пользователя</td>      </tr>      <tr>       <td valign="top"><blockquote>$PATH</blockquote></td>       <td valign="top">Разделенный двоеточиями список каталогов для поиска команд</td>      </tr>      <tr>       <td valign="top"><blockquote>$PS1</blockquote></td>       <td valign="top">Подсказка или приглашение командной строки. Часто знак <blockquote>$</blockquote>, но в оболочке bash можно применять и более сложные варианты. Например, строка <blockquote>[\u@\h \w]$</blockquote> — популярный стандарт, сообщающий в подсказке пользователя имя компьютера и текущий каталог, а также знак <blockquote>$</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>$PS2</blockquote></td>       <td valign="top">Дополнительная подсказка или приглашение, применяемое как приглашение для дополнительного ввода; обычно знак <blockquote>&gt;</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>$IFS</blockquote></td>       <td valign="top">Разделитель полей ввода. Список символов, применяемых для разделения слов при чтении оболочкой ввода, как правило, пробел, знак табуляции и символ перехода на новую строку</td>      </tr>      <tr>       <td valign="top"><blockquote>$0</blockquote></td>       <td valign="top">Имя сценария командной оболочки</td>      </tr>      <tr>       <td valign="top"><blockquote>$#</blockquote></td>       <td valign="top">Количество передаваемых параметров</td>      </tr>      <tr>       <td valign="top"><blockquote>$$</blockquote></td>       <td valign="top">ID (идентификатор) процесса сценария оболочки, часто применяемый внутри сценария для генерации уникальных имен временных файлов; например, /tmp/tmpfile_$$</td>      </tr>     </table>     <blockquote>      <b>Примечание</b>      <p>Если вы хотите проверить с помощью команды <blockquote>env &lt;<i>команда</i>&gt;</blockquote><i>,</i> как работает программа в разных окружениях, познакомьтесь с интерактивным справочным руководством к команде <blockquote>env</blockquote>. Далее в этой главе вы увидите, как задавать переменные окружения в подоболочках (subshells), применяя команду <blockquote>export</blockquote>.</p>     </blockquote>     <b>Переменные-параметры</b>     <p>Если ваш сценарий вызывается с параметрами, создается несколько дополнительных переменных. Если параметры не передаются, переменная окружения <blockquote>$#</blockquote> все равно существует, но равна 0.</p>     <p>Переменные-параметры перечислены в табл. 2.3.</p>     <br>     <p><b><i>Таблица 2.3</i></b></p>     <table>      <tr>       <th valign="top">Переменная-параметр</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>$1</blockquote>, <blockquote>$2</blockquote>, ...</td>       <td valign="top">Параметры, передаваемые сценарию</td>      </tr>      <tr>       <td valign="top"><blockquote>$*</blockquote></td>       <td valign="top">Список всех параметров в единственной переменной, разделенных первым символом из переменной окружения <blockquote>IFS</blockquote>. Если <blockquote>IFS</blockquote> корректируется, способ разделения командной строки на параметры в переменной <blockquote>$*</blockquote> изменяется</td>      </tr>      <tr>       <td valign="top"><blockquote>$@</blockquote></td>       <td valign="top">Едва различимая вариация <blockquote>$*</blockquote>; не использует переменную окружения <blockquote>IFS</blockquote>, поэтому параметры не сольются, даже если переменная <blockquote>IFS</blockquote> пуста</td>      </tr>     </table>     <p>Легче всего увидеть разницу между переменными-параметрами <blockquote>$*</blockquote> и <blockquote>$@</blockquote>, опробовав их.</p>     <p><blockquote>$ <b>IFS=''</b></blockquote></p>     <p><blockquote>$ <b>set foo bar bam</b></blockquote></p>     <p><blockquote>$ <b>echo "$@"</b></blockquote></p>     <p><blockquote>foo bar bam</blockquote></p>     <p><blockquote>$ <b>echo "$*"</b></blockquote></p>     <p><blockquote>foobarbam</blockquote></p>     <p><blockquote>$ <b>unset IFS</b></blockquote></p>     <p><blockquote>$ <b>echo "$*"</b></blockquote></p>     <p><blockquote>foo bar bam</blockquote></p>     <p>Как видите, заключенная в двойные кавычки переменная-параметр <blockquote>$@</blockquote> представляет позиционные параметры как отдельные поля, независимо от значения переменной окружения <blockquote>IFS</blockquote>. Как правило, если вы хотите получить доступ к параметрам, лучше использовать переменную-параметр.</p>     <p>Помимо вывода на экран содержимого переменных с помощью команды <blockquote>echo</blockquote>, вы также можете прочитать его командой <blockquote>read</blockquote> (упражнение 2.2).</p>     <b>Упражнение 2.2. Манипулирование параметрами и переменными окружения</b>     <p>В приведенном далее сценарии показано несколько простых манипуляций переменными. После ввода сценария и записи его в файл try_var не забудьте превратить его в исполняемый файл с помощью команды <blockquote>chmod +х try_var</blockquote>.</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>salutation="Hello"</blockquote></p>     <p><blockquote>echo $salutation</blockquote></p>     <p><blockquote>echo "The program $0 is now running"</blockquote></p>     <p><blockquote>echo "The second parameter was $2"</blockquote></p>     <p><blockquote>echo "The first parameter was $1"</blockquote></p>     <p><blockquote>echo "The parameter list was</blockquote></p>     <p><blockquote>echo "The user's home directory is $HOME"</blockquote></p>     <p><blockquote>echo "Please enter a new greeting"</blockquote></p>     <p><blockquote>read salutation</blockquote></p>     <br>     <p><blockquote>echo $salutation</blockquote></p>     <p><blockquote>echo "The script is now complete"</blockquote></p>     <p><blockquote>exit 0</blockquote></p>     <p>Если вы выполните этот сценарий, то получите следующий вывод:</p>     <p><blockquote>$ <b>./try_var foo bar baz</b></blockquote></p>     <p><blockquote>Hello</blockquote></p>     <p><blockquote>The program ./try_var is now running</blockquote></p>     <p><blockquote>The second parameter was bar</blockquote></p>     <p><blockquote>The first parameter was foo</blockquote></p>     <p><blockquote>The parameter list was foo bar baz</blockquote></p>     <p><blockquote>The user's home directory is /home/rick</blockquote></p>     <p><blockquote>Please enter a new greeting</blockquote></p>     <p><blockquote><b>Sire</b></blockquote></p>     <p><blockquote>Sire</blockquote></p>     <p><blockquote>The script is now complete $</blockquote></p>     <p><b>Как это работает</b></p>     <p>Сценарий создает переменную <blockquote>salutation</blockquote>, выводит на экран ее содержимое и затем показывает, что уже сформированы и имеют соответствующие значения различные переменные-параметры и переменная окружения <blockquote>$НОМЕ</blockquote>.</p>     <p>Далее в этой главе мы рассмотрим более подробно подстановку параметров.</p>             <a name="metkadoc15"><h1>Условия</h1></a>     <p>Основа всех языков программирования — средства проверки условий и выполнение различных действий с учетом результатов этой проверки. Но прежде чем говорить об этом, давайте рассмотрим условные конструкции, которые можно применять в сценариях командной оболочки, а затем познакомимся с использующими их управляющими структурами.</p>     <p>Сценарий командной оболочки может проверить код завершения любой команды, вызванной из командной строки, включая сценарии, написанные вами. Вот почему так важно всегда включать в создаваемые вами сценарии команду exit с определенным значением.</p>     <b>Команда <i>test</i> или <i>[</i></b>     <p>На практике в большинстве сценариев широко используется команда <blockquote>[</blockquote> или <blockquote>test</blockquote> — логическая проверка командной оболочки. В некоторых системах команды <blockquote>[</blockquote> и <blockquote>test</blockquote> — синонимы, за исключением того, что при использовании команды <blockquote>[</blockquote> для удобочитаемости применяется и завершающая часть <blockquote>]</blockquote>. Наличие команды <blockquote>[</blockquote> может показаться странным, но в программном коде она упрощает синтаксис и делает его более похожим на другие языки программирования.</p>     <blockquote>      <b>Примечание</b>      <p>Эти команды в некоторых ранних оболочках UNIX вызывают внешнюю программу, но в более современных версиях их стараются делать встроенными. Мы вернемся к этому, когда будем рассматривать команды в следующем разделе.</p>      <p>Поскольку команда <blockquote>test</blockquote> не часто применяется за пределами сценариев командной оболочки, многие пользователи ОС Linux, никогда раньше не писавшие сценариев, пытаются создавать простые программы и называют их test. Если такая программа не работает, вероятно, она конфликтует с командой оболочки <blockquote>test</blockquote>. Для того чтобы выяснить, есть ли в вашей системе внешняя команда с данным именем, попытайтесь набрать что-нибудь вроде <blockquote>which test</blockquote> и проверить, какая именно команда <blockquote>test</blockquote> выполняется в данный момент, или используйте форму <blockquote>./test</blockquote>, чтобы быть уверенным в том, что вы выполняете сценарий из текущего каталога. Если сомневаетесь, примите за правило выполнять свои сценарии, предваряя при запуске их имена комбинацией символов <blockquote>./</blockquote>.</p>     </blockquote>     <p>Мы представим команду <blockquote>test</blockquote> на примере одного простейшего условия: проверки наличия файла. Для нее понадобится следующая команда: <blockquote>test -f &lt;<i>имя_файла</i>&gt;</blockquote>, поэтому в сценарии можно написать</p>     <p><blockquote>if test -f fred.c</blockquote></p>     <p><blockquote>then</blockquote></p>     <p><blockquote> ...</blockquote></p>     <p><blockquote>fi</blockquote></p>     <p>To же самое можно записать следующим образом:</p>     <p><blockquote>if [ -f fred.c ]</blockquote></p>     <p><blockquote>then</blockquote></p>     <p><blockquote> ...</blockquote></p>     <p><blockquote>fi</blockquote></p>     <p>Код завершения команды <blockquote>test</blockquote> (выполнено ли условие) определяет, будет ли выполняться условный программный код.</p>     <blockquote>      <b>Примечание</b>      <p>Имейте в виду, что вы должны вставлять пробелы между квадратной скобкой <blockquote>[</blockquote> и проверяемым условием. Это легко усвоить, если запомнить, что вставить символ <blockquote>[</blockquote> — это все равно, что написать <blockquote>test</blockquote>, а после имени команды вы всегда должны вставлять пробел.</p>      <p>Если вы предпочитаете помещать слово <blockquote>then</blockquote> в той же строке, что и <blockquote>if</blockquote>, нужно добавить точку с запятой для отделения команды <blockquote>test</blockquote> от <blockquote>then</blockquote>:</p>      <p><blockquote>if [ -f fred.c ]; then</blockquote></p>      <p><blockquote> ...</blockquote></p>      <p><blockquote>fi</blockquote></p>     </blockquote>     <p>Варианты условий, которые вы можете применять в команде <blockquote>test</blockquote>, делятся на три типа: строковые сравнения, числовые сравнения и проверка файловых флагов (file conditionals). Эти типы условий описаны в табл. 2.4.</p>     <br>     <p><b><i>Таблица 2.4</i></b></p>     <table>      <tr>       <th valign="top">Варианты условий</th>       <th valign="top">Результат</th>      </tr>      <tr>       <th colspan="2" valign="top">Сравнения строк</th>      </tr>      <tr>       <td valign="top"><i><blockquote><i>Строка1 = Строка2</i></blockquote></i></td>       <td valign="top"><blockquote>True</blockquote> (истина), если строки одинаковы</td>      </tr>      <tr>       <td valign="top"><blockquote><i>Строка1 != Строка2</i></blockquote></td>       <td valign="top"><blockquote>True</blockquote> (истина), если строки разные</td>      </tr>      <tr>       <td valign="top"><blockquote>-n<i> Строка</i></blockquote></td>       <td valign="top"><blockquote>True</blockquote> (истина), если<i> <blockquote>Строка</blockquote></i> не <blockquote>null</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>-z <i>Строка</i></blockquote></td>       <td valign="top"><blockquote>True</blockquote> (истина), если<i> <blockquote><i>Строка</i> null</blockquote></i> (пустая строка)</td>      </tr>      <tr>       <th colspan="2" valign="top">Сравнения чисел</th>      </tr>      <tr>       <td valign="top"><i><blockquote><i>Выражение1</i> -eq <i>Выражение2</i></blockquote></i></td>       <td valign="top"><blockquote>True</blockquote> (истина), если выражения равны</td>      </tr>      <tr>       <td valign="top"><blockquote><i>Выражение1</i> -ne<i> Выражение2</i></blockquote></td>       <td valign="top"><blockquote>True</blockquote> (истина), если выражения не равны</td>      </tr>      <tr>       <td valign="top"><blockquote><i>Выражение1</i> -gt Вы<i>ражение2</i></blockquote></td>       <td valign="top"><blockquote>True</blockquote> (истина), если<i> <blockquote>Выражение1</blockquote></i> больше, чем<i> <blockquote>Выражение2</blockquote></i></td>      </tr>      <tr>       <td valign="top"><blockquote><i>Выражение1</i> -ge <i>Выражение2</i></blockquote></td>       <td valign="top"><blockquote>True</blockquote> (истина), если<i> <blockquote>Выражение1</blockquote></i> не меньше<i> <blockquote>Выражение2</blockquote></i></td>      </tr>      <tr>       <td valign="top"><blockquote><i>Выражение1</i> -lt <i>Выражение2</i></blockquote></td>       <td valign="top"><blockquote>True</blockquote> (истина), если<i> <blockquote>Выражение1</blockquote></i> меньше, чем<i> <blockquote>Выражение2</blockquote></i></td>      </tr>      <tr>       <td valign="top"><blockquote><i>Выражение1</i> -lе<i> Выражение2</i></blockquote></td>       <td valign="top"><blockquote>True</blockquote> (истина), если<i> <blockquote>Выражение1</blockquote></i> не больше<i> <blockquote>Выражение2</blockquote></i></td>      </tr>      <tr>       <td valign="top"><blockquote>! <i>Выражение</i></blockquote></td>       <td valign="top"><blockquote>True</blockquote> (истина), если<i> <blockquote>Выражение</blockquote></i> ложно, и наоборот</td>      </tr>      <tr>       <th colspan="2" valign="top">Файловый флаг</th>      </tr>      <tr>       <td valign="top"><blockquote>-d <i>файл</i></blockquote></td>       <td valign="top"><blockquote>True</blockquote> (истина), если<i> <blockquote>файл</blockquote> </i>— каталог</td>      </tr>      <tr>       <td valign="top"><blockquote>-е<i> файл</i></blockquote></td>       <td valign="top"><blockquote>True</blockquote> (истина), если<i> <blockquote>файл</blockquote></i> существует. Исторически, опция <blockquote>-e</blockquote> не была переносима на другие платформы, поэтому обычно применяется <blockquote>-f</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>-f <i>файл</i></blockquote></td>       <td valign="top"><blockquote>True</blockquote> (истина), если<i> <blockquote>файл</blockquote> </i>— обычный файл</td>      </tr>      <tr>       <td valign="top"><blockquote>-g <i>файл</i></blockquote></td>       <td valign="top"><blockquote>True</blockquote> (истина), если для<i> <blockquote>файла</blockquote></i> установлен бит set-group-id</td>      </tr>      <tr>       <td valign="top"><blockquote>-r<i> файл</i></blockquote></td>       <td valign="top"><blockquote>True</blockquote> (истина), если <blockquote><i>файл</i></blockquote> доступен для чтения</td>      </tr>      <tr>       <td valign="top"><blockquote>-s <i>файл</i></blockquote></td>       <td valign="top"><blockquote>True</blockquote> (истина), если <blockquote><i>файл</i></blockquote> ненулевого размера</td>      </tr>      <tr>       <td valign="top"><blockquote>-u<i> файл</i></blockquote></td>       <td valign="top"><blockquote>True</blockquote> (истина), если для<i> <blockquote>файла</blockquote></i> установлен бит set-user-id</td>      </tr>      <tr>       <td valign="top"><blockquote>-v <i>файл</i></blockquote></td>       <td valign="top"><blockquote>True</blockquote> (истина), если<i> <blockquote>файл</blockquote></i> доступен для записи</td>      </tr>      <tr>       <td valign="top"><blockquote>-х<i> файл</i></blockquote></td>       <td valign="top"><blockquote>True</blockquote> (истина), если <i><blockquote><i>файл </i></blockquote></i>— исполняемый файл</td>      </tr>     </table>     <blockquote>      <b>Примечание</b>      <p>Вас могли заинтересовать непонятные биты set-group-id и set-user-id (также называемые set-gid и set-uid). Бит set-uid предоставляет программе права владельца, а не просто ее пользователя, бит set-gid предоставляет программе права группы. Эти биты устанавливаются командой <blockquote>chmod</blockquote> с помощью опций <blockquote>s</blockquote> и <blockquote>g</blockquote>. На файлы, содержащие сценарии, флаги set-gid и set-uid не влияют, они оказывают влияние только на исполняемые двоичные файлы.</p>     </blockquote>     <p>Мы немного сами себя обогнали, но далее следует пример тестирования состояния файла /bin/bash, так что вы сможете увидеть, как это выглядит на практике.</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>if [ -f /bin/bash ]</blockquote></p>     <p><blockquote>then</blockquote></p>     <p><blockquote> echo "file /bin/bash exists"</blockquote></p>     <p><blockquote>fi</blockquote></p>     <br>     <p><blockquote>if [ -d /bin/bash ]</blockquote></p>     <p><blockquote>then</blockquote></p>     <p><blockquote> echo "/bin/bash is a directory"</blockquote></p>     <p><blockquote>else</blockquote></p>     <p><blockquote> echo "/bin/bash is NOT a directory"</blockquote></p>     <p><blockquote>fi</blockquote></p>     <p>Для того чтобы тест мог оказаться истинным, предварительно, для проверки всех файловых флагов требуется наличие файла. Данный перечень включает только самые широко используемые опции команды <blockquote>test</blockquote>, полный список можно найти в интерактивном справочном руководстве. Если вы применяете оболочку bash, в которую встроена команда <blockquote>test</blockquote>, используйте команду <blockquote>help test</blockquote> для получения дополнительных сведений. Позже в этой главе мы применим некоторые из этих опций.</p>     <p>Теперь, когда вы познакомились с условиями, можно рассмотреть управляющие структуры, использующие эти условия.</p>             <a name="metkadoc16"><h1>Управляющие структуры</h1></a>     <p>В командной оболочке есть ряд управляющих структур или конструкций, похожих на аналогичные структуры в других языках программирования.</p>     <blockquote>      <b>Примечание</b>      <p>В следующих разделах элемент синтаксической записи <i>операторы </i>— это последовательности команд, которые выполняются, когда или пока условие удовлетворяется или пока оно не удовлетворяется. </p>     </blockquote>     <b><i>if</i></b>     <p>Управляющий оператор <blockquote>if</blockquote> очень прост: он проверяет результат выполнения команды и затем в зависимости от<i> <blockquote>условия</blockquote></i> выполняет ту или иную группу операторов.</p>     <p><blockquote><b>if</b> <i>условие</i></blockquote></p>     <p><blockquote><b>then</b></blockquote></p>     <p><blockquote><i> операторы</i></blockquote></p>     <p><blockquote><b>else</b></blockquote></p>     <p><blockquote><i> операторы</i></blockquote></p>     <p><blockquote><b>fi</b></blockquote></p>     <p>Наиболее часто оператор <blockquote>if</blockquote> применяется, когда задается вопрос, и решение принимается в зависимости от ответа:</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>echo "Is it morning? Please answer yes or no "</blockquote></p>     <p><blockquote>read timeofday</blockquote></p>     <p><blockquote>if [ $timeofday = "yes" ]; then</blockquote></p>     <p><blockquote> echo "Good morning"</blockquote></p>     <p><blockquote>else</blockquote></p>     <p><blockquote> echo "Good afternoon"</blockquote></p>     <p><blockquote>fi</blockquote></p>     <p><blockquote>exit 0</blockquote></p>     <p>В результате будет получен следующий вывод на экран:</p>     <p><blockquote>Is it morning? Please answer yes or no</blockquote></p>     <p><blockquote><b>yes</b></blockquote></p>     <p><blockquote>Good morning</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>В этом сценарии для проверки содержимого переменной <blockquote>timeofday</blockquote> применяется команда <blockquote>[</blockquote>. Результат оценивается оператором командной оболочки <blockquote>if</blockquote>, который затем разрешает выполнять разные строки программного кода.</p>     <blockquote>      <b>Примечание</b>      <p>Обратите внимание на дополнительные пробелы, используемые для формирования отступа внутри оператора <blockquote>if</blockquote>. Это делается только для удобства читателя; командная оболочка игнорирует дополнительные пробелы.</p>     </blockquote>     <b><i>elif</i></b>     <p>К сожалению, с этим простым сценарием связано несколько проблем. Во-первых, он принимает в значении <blockquote>no</blockquote> (нет) любой ответ за исключением <blockquote>yes</blockquote> (да). Можно помешать этому, воспользовавшись конструкцией <blockquote>elif</blockquote>, которая позволяет добавить второе условие, проверяемое при выполнении части <blockquote>else</blockquote> оператора <blockquote>if</blockquote> (упражнение 2.3). </p>     <b>Упражнение 2.3. Выполнение проверок с помощью <blockquote>elif</blockquote></b>     <p>Вы можете откорректировать предыдущий сценарий так, чтобы он выводил сообщение об ошибке, если пользователь вводит что-либо отличное от <blockquote>yes</blockquote> или <blockquote>no</blockquote>. Для этого замените ветку <blockquote>else</blockquote> веткой <blockquote>elif</blockquote> и добавьте еще одно условие:</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <p><blockquote>echo "Is it morning? Please answer yes or no "</blockquote></p>     <p><blockquote>read timeofday</blockquote></p>     <br>     <p><blockquote>if [ $timeofday = "yes" ]</blockquote></p>     <p><blockquote>then</blockquote></p>     <p><blockquote> echo "Good morning"</blockquote></p>     <p><blockquote><i>elif [ $timeofday = "no" ]; then</i></blockquote></p>     <p><blockquote><i> echo "Good afternoon"</i></blockquote></p>     <p><blockquote><i>else</i></blockquote></p>     <p><blockquote><i> echo "Sorry, $timeofday not recognized. Enter yes or no "</i></blockquote></p>     <p><blockquote><i> exit 1</i></blockquote></p>     <p><blockquote>fi</blockquote></p>     <p><blockquote>exit 0</blockquote></p>     <p><b>Как это работает</b></p>     <p>Этот пример очень похож на предыдущий, но теперь, если первое условие не равно <blockquote>true</blockquote>, оператор командной оболочки <blockquote>elif</blockquote> проверяет переменную снова. Если обе проверки не удачны, выводится сообщение об ошибке, и сценарий завершается со значением 1, которое в вызывающей программе можно использовать для проверки успешного выполнения сценария.</p>     <b>Проблема, связанная с переменными</b>     <p>Данный сценарий исправляет наиболее очевидный дефект, а более тонкая проблема остается незамеченной. Запустите новый вариант сценария, но вместо ответа на вопрос просто нажмите клавишу &lt;Enter&gt; (или на некоторых клавиатурах клавишу &lt;Return&gt;). Вы получите сообщение об ошибке:</p>     <p><blockquote>[: =: unary operator expected</blockquote></p>     <p>Что же не так? Проблема в первой ветви оператора <blockquote>if</blockquote>. Когда проверялась переменная <blockquote>timeofday</blockquote>, она состояла из пустой строки. Следовательно, ветвь оператора <blockquote>if</blockquote> выглядела следующим образом:</p>     <p><blockquote><i>if [ = "yes" ]</i></blockquote></p>     <p>и не представляла собой верное условие. Во избежание этого следует заключить имя переменной в кавычки:</p>     <p><blockquote><i>if [ "$timeofday" = "yes" ]</i></blockquote></p>     <p>Теперь проверка с пустой переменной будет корректной:</p>     <p><blockquote><i>if [ "" = "yes" ]</i></blockquote></p>     <p>Новый сценарий будет таким:</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>echo "Is it morning? Please answer yes or no "</blockquote></p>     <p><blockquote>read timeofday</blockquote></p>     <br>     <p><blockquote><i>if [ "$timeofday" = "yes" ]</i></blockquote></p>     <p><blockquote>then</blockquote></p>     <p><blockquote> echo "Good morning"</blockquote></p>     <p><blockquote>elif [ "$timeofday" = "no" ]; then</blockquote></p>     <p><blockquote> echo "Good afternoon"</blockquote></p>     <p><blockquote>else</blockquote></p>     <p><blockquote><i> echo "Sorry, $timeofday not recognized. Enter yes or no "</i></blockquote></p>     <p><blockquote> exit 1</blockquote></p>     <p><blockquote>fi</blockquote></p>     <br>     <p><blockquote>exit 0</blockquote></p>     <p>Этот вариант безопасен, даже если пользователь в ответ на вопрос просто нажмет клавишу &lt;Enter&gt;.</p>     <blockquote>      <b>Примечание</b>      <p>Если вы хотите, чтобы команда <blockquote>echo</blockquote> удалила новую строку в конце, наиболее легко переносимый вариант — применить команду <blockquote>printf </blockquote><i>(см. разд. "printf" далее в этой главе)</i> вместо команды <blockquote>echo</blockquote>. В некоторых командных оболочках применяется команда <blockquote>echo -е</blockquote>, но она поддерживается не всеми системами. В оболочке bash для запрета перехода на новую строку допускается команда <blockquote>echo -n</blockquote>, поэтому, если вы уверены, что вашему сценарию придется трудиться только в оболочке bash, предлагаем вам использовать следующий синтаксис:</p>      <p><blockquote>echo -n "Is it morning? Please answer yes or no: "</blockquote></p>      <p>Помните о том, что нужно оставлять дополнительный пробел перед закрывающими кавычками, таким образом формируется зазор перед вводимым пользователем ответом, который в этом случае выглядит четче.</p>     </blockquote>     <b><i>for</i></b>     <p>Применяйте конструкцию <blockquote>for</blockquote> для обработки в цикле ряда значений, которые могут представлять собой любое множество строк. Строки могут быть просто перечислены в программе или, что бывает чаще, представлять собой результат выполненной командной оболочкой подстановки имен файлов.</p>     <p>Синтаксис этого оператора прост:</p>     <p><blockquote><b>for</b> <i>переменная </i><b>in</b> <i>значения</i></blockquote></p>     <p><blockquote><b>do</b></blockquote></p>     <p><blockquote><i> операторы</i></blockquote></p>     <p><blockquote><b>done</b></blockquote></p>     <p>Выполните упражнения 2.4 и 2.5.</p>     <b>Упражнение 2.4. Применение цикла <blockquote>for</blockquote> к фиксированным строкам</b>     <p>В командной оболочке значения обычно представлены в виде строк, поэтому можно написать следующий сценарий:</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>for foo in bar fud 43</blockquote></p>     <p><blockquote>do</blockquote></p>     <p><blockquote> echo $foo</blockquote></p>     <p><blockquote>done</blockquote></p>     <p><blockquote>exit 0</blockquote></p>     <p>В результате будет получен следующий вывод:</p>     <p><blockquote>bar</blockquote></p>     <p><blockquote>fud</blockquote></p>     <p><blockquote>43</blockquote></p>     <blockquote>      <b>Примечание</b>      <p>Что произойдет, если вы измените первую строку с <blockquote>for foo in bar fud 43</blockquote> на <blockquote>for foo in "bar fud 43"</blockquote>? Напоминаем, что вставка кавычек заставляет командную оболочку считать все, что находится между ними, единой строкой. Это один из способов сохранения пробелов в переменной.</p>     </blockquote>     <p><b>Как это работает</b></p>     <p>В данном примере создается переменная <blockquote>foo</blockquote> и ей в каждом проходе цикла <blockquote>for</blockquote> присваиваются разные значения. Поскольку оболочка считает по умолчанию все переменные строковыми, применять строку 43 так же допустимо, как и строку <blockquote>fud</blockquote>.</p>     <b>Упражнение 2.5. Применение цикла <blockquote>for</blockquote> с метасимволами</b>     <p>Как упоминалось ранее, цикл <blockquote>for</blockquote> обычно используется в командной оболочке вместе с метасимволами или знаками подстановки для имен файлов. Это означает применение метасимвола для строковых значений и предоставление оболочке возможности подставлять все значения на этапе выполнения.</p>     <p>Вы уже видели этот прием в первом примере first. В сценарии применялись средства подстановки командной оболочки — символ <blockquote>*</blockquote> для подстановки имен всех файлов из текущего каталога. Каждое из этих имен по очереди используется в качестве значения переменной <blockquote>$file</blockquote> внутри цикла <blockquote>for</blockquote>.</p>     <p>Давайте бегло просмотрим еще один пример подстановки с помощью метасимвола. Допустим, что вы хотите вывести на экран все имена файлов сценариев в текущем каталоге, начинающиеся с буквы "f", и вы знаете, что имена всех ваших сценариев заканчиваются символами .sh. Это можно сделать следующим образом:</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>for file in $(ls f*.sh); do</blockquote></p>     <p><blockquote> lpr $file</blockquote></p>     <p><blockquote>done</blockquote></p>     <p><blockquote>exit 0</blockquote></p>     <p><b>Как это работает</b></p>     <p>В этом примере показано применение синтаксической конструкции <blockquote>$(<i>команда</i>)</blockquote>, которая будет подробно обсуждаться далее (в разделе, посвященном выполнению команд). Обычно список параметров для цикла <blockquote>for</blockquote> задается выводом команды, включенной в конструкцию <blockquote>$()</blockquote>.</p>     <p>Командная оболочка раскрывает <blockquote>f*.sh</blockquote>, подставляя имена всех файлов, соответствующих данному шаблону.</p>     <blockquote>      <b>Примечание</b>      <p>Помните о том, что все подстановки переменных в сценариях командной оболочки делаются во время выполнения сценария, а не в процессе их написания, поэтому все синтаксические ошибки в объявлениях переменных обнаруживаются только на этапе выполнения, как было показано ранее, когда мы заключали в кавычки пустые переменные.</p>     </blockquote>     <b><i>while</i></b>     <p>Поскольку по умолчанию командная оболочка считает все значения строками, оператор <blockquote>for</blockquote> хорош для циклической обработки наборов строк, но не слишком удобен, если вы не знаете заранее, сколько раз придется его выполнить.</p>     <p>Если нужно повторить выполнение последовательности команд, но заранее не известно, сколько раз следует их выполнить, вы, как правило, будете применять цикл <blockquote>while</blockquote> со следующей синтаксической записью:</p>     <p><blockquote><b>while</b>  <i>условие</i></blockquote></p>     <p><blockquote><b>do</b> </blockquote></p>     <p><blockquote><i> операторы</i></blockquote></p>     <p><blockquote><b>done</b> </blockquote></p>     <p>Далее приведен пример довольно слабой программы проверки паролей.</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>echo "Enter password"</blockquote></p>     <p><blockquote>read trythis</blockquote></p>     <p><blockquote>while [ "$trythis" != "secret" ]; do</blockquote></p>     <p><blockquote> echo "Sorry, try again"</blockquote></p>     <p><blockquote> read trythis</blockquote></p>     <p><blockquote>done</blockquote></p>     <p><blockquote>exit 0</blockquote></p>     <p>Следующие строки могут служить примером вывода данного сценария:</p>     <p><blockquote>Enter password</blockquote></p>     <p><blockquote><b>password</b></blockquote></p>     <p><blockquote>Sorry, try again</blockquote></p>     <p><blockquote><b>secret</b></blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Ясно, что это небезопасный способ выяснения пароля, но он вполне подходит для демонстрации применения цикла <blockquote>while</blockquote>. Операторы, находящиеся между операторами <blockquote>do</blockquote> и <blockquote>done</blockquote>, выполняются бесконечное число раз до тех пор, пока условие остается истинным (<blockquote>true</blockquote>). В данном случае вы проверяете, равно ли значение переменной <blockquote>trythis</blockquote> строке <blockquote>secret</blockquote>. Цикл будет выполняться, пока <blockquote>$trythis</blockquote> не равно <blockquote>secret</blockquote>. Затем выполнение сценария продолжится с оператора, следующего сразу за оператором <blockquote>done</blockquote>.</p>     <b><i>until</i></b>     <p>У цикла <blockquote>until</blockquote> следующая синтаксическая запись:</p>     <p><blockquote><b>until</b>  <i>условие</i></blockquote></p>     <p><blockquote><b>do</b></blockquote></p>     <p><blockquote><i> операторы</i></blockquote></p>     <p><blockquote><b>done</b></blockquote></p>     <p>Она очень похожа на синтаксическую запись цикла <blockquote>while</blockquote>, но с обратным проверяемым условием. Другими словами, цикл продолжает выполняться, пока<i> <blockquote>условие</blockquote></i> не станет истинным (true).</p>     <blockquote>      <b>Примечание</b>      <p>Как правило, если нужно выполнить цикл хотя бы один раз, применяют цикл <blockquote>while</blockquote>; если такой необходимости нет, используют цикл <blockquote>until</blockquote>.</p>     </blockquote>     <p>Как пример цикла <blockquote>until</blockquote> можно установить звуковой сигнал предупреждения, инициируемый во время регистрации нового пользователя, регистрационное имя которого передается в командную строку.</p>     <p><blockquote>#!/bin/bash</blockquote></p>     <br>     <p><blockquote>until who | grep "$1" &gt; /dev/null</blockquote></p>     <p><blockquote>do</blockquote></p>     <p><blockquote> sleep 60</blockquote></p>     <p><blockquote>done</blockquote></p>     <p><blockquote># Теперь звонит колокольчик и извещает о новом пользователе</blockquote></p>     <p><blockquote>echo -е '\а'</blockquote></p>     <p><blockquote>echo "**** $1 has just logged in ****"</blockquote></p>     <p><blockquote>exit 0</blockquote></p>     <p>Если пользователь уже зарегистрировался в системе, выполнять цикл нет необходимости. Поэтому естественно выбрать цикл <blockquote>until</blockquote>, а не цикл <blockquote>while</blockquote>.</p>     <b><i>case</i></b>     <p>Оператор <blockquote>case</blockquote> немного сложнее уже рассмотренных нами операторов. У него следующая синтаксическая запись:</p>     <p><blockquote><b>case</b><i> переменная</i>  <b>in</b></blockquote></p>     <p><blockquote><i> образец</i> [ | <i>образец</i>] ...) <i>операторы</i>;;</blockquote></p>     <p><blockquote> <i>образец</i> [ | <i>образец</i>] ...)<i> операторы</i>;;</blockquote></p>     <p><blockquote><b>esac</b></blockquote></p>     <p>Конструкция оператора <blockquote>case</blockquote> выглядит слегка устрашающей, но она позволяет довольно изощренным способом сопоставлять содержимое<i> переменной</i> с<i> образцами</i> и затем выполнять разные операторы в зависимости от того, с каким образцом найдено соответствие. Это гораздо проще, чем проверять несколько условий, применяемых во множественных операторах <blockquote>if</blockquote>, <blockquote>elif</blockquote> и <blockquote>else</blockquote>.</p>     <blockquote>      <b>Примечание</b>      <p>Обратите внимание на то, что каждая ветвь с образцами завершается удвоенным символом "точка с запятой" (<blockquote>;;</blockquote>). В каждой ветви оператора <blockquote>case</blockquote> можно поместить несколько операторов, поэтому сдвоенная точка с запятой необходима для отметки завершения очередного оператора и начала следующей ветви с новым образцом в операторе <blockquote>case</blockquote>.</p>     </blockquote>     <p>Возможность сопоставлять многочисленные образцы и затем выполнять множественные связанные с образцом операторы делают конструкцию <blockquote>case</blockquote> очень удобной для обработки пользовательского ввода. Лучше всего увидеть, как работает конструкция <blockquote>case</blockquote> на примерах. Мы будем применять ее в упражнениях 2.6–2.8, каждый раз совершенствуя сопоставление с образцами.</p>     <blockquote>      <b>Примечание</b>      <p>Применяя конструкцию <blockquote>case</blockquote> с метасимволами в образцах, такими как <blockquote>*</blockquote>, будьте особенно внимательны. Проблема заключается в том, что принимается во внимание первое найденное соответствие образцу, несмотря на то, что в последующих ветвях могут быть образцы с более точным соответствием.</p>     </blockquote>     <b>Упражнение 2.6. Вариант 1: пользовательский ввод</b>     <p>Вы можете написать новую версию сценария проверки пользовательского ввода с помощью конструкции <blockquote>case</blockquote>, сделав сценарий немного более избирательным и терпимым к неожиданным вариантам ввода.</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>echo "Is it morning? Please answer yes or no "</blockquote></p>     <p><blockquote>read timeofday</blockquote></p>     <br>     <p><blockquote>case "$timeofday" in</blockquote></p>     <p><blockquote> yes) echo "Good Morning";;</blockquote></p>     <p><blockquote> no ) echo "Good Afternoon";;</blockquote></p>     <p><blockquote> y  ) echo "Good Morning";;</blockquote></p>     <p><blockquote> n  ) echo "Good Afternoon";;</blockquote></p>     <p><blockquote> *  ) echo "Sorry, answer not recognized";;</blockquote></p>     <p><blockquote>esac</blockquote></p>     <br>     <p><blockquote>exit 0</blockquote></p>     <p><b>Как это работает</b></p>     <p>Когда выполняется оператор <blockquote>case</blockquote>, он берет содержимое переменной <blockquote>timeofday</blockquote> и сравнивает его поочередно с каждой строкой-образцом. Как только строка совпадает с введенной информацией, оператор <blockquote>case</blockquote> выполняет код, следующий за <blockquote>)</blockquote>, и завершается.</p>     <p>Оператор <blockquote>case</blockquote> выполняет обычную подстановку в строках, которые он использует для сравнения. Следовательно, вы можете задать часть строки с последующим метасимволом <blockquote>*</blockquote>. Применение единственного символа <blockquote>*</blockquote> будет соответствовать совпадению с любой введенной строкой, поэтому поместите этот вариант после всех остальных образцов строк для того, чтобы задать некоторое стандартное поведение оператора <blockquote>case</blockquote>, если не будут найдены совпадения с другими строками-образцами. Это возможно, потому что оператор <blockquote>case</blockquote> сравнивает с каждой строкой-образцом поочередно. Он не ищет наилучшее соответствие, а всего лишь первое встретившееся. Условие, принятое по умолчанию, часто оказывается невыполнимым, поэтому применение метасимвола <blockquote>*</blockquote> может помочь в отладке сценариев.</p>     <b>Упражнение 2.7. Вариант 3: объединение образцов</b>     <p>Предыдущая версия конструкции case, безусловно, элегантнее варианта с множественными операторами <blockquote>if</blockquote>, но, объединив все образцы, можно создать более красивую версию.</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <p><blockquote>echo "Is it morning? Please answer yes or no "</blockquote></p>     <p><blockquote>read timeofday</blockquote></p>     <br>     <p><blockquote><i>case "$timeofday" in</i></blockquote></p>     <p><blockquote><i> yes | y | Yes | YES ) echo "Good Morning";;</i></blockquote></p>     <p><blockquote><i> n* | N*)              echo "Good Afternoon";;</i></blockquote></p>     <p><blockquote><i> * )                   echo "Sorry, answer not recognized";;</i></blockquote></p>     <p><blockquote><i>esac</i></blockquote></p>     <br>     <p><blockquote>exit 0</blockquote></p>     <p><b>Как это работает</b></p>     <p>Данный сценарий в операторе <blockquote>case</blockquote> использует несколько строк-образцов в каждой ветви, таким образом, <blockquote>case</blockquote> проверяет несколько разных строк для каждого возможного оператора. Этот прием делает сценарий короче и, как показывает практика, облегчает его чтение. Приведенный программный код также показывает, как можно использовать метасимвол <blockquote>*</blockquote>, несмотря на то, что он может соответствовать непредусмотренным образцам. Например, если пользователь введет строку <blockquote>never</blockquote>, она будет соответствовать образцу <blockquote>n*</blockquote>, и на экран будет выведено приветствие Good Afternoon (Добрый день), хотя такое поведение в сценарии не предусматривалось. Учтите также, что заключенный в кавычки знак подстановки <blockquote>*</blockquote> не действует.</p>     <b>Упражнение 2.8. Вариант 3: выполнение нескольких операторов</b>     <p>В заключение, для того чтобы сделать сценарий многократно используемым, вам необходимо использовать другое значение кода завершения в том случае, когда применяется образец по умолчанию для непонятного варианта ввода.</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>echo "Is it -morning? Please answer yes or no"</blockquote></p>     <p><blockquote>read timeofday</blockquote></p>     <br>     <p><blockquote><i>case "$timeofday" in</i></blockquote></p>     <p><blockquote><i> yes | y | Yes | YES )</i></blockquote></p>     <p><i><blockquote>  echo "Good Morning"</blockquote></i></p>     <p><blockquote><i>  echo "Up bright and early this morning"</i></blockquote></p>     <p><blockquote><i>  ;;</i></blockquote></p>     <p><blockquote><i> [nN]*)</i></blockquote></p>     <p><blockquote><i>  echo "Good Afternoon"</i></blockquote></p>     <p><blockquote><i>  ;;</i></blockquote></p>     <p><blockquote><i> *)</i></blockquote></p>     <p><blockquote><i>  echo "Sorry, answer not recognized"</i></blockquote></p>     <p><blockquote><i>  echo "Please answer yes or no"</i></blockquote></p>     <p><blockquote><i>  exit 1</i></blockquote></p>     <p><blockquote><i>  ;;</i></blockquote></p>     <p><blockquote><i>esac</i></blockquote></p>     <br>     <p><blockquote>exit 0</blockquote></p>     <p><b>Как это работает</b></p>     <p>Для демонстрации другого способа определения соответствия образцу в этом программном коде изменен вариант определения соответствия для ветви <blockquote>no</blockquote>. Также видно, как в каждой ветви оператора case может выполняться несколько операторов. Следует быть внимательным и располагать в операторе самые точные образцы строк первыми, а самые общие варианты образцов последними. Это очень важно, потому что оператор <blockquote>case</blockquote> выполняется, как только найдено первое, а не наилучшее соответствие. Если вы поставите ветвь <blockquote>*)</blockquote> первой, совпадение с этим образцом будет определяться всегда, независимо от варианта введенной строки.</p>     <blockquote>      <b>Примечание</b>      <p>Учтите, что сдвоенная точка с запятой <blockquote>;;</blockquote> перед служебным словом <blockquote>esac</blockquote> необязательна. В отличие от программирования на языке С, в котором пропуск маркера завершения считается плохим стилем программирования, пропуск <blockquote>;;</blockquote> не создает проблем, если последняя ветвь оператора <blockquote>case</blockquote> — это вариант, принятый по умолчанию, поскольку другие образцы уже не будут анализироваться.</p>     </blockquote>     <p>Для того чтобы сделать средства установления соответствия образцам более мощными, можно применять следующие строки-образцы:</p>     <p><blockquote>[yY] | [Yy][Ее][Ss])</blockquote></p>     <p>В них ограничен набор разрешенных букв, но при этом допускаются разнообразные ответы и предлагается более строгий контроль, чем при применении метасимвола <blockquote>*</blockquote>.</p>     <b>Списки</b>     <p>Иногда может понадобиться сформировать последовательность команд. Например, вы хотите выполнить оператор, только если удовлетворяется несколько условий.</p>     <p><blockquote>if [ -f this_file ]; then</blockquote></p>     <p><blockquote> if [ -f that_file ]; then</blockquote></p>     <p><blockquote>  if [ -f the_other_file ]; then</blockquote></p>     <p><blockquote>   echo "All files present, and correct"</blockquote></p>     <p><blockquote>  fi</blockquote></p>     <p><blockquote> fi</blockquote></p>     <p><blockquote>fi</blockquote></p>     <p>Или вы хотите, чтобы хотя бы одно условие из последовательности условий было истинным.</p>     <p><blockquote>if [ -f this_file ]; then</blockquote></p>     <p><blockquote> foo="True"</blockquote></p>     <p><blockquote>elif [ -f that_file ]; then</blockquote></p>     <p><blockquote> foo="True"</blockquote></p>     <p><blockquote>elif [ -f the_other_file ];</blockquote></p>     <p><blockquote> then foo="True"</blockquote></p>     <p><blockquote>else</blockquote></p>     <p><blockquote> foo="False"</blockquote></p>     <p><blockquote>fi</blockquote></p>     <p><blockquote>if ["$foo" = "True" ]; then</blockquote></p>     <p><blockquote> echo "One of the files exists"</blockquote></p>     <p><blockquote>fi</blockquote></p>     <p>Несмотря на то, что это можно реализовать с помощью нескольких операторов <blockquote>if</blockquote>, как видите, результаты получаются очень громоздкими. В командной оболочке есть пара специальных конструкций для работы со списками команд: И-список (AND list) и ИЛИ-список (OR list). Обе они часто применяются вместе, но мы рассмотрим синтаксическую запись каждой из них отдельно.</p>     <b>И-cписок</b>     <p>Эта конструкция позволяет выполнять последовательность команд, причем каждая последующая выполняется только при успешном завершении предыдущей. Синтаксическая запись такова:</p>     <p><i><blockquote><i>оператор1 </i><b>&amp;&amp;</b><i> оператор2 </i><b>&amp;&amp;</b><i> оператор3</i>  <b>&amp;&amp;</b> ...</blockquote></i></p>     <p>Выполнение операторов начинается с самого левого, если он возвращает значение <blockquote>true</blockquote> (истина), выполняется оператор, расположенный справа от первого оператора. Выполнение продолжается до тех пор, пока очередной оператор не вернет значение <blockquote>false</blockquote> (ложь), после чего никакие операторы списка не выполняются. Операция <blockquote>&amp;&amp;</blockquote>проверяет условие предшествующей команды.</p>     <p>Каждый оператор выполняется независимо, позволяя соединять в одном списке множество разных команд, как показано в приведенном далее сценарии. И-список успешно обрабатывается, если все команды выполнены успешно, в противном случае его обработка заканчивается неудачно.</p>     <p>Выполните упражнение 2.9.</p>     <b>Упражнение 2.9. И-списки</b>     <p>В следующем сценарии вы обращаетесь к файлу file_one (для проверки его наличия, и если файл не существует, создаете его) и затем удаляете файл file_two. Далее И-список проверяет наличие каждого файла и между делом выводит на экран кое-какой текст.</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>touch file_one</blockquote></p>     <p><blockquote>rm -f file_two</blockquote></p>     <br>     <p><blockquote>if [ -f file_one ] &amp;&amp; echo "hello" [ -f file_two ] &amp;&amp; echo " there"</blockquote></p>     <p><blockquote>then</blockquote></p>     <p><blockquote> echo "in if"</blockquote></p>     <p><blockquote>else</blockquote></p>     <p><blockquote> echo "in else"</blockquote></p>     <p><blockquote>fi</blockquote></p>     <br>     <p><blockquote>exit 0</blockquote></p>     <p>Попробуйте выполнить сценарий, и вы получите следующий вывод:</p>     <p><blockquote>hello</blockquote></p>     <p><blockquote>in else</blockquote></p>     <p><b>Как это работает</b></p>     <p>Команды <blockquote>touch</blockquote> и <blockquote>rm</blockquote> гарантируют, что файлы в текущем каталоге находятся в известном состоянии. Далее И-список выполняет команду <blockquote>[ -f file one ]</blockquote>, которая возвращает значение <blockquote>true</blockquote>, потому что вы только что убедились в наличии файла. Поскольку предыдущий оператор завершился успешно, теперь выполняется команда <blockquote>echo</blockquote>. Она тоже завершается успешно (<blockquote>echo</blockquote> всегда возвращает <blockquote>true</blockquote>). Затем выполняется третья проверка <blockquote>[ -f file_two ]</blockquote>. Она возвращает значение <blockquote>false</blockquote>, т.к. файл не существует. Поскольку последняя команда вернула <blockquote>false</blockquote>, заключительная команда <blockquote>echo</blockquote> не выполняется. В результате И-список возвращает значение <blockquote>false</blockquote>, поэтому в операторе <blockquote>if</blockquote> выполняется вариант <blockquote>else</blockquote>.</p>     <b>ИЛИ-список</b>     <p>Эта конструкция позволяет выполнять последовательность команд до тех пор, пока одна из них не вернет значение true, и далее не выполняется ничего более. У нее следующая синтаксическая запись:</p>     <p><blockquote><i>оператор1 </i><b>||</b><i> оператор2 </i><b>||</b><i> оператор3 </i><b>||</b><i> ...</i></blockquote></p>     <p>Операторы выполняются слева направо. Если очередной оператор возвращает значение <blockquote>false</blockquote>, выполняется следующий за ним оператор. Это продолжается до тех пор, пока очередной оператор не вернет значение <blockquote>true</blockquote>, после этого никакие операторы уже не выполняются.</p>     <p>ИЛИ-список очень похож на И-список, за исключением того, что правило для выполнения следующего оператора — выполнение предыдущего оператора со значением <blockquote>false</blockquote>.</p>     <p>Рассмотрим упражнение 2.10.</p>     <b>Упражнение 2.10. ИЛИ-списки</b>     <p>Скопируйте сценарий из предыдущего упражнения и измените затененные строки следующим образом.</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote><i>rm -f file_one</i></blockquote></p>     <br>     <p><blockquote><i>if [ -f file_one ] || echo "hello" || echo " there" then</i></blockquote></p>     <p><blockquote> echo "in if"</blockquote></p>     <p><blockquote>else</blockquote></p>     <p><blockquote> echo "in else"</blockquote></p>     <p><blockquote>fi</blockquote></p>     <br>     <p><blockquote>exit 0</blockquote></p>     <p>В результате выполнения данного сценария будет получен следующий вывод:</p>     <p><blockquote>hello</blockquote></p>     <p><blockquote>in if</blockquote></p>     <p><b>Как это работает</b></p>     <p>В первых двух строках просто задаются файлы для остальной части сценария. Первая команда списка <blockquote>[ -f file one ]</blockquote> возвращает значение <blockquote>false</blockquote>, потому что файла в каталоге нет. Далее выполняется команда <blockquote>echo</blockquote>. Вот это да — она возвращает значение <blockquote>true</blockquote>, и больше в ИЛИ-списке не выполняются никакие команды. Оператор <blockquote>if</blockquote> получает из списка значение true, поскольку одна из команд ИЛИ-списка (команда <blockquote>echo</blockquote>) вернула это значение.</p>     <p>Результат, возвращаемый обоими этими списками, — это результат последней выполненной команды списка.</p>     <p>Описанные конструкции списков выполняются так же, как аналогичные конструкции в языке С, когда проверяются множественные условия. Для определения результата выполняется минимальное количество операторов. Операторы, не влияющие на конечный результат, не выполняются. Обычно этот подход называют<i> оптимизацией вычислений</i> (short circuit evaluation).</p>     <p>Комбинирование этих двух конструкций — высшее блаженство для любителей логических задач. Попробуйте проанализировать следующий список:</p>     <p><blockquote>[ -f file_one ] &amp;&amp;<i> команда в случае true</i> ||<i> команда в случае false</i></blockquote></p>     <p>В нем будет выполняться первая команда в случае истинности проверки и вторая команда в противном случае. Всегда лучше всего поэкспериментировать с этими довольно необычными списками, и, как правило, вам придется использовать скобки для изменения порядка вычислений.</p>     <b>Операторные блоки</b>     <p>Если вы хотите применить несколько операторов в том месте программного кода, где разрешен только один, например в ИЛИ-списке или И-списке, то можете сделать это, заключив операторы в фигурные скобки <blockquote>{}</blockquote> и создав тем самым<i> операторный блок.</i> Например, в приложении, представленном далее в этой главе, вы увидите следующий фрагмент программного кода:</p>     <p><blockquote>get_confirm &amp;&amp; {</blockquote></p>     <p><blockquote> grep -v "$cdcatnum" $tracks_file &gt; $temp_file</blockquote></p>     <p><blockquote> cat $temp_file &gt; $tracks_file</blockquote></p>     <p><blockquote> echo</blockquote></p>     <p><blockquote> add record_tracks</blockquote></p>     <p><blockquote>}</blockquote></p>             <a name="metkadoc17"><h1>Функции</h1></a>     <p>В командной оболочке можно определять функции, и, если вы пишете сценарии любого размера, функции можно применять для структурирования кода.</p>     <blockquote>      <b>Примечание</b>      <p>Как альтернативу можно использовать разбиение большого сценария на много маленьких, каждый из которых выполняет небольшую задачу. У этого подхода есть несколько недостатков: выполнение вложенного в сценарий другого сценария будет гораздо медленнее, чем выполнение функции. Значительно труднее возвращать результаты, и может появиться большое количество маленьких сценариев. Следует рассмотреть наименьшую практически самостоятельную часть вашего сценария и использовать ее как эталон для того, чтобы определить, когда возникает необходимость разбиения большого сценария на коллекцию меньших по размеру сценариев.</p>     </blockquote>     <p>Для определения функции в командной оболочке просто введите ее имя и следом за ним пустые круглые скобки, а операторы тела функции заключите в фигурные скобки.</p>     <p><blockquote><i>Имя_функции</i>() {</blockquote></p>     <p><blockquote><i>операторы</i></blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Выполните упражнения 2.11 и 2.12.</p>     <b>Упражнение 2.11. Простая функция</b>     <p>Давайте начнем с действительно простой функции.</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>foo() {</blockquote></p>     <p><blockquote> echo "Function foo is executing"</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote>echo "script starting"</blockquote></p>     <p><blockquote>foo</blockquote></p>     <p><blockquote>echo "script ended"</blockquote></p>     <p><blockquote>exit 0</blockquote></p>     <p>Выполняющийся сценарий, выведет на экран следующий текст:</p>     <p><blockquote>script starting</blockquote></p>     <p><blockquote>Function foo is executingscript ended</blockquote></p>     <p><b>Как это работает</b></p>     <p>Данный сценарий начинает выполняться с первой строки. Таким образом, ничего необычного нет, но, когда он находит конструкцию <blockquote>foo() {</blockquote>, он знает, что здесь дается определение функции, названной <blockquote>foo</blockquote>. Он запоминает ссылку на функцию и foo продолжает выполнение после обнаружения скобки <blockquote>}</blockquote>. Когда выполняется строка с единственным именем <blockquote>foo</blockquote>, командная оболочка знает, что нужно выполнить предварительно определенную функцию. Когда функция завершится, выполнение сценария продолжится в строке, следующей за вызовом функции <blockquote>foo</blockquote>.</p>     <p>Вы должны всегда определить функцию прежде, чем сможете ее запустить, немного похоже на стиль, принятый в языке программирования Pascal, когда вызову функции предшествует ее определение, за исключением того, что в командной оболочке нет опережающего объявления (forward) функции. Это ограничение не создает проблем, потому что все сценарии выполняются с первой строки, поэтому если просто поместить все определения функций перед первым вызовом любой функции, все функции окажутся определенными до того, как будут вызваны.</p>     <p>Когда функция вызывается, позиционные параметры сценария <blockquote>$*</blockquote>, <blockquote>$@</blockquote>, <blockquote>$#</blockquote>, <blockquote>$1</blockquote>, <blockquote>$2</blockquote> и т.д. заменяются параметрами функции. Именно так вы считываете параметры, передаваемые функции. Когда функция завершится, они восстановят свои прежние значения.</p>     <blockquote>      <b>Примечание</b>      <p>Некоторые более ранние командные оболочки не могут восстанавливать значения позиционных параметров после выполнения функций. Не стоит полагаться на описанное в предыдущем абзаце поведение, если вы хотите, чтобы ваши сценарии были переносимыми.</p>     </blockquote>     <p>Вы можете заставить функцию возвращать числовые значения с помощью команды <blockquote>return</blockquote>. Обычный способ возврата функцией строковых значений — сохранение строки в переменной, которую можно использовать после завершения функции. Другой способ — вывести строку с помощью команды <blockquote>echo</blockquote> и перехватить результат, как показано далее.</p>     <p><blockquote>foo() { echo JAY;}</blockquote></p>     <p><blockquote>...</blockquote></p>     <p><blockquote>result="$(foo)"</blockquote></p>     <p>Вы можете объявлять локальные переменные в функциях командной оболочки с помощью ключевого слова <blockquote>local</blockquote>. В этом случае переменная действительна только в пределах функции. В других случаях функция может обращаться к переменным командной оболочки, у которых глобальная область действия. Если у локальной переменной то же имя, что и у глобальной, в пределах функции локальная переменная перекрывает глобальную. Для того чтобы убедиться в этом на практике, можно изменить предыдущий сценарий следующим образом.</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote><i>sample_text="global variable" </i></blockquote></p>     <br>     <p><blockquote>foo() {</blockquote></p>     <p><blockquote> local sample_text="local variable"</blockquote></p>     <p><blockquote> echo "Function foo is executing"</blockquote></p>     <p><blockquote><i> echo $sample_text</i></blockquote></p>     <p><blockquote>}</blockquote></p>     <p><blockquote>echo "script starting"</blockquote></p>     <p><blockquote><i>echo $sample_text</i></blockquote></p>     <br>     <p><blockquote>foo</blockquote></p>     <br>     <p><blockquote>echo "script ended"</blockquote></p>     <p><blockquote><i>echo $sample_text</i></blockquote></p>     <br>     <p><blockquote>exit 0</blockquote></p>     <p>При отсутствии команды <blockquote>return</blockquote>, задающей возвращаемое значение, функция возвращает статус завершения последней выполненной команды,</p>     <b>Упражнение 2.12. Возврат значения</b>     <p>В следующем сценарии, my_name, показано, как в функцию передаются параметры и как функции могут вернуть логический результат <blockquote>true</blockquote> или <blockquote>false</blockquote>. Вы можете вызвать этот сценарий с параметром, задающим имя, которое вы хотите использовать в вопросе.</p>     <p>1. После заголовка командной оболочки определите функцию <blockquote>yes_or_no</blockquote>.</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>yes_or_no() {</blockquote></p>     <p><blockquote> echo "Is your name $* ? "</blockquote></p>     <p><blockquote> while true</blockquote></p>     <p><blockquote> do</blockquote></p>     <p><blockquote>  echo -n "Enter yes or no: "</blockquote></p>     <p><blockquote>  read x</blockquote></p>     <p><blockquote>  case "$x" in</blockquote></p>     <p><blockquote>   y | yes ) return 0;;</blockquote></p>     <p><blockquote>   n | no )  return 1;;</blockquote></p>     <p><blockquote>   * )       echo "Answer yes or no"</blockquote></p>     <p><blockquote>  esac</blockquote></p>     <p><blockquote> done</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>2. Далее начинается основная часть программы.</p>     <p><blockquote>echo "Original parameters are $*"</blockquote></p>     <p><blockquote>if yes_or_no "$1"</blockquote></p>     <p><blockquote>then</blockquote></p>     <p><blockquote> echo "Hi $1, nice name"</blockquote></p>     <p><blockquote>else</blockquote></p>     <p><blockquote> echo "Never mind"</blockquote></p>     <p><blockquote>fi</blockquote></p>     <p><blockquote>exit 0</blockquote></p>     <p>Типичный вывод этого сценария может выглядеть следующим образом:</p>     <p><blockquote>$ <b>./my_name Rick Neil</b></blockquote></p>     <p><blockquote>Original parameters are Rick Neil</blockquote></p>     <p><blockquote>Is your name Rick ?</blockquote></p>     <p><blockquote>Enter yes or no:<b> yes</b></blockquote></p>     <p><blockquote>Hi Rick, nice name</blockquote></p>     <p><blockquote>$</blockquote></p>     <p><b>Как это работает</b></p>     <p>Когда сценарий начинает выполняться, функция определена, но еще не выполняется. В операторе <blockquote>if</blockquote> сценарий вызывает функцию <blockquote>yes_or_no</blockquote>, передавая ей оставшуюся часть строки как параметры после замены <blockquote>$1</blockquote> первым параметром исходного сценария строкой <blockquote>Rick</blockquote>. Функция использует эти параметры, в данный момент хранящиеся в позиционных параметрах <blockquote>$1</blockquote>, <blockquote>$2</blockquote> и т.д., и возвращает значение в вызывающую программу. В зависимости от возвращенного функцией значения конструкция <blockquote>if</blockquote> выполняет один из операторов.</p>     <p>Как видите, у командной оболочки есть большой набор управляющих структур и условных операторов. Вам необходимо познакомиться с некоторыми командами, встроенными в оболочку; после этого вы будете готовы решать реальные программистские задачи без компилятора под рукой!</p>             <a name="metkadoc18"><h1>Команды</h1></a>     <p>В сценариях командной оболочки можно выполнять два сорта команд. Как уже упоминалось, существуют "обычные" команды, которые могут выполняться и из командной строки (называемые<i> внешними командами</i>), и встроенные команды (называемые<i> внутренними командами</i>). Внутренние команды реализованы внутри оболочки и не могут вызываться как внешние программы. Но большинство внутренних команд представлено и в виде автономных программ, это условие — часть требований стандарта POSIX. Обычно, не важно, команда внешняя или внутренняя, за исключением того, что внутренние команды действуют эффективнее.</p>     <p>В этом разделе представлены основные команды, как внутренние, так и внешние, которые мы используем при написании сценариев. Как пользователь ОС Linux, вы, возможно, знаете много других команд, которые принимает командная строка. Всегда помните о том, что вы можете любую из них применить в сценарии в дополнение к встроенным командам, представленным в данном разделе.</p>     <b><i>break</i></b>     <p>Используйте команду <blockquote>break</blockquote> для выхода из циклов <blockquote>for</blockquote>, <blockquote>while</blockquote> и <blockquote>until</blockquote> до того, как будет удовлетворено управляющее условие. В команде <blockquote>break</blockquote> можно задать дополнительный числовой параметр, указывающий на число циклов, из которых предполагается выход. Однако это может сильно усложнить чтение сценариев, поэтому мы не советуем вам использовать его. По умолчанию <blockquote>break</blockquote> обеспечивает выход из одного цикла.</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>rm -rf fred*</blockquote></p>     <p><blockquote>echo &gt; fred1</blockquote></p>     <p><blockquote>echo &gt; fred2</blockquote></p>     <p><blockquote>mkdir fred3</blockquote></p>     <p><blockquote>echo &gt; fred4</blockquote></p>     <br>     <p><blockquote>for file in fred*</blockquote></p>     <p><blockquote>do</blockquote></p>     <p><blockquote> if [ -d "$file" ]; then</blockquote></p>     <p><blockquote>  break;</blockquote></p>     <p><blockquote> fi</blockquote></p>     <p><blockquote>done</blockquote></p>     <br>     <p><blockquote>echo first directory starting fred was $file</blockquote></p>     <br>     <p><blockquote>m -rf fred*</blockquote></p>     <p><blockquote>exit 0</blockquote></p>     <b>Команда :</b>     <p>Команда "двоеточие" — фиктивная команда. Она иногда полезна для упрощения логики в условиях, будучи псевдонимом команды <blockquote>true</blockquote>. Поскольку команда <blockquote>:</blockquote> встроенная, она выполняется быстрее, чем <blockquote>true</blockquote>, хотя ее вывод гораздо менее читабелен.</p>     <p>Вы можете найти эту команду в условии для циклов <blockquote>while</blockquote>. Конструкция <blockquote>while :</blockquote> выполняет бесконечный цикл вместо более общего <blockquote>while true</blockquote>.</p>     <p>Конструкция <blockquote>:</blockquote> также полезна для условного задания переменных. Например,</p>     <p><blockquote>: ${var:=value}</blockquote></p>     <p>Без <blockquote>:</blockquote> командная оболочка попытается интерпретировать <blockquote>$var</blockquote> как команду.</p>     <blockquote>      <b>Примечание</b>      <p>В некоторых более старых версиях сценариев командной оболочки можно встретить двоеточие, применяемое в начале строки для обозначения комментариев, однако в современных сценариях следует всегда применять для обозначения начала комментариев знак <blockquote>#</blockquote>, поскольку этот вариант действует эффективнее<b>.</b></p>     </blockquote>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>rm -f fred</blockquote></p>     <p><blockquote>if [ -f fred ]; then</blockquote></p>     <p><blockquote> :</blockquote></p>     <p><blockquote>else</blockquote></p>     <p><blockquote> echo file fred did not exist</blockquote></p>     <p><blockquote>fi</blockquote></p>     <br>     <p><blockquote>exit 0</blockquote></p>     <b><i>continue</i></b>     <p>Как и одноименный оператор языка С, эта команда заставляет охватывающий ее цикл <blockquote>for</blockquote>, <blockquote>while</blockquote> или <blockquote>until</blockquote> начать новый проход или следующую итерацию. При этом переменная цикла принимает следующее значение в списке.</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>rm -rf fred*</blockquote></p>     <p><blockquote>echo &gt; fred1</blockquote></p>     <p><blockquote>echo &gt; fred2</blockquote></p>     <p><blockquote>mkdir fred3</blockquote></p>     <p><blockquote>echo &gt; fred4</blockquote></p>     <br>     <p><blockquote>for file in fred*</blockquote></p>     <p><blockquote>do</blockquote></p>     <p><blockquote> if [ -d "$file" ]; then</blockquote></p>     <p><blockquote>  echo "skipping directory $file"</blockquote></p>     <p><blockquote>  continue</blockquote></p>     <p><blockquote> fi</blockquote></p>     <p><blockquote> echo file is $file</blockquote></p>     <p><blockquote>done</blockquote></p>     <br>     <p><blockquote>rm -rf fred*</blockquote></p>     <p><blockquote>exit 0</blockquote></p>     <p>Команда <blockquote>continue</blockquote> может принимать в качестве необязательного параметра номер прохода охватывающего цикла, с которого следует возобновить выполнение цикла.</p>     <p>Таким образом, вы сможете иногда выскочить из вложенных циклов. Данный параметр редко применяется, т.к. он часто сильно затрудняет понимание сценариев. Например,</p>     <p><blockquote>for x in 1 2 3</blockquote></p>     <p><blockquote>do</blockquote></p>     <p><blockquote> echo before $x</blockquote></p>     <p><blockquote> continue 1</blockquote></p>     <p><blockquote> echo after $x</blockquote></p>     <p><blockquote>done</blockquote></p>     <p>У приведенного фрагмента будет следующий вывод:</p>     <p><blockquote>before 1</blockquote></p>     <p><blockquote>before 2</blockquote></p>     <p><blockquote>before 3</blockquote></p>     <b>Команда .</b>     <p>Команда "точка" (<blockquote>.</blockquote>) выполняет команду в текущей оболочке:</p>     <p><blockquote>. ./shell_script</blockquote></p>     <p>Обычно, когда сценарий выполняет внешнюю команду или сценарий, создается новое окружение (подоболочка), команда выполняется в новом окружении и затем окружение удаляется, за исключением кода завершения, который возвращается в родительскую оболочку. Внешняя команда source и команда "точка" (еще два синонима) выполняют команды, приведенные в сценарии, в той же командной оболочке, которая выполняет сценарий.</p>     <p>Поскольку по умолчанию во время работы сценария создается новое окружение, любые изменения переменных окружения, сделанные в сценарии, теряются. С другой стороны, команда "точка" позволяет выполняющемуся сценарию изменять текущее окружение. Это часто бывает полезно, когда сценарий применяется как оболочка для настройки окружения, предназначенного для последующего выполнения какой-либо другой команды. Например, когда вы работаете над несколькими разными проектами одновременно, может оказаться, что вам необходимо выполнять команды с разными параметрами, например, запускать более старую версию компилятора для поддержки старой программы.</p>     <p>В сценариях командной оболочки команда "точка" играет роль, немного похожую на роль директивы #include в языках программирования С и С++. И хотя она не подключает сценарий в буквальном смысле слова, она действительно выполняет команду в текущем контексте, поэтому вы можете применять ее для включения переменных и определений функций в ваш сценарий.</p>     <p>Выполните упражнение 2.13.</p>     <b>Упражнение 2.13. Команда точка</b>     <p>В следующем примере команда "точка" применяется в командной строке, но с таким же успехом вы можете использовать ее и в сценарии.</p>     <p>1. Предположим, что у вас есть два файла, содержащие параметры окружения для двух разных сред разработки. Для установки окружения, предназначенного для старых классических команд, classic_set, можно применить следующий программный код.</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>version=classic</blockquote></p>     <p><blockquote>PATH=/usr/local/old_bin:/usr/bin:/bin:</blockquote></p>     <p><blockquote>.</blockquote></p>     <p><blockquote>PS1="classic&gt; "</blockquote></p>     <p>2. Для новых команд применяется latest_set.</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>version=latest</blockquote></p>     <p><blockquote>PATH=/usr/local/new_bin:/usr/bin:/bin:</blockquote></p>     <p><blockquote>.</blockquote></p>     <p><blockquote>PS1=" latest version&gt; "</blockquote></p>     <p>Вы можете установить окружение, применяя эти сценарии в сочетании с командой "точка", как показано в следующей порции примера.</p>     <p><blockquote>$ <b>. ./classic_set</b></blockquote></p>     <p><blockquote>classic&gt; <b>echo $version</b></blockquote></p>     <p><blockquote>classic</blockquote></p>     <p><blockquote>classic&gt; <b>. /latest_set</b></blockquote></p>     <p><blockquote>latest version&gt; <b>echo $version</b></blockquote></p>     <p><blockquote>latest</blockquote></p>     <p><blockquote>latest version&gt;</blockquote></p>     <p><b>Как это работает</b></p>     <p>Сценарии выполняются, используя команду "точка", поэтому каждый из них выполняется в текущей командной оболочке. Это позволяет сценарию изменять параметры окружения в текущей оболочке, которая сохраняет изменения даже после того, как сценарий завершился.</p>     <b><i>echo</i></b>     <p>Несмотря на призыв группы Х/Open применять в современных командных оболочках команду <blockquote>printf</blockquote>, мы будем продолжать следовать общепринятой практике использования команды <blockquote>echo</blockquote> для вывода строки с последующим переходом на новую строку.</p>     <p>При этом возникает общая проблема: удаление символа перехода на новую строку. К сожалению, в разных версиях ОС UNIX реализованы разные решения. В ОС Linux общепринятый метод</p>     <p><blockquote>echo -n "string to output"</blockquote></p>     <p>Но вы часто будете сталкиваться и с вариантом</p>     <p><blockquote>echo -е "string to output\c"</blockquote></p>     <p>Второй вариант <blockquote>echo -е</blockquote> рассчитан на то, что задействована интерпретация символов escape-последовательности, начинающихся с обратного слэша, таких как <blockquote>\c</blockquote> для подавления новой строки, <blockquote>\t</blockquote> для вывода табуляции, <blockquote>\n</blockquote> для вывода символов возврата каретки. В более старых версиях bash этот режим установлен по умолчанию, а в более современных версиях интерпретация символов escape-последовательностей с обратным слэшем отключена. Подробные сведения о поведении вашего дистрибутива ищите на страницах интерактивного справочного руководства.</p>     <blockquote>      <b>Примечание</b>      <p>Если вам нужен легко переносимый способ удаления завершающей новой строки, для избавления от нее можно воспользоваться внешней командой <blockquote>tr</blockquote>, но она будет выполняться немного медленнее. Если вашим системам UNIX нужна переносимость и нужно избавиться от завершающей новой строки, как правило, лучше придерживаться команды <blockquote>printf</blockquote>. Если ваши сценарии предназначены для работы только в ОС Linux и bash, вполне подойдет <blockquote>echo -n</blockquote>, хотя, возможно, придется начинать файл со строки <blockquote>#!/bin/bash</blockquote> для того, чтобы в явной форме показать, что вы рассчитываете на поведение в стиле bash.</p>     </blockquote>     <b><i>eval</i></b>     <p>Команда eval позволяет вычислять аргументы. Она встроена в командную оболочку и обычно не представлена как отдельная команда. Лучше всего ее действие демонстрирует короткий пример, позаимствованный непосредственно из стандарта X/Open.</p>     <p><blockquote>foo=10</blockquote></p>     <p><blockquote>x=foo</blockquote></p>     <p><blockquote>у='$'$х</blockquote></p>     <p><blockquote>echo $у</blockquote></p>     <p>Будет выведено <blockquote>$foo</blockquote>. Однако код</p>     <p><blockquote>foo=10</blockquote></p>     <p><blockquote>x=foo</blockquote></p>     <p><blockquote>eval у='$'$х</blockquote></p>     <p><blockquote>echo $у</blockquote></p>     <p>выведет на экран 10. Таким образом, <blockquote>eval</blockquote> немного похожа на дополнительный знак <blockquote>$</blockquote>: она возвращает значение значения переменной.</p>     <p>Команда <blockquote>eval</blockquote> очень полезна, т.к. позволяет генерировать и выполнять код на лету. Применение этой команды усложняет отладку сценария, но разрешает делать то, что в противном случае выполнить сложно или даже невозможно.</p>     <b><i>exec</i></b>     <p>У команды <blockquote>exec</blockquote> два варианта применения. Обычно ее используют для замены текущей командной оболочки другой программой.</p>     <p>Например, строка</p>     <p><blockquote>exec wall "Thanks for all the fish"</blockquote></p>     <p>в сценарии заменит текущую оболочку командой <blockquote>wall</blockquote>. Строки, следующие за командой <blockquote>exec</blockquote>, не обрабатываются, потому что командная оболочка, выполнявшая сценарий, больше не существует.</p>     <p>Второй вариант применения <blockquote>exec</blockquote> — модификация текущих дескрипторов файлов.</p>     <p><blockquote>exec 3&lt; afile</blockquote></p>     <p>Эта команда открывает файловый дескриптор 3 для чтения из файла afile. Этот вариант редко используется.</p>     <b><i>exit n</i></b>     <p>Команда <blockquote>exit</blockquote> вызывает завершение сценария с кодом завершения <i><blockquote><i>n</i></blockquote>.</i> Если вы примените ее в строке подсказки или приглашения любой интерактивной командной оболочки, она приведет к вашему выходу из системы. Если разрешить сценарию завершиться без указания кода завершения, статус последней выполненной в сценарии команды используется как возвращаемое значение. Задание кода завершения считается хорошим стилем программирования.</p>     <p>При программировании сценариев в командной оболочке код завершения 0 — успешное завершение сценария, коды от 1 до 125 включительно — коды ошибок, которые можно использовать в сценариях. Оставшиеся значения зарезервированы в соответствии с табл. 2.5.</p>     <br>     <p><b><i>Таблица 2.5</i></b></p>     <table>      <tr>       <th valign="top">Код завершения</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top">126</td>       <td valign="top">Файл не является исполняемым</td>      </tr>      <tr>       <td valign="top">127</td>       <td valign="top">Команда не найдена</td>      </tr>      <tr>       <td valign="top">128 и выше</td>       <td valign="top">Появившийся сигнал</td>      </tr>     </table>     <p>Многим программистам на языках С и С++ использование нуля как признака успешного завершения может показаться несколько необычным. Большое преимущество сценариев — возможность применения 125 кодов ошибок, определенных пользователем, и отсутствие необходимости в глобальной переменной для хранения кода ошибки.</p>     <p>Далее приведен простой пример, возвращающий код успешного завершения, если в текущем каталоге существует файл с именем .profile.</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>if [ -f .profile ]; then</blockquote></p>     <p><blockquote> exit 0</blockquote></p>     <p><blockquote>fi</blockquote></p>     <p><blockquote>exit 1</blockquote></p>     <p>Если вы любитель острых ощущений или, как минимум, лаконичных сценариев, можете переписать сценарий в виде одной строки, используя комбинацию И-списка и ИЛИ-списка, описанных ранее:</p>     <p><blockquote>[ -f .profile ] &amp;&amp; exit 0 || exit 1</blockquote></p>     <b><i>export</i></b>     <p>Команда <blockquote>export</blockquote> делает переменную, называемую ее параметром, доступной в подоболочках. По умолчанию переменные, созданные в командной оболочке, не доступны в новых дочерних подоболочках, запускаемых из данной. Команда <blockquote>export</blockquote> создает из своего параметра переменную окружения, которая видна другим сценариям и программам, запускаемым из текущей программы. Говоря профессиональным языком, экспортируемые переменные формируют переменные окружения в любых дочерних процессах, порожденных командной оболочкой. Лучше всего проиллюстрировать это примером из двух сценариев: <blockquote>export1</blockquote> и <blockquote>export2</blockquote> (упражнение 2.14).</p>     <b>Упражнение 2.14. Экспорт переменных</b>     <p>1. Первым представим сценарий export2.</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>echo "$foo"</blockquote></p>     <p><blockquote>echo "$bar"</blockquote></p>     <p>2. Теперь сценарий export1. В конце сценария запускается export2.</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>foo="The first meta-syntactic variable"</blockquote></p>     <p><blockquote>export bar="The second meta-syntactic variable"</blockquote></p>     <p><blockquote>export2</blockquote></p>     <p>Если вы запустите их, то получите следующий результат.</p>     <p><blockquote>$ <b>./export1</b></blockquote></p>     <p><blockquote>The second meta-syntactic variable</blockquote></p>     <p><blockquote>$</blockquote></p>     <p><b>Как это работает</b></p>     <p>Сценарий export2 просто выводит значения двух переменных. В сценарии export1 задаются значения обеих переменных, но только переменная bar помечается как экспортируемая, поэтому, когда впоследствии запускается сценарий export2, значение переменной <blockquote>foo</blockquote> потеряно, а значение переменной <blockquote>bar</blockquote> экспортировано во второй сценарий. На экране появляется пустая строка, поскольку <blockquote>$foo</blockquote> ничего не содержит и вывод переменной со значением <blockquote>null</blockquote> приводит к отображению новой строки.</p>     <p>После того как переменная была экспортирована из командной оболочки, она экспортируется в любые сценарии, запускаемые из этой оболочки, и в любые командные оболочки, которые в свою очередь запускают эти сценарии, и т.д. Если бы сценарий export2 вызвал другой сценарий, в нем переменная <blockquote>bar</blockquote> также была бы доступна.</p>     <blockquote>      <b>Примечание</b>      <p>Команды <blockquote>set -а</blockquote> или <blockquote>set -allexport</blockquote> экспортируют все переменные соответственно.</p>     </blockquote>     <b><i>expr</i></b>     <p>Команда <blockquote>expr</blockquote> вычисляет выражение, составленное из ее аргументов. Чаще всего она применяется для подсчета простых арифметических выражений в следующем виде:</p>     <p><blockquote>х=`expr $x + 1`</blockquote></p>     <p>Символы <blockquote>``</blockquote> (обратная кавычка или обратный апостроф) заставляют переменную <blockquote>х</blockquote> принять результат выполнения команды <blockquote>expr $х + 1</blockquote>. Ее можно также записать с помощью синтаксической конструкции <blockquote>$( )</blockquote> вместо обратной кавычки, например, следующим образом:</p>     <p><blockquote>х=$(expr $х + 1)</blockquote></p>     <p>Команда expr обладает большими возможностями, с ее помощью можно вычислять различные выражения. Основные виды вычислений перечислены в табл. 2.6.</p>     <br>     <p><b><i>Таблица 2.6</i></b></p>     <table>      <tr>       <th valign="top">Вычисление выражения</th>       <th valign="top">Описания</th>      </tr>      <tr>       <td valign="top"><blockquote><i>Выражение1 | Выражение2</i></blockquote></td>       <td valign="top"><blockquote><i>Выражение1</i></blockquote>, если<i> <blockquote>Выражение1</blockquote></i> не равно нулю, в противном случае<i> <blockquote>Выражение2</blockquote></i></td>      </tr>      <tr>       <td valign="top"><blockquote><i>Выражение1</i> &amp; <i>Выражение2</i></blockquote></td>       <td valign="top">Нуль, если оба выражения равны нулю, в противном случае<i> <blockquote>Выражение1</blockquote></i></td>      </tr>      <tr>       <td valign="top"><blockquote><i>Выражение1</i> = <i>Выражение2</i></blockquote></td>       <td valign="top">Равенство</td>      </tr>      <tr>       <td valign="top"><blockquote><i>Выражение1</i> &gt; <i>Выражение2</i></blockquote></td>       <td valign="top">Больше чем</td>      </tr>      <tr>       <td valign="top"><blockquote><i>Выражение1</i> &gt;= <i>Выражение2</i></blockquote></td>       <td valign="top">Больше или равно</td>      </tr>      <tr>       <td valign="top"><blockquote><i>Выражение1</i> &lt; <i>Выражение2</i></blockquote></td>       <td valign="top">Меньше чем</td>      </tr>      <tr>       <td valign="top"><blockquote><i>Выражение1</i> &lt;= <i>Выражение2</i></blockquote></td>       <td valign="top">Меньше или равно</td>      </tr>      <tr>       <td valign="top"><blockquote><i>Выражение1</i> != <i>Выражение2</i></blockquote></td>       <td valign="top">Неравенство</td>      </tr>      <tr>       <td valign="top"><blockquote><i>Выражение1</i> + <i>Выражение2</i></blockquote></td>       <td valign="top">Сложение</td>      </tr>      <tr>       <td valign="top"><blockquote><i>Выражение1</i> — <i>Выражение2</i></blockquote></td>       <td valign="top">Вычитание</td>      </tr>      <tr>       <td valign="top"><blockquote><i>Выражение1</i> * <i>Выражение2</i></blockquote></td>       <td valign="top">Умножение</td>      </tr>      <tr>       <td valign="top"><blockquote><i>Выражение1</i> / <i>Выражение2</i></blockquote></td>       <td valign="top">Деление нацело</td>      </tr>      <tr>       <td valign="top"><blockquote><i>Выражение1</i> % <i>Выражение2</i></blockquote></td>       <td valign="top">Остаток от деления нацело</td>      </tr>     </table>     <p>В современных сценариях вместо команды <blockquote>expr</blockquote> обычно применяется более эффективная синтаксическая конструкция <blockquote>$((...))</blockquote>, которая будет описана далее в этой главе.</p>     <b><i>printf</i></b>     <p>Команда <blockquote>printf</blockquote> есть только в современных командных оболочках. Группа X/Open полагает, что ее следует применять вместо команды <blockquote>echo</blockquote> для генерации форматированного вывода, несмотря на то, что, кажется, лишь немногие следуют этому совету.</p>     <p>У команды следующая синтаксическая запись.</p>     <p><blockquote><b>printf</b><i> "строка формата" параметр1 параметр2 ...</i></blockquote></p>     <p>Строка формата очень похожа с некоторыми ограничениями на применяемую в языках программирования С и С++. Главным образом не поддерживаются числа с плавающей точкой, поскольку все арифметические операции в командной оболочке выполняются над целыми числами. Строка формата состоит из произвольной комбинации литеральных символов, escape-последовательностей и спецификаторов преобразования. Все символы строки формата, отличающиеся от <blockquote>\</blockquote> и <blockquote>%</blockquote>, отображаются на экране при выводе.</p>     <p>В табл. 2.7 приведены поддерживаемые командой escape-последовательности.</p>     <br>     <p><b><i>Таблица 2.7</i></b></p>     <table>      <tr>       <th valign="top">Escape-последовательность</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>\"</blockquote></td>       <td valign="top">Двойная кавычка</td>      </tr>      <tr>       <td valign="top"><blockquote>\\</blockquote></td>       <td valign="top">Символ обратный слэш</td>      </tr>      <tr>       <td valign="top"><blockquote>\a</blockquote></td>       <td valign="top">Звуковой сигнал тревоги (звонок колокольчика или прерывистый звуковой сигнал)</td>      </tr>      <tr>       <td valign="top"><blockquote>\b</blockquote></td>       <td valign="top">Символ Backspace (стирание слева)</td>      </tr>      <tr>       <td valign="top"><blockquote>\c</blockquote></td>       <td valign="top">Отбрасывание последующего вывода</td>      </tr>      <tr>       <td valign="top"><blockquote>\f</blockquote></td>       <td valign="top">Символ Form feed (подача бумаги)</td>      </tr>      <tr>       <td valign="top"><blockquote>\n</blockquote></td>       <td valign="top">Символ перехода на новую строку</td>      </tr>      <tr>       <td valign="top"><blockquote>\r</blockquote></td>       <td valign="top">Возврат каретки</td>      </tr>      <tr>       <td valign="top"><blockquote>\t</blockquote></td>       <td valign="top">Символ табуляции</td>      </tr>      <tr>       <td valign="top"><blockquote>\v</blockquote></td>       <td valign="top">Символ вертикальной табуляции</td>      </tr>      <tr>       <td valign="top"><blockquote>\ooo</blockquote></td>       <td valign="top">Один символ с восьмеричным значением <blockquote>ooo</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>\xHH</blockquote></td>       <td valign="top">Один символ с шестнадцатеричным значением <blockquote>HH</blockquote></td>      </tr>     </table>     <p>Спецификаторы преобразований довольно сложны, поэтому мы приведем наиболее распространенные варианты их применения. Более подробную информацию можно найти в интерактивном справочном руководстве командной оболочки bash или на страницах раздела 1 интерактивного руководства к команде <blockquote>printf</blockquote> (<blockquote>man 1 printf</blockquote>). (Если вы не найдете нужных сведений в разделе 1, попробуйте поискать в разделе 3.) Спецификатор преобразования состоит из символа <blockquote>%</blockquote>, за которым следует символ преобразования. Основные варианты преобразований перечислены в табл. 2.8.</p>     <br>     <p><b><i>Таблица 2.8</i></b></p>     <table>      <tr>       <th valign="top">Символ преобразования</th>       <th valign="top"> Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>D</blockquote></td>       <td valign="top">Вывод десятичного числа</td>      </tr>      <tr>       <td valign="top"><blockquote>С</blockquote></td>       <td valign="top">Вывод символа</td>      </tr>      <tr>       <td valign="top"><blockquote>S</blockquote></td>       <td valign="top">Вывод строки</td>      </tr>      <tr>       <td valign="top"><blockquote>%</blockquote></td>       <td valign="top">Вывод знака <blockquote>%</blockquote></td>      </tr>     </table>     <p>Строка формата используется для интерпретации остальных параметров команды и вывода результата, как показано в следующем примере:</p>     <p><blockquote>$ <b>printf "%s\n" hello</b></blockquote></p>     <p><blockquote>hello</blockquote></p>     <p><blockquote>$ <b>printf "%s %d\t%s" "Hi There" 15 people</b></blockquote></p>     <p><blockquote>Hi There 15 people</blockquote></p>     <p>Обратите внимание на то, что для защиты строки <blockquote>Hi There</blockquote> и превращения ее в единый параметр, строку нужно заключить в кавычки (<blockquote>""</blockquote>).</p>     <b><i>return</i></b>     <p>Команда <blockquote>return</blockquote> служит для возврата значений из функций, как уже упоминалось ранее при обсуждении функций. Команда принимает один числовой параметр, который становится доступен в сценарии, вызывающем функцию. Если параметр не задан, команда <blockquote>return</blockquote> по умолчанию возвращает код завершения последней команды.</p>     <b><i>set</i></b>     <p>Команда <blockquote>set</blockquote> задает переменные-параметры командной оболочки. Она может быть полезна при использовании полей в командах, выводящих значения, разделенные пробелами.</p>     <p>Предположим, что вы хотите использовать в сценарии название текущего месяца. В системе есть команда <blockquote>date</blockquote>, содержащая название месяца в виде строки, но нужно отделить его от других полей. Это можно сделать с помощью комбинации команды <blockquote>set</blockquote> и конструкции <blockquote>$(...)</blockquote>, которые обеспечат выполнение команды <blockquote>date</blockquote> и возврат результата (более подробно об этом<i> см. далее</i>). В выводе команды date строка с названием месяца — второй параметр.</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>echo the date is $(date)</blockquote></p>     <p><blockquote>set $(date)</blockquote></p>     <p><blockquote>echo The month is $2</blockquote></p>     <br>     <p><blockquote>exit 0</blockquote></p>     <p>Программа задает список параметров для вывода команды <blockquote>date</blockquote> и затем использует позиционный параметр <blockquote>$2</blockquote> для получения названия месяца.</p>     <p>Мы использовали команду <blockquote>date</blockquote> только как простой пример, демонстрирующий, как извлекать позиционные параметры. Поскольку команда <blockquote>date</blockquote> зависит от языковых параметров или локализации, в действительности мы бы извлекли название месяца командой <blockquote>date +%B</blockquote>. У команды <blockquote>date</blockquote> много других вариантов форматирования, более подробную информацию см. на страницах интерактивного справочного руководства к команде.</p>     <p>Команду <blockquote>set</blockquote> можно также применять для передачи параметров командной оболочке и тем самым управления режимом ее работы. Наиболее часто используемый вариант команды <blockquote>set -х</blockquote>, который заставляет сценарий выводить на экран трассировку выполняемой в данный момент команды. Мы обсудим команду <blockquote>set</blockquote> и ее дополнительные опции позже в этой главе, когда будем рассматривать отладку программ.</p>     <b><i>shift</i></b>     <p>Команда <blockquote>shift</blockquote> сдвигает все переменные-параметры на одну позицию назад, так что параметр <blockquote>$2</blockquote> становится параметром <blockquote>$1</blockquote>, параметр <blockquote>$3</blockquote> — <blockquote>$2</blockquote> и т.д. Предыдущее значение параметра <blockquote>$1</blockquote> отбрасывается, а значение параметра <blockquote>$0</blockquote> остается неизменным. Если в вызове команды <blockquote>shift</blockquote> задан числовой параметр, параметры сдвигаются на указанное количество позиций. Остальные переменные <blockquote>$*</blockquote>, <blockquote>$@</blockquote> и <blockquote>$#</blockquote> также изменяются в связи с новой расстановкой переменных-параметров.</p>     <p>Команда <blockquote>shift</blockquote> часто полезна при поочередном просмотре параметров, переданных в сценарий, и если вашему сценарию требуется 10 и более параметров, вам понадобится команда <blockquote>shift</blockquote> для обращения к 10-му параметру и следующим за ним.</p>     <p>Например, вы можете просмотреть все позиционные параметры:</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>while [ "$1" != "" ]; do</blockquote></p>     <p><blockquote> echo "$1"</blockquote></p>     <p><blockquote> shift</blockquote></p>     <p><blockquote>done</blockquote></p>     <br>     <p><blockquote>exit 0</blockquote></p>     <b><i>trap</i></b>     <p>Команда <blockquote>trap</blockquote> применяется для задания действий, предпринимаемых при получении сигналов, которые подробно будут обсуждаться далее в этой книге. Обычное действие — удалить сценарий, когда он прерван. Исторически командные оболочки всегда использовали числа для обозначения сигналов, но в современных сценариях следует применять имена, которые берутся из файла signal.h директивы <blockquote>#include</blockquote> с опущенным префиксом <blockquote>SIG</blockquote><b>.</b> Для того чтобы посмотреть номера сигналов и соответствующие им имена, можно ввести в командной строке команду <blockquote>trap -l</blockquote>.</p>     <blockquote>      <b>Примечание</b>      <p>Для тех, кто не знаком с сигналами, это события, асинхронно посылаемые программе. Стандартно они обычно вызывают прекращение выполнения программы.</p>     </blockquote>     <p>С помощью команды <blockquote>trap</blockquote> передается предпринимаемое действие, за которым следует имя (имена) сигнала для перехвата:</p>     <p><b><blockquote><b>trap </b><i>команда сигнал</i></blockquote></b></p>     <p>Напоминаем, что обычно сценарии обрабатываются интерпретатором сверху вниз, поэтому вы должны задать, команду <blockquote>trap</blockquote> перед той частью сценария, которую хотите защитить.</p>     <p>Для возврата к стандартной реакции на сигнал, просто задайте<i> <blockquote>команду</blockquote></i> как <blockquote>-</blockquote>. Для игнорирования сигнала задайте в<i> <blockquote>команде</blockquote></i> пустую строку <blockquote>''</blockquote>. Команда trap без параметров выводит текущий список перехватов и действий.</p>     <p>В табл. 2.9 перечислены самые важные, включенные в. стандарт Х/Open сигналы, которые можно отследить (со стандартными номерами в скобках). Дополнительную информацию можно найти на страницах раздела 7 интерактивного справочного руководства, посвященного сигналам (<blockquote>man 7 signal</blockquote>).</p>     <br>     <p><b><i>Таблица 2.9</i></b></p>     <table>      <tr>       <th valign="top">Сигнал</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>HUP (1)</blockquote></td>       <td valign="top">Неожиданный останов; обычно посылается, когда отключается терминал или пользователь выходит из системы</td>      </tr>      <tr>       <td valign="top"><blockquote>INT (2)</blockquote></td>       <td valign="top">Прерывание; обычно посылается нажатием комбинации клавиш &lt;Ctrl&gt;+&lt;C&gt;</td>      </tr>      <tr>       <td valign="top"><blockquote>QUIT (3)</blockquote></td>       <td valign="top">Завершение выполнения; обычно посылается нажатием комбинации клавиш &lt;Ctrl&gt;+&lt;\&gt;</td>      </tr>      <tr>       <td valign="top"><blockquote>ABRT (6)</blockquote></td>       <td valign="top">Аварийное завершение; обычно посылается при возникновении серьезной ошибки выполнения</td>      </tr>      <tr>       <td valign="top"><blockquote>ALRM (14)</blockquote></td>       <td valign="top">Аварийный сигнал; обычно посылается для обработки превышений лимита времени</td>      </tr>      <tr>       <td valign="top"><blockquote>TERM (15)</blockquote></td>       <td valign="top">Завершение; обычно посылается системой, когда она завершает работу</td>      </tr>     </table>     <p>А теперь выполните упражнение 2.15.</p>     <b>Упражнение 2.15. Сигналы прерываний</b>     <p>В следующем сценарии показана простая обработка сигнала.</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>trap 'rm -f /tmp/my_tmp_file_$$' INT</blockquote></p>     <p><blockquote>echo creating file /tmp/my_tmp_file_$$</blockquote></p>     <p><blockquote>date &gt; /tmp/my_tmp_file_$$</blockquote></p>     <br>     <p><blockquote>echo "press interrupt (CTRL-C) to interrupt..."</blockquote></p>     <p><blockquote>while [ -f /tmp/my_tmp_file_$$ ] ; do</blockquote></p>     <p><blockquote> echo File exists</blockquote></p>     <p><blockquote> sleep 1</blockquote></p>     <p><blockquote>done</blockquote></p>     <br>     <p><blockquote>echo The file no longer exists trap INT</blockquote></p>     <p><blockquote>echo creating file /tmp/my_tmp_file_$$</blockquote></p>     <p><blockquote>date &gt; /tmp/my_tmp_file_$$</blockquote></p>     <br>     <p><blockquote>echo "press interrupt (CTRL-C) to interrupt..."</blockquote></p>     <p><blockquote>while [ -f /tmp/my_tmp_file_$$ ]; do</blockquote></p>     <p><blockquote> echo File exists</blockquote></p>     <p><blockquote> sleep 1</blockquote></p>     <p><blockquote>done</blockquote></p>     <br>     <p><blockquote>echo we never get here</blockquote></p>     <p><blockquote>exit 0</blockquote></p>     <p>Если вы выполните этот сценарий, нажимая и удерживая нажатой клавишу &lt;Ctrl&gt; и затем нажимая клавишу &lt;C&gt; (или любую другую прерывающую комбинацию клавиш) в каждом из циклов, то получите следующий вывод:</p>     <p><blockquote>creating file /tmp/my_tmp_file_141</blockquote></p>     <p><blockquote>press interrupt (CTRL-C) to interrupt ...</blockquote></p>     <p><blockquote>File exists</blockquote></p>     <p><blockquote>File exists</blockquote></p>     <p><blockquote>File exists</blockquote></p>     <p><blockquote>File exists</blockquote></p>     <p><blockquote>The file no longer exists</blockquote></p>     <p><blockquote>creating file /tmp/my tmp_file_141</blockquote></p>     <p><blockquote>press interrupt (CTRL-C) to interrupt ...</blockquote></p>     <p><blockquote>File exists</blockquote></p>     <p><blockquote>File exists</blockquote></p>     <p><blockquote>File exists</blockquote></p>     <p><blockquote>File exists</blockquote></p>     <p><b>Как это работает</b></p>     <p>Сценарий использует команду <blockquote>trap</blockquote> для организации выполнения команды <blockquote>rm -f /tmp/my_tmp_file_$$</blockquote> при возникновении сигнала <blockquote>INT</blockquote> (прерывание). Затем сценарий выполняет цикл <blockquote>while</blockquote> до тех пор, пока существует файл. Когда пользователь нажимает комбинацию клавиш &lt;Ctrl&gt;+&lt;C&gt;, выполняется команда <blockquote>rm -f /tmp/my_tmp_file_$$</blockquote>, а затем возобновляется выполнение цикла <blockquote>while</blockquote>. Поскольку теперь файл удален, первый цикл <blockquote>while</blockquote> завершается стандартным образом.</p>     <p>Далее сценарий снова применяет команду <blockquote>trap</blockquote>, на этот раз для того, чтобы сообщить, что при возникновении сигнала <blockquote>INT</blockquote> никакая команда не выполняется. Затем сценарий создает заново файл и выполняет второй цикл <blockquote>while</blockquote>. Когда пользователь снова нажимает комбинацию клавиш &lt;Ctrl&gt;+&lt;C&gt;, не задана команда для выполнения, поэтому реализуется стандартное поведение: немедленное прекращение выполнения сценария. Поскольку сценарий завершается немедленно, заключительные команды <blockquote>echo</blockquote> и <blockquote>exit</blockquote> никогда не выполняются.</p>     <b><i>unset</i></b>     <p>Команда <blockquote>unset</blockquote> удаляет переменные или функции из окружения. Она не может проделать это с переменными, предназначенными только для чтения и определенными командной оболочкой, такими как <blockquote>IFS</blockquote>. Команда применяется редко.</p>     <p>В следующем сценарии сначала выводится строка <blockquote>Hello world</blockquote>, а во второй раз новая строка.</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>foo="Hello World"</blockquote></p>     <p><blockquote>echo $foo</blockquote></p>     <br>     <p><blockquote>unset foo</blockquote></p>     <p><blockquote>echo $foo</blockquote></p>     <blockquote>      <b>Примечание</b>      <p>Написание <blockquote>foo=</blockquote> подобно, но не идентично применению команды <blockquote>unset</blockquote> в только что приведенной программе. Оператор <blockquote>foo=</blockquote> задает для переменной <blockquote>foo</blockquote> значение <blockquote>null</blockquote>, но при этом переменная <blockquote>foo</blockquote> все еще существует. Команда <blockquote>unset foo</blockquote> удаляет из окружения переменную <blockquote>foo</blockquote>.</p>     </blockquote>     <b>Еще две полезные команды и регулярные выражения</b>     <p>Прежде чем вы увидите, как применять на практике полученные навыки программирования в командной оболочке, давайте рассмотрим еще две очень полезные команды, которые, хотя и не являются часть оболочки, очень пригодятся при написании ее программ. Попутно мы также познакомимся с регулярными выражениями, средством поиска по шаблону, которое обнаруживает себя в разных частях ОС Linux и тесно связанных с нею программах.</p>     <b>Команда<i> find</i></b>     <p>Первой рассмотрим команду <blockquote>find</blockquote>. Эта команда, применяющаяся для поиска файлов, чрезвычайно полезна, но новички в ОС Linux часто находят ее немного сложной в использовании в немалой степени из-за ее опций, критериев и аргументов, определяющих действия (action-type), причем результат одного из этих аргументов может влиять на обработку последующих аргументов.</p>     <p>Прежде чем углубиться в изучение опций, критериев и аргументов команды, рассмотрим очень простой пример поиска на вашей машине файла <blockquote>test</blockquote>. Выполните приведенную далее команду под именем суперпользователя root, чтобы иметь достаточно прав доступа для обследования всего компьютера.</p>     <p><blockquote># <b>find / -name test -print</b></blockquote></p>     <p><blockquote>/usr/bin/test</blockquote></p>     <p><blockquote>#</blockquote></p>     <p>В зависимости от варианта установки системы на вашей машине вы можете найти и другие файлы, также названные test. Как вы, вероятно, догадываетесь, команда звучит так: "искать, начиная с каталога /, файл с именем test и затем вывести на экран имя файла". Легко, не правда ли? Безусловно.</p>     <p>Выполнение команды займет какое-то время, она будет искать на нашей машине и на сетевом диске машины с ОС Windows. Это происходит потому, что на компьютере с Linux смонтирована (с помощью пакета SAMBA) порция файловой системы машины с ОС Windows. Похоже, что подобный поиск будет вестись, даже если мы знаем, что искомый файл находится на машине под управлением ОС Linux.</p>     <p>В этом случае на помощь приходит первая опция. Если вы укажете опцию <blockquote>-mount</blockquote>, то сможете сообщить команде find о том, что смонтированные каталоги проверять не нужно.</p>     <p><blockquote># <b>find / -mount -name test -print</b></blockquote></p>     <p><blockquote>/usr/bin/test</blockquote></p>     <p><blockquote># </blockquote></p>     <p>Мы нашли все тот же файл на нашей машине, но на сей раз гораздо быстрее и без поиска в смонтированных файловых системах.</p>     <p>Полная синтаксическая запись команды <blockquote>find</blockquote> выглядит следующим образом:</p>     <p><blockquote><b>find</b> [<i>путь</i>] [<i>опции</i>] [<i>критерии</i>] [<i>действия</i>]</blockquote></p>     <p>Часть записи <blockquote>[<i>путь</i>]</blockquote> понятна и проста: вы можете указать абсолютный путь поиска, например, <blockquote>/bin</blockquote>, или относительный, например <blockquote>..</blockquote> При необходимости можно задать несколько путей — например, <blockquote>find /var /home</blockquote>.</p>     <p>В табл. 2.10 перечислены основные опции команды.</p>     <br>     <p><b><i>Таблица 2.10</i></b></p>     <table>      <tr>       <th valign="top">Опция</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>-depth</blockquote></td>       <td valign="top">Поиск в подкаталогах перед поиском в самом каталоге</td>      </tr>      <tr>       <td valign="top"><blockquote>-follow</blockquote></td>       <td valign="top">Следовать по символическим ссылкам</td>      </tr>      <tr>       <td valign="top"><blockquote>-maxdepths <i>N</i></blockquote></td>       <td valign="top">При поиске проверять не более<i> <blockquote>N</blockquote></i> вложенных уровней каталога</td>      </tr>      <tr>       <td valign="top"><blockquote>-mount</blockquote> (или <blockquote>-xdev</blockquote>)</td>       <td valign="top">Не искать в каталогах других файловых систем</td>      </tr>     </table>     <p>Теперь о критериях. В команде <blockquote>find</blockquote> можно задать большое число критериев, и каждый из них возвращает либо <blockquote>true</blockquote>, либо <blockquote>false</blockquote>. В процессе работы команда <blockquote>find</blockquote> рассматривает по очереди каждый файл и применяет к нему все критерий в порядке их определения. Если очередной критерий возвращает значение <blockquote>false</blockquote>, команда <blockquote>find</blockquote> прекращает анализ текущего файла и переходит к следующему; если критерий возвращает значение <blockquote>true</blockquote>, команда применяет следующий критерий к текущему файлу или совершает заданное действие над ним. В табл. 2.11 перечислены самые распространенные критерии; полный список тестов, которые можно применять в команде <blockquote>find</blockquote>, вы найдете на страницах интерактивного справочного руководства.</p>     <br>     <p><b><i>Таблица 2.11</i></b></p>     <table>      <tr>       <th valign="top">Критерий</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>-atime <i>N</i></blockquote></td>       <td valign="top">К файлу обращались последний раз <blockquote><i>N</i></blockquote> дней назад</td>      </tr>      <tr>       <td valign="top"><blockquote>-mtime <i>N</i></blockquote></td>       <td valign="top">Файл последний раз изменялся <blockquote><i>N</i></blockquote> дней назад</td>      </tr>      <tr>       <td valign="top"><blockquote>-name<i> шаблон</i></blockquote></td>       <td valign="top">Имя файла без указания пути соответствует заданному шаблону. Для гарантии того, что шаблон будет передан в команду <blockquote>find</blockquote> и не будет немедленно обработан командной оболочкой, его следует всегда заключать в кавычки</td>      </tr>      <tr>       <td valign="top"><blockquote>-newer <i>другой файл</i></blockquote></td>       <td valign="top">Текущий файл, измененный позже, чем<i> другой файл</i></td>      </tr>      <tr>       <td valign="top"><blockquote>-type <i>С</i></blockquote></td>       <td valign="top">Файл типа <blockquote><i>C</i></blockquote>, где <blockquote><i>C</i></blockquote> может принимать определенные значения; наиболее широко используемые "<blockquote>d</blockquote>" для каталогов и "<blockquote>f</blockquote>" для обычных файлов. Остальные обозначения типов можно посмотреть на страницах интерактивного справочного руководства</td>      </tr>      <tr>       <td valign="top"><blockquote>-user <i>имя пользователя</i></blockquote></td>       <td valign="top">Файл принадлежит пользователю с заданным именем</td>      </tr>     </table>     <p>Вы также можете объединять критерии с помощью операторов. Как показано в табл. 2.12, у большинства из них две формы записи: короткая и более длинная форма.</p>     <br>     <p><b><i>Таблица 2.12</i></b></p>     <table>      <tr>       <th valign="top">Оператор, короткая форма</th>       <th valign="top">Оператор, длинная форма</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>!</blockquote></td>       <td valign="top"><blockquote>-not</blockquote></td>       <td valign="top">Инвертирование критерия</td>      </tr>      <tr>       <td valign="top"><blockquote>-а</blockquote></td>       <td valign="top"><blockquote>-and</blockquote></td>       <td valign="top">Оба критерия должны быть истинны</td>      </tr>      <tr>       <td valign="top"><blockquote>-о</blockquote></td>       <td valign="top"><blockquote>-or</blockquote></td>       <td valign="top">Один из критериев должен быть истинным</td>      </tr>     </table>     <p>Изменить порядок проверки критериев и выполнения операторов можно с помощью скобок. Поскольку в командной оболочке у них есть особое назначение, скобки также следует выделять с помощью обратного слэша. Кроме того, если вы применяете шаблон для имени файла, то следует использовать кавычки, чтобы оболочка не выполняла подстановку имени, а прямо передала шаблон команде <blockquote>find</blockquote>. Например, если вы хотите задать критерий "измененный позже, чем файл <blockquote>X</blockquote>, или с именем, начинающимся со знака подчеркивания", его можно записать следующим образом:</p>     <p><blockquote>\(-newer X -о -name "_*" \)</blockquote></p>     <p>Мы приведем пример сразу после описания "Как это работает". А сейчас выполните упражнение 2.16.</p>     <b>Упражнение 2.16 Применение команды <blockquote>find</blockquote> с критериями</b>     <p>Попытаемся найти в текущем каталоге файлы, измененные после модификации файла while2.</p>     <p><blockquote>$ <b>find . -newer while2 -print</b></blockquote></p>     <p><blockquote>.</blockquote></p>     <p><blockquote>./elif3</blockquote></p>     <p><blockquote>./words.txt</blockquote></p>     <p><blockquote>./words2.txt</blockquote></p>     <p><blockquote>./_trap</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Все чудесно, за исключением того, что вы нашли ненужный вам текущий каталог. Вас интересуют только обычные файлы, поэтому добавьте дополнительный критерий <blockquote>-type f</blockquote>.</p>     <p><blockquote>$ <b>find . -newer while2 -type f -print</b></blockquote></p>     <p><blockquote>./elif3</blockquote></p>     <p><blockquote>./words.txt</blockquote></p>     <p><blockquote>./words2.txt</blockquote></p>     <p><blockquote>./_trap</blockquote></p>     <p><blockquote>$</blockquote></p>     <p><b>Как это работает</b></p>     <p>Как это работает? Вы определили, что команда <blockquote>find</blockquote> должна искать в текущем каталоге (<blockquote>.</blockquote>) файлы, измененные позже, чем файл while2 (<blockquote>-newer while2</blockquote>), и, если этот критерий пройден, проверять с помощью следующего критерия (<blockquote>-type f</blockquote>), обычные ли это файлы. В заключение вы применили действие, с которым уже сталкивались, <blockquote>-print</blockquote>, просто для того чтобы подтвердить, что файлы были найдены.</p>     <p>Теперь найдем файлы с именами, начинающимися с символа подчеркивания или измененные позже, чем файл while2, но в любом случае обычные файлы. Этот пример покажет, как объединять критерии с помощью скобок.</p>     <p><blockquote>$ <b>find . \( -name "_*" -or -newer while2 \) -type f -print</b></blockquote></p>     <p><blockquote>./elif3</blockquote></p>     <p><blockquote>./words.txt</blockquote></p>     <p><blockquote>./words2.txt</blockquote></p>     <p><blockquote>./_break</blockquote></p>     <p><blockquote>./_if</blockquote></p>     <p><blockquote>./set</blockquote></p>     <p><blockquote>./_shift</blockquote></p>     <p><blockquote>./_trap</blockquote></p>     <p><blockquote>./_unset</blockquote></p>     <p><blockquote>./ until</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Это не слишком трудный пример, не так ли? Вы должны экранировать скобки, чтобы они не обрабатывались командной оболочкой, и заключить в кавычки символ <blockquote>*</blockquote>, чтобы он также был передан непосредственно в команду <blockquote>find</blockquote>.</p>     <p>Теперь, когда вы можете правильно искать файлы, рассмотрим действия, которые можно совершить, когда найден файл, соответствующий вашей спецификации. И снова в табл. 2.13 перечислены только самые популярные действия; полный список можно найти на страницах интерактивного справочного руководства.</p>     <br>     <p><b><i>Таблица 2.13</i></b></p>     <table>      <tr>       <th valign="top">Действие</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>-exec <i>команда</i></blockquote></td>       <td valign="top">Выполняет<i><blockquote>команду</blockquote></i>. Наиболее широко используемое действие. После табл. 2.13 приведено объяснение способа передачи параметров в команду. Это действие следует завершать символьной парой <blockquote>\;</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>-ok <i>команда</i></blockquote></td>       <td valign="top">Подобно действию <blockquote>exec</blockquote>, за исключением того, что перед обработкой файлов<i><blockquote>командой</blockquote></i> выводится подсказка для получения подтверждения пользователя на обработку каждого файла. Это действие следует завершать символьной парой <blockquote>\;</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>-print</blockquote></td>       <td valign="top">Вывод на экран имени файла</td>      </tr>      <tr>       <td valign="top"><blockquote>-ls</blockquote></td>       <td valign="top">Применение команды <blockquote>ls -dils</blockquote> к текущему файлу</td>      </tr>     </table>     <p>Команда в аргументах <blockquote>-exec</blockquote> и <blockquote>-ok</blockquote> принимает последующие параметры в строке как собственные, пока не встретится последовательность <blockquote>\;</blockquote> В действительности команда, в аргументах <blockquote>-exec</blockquote> и <blockquote>-ok</blockquote> выполняет встроенную команду, поэтому встроенная команда должна завершиться экранированной точкой с запятой, для того чтобы команда <blockquote>find</blockquote> могла определить, когда ей следует продолжить поиск в командной строке аргументов, предназначенных для нее самой. Магическая строка <blockquote>{}</blockquote> — параметр специального типа для команд <blockquote>-exec</blockquote> и <blockquote>-ok</blockquote>, который заменяется полным путем к текущему файлу.</p>     <p>Объяснение, возможно, не слишком легкое для понимания, поэтому рассмотрим пример, который поможет внести ясность. Взгляните на простой пример, использующий хорошую безопасную команду <blockquote>ls</blockquote>:</p>     <p><blockquote>$ <b>find . -newer while2 -type f -exec ls -l  {} \;</b></blockquote></p>     <p><blockquote>-rwxr-xr-x 1 rick rick  275 Feb 8 17:07 ./elif3</blockquote></p>     <p><blockquote>-rwxr-xr-x 1 rick rick  336 Feb 8 16:52 ./words.txt</blockquote></p>     <p><blockquote>-rwxr-xr-x 1 rick rick 1274 Feb 8 16:52 ./words2.txt</blockquote></p>     <p><blockquote>-rwxr-xr-x 1 rick rick  504 Feb 8 18:43 ./_trap</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Как видите, команда <blockquote>find</blockquote> чрезвычайно полезна; она только требует небольшой практики для умелого ее применения. И такая практика, как и эксперименты с командой <blockquote>find</blockquote>, обязательно принесет дивиденды.</p>     <b>Команда<i> grep</i></b>     <p>Вторая очень полезная команда, заслуживающая рассмотрения, — это команда <blockquote>grep</blockquote>. Необычное имя, означающее<i> общий синтаксический анализатор регулярных выражений</i> (general regular expression parser). Вы применяете команду <blockquote>find</blockquote> для поиска файлов в вашей системе, а команду <blockquote>grep</blockquote> для поиска строк в ваших файлах. Действительно, очень часто при использовании команды <blockquote>find</blockquote> команда <blockquote>grep</blockquote> передается после аргумента <blockquote>-exec</blockquote>.</p>     <p>Команда <blockquote>grep</blockquote> принимает опции, шаблон соответствия и файлы для поиска:</p>     <p><blockquote><b>grep</b> [<i>опции</i>]<i> шаблон</i> [<i>файлы</i>]</blockquote></p>     <p>Если имена файлов не заданы, команда анализирует стандартный ввод.</p>     <p>Давайте начнем с изучения основных опций команды <blockquote>grep</blockquote>. И на этот раз в табл. 2.14 приведены только самые важные из них; полный список см. на страницах интерактивного справочного руководства.</p>     <br>     <p><b><i>Таблица 2.14</i></b></p>     <table>      <tr>       <th valign="top">Опция</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>-с</blockquote></td>       <td valign="top">Вместо вывода на экран совпавших с шаблоном строк выводит их количество</td>      </tr>      <tr>       <td valign="top"><blockquote>-E</blockquote></td>       <td valign="top">Включает расширенные регулярные выражения</td>      </tr>      <tr>       <td valign="top"><blockquote>-h</blockquote></td>       <td valign="top">Ужимает обычное начало каждой строки вывода за счет удаления имени файла, в котором строка найдена</td>      </tr>      <tr>       <td valign="top"><blockquote>-i</blockquote></td>       <td valign="top">Не учитывает регистр букв</td>      </tr>      <tr>       <td valign="top"><blockquote>-l</blockquote></td>       <td valign="top">Перечисляет имена файлов со строками, совпадающими с шаблоном; не выводит сами найденные строки</td>      </tr>      <tr>       <td valign="top"><blockquote>-v</blockquote></td>       <td valign="top">Меняет шаблон соответствия для выбора вместо строк, соответствующих шаблону, несовпадающих с ним строк</td>      </tr>     </table>     <p>Выполните упражнение 2.17.</p>     <b>Упражнение 2.17. Основной вариант использования команды <blockquote>grep</blockquote></b>     <p>Посмотрим команду <blockquote>grep</blockquote> в действии на примерах простых шаблонов.</p>     <p><blockquote>$ <b>grep in words.txt</b></blockquote></p>     <p><blockquote>When shall we three meet again. In thunder, lightning, or in rain?</blockquote></p>     <p><blockquote>I come, Graymalkin!</blockquote></p>     <p><blockquote>$ <b>grep -c in words.txt words2.txt</b></blockquote></p>     <p><blockquote>words.txt:2 words2.txt:14</blockquote></p>     <p><blockquote>$ <b>grep -c -v in words.txt words2.txt</b></blockquote></p>     <p><blockquote>words.txt:9</blockquote></p>     <p><blockquote>words2.txt:16$</blockquote></p>     <p><b>Как это работает</b></p>     <p>В первом примере нет опций; в нем просто ищется строка <blockquote>in</blockquote> в файле words.txt и выводятся на экран любые строки, соответствующие условию поиска. Имя файла не отображается, поскольку поиск велся в единственном файле.</p>     <p>Во втором примере в двух разных файлах подсчитывается количество строк, соответствующих шаблону. В этом случае имена файлов выводятся на экран.</p>     <p>В заключение применяется опция <blockquote>-v</blockquote> для инвертирования критерия поиска и подсчета строк, не совпадающих с шаблоном.</p>     <b>Регулярные выражения</b>     <p>Как вы убедились, основной вариант применения команды grep легко усвоить. Теперь пришло время рассмотреть основы построения регулярных выражений, которые позволят вам выполнять более сложный поиск. Как упоминалось ранее в этой главе, регулярные выражения применяются в системе Linux и многих языках программирования с открытым исходным кодом. Вы можете использовать их в редакторе vi и в скриптах на языке Perl, применяя одни и те же принципы, общие для регулярных выражений, где бы они ни появлялись.</p>     <p>При обработке регулярных выражений определенные символы интерпретируются особым образом. В табл. 2.15 приведены наиболее часто используемые в регулярных выражениях символы.</p>     <br>     <p><b><i>Таблица 2.15</i></b></p>     <table>      <tr>       <th valign="top">Символ</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>^</blockquote></td>       <td valign="top">Привязка к началу строки</td>      </tr>      <tr>       <td valign="top"><blockquote>$</blockquote></td>       <td valign="top">Привязка к концу строки</td>      </tr>      <tr>       <td valign="top"><blockquote>.</blockquote></td>       <td valign="top">Любой одиночный символ</td>      </tr>      <tr>       <td valign="top"><blockquote>[]</blockquote></td>       <td valign="top">В квадратных скобках содержится диапазон символов, с любым из них возможно совпадение, например, диапазон символов <blockquote>a-e</blockquote> или инвертированный диапазон, перед которым стоит символ <blockquote>^</blockquote></td>      </tr>     </table>     <p>Если вы хотите использовать любые из перечисленных символов как "обычные", поставьте перед ними символ <blockquote>\</blockquote>. Например, если нужно найти символ <blockquote>$</blockquote>, просто введите <blockquote>\$</blockquote>.</p>     <p>Есть также несколько полезных специальных проверочных шаблонов, которые могут указываться в квадратных скобках (табл. 2.16).</p>     <br>     <p><b><i>Таблица 2.16</i></b></p>     <table>      <tr>       <th valign="top">Проверочный шаблон</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>[:alnum:]</blockquote></td>       <td valign="top">Буквенно-цифровые символы</td>      </tr>      <tr>       <td valign="top"><blockquote>[:alpha:]</blockquote></td>       <td valign="top">Буквы</td>      </tr>      <tr>       <td valign="top"><blockquote>[:ascii:]</blockquote></td>       <td valign="top">Символы таблицы ASCII</td>      </tr>      <tr>       <td valign="top"><blockquote>[:blank:]</blockquote></td>       <td valign="top">Пробел или табуляция</td>      </tr>      <tr>       <td valign="top"><blockquote>[:cntrl:]</blockquote></td>       <td valign="top">Управляющие символы ASCII</td>      </tr>      <tr>       <td valign="top"><blockquote>[:digit:]</blockquote></td>       <td valign="top">Цифры</td>      </tr>      <tr>       <td valign="top"><blockquote>[:graph:]</blockquote></td>       <td valign="top">Неуправляющие и непробельные символы</td>      </tr>      <tr>       <td valign="top"><blockquote>[:lower:]</blockquote></td>       <td valign="top">Строчные буквы</td>      </tr>      <tr>       <td valign="top"><blockquote>[:print:]</blockquote></td>       <td valign="top">Печатные символы</td>      </tr>      <tr>       <td valign="top"><blockquote>[:punct:]</blockquote></td>       <td valign="top">Знаки пунктуации</td>      </tr>      <tr>       <td valign="top"><blockquote>[:space:]</blockquote></td>       <td valign="top">Пробельные символы, включая вертикальную табуляцию</td>      </tr>      <tr>       <td valign="top"><blockquote>[:upper:]</blockquote></td>       <td valign="top">Прописные буквы</td>      </tr>      <tr>       <td valign="top"><blockquote>[:xdigit:]</blockquote></td>       <td valign="top">Шестнадцатиричные цифры</td>      </tr>     </table>     <p>Кроме того, если задана опция <blockquote>=E</blockquote> для расширенного соответствия, за регулярным выражением могут следовать и другие символы, управляющие выполнением проверки на соответствие шаблону (табл. 2.17). В команде <blockquote>grep</blockquote> перед этими символами необходимо вводить символ <blockquote>\</blockquote>.</p>     <br>     <p><b><i>Таблица 2.17</i></b></p>     <table>      <tr>       <th valign="top">Опция</th>       <th valign="top"> Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>?</blockquote></td>       <td valign="top">Совпадение не обязательно, но возможно не более одного раза</td>      </tr>      <tr>       <td valign="top"><blockquote>*</blockquote></td>       <td valign="top">Совпадения может не быть, оно может быть однократным или многократным</td>      </tr>      <tr>       <td valign="top"><blockquote>+</blockquote></td>       <td valign="top">Совпадение должно быть однократным или многократным</td>      </tr>      <tr>       <td valign="top"><blockquote>{<i>n</i>}</blockquote></td>       <td valign="top">Совпадение должно быть <blockquote><i>n</i></blockquote> раз</td>      </tr>      <tr>       <td valign="top"><blockquote>{<i>n</i>, }</blockquote></td>       <td valign="top">Совпадение должно быть <i><blockquote><i>n</i></blockquote> </i>раз и больше</td>      </tr>      <tr>       <td valign="top"><blockquote>{<i>n</i>, <i>m</i>}</blockquote></td>       <td valign="top">Совпадение должно быть от <i><blockquote><i>n</i></blockquote></i> до <i><blockquote><i>m</i></blockquote> </i>раз включительно</td>      </tr>     </table>     <p>Все это выглядит немного запутанно, но если осваивать все возможности постепенно, то вы увидите, что все не так сложно, как кажется на первый взгляд. Самый легкий способ понять регулярные выражения — просто попробовать применить несколько.</p>     <p>1. Начнем с поиска строк, заканчивающихся буквой "е". Возможно, вы уже догадались, что нужно использовать специальный символ <blockquote>$</blockquote>:</p>     <p><blockquote>$ <b>grep e$ words2.txt</b></blockquote></p>     <p><blockquote>Art thou not, fatal vision, sensible</blockquote></p>     <p><blockquote>I see thee yet, in form as palpable</blockquote></p>     <p><blockquote>Nature seems dead, and wicked dreams abuse</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Как видите, найдены строки, заканчивающиеся буквой "е".</p>     <p>2. Теперь найдите трехбуквенные слова, начинающиеся с символов "Th". В данном случае вам понадобится шаблон <blockquote>[[:space:]]</blockquote> для ограничения длины слова и <blockquote>.</blockquote> для единственного дополнительного символа.</p>     <p><blockquote>$ <b>grep Th.[[:space:]] words 2.txt</b></blockquote></p>     <p><blockquote>The handle toward my hand? Come, let me clutch thee.</blockquote></p>     <p><blockquote>The curtain'd sleep; witchcraft celebrates</blockquote></p>     <p><blockquote>Thy very stones prate of my whereabout,</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>3. В заключение примените расширенный режим поиска в команде <blockquote>grep</blockquote> для обнаружения слов из строчных букв длиной ровно 10 символов. Для этого задайте диапазон совпадающих символов от а до z и 10 повторяющихся совпадений.</p>     <p><blockquote>$ <b>grep -Е [a-z]\{10\} words2.txt</b></blockquote></p>     <p><blockquote>Proceeding from the heat-oppressed brain?</blockquote></p>     <p><blockquote>And such an instrument I was to use.</blockquote></p>     <p><blockquote>The curtain'd sleep; witchcraft celebrates</blockquote></p>     <p><blockquote>hy very stones prate of my whereabout,</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Приведенные примеры лишь коснулись наиболее важных компонентов регулярных выражений. Как и для большинства составных частей ОС Linux, существует множество дополнительной документации помимо этой книги, которая поможет вам узнать еще больше подробностей, но лучший способ изучения регулярных выражений — экспериментировать с ними.</p>             <a name="metkadoc19"><h1>Выполнение команд</h1></a>     <p>При написании сценариев вам часто требуется перехватить результат выполнения команды для использования его в сценарии командной оболочки; т.е. вы хотите выполнить команду и поместить ее вывод в переменную.</p>     <p>Сделать это можно с помощью синтаксической конструкции <blockquote>$(<i>команда</i>)</blockquote>, показанной ранее в примере с командой <blockquote>set</blockquote>. Существует устаревший вариант подстановки команды <blockquote>`<i>команда</i>`</blockquote>, который все еще широко распространен.</p>     <blockquote>      <b>Примечание</b>      <p>В более раннем варианте конструкции применяется обратный апостроф или обратная кавычка (<blockquote>`</blockquote>), а не обычный апостроф (<blockquote>'</blockquote>), который мы использовали раньше в командной оболочке для экранирования (защиты от подстановки переменных). В сценариях оболочки применяйте этот вариант, только если вы хотите добиться высокой степени переносимости сценариев.</p>     </blockquote>     <p>Во всех современных сценариях следует применять <i>конструкцию выполнения или подстановки команды</i> <blockquote>$(<i>команда</i>)</blockquote>, которая введена для того, чтобы избавиться от довольно сложных правил использования символов <blockquote>$</blockquote>, <blockquote>'</blockquote> и <blockquote>\</blockquote> внутри команды, заключенной в обратные апострофы. Если применяется обратный апостроф внутри конструкции <blockquote>`...`</blockquote> , его необходимо экранировать символом <blockquote>\</blockquote>. Эти непонятные знаки часто заставляют программистов путаться, и иногда даже опытные специалисты в программировании средствами командной оболочки вынуждены ставить опыты для того, чтобы добиться правильного использования кавычек и апострофов в командах, заключенных в обратные апострофы.</p>     <p>Результат выполнения конструкции <blockquote>$(<i>команда</i>)</blockquote> — просто вывод команды. Имейте в виду, что это не статус возврата команды, а просто строковый вывод, показанный далее.</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>echo The current directory is $PWD</blockquote></p>     <p><blockquote>echo The current users are $(who)</blockquote></p>     <br>     <p><blockquote>exit 0</blockquote></p>     <p>Поскольку текущий каталог — это переменная окружения командной оболочки, первая строка не нуждается в применении подстановки команды. Результат выполнения программы <blockquote>who</blockquote>, напротив, нуждается в ней, если он должен стать переменной в сценарии.</p>     <p>Если вы хотите поместить результат в переменную, то можете просто присвоить его обычным образом:</p>     <p><blockquote>whoisthere=$(who)</blockquote></p>     <p><blockquote>echo Swhoisthere</blockquote></p>     <p>Возможность поместить результат выполнения команды в переменную сценария — очень мощное средство, поскольку оно облегчает использование существующих команд в сценариях и перехват результата их выполнения. Если когда-нибудь вам понадобится преобразовать набор параметров, представляющих собой вывод команды на стандартное устройство вывода, и передать их как аргументы в программу, возможно, вас порадует то, что команда <blockquote>xargs</blockquote> сможет это сделать за вас. Дополнительные подробности ищите на страницах интерактивного справочного руководства.</p>     <p>Иногда возникают проблемы, если команда, которую вы хотите выполнить, выводит несколько пробелов перед нужным вам текстом, или больше информации, чем вам нужно. В таких случаях можно воспользоваться командой <blockquote>set</blockquote>, как было показано ранее.</p>     <b>Подстановки в арифметических выражениях</b>     <p>Мы уже использовали команду <blockquote>expr</blockquote>, которая позволяет выполнять простые арифметические операции, но она делает это очень медленно, потому что для выполнения команды <blockquote>expr</blockquote> запускается новая командная оболочка.</p>     <p>Современная и лучшая альтернатива — синтаксическая конструкция <blockquote>$((...))</blockquote>. Поместив в эту конструкцию выражение, которое вы хотите вычислить, вы можете выполнить простые арифметические операции гораздо эффективнее.</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>х=0</blockquote></p>     <p><blockquote>while [ "$х" -ne 10 ]; do</blockquote></p>     <p><blockquote> echo $х</blockquote></p>     <p><blockquote> х=$(($x+1))</blockquote></p>     <p><blockquote>done</blockquote></p>     <br>     <p><blockquote>exit 0</blockquote></p>     <blockquote>      <b>Примечание</b>      <p>Обратите внимание на тонкое отличие приведенной подстановки от команды <blockquote>х=$(...)</blockquote>. Двойные скобки применяются для подстановки значений в арифметические выражения. Вариант с одиночными скобками, показанный ранее, используется для выполнения команд и перехвата их вывода.</p>     </blockquote>     <b>Подстановка значений параметров</b>     <p>Вы уже видели простейший вариант присваивания параметра и подстановки значения параметра:</p>     <p><blockquote>foo=fredecho $foo</blockquote></p>     <p>Проблема возникает, когда вы хотите вставить дополнительные символы в конец значения переменной. Предположим, что вы хотите написать короткий сценарий обработки файлов 1_tmp и 2_tmp. Вы могли бы написать следующие строки:</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>for i in 1 2 do</blockquote></p>     <p><blockquote> my_secret_process $i_tmp</blockquote></p>     <p><blockquote>done</blockquote></p>     <p>Но в каждом проходе цикла вы получите следующее сообщение:</p>     <p><blockquote>my_secret_process: too few arguments</blockquote></p>     <p>В чем ошибка?</p>     <p>Проблема заключается в том, что командная оболочка попыталась подставить значение переменной <blockquote>$i_tmp</blockquote>, которая не существует. Оболочка не считает это ошибкой; она просто не делает никакой подстановки, поэтому в сценарий my_secret_process не передаются никакие параметры. Для обеспечения подстановки в переменную части ее значения <blockquote>$i</blockquote> необходимо <blockquote>i</blockquote> заключить в фигурные скобки следующим образом:</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>for i in 1 2 do</blockquote></p>     <p><blockquote> my_secret_process ${i}_tmp</blockquote></p>     <p><blockquote>done</blockquote></p>     <p>В каждом проходе цикла вместо <blockquote>${i}</blockquote> подставляется значение <blockquote>i</blockquote> и получаются реальные имена файлов. Вы подставляете значение параметра в строку.</p>     <p>В командной оболочке можно выполнять разнообразные виды подстановок. Часто они помогают найти красивое решение задач, требующих обработки многих параметров. Самые распространенные виды подстановок значений параметров приведены в табл. 2.18.</p>     <br>     <p><b><i>Таблица 2.18</i></b></p>     <table>      <tr>       <th valign="top">Шаблон подстановки параметра</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>${<i>парам</i>:-<i>значение по умолчанию</i>}</blockquote></td>       <td valign="top">Если у<i> <blockquote>парам</blockquote></i> нет значения, ему присваивается значение по умолчанию</td>      </tr>      <tr>       <td valign="top"><blockquote>${#<i>парам</i>}</blockquote></td>       <td valign="top">Задается длина<i> <blockquote>парам</blockquote></i></td>      </tr>      <tr>       <td valign="top"><blockquote>${<i>парам</i>%<i>строка</i>}</blockquote></td>       <td valign="top">От конца значения<i> <blockquote>парам</blockquote></i> отбрасывается наименьшая порция, совпадающая со<i> <blockquote>строкой</blockquote></i>, и возвращается остальная часть значения</td>      </tr>      <tr>       <td valign="top"><blockquote>${<i>парам</i>%%<i>строка</i>}</blockquote></td>       <td valign="top">От конца значения<i> <blockquote>парам</blockquote></i> отбрасывается наибольшая порция, совпадающая со<i> <blockquote>строкой</blockquote></i>, и возвращается остальная часть значения</td>      </tr>      <tr>       <td valign="top"><blockquote>${<i>парам</i>#<i>строка</i>}</blockquote></td>       <td valign="top">От начала значения<i> <blockquote>парам</blockquote></i> отбрасывается наименьшая порция, совпадающая со<i> <blockquote>строкой</blockquote></i>, и возвращается остальная часть значения</td>      </tr>      <tr>       <td valign="top"><blockquote>${<i>парам</i>##<i>строка</i>}</blockquote></td>       <td valign="top">От начала значения<i> <blockquote>парам</blockquote></i> отбрасывается наибольшая порция, совпадающая со<i> <blockquote>строкой</blockquote></i>, и возвращается остальная часть значения</td>      </tr>     </table>     <p>Эти подстановки очень полезны при работе со строками. Последние четыре варианта, удаляющие части строк, особенно пригодятся при обработке имен файлов и путей к ним, как показано в упражнении 2.18.</p>     <p>В приведенном далее сценарии показано применение шаблонов при подстановках значений параметров.</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>unset foo</blockquote></p>     <p><blockquote>echo ${foo:-bar}</blockquote></p>     <p><blockquote>foo=fud</blockquote></p>     <p><blockquote>echo ${foo:-bar}</blockquote></p>     <br>     <p><blockquote>foo=/usr/bin/X11/startx</blockquote></p>     <p><blockquote>echo ${foo#*/}</blockquote></p>     <p><blockquote>echo ${foo##*/}</blockquote></p>     <br>     <p><blockquote>bar=/usr/local/etc/local/networks</blockquote></p>     <p><blockquote>echo ${bar%local*}</blockquote></p>     <p><blockquote>echo ${bar%%local*}</blockquote></p>     <br>     <p><blockquote>exit 0</blockquote></p>     <p>У этого сценария следующий вывод:</p>     <p><blockquote>bar</blockquote></p>     <p><blockquote>fud</blockquote></p>     <p><blockquote>usr/bin/X11/startx</blockquote></p>     <p><blockquote>startx</blockquote></p>     <p><blockquote>/usr/local/etc/usr</blockquote></p>     <p><b>Как это работает</b></p>     <p>Первая подстановка <blockquote>${foo:-bar}</blockquote> дает значение <blockquote>bar</blockquote>, поскольку у <blockquote>foo</blockquote> нет значения в момент выполнения команды. Переменная <blockquote>foo</blockquote> остается неизменной, т.е. она остается незаданной.</p>     <blockquote>      <b>Примечание</b>      <p>Подстановка <blockquote>${foo:=bar}</blockquote> установила бы значение переменной <blockquote>$foo</blockquote>. Этот строковый шаблон устанавливает, что переменная <blockquote>foo</blockquote> существует и не равна <blockquote>null</blockquote>. Если значение переменной не равно <blockquote>null</blockquote>, оператор возвращает ее значение, в противном случае вместо этого переменной <blockquote>foo</blockquote> присваивается значение <blockquote>bar</blockquote>.</p>      <p>Подстановка <blockquote>${foo:?bar}</blockquote> выведет на экран <blockquote>foo: bar</blockquote> и аварийно завершит команду, если переменной <blockquote>foo</blockquote> не существует или ее значение не определено. И наконец, <blockquote>${foo:+bar}</blockquote> вернет <blockquote>bar</blockquote>, если <blockquote>foo</blockquote> существует и не равна <blockquote>null</blockquote>. Какое разнообразие вариантов!</p>     </blockquote>     <p>Шаблон <blockquote>{foo#*/}</blockquote> задает поиск и удаление только левого символа <blockquote>/</blockquote> (символ <blockquote>*</blockquote> соответствует любой строке, в том числе и пустой). Шаблон <blockquote>{foo##*/}</blockquote> задает поиск максимальной подстроки, совпадающей с ним, и, таким образом, удаляет самый правый символ / и все предшествующие ему символы.</p>     <p>Шаблон <blockquote>${bar%local*}</blockquote> определяет просмотр символов в значении параметра, начиная от крайнего правого, до первого появления подстроки <blockquote>local</blockquote>, за которой следует любое количество символов, а в случае шаблона <blockquote>${bar%%local*}</blockquote> ищется максимально возможное количество символов, начиная от крайнего правого символа значения и заканчивая крайним левым появлением подстроки <blockquote>local</blockquote>.</p>     <p>Поскольку в системах UNIX и Linux многое основано на идеи фильтров, результат какой-либо операции часто должен перенаправляться вручную. Допустим, вы хотите преобразовать файлы GIF в файлы JPEG с помощью программы cjpeg:</p>     <p><blockquote>$ <b>cjpeg image.gif &gt; image.jpg</b></blockquote></p>     <p>Порой вам может потребоваться выполнить такого рода операцию над большим числом файлов. Как автоматизировать подобное перенаправление? Это очень просто:</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <p><blockquote>for image in *.gif</blockquote></p>     <p><blockquote>do</blockquote></p>     <p><blockquote> cjpeg $image &gt; {image%%gif}jpg</blockquote></p>     <p><blockquote>done</blockquote></p>     <p>Этот сценарий, giftojpeg, создает в текущем каталоге для каждого файла формата GIF файл формата JPEG.</p>             <a name="metkadoc20"><h1>Встроенные документы</h1></a>     <p>Особый способ передачи из сценария командной оболочки входных данных команде — использование<i> встроенного документа</i> (here document). Такой документ позволяет команде выполняться так, как будто она читает данные из файла или с клавиатуры, в то время как на самом деле она получает их из сценария.</p>     <p>Встроенный документ начинается со служебных символов <blockquote>&lt;&lt;</blockquote>, за которыми следует специальная символьная последовательность, повторяющаяся и в конце документа. Символы <blockquote>&lt;&lt;</blockquote> обозначают в командной оболочке перенаправление данных, которое в данном случае заставляет вход команды превратиться во встроенный документ. Специальная последовательность символов действует как маркер, указывая оболочке, где завершается встроенный документ. Маркерная последовательность не должна включаться в строки, передаваемые команде, поэтому лучше всего сделать ее запоминающейся и четко выделяющейся.</p>     <p>Рассмотрим упражнение 2.19.</p>     <b>Упражнение 2.19. Применение встроенных документов</b>     <p>Простейший пример просто передает входные данные команде <blockquote>cat</blockquote>.</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <p><blockquote>cat &lt;&lt;!FUNKY!</blockquote></p>     <p><blockquote>hello</blockquote></p>     <p><blockquote>this is a here</blockquote></p>     <p><blockquote>document</blockquote></p>     <p><blockquote>!FUNKY!</blockquote></p>     <p>Этот пример выводит на экран следующие строки:</p>     <p>hello</p>     <p>this is a here</p>     <p>document</p>     <p>Встроенные документы могут показаться странным средством, но они очень полезны, т.к. позволяют запускать интерактивные программы, например редактор, и снабжать их каким-либо заранее определенным вводом. Но особенно часто они применяются при выводе из сценария больших порций текста, как вы уже видели, и при этом позволяют избавиться от необходимости применять команду <blockquote>echo</blockquote> для каждой выводимой строки. Вы можете использовать восклицательные знаки (<blockquote>!</blockquote>) с двух сторон от идентификатора документа во избежание путаницы.</p>     <p>Если вы хотите обработать несколько строк заранее определенным способом, можно применить в сценарии строчный редактор ed и передать ему команды из встроенного документа (упражнение 2.20).</p>     <b>Упражнение 2.20. Ещё одно применение встроенного документа</b>     <p>1. Начнем с файла, названного a_text_file и содержащего следующие строки:</p>     <p><blockquote>That is line 1</blockquote></p>     <p><blockquote>That is line 2</blockquote></p>     <p><blockquote>That is line 3That is line 4</blockquote></p>     <p>2. Вы можете отредактировать этот файл, совместно используя встроенный документ и редактор ed:</p>     <p><blockquote>#!/bin/sh</blockquote></p>     <br>     <p><blockquote>ed a_text_file &lt;&lt;!FunkyStuff!</blockquote></p>     <p><blockquote>3</blockquote></p>     <p><blockquote>d</blockquote></p>     <p><blockquote>., \$s/is/was/ w</blockquote></p>     <p><blockquote>q</blockquote></p>     <p><blockquote>!FunkyStuff!</blockquote></p>     <br>     <p><blockquote>exit 0</blockquote></p>     <p>Если вы выполните этот сценарий, то увидите, что теперь файл содержит следующие строки:</p>     <p><blockquote>That is line 1</blockquote></p>     <p><blockquote>That is line 2</blockquote></p>     <p><blockquote>That was line 4</blockquote></p>     <p><b>Как это работает</b></p>     <p>Сценарий командной оболочки запускает редактор ed и передает ему команды, необходимые для перехода к третьей строке, удаления строки и затем замены ее содержимым текущей строки (поскольку строка 3 (line 3) была удалена, теперь текущая строка — последняя строка файла). Эти команды редактора ed берутся из строк сценария, формирующих встроенный документ, строк между маркерами <blockquote>!Funky Stuff!</blockquote>.</p>     <blockquote>      <b>Примечание</b>      <p>Обратите внимание на знак <blockquote>\</blockquote> внутри встроенного документа, применяемый для защиты от подстановки, выполняемой командной оболочкой. Символ <blockquote>\</blockquote> экранирует знак <blockquote>$</blockquote>, поэтому оболочка знает, что не следует пытаться подставить вместо строки <blockquote>\$s/is/was/</blockquote> ее значение, которого у нее конечно же нет. Оболочка просто передает текст <blockquote>\$</blockquote> как $, который затем сможет интерпретировать редактор e</p>     </blockquote>             <a name="metkadoc21"><h1>Отладка сценариев</h1></a>     <p>Обычно отлаживать сценарии командной оболочки довольно легко, хотя специальных вспомогательных средств отладки не существует. В этом разделе мы дадим краткий обзор наиболее распространенных приемов.</p>     <p>Когда возникает ошибка, командная оболочка, как правило, выводит на экран номер строки, содержащей ошибку. Если ошибка сразу не видна, вы можете добавить несколько дополнительных команд <blockquote>echo</blockquote> для отображения содержимого переменных и протестировать фрагменты программного кода, просто вводя их в командной оболочке в интерактивном режиме.</p>     <p>Поскольку сценарии обрабатываются интерпретатором, нет затрат на компиляцию при корректировке и повторном выполнении сценария. Основной способ отслеживания наиболее трудно выявляемых ошибок — задание различных опций командной оболочки. Для этого вы можете применять опции командной строки после запуска командной оболочки или использовать команду <blockquote>set</blockquote>. В табл. 2.19 перечислены эти опции.</p>     <br>     <p><b><i>Таблица 2.19</i></b></p>     <table>      <tr>       <th valign="top">Опция командной строки</th>       <th valign="top">Опция команды <blockquote>set</blockquote></th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>sh -n &lt;<i>сценарий</i>&gt;</blockquote></td>       <td valign="top"><blockquote>set -о noexec  set -n</blockquote></td>       <td valign="top">Только проверяет синтаксические ошибки; не выполняет команды</td>      </tr>      <tr>       <td valign="top"><blockquote>sh -v &lt;<i>сценарий</i>&gt;</blockquote></td>       <td valign="top"><blockquote>set -о verbose  set -v</blockquote></td>       <td valign="top">Выводит на экран команды перед их выполнением</td>      </tr>      <tr>       <td valign="top"><blockquote>sh -х &lt;<i>сценарий</i>&gt;</blockquote></td>       <td valign="top"><blockquote>set -о xtrace  set -x</blockquote></td>       <td valign="top">Выводит на экран команды после обработки командной строки</td>      </tr>      <tr>       <td valign="top"><blockquote>sh -u &lt;<i>сценарий</i>&gt;</blockquote></td>       <td valign="top"><blockquote>set -o nounset  set -u</blockquote></td>       <td valign="top">Выдает сообщение об ошибке при использовании неопределенной переменной</td>      </tr>     </table>     <p>Вы можете установить опции с помощью флагов <blockquote>-о</blockquote> и сбросить их с помощью флагов <blockquote>+о</blockquote> подобным же образом в сокращенных версиях. Получить простое отслеживание выполнения можно, используя опцию <blockquote>xtrace</blockquote>. Для начала вы можете применить опцию командной строки, но для более тщательной отладки следует поместить опции <blockquote>xtrace</blockquote> (задавая выполнение и сброс отслеживания выполнения) внутрь сценария, в тот фрагмент кода, который создает проблему. Отслеживание выполнения заставляет командную оболочку перед выполнением каждой строки сценария выводить на экран эту строку и подставлять в нее значения используемых переменных.</p>     <p>Для установки опции <blockquote>xtrace</blockquote> используйте следующую команду:</p>     <p><blockquote>set -о xtrace</blockquote></p>     <p>Для того чтобы снова отключить эту опцию, применяйте следующую команду:</p>     <p><blockquote>set +о xtrace</blockquote></p>     <p>Уровень выполняемых подстановок задается (по умолчанию) количеством знаков <blockquote>+</blockquote> в начале каждой строки. Вы можете заменить знак <blockquote>+</blockquote> на что-то более осмысленное, определив переменную командной оболочки <blockquote>PS4</blockquote> в вашем файле конфигурации оболочки.</p>     <p>В командной оболочке также можно выяснить состояние программы после ее завершения, перехватив сигнал <blockquote>EXIT</blockquote> с помощью строки, подобной приведенной далее и помещенной в начале вашего сценария:</p>     <p><blockquote>trap 'echo Exiting: critical variable = $critical_variable' EXIT</blockquote></p>              <a name="metkadoc22"><h1>По направлению к графическому режиму — утилита<i> dialog</i></h1></a>    <p>Прежде чем мы закончим обсуждение сценариев командной оболочки, обратимся к еще одному средству, которое, хотя, строго говоря, и не является частью оболочки, в основном полезно применять именно в программах командной оболочки.</p>    <p>Если вы знаете, что ваш сценарий придется выполнять только с консоли ОС Linux, существует довольно изящный способ оживить сценарий, применяя служебную команду <blockquote>dialog</blockquote>. Она использует средства псевдографики текстового режима и цвет, но при этом выглядит привлекательно.</p>    <blockquote>     <b>Примечание</b>     <p>В некоторых дистрибутивах команда <blockquote>dialog</blockquote> по умолчанию не устанавливается; например, в Ubuntu вам, возможно, придется добавить совместно поддерживаемые репозитарии для поиска готовой версии. В других дистрибутивах вы можете найти уже установленный альтернативный вариант, <blockquote>gdialog</blockquote>. Он очень похож, но рассчитан на пользовательский интерфейс GNOME, применяемый для отображения диалоговых окон команды. В этом случае вы получите настоящий графический интерфейс. Как правило, в любой программе, использующей команду <blockquote>dialog</blockquote>, можно заменить все вызовы этой команды на <blockquote>gdialog</blockquote>, и вы получите графическую версию вашей программы. В конце этого раздела мы покажем пример программы, использующей команду <blockquote>gdialog</blockquote>.</p>    </blockquote>    <p>Общая концепция утилиты <blockquote>dialog</blockquote> проста — одна программа с множеством параметров и опций, позволяющих отображать различные типы графических окон, начиная с простых окон с кнопками типа <b>Yes/No</b> (Да/Нет) и заканчивая окнами ввода и даже выбором пункта меню. Утилита обычно возвращает результат, когда пользователь выполнил какой-либо ввод, и результат может быть получен или из статуса завершения, или, если вводился текст, извлечением стандартного потока ошибок.</p>    <p>Прежде чем переходить к подробностям, давайте рассмотрим очень простой пример применения утилиты <blockquote>dialog</blockquote>. Вы можете вызывать ее непосредственно из командной строки, что прекрасно с точки зрения создания прототипов. Поэтому создадим простое окно сообщений для отображения традиционной первой программы:</p>    <p><blockquote>dialog --msgbox "Hello World" 9 18</blockquote></p>    <p>На экране появится графическое информационное окно, дополненное кнопкой OK (рис. 2.3).</p>    <img src="image004.jpg"/>    <p><b>Рис. 2.3</b></p>    <br>    <p>Теперь, когда вы убедились в простоте утилиты <blockquote>dialog</blockquote>, давайте поподробнее рассмотрим ее функциональные возможности. Основные типы диалоговых окон, которые вы можете создавать, перечислены в табл. 2.20.</p>    <br>    <p><b><i>Таблица 2.20</i></b></p>    <table>     <tr>      <th valign="top">Тип диалогового окна</th>      <th valign="top">Опция, применяемая для создания окна этого типа</th>      <th valign="top">Назначение окна</th>     </tr>     <tr>      <td valign="top">Окна с флажками (Check boxes)</td>      <td valign="top"><blockquote>--checklist</blockquote></td>      <td valign="top">Позволяет отображать список флажков, каждый из которых можно установить или сбросить</td>     </tr>     <tr>      <td valign="top">Информационные окна (Info boxes)</td>      <td valign="top"><blockquote>--infobox</blockquote></td>      <td valign="top">Простое немедленное отображение в окне, без очистки экрана, возвращаемых данных</td>     </tr>     <tr>      <td valign="top">Окна ввода (Input boxes)</td>      <td valign="top"><blockquote>--inputbox</blockquote></td>      <td valign="top">Позволяет пользователю вводить в окно текст</td>     </tr>     <tr>      <td valign="top">Окна меню (Menu boxes)</td>      <td valign="top"><blockquote>--menu</blockquote></td>      <td valign="top">Позволяет пользователю выбрать один пункт из списка</td>     </tr>     <tr>      <td valign="top">Окна сообщений (Message boxes)</td>      <td valign="top"><blockquote>--msgbox</blockquote></td>      <td valign="top">Отображает сообщения для пользователей и снабжено кнопкой OK, которую они должны нажать для продолжения</td>     </tr>     <tr>      <td valign="top">Окна с переключателями (Radio selection boxes)</td>      <td valign="top"><blockquote>--radiolist</blockquote></td>      <td valign="top">Позволяет пользователю выбрать один переключатель из списка</td>     </tr>     <tr>      <td valign="top">Текстовые окна (Text boxes)</td>      <td valign="top"><blockquote>--textbox</blockquote></td>      <td valign="top">Позволяют отображать содержимое файла в окне с прокруткой</td>     </tr>     <tr>      <td valign="top">Диалоговые окна <b>Да/Нет</b> (Yes/No boxes)</td>      <td valign="top"><blockquote>--yesno</blockquote></td>      <td valign="top">Позволяют задать вопрос, на который пользователь может ответить "Да" или "Нет"</td>     </tr>    </table>    <p>Доступны также и некоторые дополнительные типы диалоговых окон (например, индикатор процесса или окно ввода пароля). Если вы хотите узнать побольше о необычных типах диалоговых окон, как всегда подробную информацию можно найти на страницах интерактивного справочного руководства.</p>    <p>Для получения вывода из диалогового окна любого типа, допускающего текстовый ввод или выбор, вы должны перехватить стандартный поток ошибок, как правило, направляя его во временный файл, который вы сможете обработать позже. Для получения ответа на вопросы типа "Да"/"Нет", просто проверьте код завершения, который, как и во всех соблюдающих приличия программах, в случае успеха возвращает 0 (т. е. выбор ответа "Да" (Yes)) и 1 в остальных случаях.</p>    <p>У всех типов диалоговых окон есть дополнительные управляющие параметры, такие как размер и контур отображаемого окна. В табл. 2.21 перечислены разные параметры, необходимые окнам каждого типа, а затем демонстрируется использование некоторых из них в командной строке. В заключение вы увидите простой пример, объединяющий в одной программе несколько диалоговых окон разных типов.</p>    <br>    <p><b><i>Таблица 2.21</i></b></p>    <table>     <tr>      <th valign="top">Тип диалогового окна</th>      <th valign="top">Параметры</th>     </tr>     <tr>      <td valign="top"><blockquote>--checklist</blockquote></td>      <td valign="top"><blockquote>text height width list-height [tag text status] ...</blockquote></td>     </tr>     <tr>      <td valign="top"><blockquote>--infobox</blockquote></td>      <td valign="top"><blockquote>text height width</blockquote></td>     </tr>     <tr>      <td valign="top"><blockquote>--inputbox</blockquote></td>      <td valign="top"><blockquote>text height width [initial string]</blockquote></td>     </tr>     <tr>      <td valign="top"><blockquote>--menu</blockquote></td>      <td valign="top"><blockquote>text height width menu-height [tag item ] ...</blockquote></td>     </tr>     <tr>      <td valign="top"><blockquote>--msgbox</blockquote></td>      <td valign="top"><blockquote>text height width</blockquote></td>     </tr>     <tr>      <td valign="top"><blockquote>--radiolist</blockquote></td>      <td valign="top"><blockquote>text height width list-height [tag text status] ...</blockquote></td>     </tr>     <tr>      <td valign="top"><blockquote>--textbox</blockquote></td>      <td valign="top"><blockquote>filename height width</blockquote></td>     </tr>     <tr>      <td valign="top"><blockquote>--yesno</blockquote></td>      <td valign="top"><blockquote>text height width</blockquote></td>     </tr>    </table>    <p>Помимо параметров диалоговые окна всех типов принимают ряд опций. Мы не будем перечислять все, а упомянем лишь две из них: <blockquote>--title</blockquote>, позволяющую задать заголовок окна, и <blockquote>-clear</blockquote>, применяемую по прямому назначению, т.е. для очистки экрана. Полный список опций см. на страницах интерактивного справочного руководства.</p>    <p>Выполните упражнения 2.21 и 2.22.</p>    <b>Упражнение 2.21. Применение утилиты <blockquote>dialog</blockquote></b>    <p>Давайте сразу перейдем к красивому сложному примеру. Если вы поймете его, все остальные покажутся легкими! В этом примере вы создадите диалоговое окно со списком флажков, с заголовком<b> Check me</b> (Поставь галочку) и пояснительной надписью<b> Pick Numbers</b> (Выбери номера). Окно с флажками будет высотой 15 строк и шириной 25 символов, и каждый флажок будет занимать 3 символа по высоте. И последнее, но не по степени важности, вы перечислите отображаемые элементы вместе с принятой по умолчанию установкой или сбросом (on/off) флажка.</p>    <p><blockquote>dialog --title "Check me" --checklist "Pick Numbers" 15 25 3 1 "one" "off" 2 "two" "on" 3 "three" "off"</blockquote></p>    <p>Полученный результат показан на рис. 2.4.</p>    <p><b>Как это работает</b></p>    <p>В этом примере параметр <blockquote>--checklist</blockquote> указывает на то, что вы собираетесь создать диалоговое окно с флажками. Вы используете опцию <blockquote>--title</blockquote> для задания заголовка "<blockquote>Check me</blockquote>", следующий параметр — пояснительная надпись "<blockquote>Pick Numbers</blockquote>".</p>    <p>Далее вы переходите к указанию размеров диалогового окна. Оно будет высотой 15 строк и шириной 25 символов и 3 строки отводятся для меню. Это не самый удачный выбор размеров, но он позволит вам увидеть, как размещаются элементы.</p>    <p>Опции выглядят несколько мудрено, но вам следует запомнить только то, что у каждого элемента списка есть три значения:</p>    <p>&#9633; номер в списке;</p>    <p>&#9633; текст;</p>    <p>&#9633; состояние.</p>    <img src="image005.jpg"/>    <p><b>Рис. 2.4</b></p>    <br>    <p>У первого элемента номер 1, отображается текст "one" (один) и выбрано состояние "off" (сброшен). Далее вы переходите ко второму элементу с номером 2, текстом "two" и состоянием "on" (установлен). Так продолжается до тех пор, пока вы не опишите все элементы списка.</p>    <p>Легко, не правда ли? Теперь попробуйте ввести несколько вариантов в командной строке и убедитесь, насколько эту утилиту легко применять. Для того чтобы включить этот пример в программу, вы должны иметь доступ к результатам пользовательского ввода. Это совсем просто: перенаправьте стандартный поток ошибок в текстовый ввод или проверьте переменную окружения <blockquote>$?</blockquote>, которая, как вы помните, не что иное, как код завершения предыдущей команды.</p>    <b>Упражнение 2.22. Более сложная программа, использующая утилиту <blockquote>dialog</blockquote></b>    <p>Давайте рассмотрим простую программу questions, которая принимает к сведению пользовательские ответы.</p>    <p>1. Начните с простого диалогового окна, сообщающего пользователю о происходящем. Вам не нужно получать результат или какой бы то ни было ввод пользователя, поэтому все просто и ясно:</p>    <p><blockquote>#!/bin/sh</blockquote></p>    <p><blockquote># Задайте несколько вопросов и получите ответ</blockquote></p>    <p><blockquote>dialog --title "Questionnaire" --msgbox "Welcome to my simple survey" 9 18</blockquote></p>    <p>2. Спросите пользователя с помощью простого диалогового окна с кнопками типа <b>Yes/No,</b> хочет ли он продолжать. Воспользуйтесь переменной окружения <blockquote>$?</blockquote> для того, чтобы выяснить, выбрал пользователь ответ<b> Yes</b> (код завершения 0) или <b>No.</b> Если он не хочет двигаться дальше, используйте простое информационное окно, не требующее никакого пользовательского ввода для своего завершения.</p>    <p><blockquote>dialog --title "Confirm" --yesno "Are you willing to take part?" 9 18</blockquote></p>    <p><blockquote>if [ $? != 0 ]; then</blockquote></p>    <p><blockquote> dialog --infobox "Thank you anyway" 5 20 sleep 2</blockquote></p>    <p><blockquote> dialog --clear exit 0</blockquote></p>    <p><blockquote>fi</blockquote></p>    <p>3. Спросите у пользователя его имя с помощью диалогового окна ввода. Перенаправьте стандартный поток ошибок во временный файл _1.txt, который затем вы сможете обработать в переменной <blockquote>QNAME</blockquote>.</p>    <p><blockquote>dialog --title "Questionnaire" --inputbox "Please enter your name" 9 30 2&gt;_1.txt</blockquote></p>    <p><blockquote>Q_NAME=$(cat _1.txt)</blockquote></p>    <p>4. Здесь у вас появляется меню из четырех пунктов. И снова вы перенаправляете стандартный поток ошибок и загружаете его в переменную.</p>    <p><blockquote>dialog --menu "$Q_NAME, what music do you like best?" 15 30 4 1 "Classical" 2 "Jazz" 3 "Country" 4 "Other" 2&gt;_1.txt</blockquote></p>    <p><blockquote>Q_MUSIC=$(cat _1.txt)</blockquote></p>    <p>5. Номер, выбранный пользователем, будет запоминаться во временном файле _1.txt, который перехватывается переменной <blockquote>Q_MUSIC</blockquote>, поэтому вы сможете проверить результат.</p>    <p><blockquote>if [ "$Q_MUSIC" = "1" ]; then</blockquote></p>    <p><blockquote> dialog --title "Likes Classical" --msgbox "Good choice!" 12 25</blockquote></p>    <p><blockquote>else</blockquote></p>    <p><blockquote> dialog --title "Doesn't like Classical" --msgbox "Shame" 12 25</blockquote></p>    <p><blockquote>fi</blockquote></p>    <p>В заключение очистите последнее диалоговое окно и завершите программу.</p>    <p><blockquote>sleep 2</blockquote></p>    <p><blockquote>dialog --clear</blockquote></p>    <p><blockquote>exit 0</blockquote></p>    <p>На рис. 2.5 показан результат.</p>    <p><b>Как это работает</b></p>    <p>В данном примере вы соединяете команду <blockquote>dialog</blockquote> и простой программный код на языке командной оболочки для того, чтобы показать, как можно создавать простые программы с графическим пользовательским интерфейсом, используя только сценарий командной оболочки. Вы начинаете с обычного экрана-приветствия, а затем с помощью простого диалогового окна с кнопками типа <b>Yes/No</b> спрашиваете пользователя о его желании участвовать в опросе. Вы используете переменную <blockquote>$?</blockquote> для проверки ответа пользователя. Если он согласен, вы запрашиваете его имя, сохраняете его в переменной <blockquote>Q_NAME</blockquote> и выясняете с помощью диалогового окна-меню, какой музыкальный стиль он любит. Сохранив числовой вывод в переменной <blockquote>Q_MUSIC</blockquote>, вы сможете увидеть, что ответил пользователь, и отреагировать соответственно.</p>    <img src="image006.jpg"/>    <p><b>Рис. 2.5</b></p>    <br>    <img src="image007.jpg"/>    <p><b>Рис. 2.6</b></p>    <br>    <p>Если вы применяете графический пользовательский интерфейс (GUI) на базе графической среды GNOME и в данный момент запустили в нем сеанс работы с терминалом, на месте команды <blockquote>dialog</blockquote> можно использовать команду <blockquote>gdialog</blockquote>. У обеих команд одинаковые параметры, поэтому вы сможете воспользоваться тем же программным кодом, не считая замены запускаемой вами команды <blockquote>dialog</blockquote> командой <blockquote>gdialog</blockquote>. На рис. 2.6 показано, как выглядит этот сценарий в дистрибутиве Ubuntu, когда применяется команда <blockquote>gdialog</blockquote>.</p>    <p>Это очень лёгкий способ формирования из сценария удачного графического пользовательского интерфейса.</p>          <a name="metkadoc23"><h1>Соединяем все вместе</h1></a>         <p>Теперь, когда вы познакомились с основными функциональными возможностями командной оболочки как языка программирования, пора написать программу, в которой используется кое-что из того, чему вы научились.</p>     <p>На протяжении всей книги вы будете пытаться разработать приложение управления базой данных компакт-дисков для того, чтобы продемонстрировать приемы и методы, которые вы только что освоили. Вы начинаете со сценария командной оболочки, но очень скоро вы будете делать то же самое на языке программирования С, добавлять базу данных и т.д.</p>             <a name="metkadoc24"><h1>Требования</h1></a>     <p>Предположим, что у вас есть разнообразная коллекция компакт-дисков. Для того чтобы облегчить себе жизнь, вы собираетесь разработать и реализовать программу управления компакт-дисками. Электронный каталог представляется идеальным проектом для реализации, когда вы учитесь программированию в ОС Linux.</p>     <p>Вначале вы хотите, по меньшей мере, хранить некоторые основные сведения о каждом компакт-диске, такие как название, музыкальный стиль и исполнитель или композитор. Возможно, вам также хотелось бы запоминать некоторую простую информацию о дорожках. Вы хотите иметь возможность находить любое музыкальное произведение из хранящихся на компакт-диске, но не какие-то подробности, касающиеся дорожек. Для придания законченности мини-приложению вам хотелось бы иметь возможность в самом приложении вводить, обновлять и удалять любую часть информации.</p>             <a name="metkadoc25"><h1>Проектирование</h1></a>     <p>Поиск и отображение данных — заставляют предполагать, что адекватным решением будет простое меню. Все данные, которые следует хранить, — текстовые, и, полагая, что ваша коллекция компакт-дисков не слишком велика, для управления ею не потребуется сложная база данных, подойдут простые текстовые файлы. Сохранение информации в текстовых файлах позволит сделать приложение простым, и если ваши требования изменятся, всегда легче манипулировать текстовыми файлами, чем какими бы то ни было еще. И, в крайнем случае, вы сможете применить редактор для ввода и удаления данных вручную, а не писать для этого специальную программу.</p>     <p>Необходимо принять важное проектное решение, касающееся способа хранения данных. Достаточно одного файла? Если да, то какой у него должен быть формат? Большая часть информации, которую вы собираетесь хранить, за исключением данных о дорожках, вводится однократно для каждого компакт-диска (мы пока оставим в стороне вариант наличия на одном CD произведений разных композиторов и исполнителей). И практически на всех компакт-дисках много дорожек.</p>     <p>Нужно ли ограничить количество дорожек на одном компакт-диске, которые можно хранить? Это ограничение кажется лишним, поэтому сразу отбросим его.</p>     <p>Если вы допускаете, что на компакт-диске может быть разное количество дорожек, у вас есть три варианта:</p>     <p>&#9633; использовать один файл с одной строкой для "заголовочной" типовой информации и <i>n</i> строк для сведений о дорожках на каждом компакт-диске;</p>     <p>&#9633; поместить всю информацию о каждом компакт-диске в одну строку, разрешая ей продолжаться то тех пор, пока вся информация о дорожках диска не будет сохранена;</p>     <p>&#9633; отделить заголовочную информацию от данных о дорожках и для каждого типа информации использовать отдельный файл.</p>     <p>Только третий вариант позволит нам легко изменять формат файлов, что потребуется, если вы когда-либо захотите превратить вашу базу данных в реляционную (более подробную информацию об этом<i> см. в главе</i> 7), поэтому выберем этот вариант.</p>     <p>Далее нужно решить, какие данные помещать в файлы.</p>     <p>Сначала вы выбираете для заголовка каждого компакт-диска хранение следующей информации:</p>     <p>&#9633; номер компакт-диска в каталоге;</p>     <p>&#9633; название;</p>     <p>&#9633; музыкальный стиль (классика, рок, поп, джаз и т.д.);</p>     <p>&#9633; композитор или исполнитель.</p>     <p>О дорожках вы будете хранить две характеристики:</p>     <p>&#9633; номер дорожки;</p>     <p>&#9633; ее название.</p>     <p>Для объединения двух файлов вы должны сопоставить данные о дорожках с остальной информацией о компакт-диске. Для этого будет использоваться номер компакт-диска в каталоге. Поскольку он уникален для каждого диска, он будет появляться однократно в файле с заголовками и один раз для каждой дорожки в файле с данными о дорожках.</p>     <p>В табл. 2.22 показан пример файла с заголовочными данными, а соответствующий ему файл с данными о дорожках может выглядеть так, как представлено в табл. 2.23.</p>     <br>     <p><b><i>Таблица 2.22</i></b></p>     <table>      <tr>       <th valign="top">Catalog</th>       <th valign="top">Title</th>       <th valign="top">Type</th>       <th valign="top">Composer</th>      </tr>      <tr>       <td valign="top">CD123</td>       <td valign="top">Cool sax</td>       <td valign="top">Jazz</td>       <td valign="top">Bix</td>      </tr>      <tr>       <td valign="top">CD234</td>       <td valign="top">Classic violin</td>       <td valign="top">Classical</td>       <td valign="top">Bach</td>      </tr>      <tr>       <td valign="top">CD345</td>       <td valign="top">Hits99</td>       <td valign="top">Pop</td>       <td valign="top">Various</td>      </tr>     </table>     <br>     <p><b><i>Таблица 2.23</i></b></p>     <table>      <tr>       <th valign="top">Catalog</th>       <th valign="top">Track No.</th>       <th valign="top">Title</th>      </tr>      <tr>       <td valign="top">CD123</td>       <td valign="top">1</td>       <td valign="top">Some jazz</td>      </tr>      <tr>       <td valign="top">CD123</td>       <td valign="top">2</td>       <td valign="top">More jazz</td>      </tr>      <tr>       <td valign="top">CD234</td>       <td valign="top">1</td>       <td valign="top">Sonata in D minor</td>      </tr>      <tr>       <td valign="top">CD345</td>       <td valign="top">1</td>       <td valign="top">Dizzy</td>      </tr>     </table>     <p>Два файла объединены общим полем <blockquote>Catalog</blockquote> (Каталог). Следует помнить о том, что обычно на одну строку файла с заголовочной информацией приходится много строк в файле с данными о дорожках.</p>     <p>Последнее, что мы должны решить, — способ разделения элементов данных. Поля фиксированной ширины, обычные в реляционных базах, — не всегда самый удобный вариант. Другой распространенный способ, применяемый в данном примере, — запятая (т. е. файл со значениями, разделенными запятыми, или CSV-файл).</p>     <p>В упражнении 2.23 только для того, чтобы вы окончательно не запутались, применяются следующие функции:</p>     <p>&#9633; <blockquote>get_return()</blockquote>;</p>     <p>&#9633; <blockquote>get_confirm()</blockquote>;</p>     <p>&#9633; <blockquote>set_menu_choice()</blockquote>;</p>     <p>&#9633; <blockquote>insert_title()</blockquote>;</p>     <p>&#9633; <blockquote>insert_track()</blockquote>;</p>     <p>&#9633; <blockquote>add_record_tracks()</blockquote>;</p>     <p>&#9633; <blockquote>add_records()</blockquote>;</p>     <p>&#9633; <blockquote>find_cd()</blockquote>;</p>     <p>&#9633; <blockquote>update_cd()</blockquote>;</p>     <p>&#9633; <blockquote>count_cds()</blockquote>;</p>     <p>&#9633; <blockquote>remove_records()</blockquote>;</p>     <p>&#9633; <blockquote>list_tracks()</blockquote>.</p>     <b>Упражнение 2.23. Приложение для работы с коллекцией компакт-дисков</b>     <p>1. Сначала в примере сценария как всегда стоит строка, обеспечивающая его выполнение как сценария командной оболочки, за которой следует некоторая информация об авторских правах:</p>     <p><blockquote>#!/bin/bash</blockquote></p>     <br>     <p><blockquote># Очень простой пример сценария командной оболочки для управления</blockquote></p>     <p><blockquote># коллекцией компакт-дисков.</blockquote></p>     <p><blockquote># Copyright (С) 1996-2007 Wiley Publishing Inc.</blockquote></p>     <p><blockquote># Это свободно распространяемое программное обеспечение;</blockquote></p>     <p><blockquote># вы можете распространять эту программу и/или изменять ее</blockquote></p>     <p><blockquote># в соответствии с положениями GNU General Public License,</blockquote></p>     <p><blockquote># документа, опубликованного фондом Free Software Foundation;</blockquote></p>     <p><blockquote># либо версии 2 этой лицензии или (по вашему выбору)</blockquote></p>     <p><blockquote># любой более свежей версии.</blockquote></p>     <p><blockquote># Эта программа распространяется в надежде на ее полезность,</blockquote></p>     <p><blockquote># но WITHOUT ANY WARRANTY, (без каких-либо гарантий);</blockquote></p>     <p><blockquote># даже без предполагаемой гарантии MERCHANTABILITY</blockquote></p>     <p><blockquote># or FITNESS FOR A PARTICULAR PURPOSE (годности</blockquote></p>     <p><blockquote># ее для продажи или применения для определенной цели).</blockquote></p>     <p><blockquote># Более подробную информацию см. в GNU General Public License.</blockquote></p>     <p><blockquote># Вы должны были получить копию GNU General Public License</blockquote></p>     <p><blockquote># вместе с этой программой;</blockquote></p>     <p><blockquote># если нет, пишите в организацию Free Software Foundation,</blockquote></p>     <p><blockquote># Inc. no адресу: 675 Mass Ave, Cambridge, MA 02139, USA.</blockquote></p>     <p>2. Теперь убедитесь, что установлены некоторые глобальные переменные, которые будут использоваться во всем сценарии. Задайте заголовочный файл, файл с данными о дорожках и временный файл и перехватите нажатие комбинации клавиш &lt;Ctrl&gt;+&lt;C&gt; для того, чтобы удалить временный файл, если пользователь прервет выполнение сценария.</p>     <p><blockquote>menu_choice=""</blockquote></p>     <p><blockquote>current cd=""</blockquote></p>     <p><blockquote>title_file="title.cdb"</blockquote></p>     <p><blockquote>tracks_file="tracks.cdb"</blockquote></p>     <p><blockquote>temp_file=/tmp/cdb.$$</blockquote></p>     <p><blockquote>trap 'rm -f $temp_file' EXIT</blockquote></p>     <p>3. Определите ваши функции так, чтобы сценарий, выполняясь с первой строки, мог найти все определения функций до того, как вы попытаетесь вызвать любую из них в первый раз. Для того чтобы не повторять один и тот же программный код в нескольких местах, сначала вставьте две функции, служащие простыми утилитами:</p>     <p><blockquote>get_return() (</blockquote></p>     <p><blockquote> echo -е "Press return \с"</blockquote></p>     <p><blockquote> read x</blockquote></p>     <p><blockquote> return 0</blockquote></p>     <p><blockquote>}</blockquote></p>     <p><blockquote>get_confirm() (</blockquote></p>     <p><blockquote> echo -e "Are you sure? \c"</blockquote></p>     <p><blockquote> while true do</blockquote></p>     <p><blockquote>  read x</blockquote></p>     <p><blockquote>  case "$x" in</blockquote></p>     <p><blockquote>   y | yes | Y | Yes | YES )</blockquote></p>     <p><blockquote>    return 0;;</blockquote></p>     <p><blockquote>   n | no | N | No | NO )</blockquote></p>     <p><blockquote>    echo</blockquote></p>     <p><blockquote>    echo "Cancelled"</blockquote></p>     <p><blockquote>    return 1;;</blockquote></p>     <p><blockquote>   *)</blockquote></p>     <p><blockquote>    echo "Please enter yes or no" ;;</blockquote></p>     <p><blockquote>  esac</blockquote></p>     <p><blockquote> done</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>4. Теперь вы дошли до основной, формирующей меню функции <blockquote>set_menu_choice</blockquote>. Содержимое меню изменяется динамически, добавляя дополнительные пункты при выборе компакт-диска.</p>     <p><blockquote>set_menu_choice() {</blockquote></p>     <p><blockquote> clear</blockquote></p>     <p><blockquote> echo "Options :-"</blockquote></p>     <p><blockquote> echo</blockquote></p>     <p><blockquote> echo " a) Add new CD"</blockquote></p>     <p><blockquote> echo " f) Find CD"</blockquote></p>     <p><blockquote> echo " c) Count the CDs and tracks in the catalog"</blockquote></p>     <p><blockquote> if [ "$cdcatnum" != "" ]; then</blockquote></p>     <p><blockquote>  echo " 1) List tracks on $cdtitle"</blockquote></p>     <p><blockquote>  echo " r) Remove $cdtitle"</blockquote></p>     <p><blockquote>  echo " u) Update track information for $cdtitle"</blockquote></p>     <p><blockquote> fi</blockquote></p>     <p><blockquote> echo " q) Quit" echo</blockquote></p>     <p><blockquote> echo -e "Please enter choice then press return \c"</blockquote></p>     <p><blockquote> read menu_choice</blockquote></p>     <p><blockquote> return</blockquote></p>     <p><blockquote>}</blockquote></p>     <blockquote>      <b>Примечание</b>      <p>Имейте в виду, что команда <blockquote>echo -е</blockquote> не переносится в некоторые командные оболочки.</p>     </blockquote>     <p>5. Далее идут две очень короткие функции, <blockquote>insert_title</blockquote> и <blockquote>insert_track</blockquote>, для пополнения файлов базы данных. Несмотря на то, что некоторые программисты ненавидят однострочные функции вроде этих, они помогают сделать понятнее другие функции.</p>     <p>За ними следует более длинная функция <blockquote>add_record_track</blockquote>, использующая эти функции. В данной функции применяется проверка на соответствие шаблону, чтобы исключить ввод запятых (поскольку мы. используем запятые для разделения полей), и арифметические операции для увеличения номера текущей дорожки на 1, когда вводятся данные о новой дорожке.</p>     <p><blockquote>insert_title() {</blockquote></p>     <p><blockquote> echo $* &gt;&gt; $title_file</blockquote></p>     <p><blockquote> return</blockquote></p>     <p><blockquote>}</blockquote></p>     <p><blockquote>insert_track() {</blockquote></p>     <p><blockquote> echo $* &gt;&gt; $tracks_file</blockquote></p>     <p><blockquote> return</blockquote></p>     <p><blockquote>}</blockquote></p>     <p><blockquote>add_record_tracks() {</blockquote></p>     <p><blockquote> echo "Enter track information for this CD"</blockquote></p>     <p><blockquote> echo "When no more tracks enter q"</blockquote></p>     <p><blockquote> cdtrack=1</blockquote></p>     <p><blockquote> cdttitle=""</blockquote></p>     <p><blockquote> while [ "$cdttitle" != "q" ]</blockquote></p>     <p><blockquote> do</blockquote></p>     <p><blockquote>  echo -e "Track $cdtrack, track title? \c"</blockquote></p>     <p><blockquote>  read tmp</blockquote></p>     <p><blockquote>  cdttitle=${tmp%%, *}</blockquote></p>     <p><blockquote>  if [ "$tmp" != "$cdttitle" ]; then</blockquote></p>     <p><blockquote>   echo "Sorry, no commas allowed"</blockquote></p>     <p><blockquote>   continue</blockquote></p>     <p><blockquote>  fi</blockquote></p>     <p><blockquote>  if [ -n "$cdttitle" ] ; then</blockquote></p>     <p><blockquote>   if [ "$cdttitle" ! = "q" ]; then</blockquote></p>     <p><blockquote>    insert_track $cdcatnum, $cdtrack, $cdttitle</blockquote></p>     <p><blockquote>   fi</blockquote></p>     <p><blockquote>  else</blockquote></p>     <p><blockquote>   cdtrack=$((cdtrack-1))</blockquote></p>     <p><blockquote>  fi</blockquote></p>     <p><blockquote>  cdtrack=$((cdtrack+1))</blockquote></p>     <p><blockquote> done</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>6. Функция <blockquote>add_records</blockquote> позволяет вводить основную информацию о новом компакт-диске.</p>     <p><blockquote>add_records() {</blockquote></p>     <p><blockquote> # Подсказка для начала ввода информации</blockquote></p>     <p><blockquote> echo -е "Enter catalog name \с"</blockquote></p>     <p><blockquote> read tmp</blockquote></p>     <p><blockquote> cdcatnum=${tmp%%, *}</blockquote></p>     <p><blockquote> echo -e "Enter title \c"</blockquote></p>     <p><blockquote> read tmp</blockquote></p>     <p><blockquote> cdtitle=${tmp%%, *}</blockquote></p>     <p><blockquote> echo -e "Enter type \c"</blockquote></p>     <p><blockquote> read tmp</blockquote></p>     <p><blockquote> cdtype=${tmp%%, *}</blockquote></p>     <p><blockquote> echo -e "Enter artist/composer \c"</blockquote></p>     <p><blockquote> read tmp</blockquote></p>     <p><blockquote> cdac=${tmp%%, *}</blockquote></p>     <p><blockquote> # Проверяет, хочет ли пользователь ввести информацию</blockquote></p>     <p><blockquote> echo About to add new entry</blockquote></p>     <p><blockquote> echo "$cdcatnum $cdtitle $cdtype $cdac"</blockquote></p>     <p><blockquote> # Если получено подтверждение, добавляет данные в конец файла.</blockquote></p>     <p><blockquote> # с заголовками</blockquote></p>     <p><blockquote> if get_confirm ; then</blockquote></p>     <p><blockquote>  insert_title $cdcatnum, $cdtitle, $cdtype, $cdac</blockquote></p>     <p><blockquote>  add_record_tracks</blockquote></p>     <p><blockquote> else</blockquote></p>     <p><blockquote>  remove_records</blockquote></p>     <p><blockquote> fi</blockquote></p>     <p><blockquote> return</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>7. Функция <blockquote>find_cd</blockquote> с помощью команды <blockquote>grep</blockquote> ищет текст с названием компакт-диска в файле с заголовочной информацией. Вам нужно знать, сколько раз была найдена строка, а команда grep только вернет значение, указывающее на то, что строка не была найдена или была найдена многократно. Для решения этой проблемы сохраните вывод в файл, отводящий по одной строке на каждое найденное совпадение, а затем сосчитайте количество строк в файле.</p>     <p>У команды счетчика слов, <blockquote>wc</blockquote>, в выводе есть пробельный символ, разделяющий количества строк, слов и символов в файле. Используйте синтаксическую запись <blockquote>$(wc -l $temp_file)</blockquote> для извлечения первого параметра в выводе и переноса его в переменную <blockquote>linesfound</blockquote>. Если бы вам был нужен другой следующий далее параметр, нужно было бы воспользоваться командой <blockquote>set</blockquote> для установки значений переменных-параметров оболочки из вывода команды.</p>     <p>Изменив значение переменной <blockquote>IFS</blockquote> (Internal Field Separator, внутренний разделитель полей) на запятую, вы сможете разделить поля, разграниченные запятыми. Альтернативный вариант — применить команду <blockquote>cut</blockquote>.</p>     <p><blockquote>find_сd() {</blockquote></p>     <p><blockquote> if [ "$1" = "n" ]; then</blockquote></p>     <p><blockquote>  asklist=n</blockquote></p>     <p><blockquote> else</blockquote></p>     <p><blockquote>  asklist=y</blockquote></p>     <p><blockquote> fi</blockquote></p>     <p><blockquote> cdcatnum=""</blockquote></p>     <p><blockquote> echo -e "Enter a string to search for in the CD titles \c"</blockquote></p>     <p><blockquote> read searchstr</blockquote></p>     <p><blockquote> if [ "$searchstr" = "" ]; then</blockquote></p>     <p><blockquote>  return 0</blockquote></p>     <p><blockquote> fi</blockquote></p>     <p><blockquote> grep "$searchstr" $title_file &gt; $temp_file</blockquote></p>     <p><blockquote> set $(wc -l $temp_file)</blockquote></p>     <p><blockquote> linesfound=$1</blockquote></p>     <p><blockquote> case "$linesfound" in</blockquote></p>     <p><blockquote>  0)</blockquote></p>     <p><blockquote>   echo "Sorry, nothing found"</blockquote></p>     <p><blockquote>   get_return</blockquote></p>     <p><blockquote>   return 0 ;;</blockquote></p>     <p><blockquote>  1) ;;</blockquote></p>     <p><blockquote>  2)</blockquote></p>     <p><blockquote>   echo "Sorry, not unique."</blockquote></p>     <p><blockquote>   echo "Found the following"</blockquote></p>     <p><blockquote>   cat $temp_file</blockquote></p>     <p><blockquote>   get_return</blockquote></p>     <p><blockquote>   return 0</blockquote></p>     <p><blockquote> esac</blockquote></p>     <p><blockquote> IFS=", "</blockquote></p>     <p><blockquote> read cdcatnum cdtitle cdtype cdac &lt; $temp_file</blockquote></p>     <p><blockquote> IFS=" "</blockquote></p>     <p><blockquote> if [ -z "$cdcatnum" ]; then</blockquote></p>     <p><blockquote>  echo "Sorry, could not extract catalog field from $temp_file"</blockquote></p>     <p><blockquote>  get_return</blockquote></p>     <p><blockquote>  return 0</blockquote></p>     <p><blockquote> fi</blockquote></p>     <p><blockquote> echo</blockquote></p>     <p><blockquote> echo Catalog number: $cdcatnum echo Title: $cdtitle</blockquote></p>     <p><blockquote> echo Type: $cdtype</blockquote></p>     <p><blockquote> echo Artist/Composer: $cdac</blockquote></p>     <p><blockquote> echo</blockquote></p>     <p><blockquote> get_return</blockquote></p>     <p><blockquote> if [ "$asklist" = "y" ]; then</blockquote></p>     <p><blockquote>  echo -e "View tracks for this CD? \c"</blockquote></p>     <p><blockquote>  read x</blockquote></p>     <p><blockquote>  if [ "$x" = "y" ]; then</blockquote></p>     <p><blockquote>   echo</blockquote></p>     <p><blockquote>   list_tracks</blockquote></p>     <p><blockquote>   echo</blockquote></p>     <p><blockquote>  fi</blockquote></p>     <p><blockquote> fi</blockquote></p>     <p><blockquote> return 1</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>8. Функция <blockquote>update_cd</blockquote> позволит вам повторно ввести сведения о компакт-диске. Учтите, что вы ищите (с помощью команды <blockquote>grep</blockquote>) строки, начинающиеся (<blockquote>^</blockquote>) с подстроки <blockquote>$cdcatnum</blockquote>, за которой следует <blockquote>", "</blockquote> и должны заключить подстановку значения <blockquote>$cdcatnum</blockquote> в <blockquote>{}</blockquote>. Таким образом, вы сможете найти запятую без специального пробельного символа между ней и номером в каталоге. Эта функция также использует <blockquote>{}</blockquote> для образования блока из нескольких операторов, которые должны выполняться, если функция <blockquote>get_confirm</blockquote> вернет значение true.</p>     <p><blockquote>update_cd() {</blockquote></p>     <p><blockquote> if [ -z "$cdcatnum" ]; then</blockquote></p>     <p><blockquote>  echo "You must select a CD first"</blockquote></p>     <p><blockquote>  find_cd n</blockquote></p>     <p><blockquote> fi</blockquote></p>     <p><blockquote> if [ -n "$cdcatnum" ]; then</blockquote></p>     <p><blockquote>  echo "Current tracks are :-"</blockquote></p>     <p><blockquote>  list_tracks</blockquote></p>     <p><blockquote>  echo</blockquote></p>     <p><blockquote>  echo "This will re-enter the tracks for $cdtitle"</blockquote></p>     <p><blockquote>  get_confirm &amp;&amp; {</blockquote></p>     <p><blockquote>   grep -v "^${cdcatnum}, " $tracks_file &gt; $temp_file</blockquote></p>     <p><blockquote>   mv $temp_file $tracks_file</blockquote></p>     <p><blockquote>   echo</blockquote></p>     <p><blockquote>   add_record_tracks</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> fi</blockquote></p>     <p><blockquote> return</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>9. Функция <blockquote>count_cds</blockquote> дает возможность быстро пересчитать содержимое базы данных.</p>     <p><blockquote>count_cds() {</blockquote></p>     <p><blockquote> set $(wc -l $title_file)</blockquote></p>     <p><blockquote> num_titles=$1</blockquote></p>     <p><blockquote> set $(wc -l $tracks_file)</blockquote></p>     <p><blockquote> num_tracks=$1</blockquote></p>     <p><blockquote> echo found $num_titles CDs, with a total of $num_tracks tracks</blockquote></p>     <p><blockquote> get_return</blockquote></p>     <p><blockquote> return</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>10. Функция <blockquote>remove_records</blockquote> удаляет элементы из файлов базы данных с помощью команды <blockquote>grep -v</blockquote>, удаляющей все совпадающие строки. Учтите, что нужно применять временный файл.</p>     <p>Если вы попытаетесь применить команду:</p>     <p><blockquote>grep -v "^$cdcatnum" &gt; $title_file</blockquote></p>     <p>файл <blockquote>$title_file</blockquote> станет пустым благодаря перенаправлению вывода <blockquote>&gt;</blockquote> до того, как команда <blockquote>grep</blockquote> выполнится, поэтому она будет читать уже пустой файл.</p>     <p><blockquote>remove_records() {</blockquote></p>     <p><blockquote> if [ -z "$cdcatnum" ]; then</blockquote></p>     <p><blockquote>  echo You must select a CD first find_cd n</blockquote></p>     <p><blockquote> fi</blockquote></p>     <p><blockquote> if [ -n "$cdcatnum" ]; then</blockquote></p>     <p><blockquote>  echo "You are about to delete $cdtitle"</blockquote></p>     <p><blockquote>  get_confirm &amp;&amp; {</blockquote></p>     <p><blockquote>   grep -v "^${cdcatnum}, " $title_file &gt; $temp_file</blockquote></p>     <p><blockquote>   mv $temp_file $title_file</blockquote></p>     <p><blockquote>   grep -v "^${cdcatnum}, " $tracks_file &gt; $temp_file</blockquote></p>     <p><blockquote>   mv $temp_file $tracks_file</blockquote></p>     <p><blockquote>   cdcatnum=""</blockquote></p>     <p><blockquote>   echo Entry removed</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  get_return</blockquote></p>     <p><blockquote> fi</blockquote></p>     <p><blockquote> return</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>11. Функция <blockquote>list_tracks</blockquote> снова использует команду <blockquote>grep</blockquote> для извлечения нужных вам строк, команду <blockquote>cut</blockquote> для доступа к отдельным полям и затем команду <blockquote>more</blockquote> для постраничного вывода. Если вы посмотрите, сколько строк на языке С займет повторная реализация этих 20 необычных строк кода, то поймете, каким мощным средством может быть командная оболочка.</p>     <p><blockquote>list_tracks() {</blockquote></p>     <p><blockquote> if [ "$cdcatnum" = "" ]; then</blockquote></p>     <p><blockquote>  echo no CD selected yet</blockquote></p>     <p><blockquote>  return</blockquote></p>     <p><blockquote> else</blockquote></p>     <p><blockquote>  grep "^${cdcatnum}, " $tracks_file &gt; $temp_file</blockquote></p>     <p><blockquote>  num_tracks=${wc -l $temp_file}</blockquote></p>     <p><blockquote>  if [ "$num_tracks" = "0" ]; then</blockquote></p>     <p><blockquote>   echo no tracks found for $cdtitle</blockquote></p>     <p><blockquote>  else</blockquote></p>     <p><blockquote>   {</blockquote></p>     <p><blockquote>    echo</blockquote></p>     <p><blockquote>    echo "$cdtitle :-"</blockquote></p>     <p><blockquote>    echo</blockquote></p>     <p><blockquote>    cut -f 2- -d , $temp_file</blockquote></p>     <p><blockquote>    echo</blockquote></p>     <p><blockquote>   } | ${PAGER:-more}</blockquote></p>     <p><blockquote>  fi</blockquote></p>     <p><blockquote> fi</blockquote></p>     <p><blockquote> get_return</blockquote></p>     <p><blockquote> return</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>12. Теперь, когда все функции определены, можно вводить основную процедуру. Первые несколько строк просто приводят файлы в известное состояние; затем вы вызываете функцию формирования меню <blockquote>set_menu_choice</blockquote> и действуете в соответствии с ее выводом.</p>     <p>Если выбран вариант <blockquote>quit</blockquote> (завершение), вы удаляете временный файл, выводите сообщение и завершаете сценарий с успешным кодом завершения.</p>     <p><blockquote>rm -f $temp_file</blockquote></p>     <p><blockquote>if [ ! -f $title_file ]; then</blockquote></p>     <p><blockquote> touch $title_file</blockquote></p>     <p><blockquote>fi</blockquote></p>     <p><blockquote>if [ ! -f $tracks_file ]; then</blockquote></p>     <p><blockquote> touch $tracks_file</blockquote></p>     <p><blockquote>fi</blockquote></p>     <br>     <p><blockquote># Теперь непосредственно приложение</blockquote></p>     <br>     <p><blockquote>clear</blockquote></p>     <p><blockquote>echo</blockquote></p>     <p><blockquote>echo</blockquote></p>     <p><blockquote>echo "Mini CD manager" sleep 1</blockquote></p>     <p><blockquote>quit=n</blockquote></p>     <p><blockquote>while [ "$quit" != "y" ]; do</blockquote></p>     <p><blockquote> set_menu_choice</blockquote></p>     <p><blockquote> case "$menu_choice" in</blockquote></p>     <p><blockquote>  a) add_records;;</blockquote></p>     <p><blockquote>  r) remove records;;</blockquote></p>     <p><blockquote>  f) find_cd y;;</blockquote></p>     <p><blockquote>  u) update_cd;;</blockquote></p>     <p><blockquote>  c) count_cds;;</blockquote></p>     <p><blockquote>  l) list_tracks;;</blockquote></p>     <p><blockquote>  b)</blockquote></p>     <p><blockquote>   echo</blockquote></p>     <p><blockquote>   more $title_file</blockquote></p>     <p><blockquote>   echo</blockquote></p>     <p><blockquote>   get return;;</blockquote></p>     <p><blockquote>  q | Q ) quit=y;;</blockquote></p>     <p><blockquote>  *) echo "Sorry, choice not recognized";;</blockquote></p>     <p><blockquote> esac</blockquote></p>     <p><blockquote>done</blockquote></p>     <br>     <p><blockquote># Убираем и покидаем</blockquote></p>     <br>     <p><blockquote>rm -f $temp_file echo "Finished"</blockquote></p>     <p><blockquote>exit 0</blockquote></p>     <b>Замечания, касающиеся приложения</b>     <p>Команда trap в начале сценария предназначена для перехвата нажатия пользователем комбинации клавиш &lt;Ctrt&gt;+&lt;C&gt;. Им может быть сигнал <blockquote>EXIT</blockquote> или <blockquote>INT</blockquote>, в зависимости от настроек терминала.</p>     <p>Существуют другие способы реализации выбора пункта меню, особенно конструкция <blockquote>select</blockquote> в оболочках bash и ksh (которая, тем не менее, не определена в стандарте X/Open). Она представляет собой специализированный селектор пунктов меню. Проверьте ее на практике, если ваш сценарий может позволить себе быть немного менее переносимым. Для передачи пользователям многострочной информации можно также воспользоваться встроенными документами.</p>     <p>Возможно, вы заметили, что нет проверки первичного ключа, когда создается новая запись; новый код просто игнорирует последующие названия с тем же кодом, но включает их дорожки в перечень первого названия:</p>     <p><blockquote>1 First CD Track 1</blockquote></p>     <p><blockquote>2 First CD Track 2</blockquote></p>     <p><blockquote>1 Another CD</blockquote></p>     <p><blockquote>2 With the same CD key</blockquote></p>     <p>Мы оставляем это и другие усовершенствования в расчете на ваше воображение и творческие способности, которые проявятся при корректировке вами программного кода в соответствии с требованиями GPL.</p>              <a name="metkadoc26"><h1>Резюме </h1></a>    <p>В этой главе вы увидели, что командная оболочка — это мощный язык программирования со своими функциональными возможностями. Ее способность легко вызывать программы и затем обрабатывать их результат делают оболочку идеальным средством для решения задач, включающих обработку текста и файлов.</p>    <p>Теперь, если вам понадобится небольшая утилита, подумайте, сможете ли вы решить вашу проблему, комбинируя множество команд ОС Linux в сценарии командной оболочки. Вы будете поражены, увидев, как много вспомогательных программ можно написать без использования компилятора. </p>     <br><br>
<center><div align="center"><a href="index.php.html">Оглавление</a></div></center>




<br>
<script type="text/javascript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="https://www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script><br>

<noindex>
<div align="center">
<center>

<!-- SAPE RTB DIV 600x340 -->
<div id="SRTB_507029"></div>
<!-- SAPE RTB END -->

</center>
</div>
</noindex>

</td>
<td width="240" valign="top">

<br>

<div id="menu3">
<ul>
<li><a href="../../alternativnaja_medicina/index.html"><span>Альтернативная медицина</span></a></li>
<li><a href="../../astronomija_i_kosmos/index.html"><span>Астрономия и Космос</span></a></li>
<li><a href="../../biologija/index.html"><span>Биология</span></a></li>
<li><a href="../../voennaja_istorija/index.html"><span>Военная история</span></a></li>
<li><a href="../../geologija_i_geografija/index.html"><span>Геология и география</span></a></li>
<li><a href="../../gosudarstvo_i_pravo/index.html"><span>Государство и право</span></a></li>
<li><a href="../../delovaja_literatura/index.html"><span>Деловая литература</span></a></li>
<li><a href="../../domashnie_zhivotnye/index.html"><span>Домашние животные</span></a></li>
<li><a href="../../domovodstvo/index.html"><span>Домоводство</span></a></li>
<li><a href="../../zdorove/index.html"><span>Здоровье</span></a></li>
<li><a href="../../istorija/index.html"><span>История</span></a></li>
<li><a href="../index.html"><span>Компьютеры и Интернет</span></a></li>
<li><a href="../../kulinarija/index.html"><span>Кулинария</span></a></li>
<li><a href="../../kulturologija/index.html"><span>Культурология</span></a></li>
<li><a href="../../literaturovedenie/index.html"><span>Литературоведение</span></a></li>
<li><a href="../../matematika/index.html"><span>Математика</span></a></li>
<li><a href="../../medicina/index.html"><span>Медицина</span></a></li>
<li><a href="../../nauchnaja_literatura_prochee/index.html"><span>Науч. литер. - прочее</span></a></li>
<li><a href="../../pedagogika/index.html"><span>Педагогика</span></a></li>
<li><a href="../../politika/index.html"><span>Политика</span></a></li>
<li><a href="../../psihologija/index.html"><span>Психология</span></a></li>
<li><a href="../../religiovedenie/index.html"><span>Религиоведение</span></a></li>
<li><a href="../../sad_i_ogorod/index.html"><span>Сад и огород</span></a></li>
<li><a href="../../samosovershenstvovanie/index.html"><span>Самосовершенствование</span></a></li>
<li><a href="../../sdelai_sam/index.html"><span>Сделай сам</span></a></li>
<li><a href="../../sport/index.html"><span>Спорт</span></a></li>
<li><a href="../../tehnicheskie_nauki/index.html"><span>Технические науки</span></a></li>
<li><a href="../../transport_i_aviacija/index.html"><span>Транспорт и авиация</span></a></li>
<li><a href="../../uchebniki/index.html"><span>Учебники</span></a></li>
<li><a href="../../fizika/index.html"><span>Физика</span></a></li>
<li><a href="../../filosofija/index.html"><span>Философия</span></a></li>
<li><a href="../../himija/index.html"><span>Химия</span></a></li>
<li><a href="../../hobbi_i_remesla/index.html"><span>Хобби и ремесла</span></a></li>
<li><a href="../../shpargalki/index.html"><span>Шпаргалки</span></a></li>
<li><a href="../../yezoterika/index.html"><span>Эзотерика</span></a></li>
<li><a href="../../yurisprudencija/index.html"><span>Юриспруденция</span></a></li>
<li><a href="../../jazykoznanie/index.html"><span>Языкознание</span></a></li>
</ul>
</div>

<br>
<div align="center">
<center>
<noindex>

<!-- SAPE RTB DIV 240x400 -->
<div id="SRTB_507028"></div>
<!-- SAPE RTB END -->

</noindex>
</center>
</div>

</td>
</tr>
<tr>
<td colspan="3" align="center">


<hr>
<a href="../../index.html"><span>Главная</span></a> | 
<a rel="sidebar" href="p6.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a> | 
<a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a> | 
<a href="p6.php.html#" onClick="scroll(0,0); return false" title="наверх">Наверх</a>
</td>
</tr>
<tr>
<td colspan="3" valign="top" align="left">
<br>

 



</td>
</tr>
</table>

<noindex>
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter21717787 = new Ya.Metrika({id:21717787,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="http://mc.yandex.ru/watch/21717787" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

</noindex>
</center>
</div></body>
</html>