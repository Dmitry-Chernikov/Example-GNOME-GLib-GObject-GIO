<html>
<head>
<meta http-equiv="Content-Language" content="ru">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<link href="../../0img/style.css" rel="stylesheet" type="text/css" />
<link rel="SHORTCUT ICON" href="http://www.redov.ru/0img/favicon.ico" type="image/x-icon"> 
<title>Глава 4 Окружение Linux / Основы программирования в Linux</title>
</head>
<body>
<div align="center">
<center>
<table border="0" cellpadding="0" cellspacing="0" width="1260">
<tr>
<td colspan="3" valign="top" align="left" height="100">
<table border="0" cellpadding="0" cellspacing="0" width="1260" height="100">
<tr>
<td valign="middle" align="center" width="350">
<a href="../../index.html"><img src="../../0img/logo.jpg" width="350" height="100" title="Онлайн библиотека redov.ru"/></a>
</td>
<td valign="middle" align="center" width="910">

<noindex>

<!-- SAPE RTB JS -->
<script
    async="async"
    src="http://cdn-rtb.sape.ru/rtb-b/js/393/2/106393.js"
    type="text/javascript">
</script>
<!-- SAPE RTB END -->

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507025"></div>
<!-- SAPE RTB END -->

</noindex>

</td>
</tr>
</table>
</td>
</tr>
<tr>
<td colspan="3" valign="middle" align="left">

<div id="menu">
<ul>
		<li><a href="../../index.html"><span>Главная</span></a></li>
		<li><a rel="sidebar" href="p8.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a></li>
		<li><a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a></li>
		<li><a href="p8.php.html#" onClick="scroll(0,9999999); return false"><span>Вниз</span></a></li>
</ul>
</div>


</td>
</tr>
<tr>
<td width="240" valign="top" align="center">

<br>
<noindex>
<!-- SAPE RTB DIV 160x600 -->
<div id="SRTB_733378"></div>
<!-- SAPE RTB END -->
</noindex>



</td>
<td valign="top" align="left" style="padding-left: 5; padding-right: 5" width="780">
<br>
<noindex>
<div align="center">

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507027"></div>
<!-- SAPE RTB END -->

</div>
</noindex>
<br>



<li><a href="p8.php.html#metkadoc2">     Аргументы программы     </a></li>
<li><a href="p8.php.html#metkadoc3">      <i>getopt</i>      </a></li>
<li><a href="p8.php.html#metkadoc4">      <i>getopt_long</i>      </a></li>
<li><a href="p8.php.html#metkadoc5">     Переменные окружения     </a></li>
<li><a href="p8.php.html#metkadoc6">      Применение переменных окружения      </a></li>
<li><a href="p8.php.html#metkadoc7">      Переменная<i> environ</i>      </a></li>
<li><a href="p8.php.html#metkadoc8">     Время и дата     </a></li>
<li><a href="p8.php.html#metkadoc9">     Временные файлы     </a></li>
<li><a href="p8.php.html#metkadoc10">     Информация о пользователе     </a></li>
<li><a href="p8.php.html#metkadoc11">     Информация о компьютере     </a></li>
<li><a href="p8.php.html#metkadoc12">     Ведение системных журналов     </a></li>
<li><a href="p8.php.html#metkadoc13">     Ресурсы и ограничения     </a></li>
<li><a href="p8.php.html#metkadoc14">     Резюме      </a></li>
<a name="metkadoc1"><h1>Глава 4</p>    <p>Окружение Linux</h1></a>       <p>Когда вы пишете программу для ОС Linux (или UNIX и UNIX-подобных систем), следует принимать во внимание то, что программа будет выполняться в многозадачной среде или<i> многозадачном окружении.</i> Это означает, что много программ будет выполняться одновременно и совместно использовать ресурсы компьютера, такие как память, дисковое пространство и циклы центрального процессора. Может даже существовать несколько экземпляров одной и той же программы, выполняющихся одновременно. Важно, чтобы эти программы не мешали друг другу, знали о своем окружении и могли действовать надлежащим образом, избегая конфликтов, таких как попытка писать в один и тот же файл одновременно с другой программой.</p>    <p>В этой главе рассматривается окружение, в котором действуют программы, как они его используют для получения информации об условиях функционирования и как пользователи программ могут изменять их поведение. В частности, в данной главе рассматриваются следующие темы:</p>    <p>&#9633; передача аргументов в программы;</p>    <p>&#9633; переменные окружения;</p>    <p>&#9633; определение текущего времени;</p>    <p>&#9633; временные файлы;</p>    <p>&#9633; получение информации о пользователе и рабочем компьютере;</p>    <p>&#9633; формирование и настройка регистрируемых сообщений;</p>    <p>&#9633; выявление ограничений, накладываемых системой.</p>          <a name="metkadoc2"><h1>Аргументы программы</h1></a>         <p>Когда в ОС Linux или UNIX выполняется программа на языке С, она начинается с функции <blockquote>main</blockquote>. В таких программах функция <blockquote>main</blockquote> объявляется следующим образом:</p>     <p><blockquote>int main(int argc, char *argv[])</blockquote></p>     <p>Здесь <blockquote>argc</blockquote> — это счетчик аргументов программы, a <blockquote>argv</blockquote> — массив символьных строк, представляющих сами аргументы.</p>     <p>Вы можете встретить программы на языке С для ОС Linux, просто объявляющие функцию <blockquote>main</blockquote> как</p>     <p><blockquote>main()</blockquote></p>     <p>Этот вариант тоже работает, поскольку по умолчанию возвращаемому функцией значению будет назначен тип <blockquote>int</blockquote>, а формальные параметры, которые в функции не применяются, не нуждаются в объявлении. Параметры <blockquote>argc</blockquote> и <blockquote>argv</blockquote> остаются на своем месте, но если вы не объявляете их, то и не можете их использовать.</p>     <p>Каждый раз, когда операционная система запускает новую программу, параметры <blockquote>argc</blockquote> и <blockquote>argv</blockquote> устанавливаются и передаются функции <blockquote>main</blockquote>. Обычно эти параметры предоставляются другой программой, часто командной оболочкой, которая запросила у операционной системы запуск новой программы. Оболочка принимает заданную командную строку, разбивает её на отдельные слова и использует их для заполнения массива <blockquote>argv</blockquote>. Помните о том, что до установки параметров <blockquote>argc</blockquote> и <blockquote>argv</blockquote> командная оболочка Linux обычно выполняет раскрытие метасимволов в аргументах, содержащих имена файлов, в то время как оболочка MS-DOS рассчитывает на то, что программы примут аргументы с метасимволами и выполнят собственную постановку.</p>     <p>Например, если мы дадим командной оболочке следующую команду:</p>     <p><blockquote>$ <b>myprog left right 'and center'</b></blockquote></p>     <p>программа myprog запустит функцию <blockquote>main</blockquote> с приведенными далее параметрами.</p>     <p><blockquote>argc: 4</blockquote></p>     <p><blockquote>argv: {"myprog", "left", "right", "and center"}</blockquote></p>     <p>Обратите внимание на то, что аргумент-счётчик содержит имя программы и в массив <blockquote>argv</blockquote> оно включено как первый элемент <blockquote>argv[0]</blockquote>. Поскольку в команде оболочки мы применили кавычки, четвертый аргумент представляет собой строку, содержащую пробелы.</p>     <p>Вам все это знакомо, если вы программировали на языке С стандарта ISO/ANSI, Аргументы функции <blockquote>main</blockquote> соответствуют позиционным параметрам в сценариях командной оболочки: <blockquote>$0</blockquote>, <blockquote>$1</blockquote> и т.д. Язык ISO/ANSI С заявляет, что функция <blockquote>main</blockquote> должна возвращать значение типа <blockquote>int</blockquote>, спецификация X/Open содержит явное объявление, данное ранее.</p>     <p>Аргументы командной строки удобны для передачи данных программам. Например, вы можете применить их в приложениях баз данных для передачи имени базы данных, которую хотите использовать, что позволит вам применить одну и ту же программу для работы с несколькими базами данных. Многие утилиты также используют аргументы командной строки для изменения собственного поведения или установки опций. Вы обычно задаете эти так называемые<i> флаги</i> или<i> переключатели </i>с помощью аргументов командной строки, начинающихся со знака "дефис". Например, программа <blockquote>sort</blockquote> принимает переключатель для изменения обычного порядка сортировки на обратный:</p>     <p><blockquote>$ <b>sort -r <i>файл</i></b></blockquote></p>     <p>Опции командной строки используются очень широко, и согласованное их применение будет реальной помощью тем, кто станет использовать вашу программу. В прошлом у каждой утилиты был свой подход к формированию опций командной строки, что приводило к некоторой путанице. Например, взгляните на то, каким способом приведенные далее команды принимают параметры:</p>     <p><blockquote>$ <b>tar cvfB /tmp/file.tar 1024</b></blockquote></p>     <p><blockquote>$ <b>dd if=/dev/fd0 of=/trap/file.dd bs=18k</b></blockquote></p>     <p><blockquote>$ <b>ps ax</b></blockquote></p>     <p><blockquote>$ <b>gcc --help</b></blockquote></p>     <p><blockquote>$ <b>ls -lstr</b></blockquote></p>     <p><blockquote>$ <b>ls -l -s -t -r</b></blockquote></p>     <p>Мы рекомендуем в ваших приложениях все переключатели командной строки начинать с дефиса и делать их односимвольными, состоящими из одной буквы или цифры. При необходимости опции, не содержащие последующих аргументов, могут группироваться вместе после общего дефиса. Таким образом, два только что приведенных примера с командой <blockquote>ls</blockquote> соответствуют нашим рекомендациям. За каждой опцией может следовать любое необходимое ей значение как отдельный аргумент. Пример с программой <blockquote>dd</blockquote> нарушает наше правило, поскольку использует многосимвольные опции, которые начинаются совсем не с дефисов (<blockquote>if=/dev/fd0</blockquote>): в примере с программой <blockquote>tar</blockquote> опции полностью оторваны от своих значений! Целесообразно добавлять более длинные и информативные имена переключателей как альтернативу односимвольных вариантов и использовать двойной дефис для их выделения. Таким образом, у нас могут быть два варианта опции получения помощи: <blockquote>-h</blockquote> и <blockquote>--help</blockquote>.</p>     <p>Еще один недостаток некоторых программ — создание опции <blockquote>+x</blockquote> (например) для выполнения функции, противоположной <blockquote>-х</blockquote>. В<i> главе 2</i> мы применяли команду <blockquote>set -о xtrace</blockquote> для включения отслеживания действий командной оболочки и команду <blockquote>set +о xtrace</blockquote> для выключения этого режима.</p>     <p>Вы, вероятно, можете сказать, что запомнить порядок и назначение всех этих программных опций достаточно трудно без необходимости освоения вызывающих идиосинкразию форматов. Часто единственный выход — применение опции <blockquote>-h</blockquote> (от англ. <i>help</i>) или страниц интерактивного справочного руководства (<blockquote>man</blockquote>), если программист предоставил одну из этих возможностей. Чуть позже в этой главе мы покажем, что функция <blockquote>getopt</blockquote> предоставляет изящное решение этих проблем. А сейчас, тем не менее, в упражнении 4.1 давайте посмотрим, как передаются аргументы программы.</p>     <b>Упражнение 4.1. Аргументы программы</b>     <p>Далее приведена программа args.c, проверяющая собственные аргументы.</p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <br>     <p><blockquote>int main(int argc, char *argv[]) {</blockquote></p>     <p><blockquote> int arg;</blockquote></p>     <p><blockquote> for (arg = 0; arg &lt; argc; arg++) {</blockquote></p>     <p><blockquote>  if (argv[arg][0] == '-')</blockquote></p>     <p><blockquote>printf("option: %s\n", argv[arg]+1);</blockquote></p>     <p><blockquote>  else</blockquote></p>     <p><blockquote>   printf("argument %d: %s\n", arg, argv[arg]);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Когда вы выполните эту программу, она просто выведет свои аргументы и определит опции. Суть в том, что программа принимает строковый аргумент и необязательный аргумент с именем файла, вводимый опцией <blockquote>-f</blockquote>. Могут быть определены и другие опции.</p>     <p><blockquote>$ <b>./args -i -lr 'hi there' -f fred.c</b></blockquote></p>     <p><blockquote>argument 0: ./args</blockquote></p>     <p><blockquote>option: i</blockquote></p>     <p><blockquote>option: lr</blockquote></p>     <p><blockquote>argument 3: hi there option: f</blockquote></p>     <p><blockquote>argument 5: fred.с</blockquote></p>     <p><b>Как это работает</b></p>     <p>Программа просто использует аргумент-счетчик <blockquote>argc</blockquote> для задания цикла, просматривающего все аргументы программы. Она находит опции поиском начального дефиса.</p>     <p>В данном примере, если мы предполагаем, что доступны опции <blockquote>-l</blockquote> и <blockquote>-r</blockquote>, то упускаем тот факт, что группа <blockquote>-lr</blockquote>, возможно, должна интерпретироваться так же, как <blockquote>-l</blockquote> и <blockquote>-r</blockquote>.</p>     <p>В стандарте X/Open (который можно найти по адресу <b>http://opengroup.org/</b>) определено стандартное применение опций командной строки (Utility Syntax Guidelines, руководство по синтаксису утилит) и стандартный программный интерфейс для представления переключателей командной строки в программах на языке С: функция <blockquote>getopt</blockquote>.</p>             <a name="metkadoc3"><h1><i>getopt</i></h1></a>     <p>Для того чтобы вам легче было следовать правилам, приведенным в этих руководствах, ОС Linux предлагает очень простое в применении средство <blockquote>getopt</blockquote>, поддерживающее использование опций со значениями и без них.</p>     <p><blockquote><b>#include &lt;unistd.h&gt;</b></blockquote></p>     <p><blockquote><b>int getopt(int argc, char *const argv[], const char *optstring);</b></blockquote></p>     <p><blockquote><b>extern char *optarg;</b></blockquote></p>     <p><blockquote><b>extern int optind, opterr, optopt;</b></blockquote></p>     <p>Функция <blockquote>getopt</blockquote> принимает параметры <blockquote>argc</blockquote> и <blockquote>argv</blockquote> в том виде, в каком они передаются функции <blockquote>main</blockquote> в программе, и строку спецификатора опций, которая сообщает <blockquote>getopt</blockquote>, какие опции определены для программы и есть ли у них связанные с ними значения. <blockquote>optstring</blockquote> — это просто список символов, каждый из которых представляет односимвольную опцию. Если за символом следует двоеточие, это означает, что у опции есть ассоциированное значение, которое будет принято как следующий аргумент. Команда <blockquote>getopt</blockquote> оболочки bash выполняет аналогичную функцию.</p>     <p>Например, для обработки предыдущего примера можно было бы применить следующий вызов:</p>     <p><blockquote>getopt(argc, argv, "if:lr");</blockquote></p>     <p>В нем учтены простые опции <blockquote>-i</blockquote>, <blockquote>-l</blockquote>, <blockquote>-r</blockquote> и <blockquote>-f</blockquote>, за которыми последует аргумент с именем файла. Вызов команды с теми же параметрами, но указанными в другом порядке, изменит поведение. Вы сможете попробовать сделать это, когда получите пример кода из упражнения 4.2.</p>     <p>Результат, возвращаемый функцией <blockquote>getopt</blockquote>, — символ следующей опции, хранящийся в массиве <blockquote>argv</blockquote> (если он есть). Вызывайте <blockquote>getopt</blockquote> повторно для поочередного получения каждой опции. Функция ведет себя следующим образом.</p>     <p>&#9633; Если опция принимает значение, на него указывает внешняя переменная <blockquote>optarg</blockquote>.</p>     <p>&#9633; Функция <blockquote>getopt</blockquote> вернет -1, когда не останется опций для обработки. Специальный аргумент <blockquote>--</blockquote> заставит <blockquote>getopt</blockquote> прекратить перебор опций.</p>     <p>&#9633; Функция <blockquote>getopt</blockquote> вернет <blockquote>?</blockquote>, если есть нераспознанная опция, которую она сохранит во внешней переменной <blockquote>optopt</blockquote>.</p>     <p>&#9633; Если опции требуется значение (например, в нашем примере опции <blockquote>-f</blockquote>) и не задана никакая величина, <blockquote>getopt</blockquote> обычно возвращает <blockquote>?</blockquote>. Если поместить двоеточие как первый символ в строке опций, при отсутствии заданной величины функция <blockquote>getopt</blockquote> вернет <blockquote>:</blockquote> вместо <blockquote>?</blockquote>.</p>     <p>Во внешней переменной <blockquote>optind</blockquote> хранится номер следующего обрабатываемого аргумента. Функция <blockquote>getopt</blockquote> использует ее, чтобы знать, как далеко она продвинулась. Программы редко нуждаются в установке этой переменной. Когда все аргументы с опциями обработаны, переменная <blockquote>optind</blockquote> указывает, где в конце массива argv можно найти оставшиеся аргументы. </p>     <p>Некоторые версии функции <blockquote>getopt</blockquote> прекратят выполнение при обнаружении первого аргумента не опции, вернув значение -1 и установив переменную <blockquote>optind</blockquote>. Другие, например предлагаемые в ОС Linux, могут обрабатывать опции, где бы они ни встретились в аргументах программы. Учтите, что в данном случае <blockquote>getopt</blockquote> фактически перепишет массив <blockquote>argv</blockquote> так, что все аргументы не опции будут собраны вместе, начиная с элемента массива <blockquote>argv[optind]</blockquote>. В случае версии GNU функции <blockquote>getopt</blockquote> ее поведение определяется переменной окружения <blockquote>POSIXLY_CORRECT</blockquote>. Если переменная установлена, <blockquote>getopt</blockquote> остановится на первом аргументе не опции. Кроме того, некоторые реализации <blockquote>getopt</blockquote> выводят сообщения об ошибке для незнакомых опций. Имейте в виду, что в стандарте POSIX написано о том, что если переменная <blockquote>opterr</blockquote> не равна нулю, функция <blockquote>getopt</blockquote> выведет сообщение об ошибке в <blockquote>stderr</blockquote>.</p>     <p>Итак, выполните упражнение 4.2.</p>     <b>Упражнение 4.2. Функция <blockquote>getopt</blockquote> </b>     <p>В этом упражнении вы используете функцию getopt; назовите новую программу argopt.c.</p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <br>     <p><blockquote>int main(int argc, char *argv[]) {</blockquote></p>     <p><blockquote> int opt;</blockquote></p>     <p><blockquote> while ((opt = getopt(argc, argv, ":if:lr")) != -1) {</blockquote></p>     <p><blockquote>  switch(opt) {</blockquote></p>     <p><blockquote>  case 'i':</blockquote></p>     <p><blockquote>  case 'l':</blockquote></p>     <p><blockquote>  case 'r':</blockquote></p>     <p><blockquote>   printf("option: %c\n", opt);</blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  case 'f':</blockquote></p>     <p><blockquote>   printf("filename: %s\n", optarg);</blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  case ':':</blockquote></p>     <p><blockquote>   printf("option needs a value\n");</blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  case '?':</blockquote></p>     <p><blockquote>   printf("unknown option: %c\n", optopt);</blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> for (; optind &lt; argc; optind++)</blockquote></p>     <p><blockquote>  printf("argument: %s\n", argv[optind]);</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Теперь, когда вы выполните программу, то увидите, что все аргументы командной строки обрабатываются автоматически:</p>     <p><blockquote>$ <b>./argopt -i -lr 'hi there' -f fred.с -q</b></blockquote></p>     <p><blockquote>option: i</blockquote></p>     <p><blockquote>option: l</blockquote></p>     <p><blockquote>option: r</blockquote></p>     <p><blockquote>filename: fred.c</blockquote></p>     <p><blockquote>unknown option: q</blockquote></p>     <p><blockquote>argument: hi there</blockquote></p>     <p><b>Как это работает</b></p>     <p>Программа многократно вызывает функцию <blockquote>getopt</blockquote> для обработки аргументов-опций до тех пор, пока не останется ни одного, в этот момент <blockquote>getopt</blockquote> вернет -1. Для каждой опции выбирается подходящее действие, включая обработку неизвестных опций и пропущенных значений. Если у вас другая версия <blockquote>getopt</blockquote>, то вы получите вывод, слегка отличающийся от показанного, — особенно сообщения об ошибках — но смысл будет понятен.</p>     <p>Когда все опции обработаны, программа просто выводит оставшиеся аргументы, как и раньше, но начиная с номера, хранящегося в переменной <blockquote>optind</blockquote>.</p>             <a name="metkadoc4"><h1><i>getopt_long</i></h1></a>     <p>Многие приложения Linux принимают более информативные аргументы, чем использованные в предыдущем примере односимвольные опции. Библиотека С проекта GNU содержит версию функции <blockquote>getopt</blockquote>, названную <blockquote>getopt_long</blockquote>, которая принимает так называемые<i> длинные аргументы,</i> которые вводятся с помощью двойного дефиса.</p>     <p>Рассмотрим упражнение 4.3.</p>     <b>Упражнение 4.3. Функция <blockquote>getopt_long</blockquote></b>     <p>Примените функцию <blockquote>getopt_long</blockquote> для создания новой версии примера программы, которая может вызываться с использованием длинных эквивалентов опций, например, следующих:</p>     <p><blockquote>$ <b>./longopt --initialize --list 'hi there' --file fred.c -q</b></blockquote></p>     <p><blockquote>option: i</blockquote></p>     <p><blockquote>option: l</blockquote></p>     <p><blockquote>filename: fred.c</blockquote></p>     <p><blockquote>./longopt: invalid option --q</blockquote></p>     <p><blockquote>unknown option: q</blockquote></p>     <p><blockquote>argument: hi there</blockquote></p>     <p>На самом деле и новые длинные опции, и исходные односимвольные можно смешивать. Длинным опциям также можно давать сокращенные названия, но они</p>     <p>должны отличаться от односимвольных опций. Длинные опции с аргументом можно задавать как единый аргумент в виде --<i>опция= значение,</i> как показано далее:</p>     <p><blockquote>$ <b>./longopt --init -l --file=fred.с 'hi there'</b></blockquote></p>     <p><blockquote>option: i</blockquote></p>     <p><blockquote>option: l</blockquote></p>     <p><blockquote>filename: fred.с</blockquote></p>     <p><blockquote>argument: hi there</blockquote></p>     <p>Далее приведена новая программа longopt.c, полученная из программы argopt.c с изменениями, обеспечивающими поддержку длинных опций, которые в тексте программы выделены цветом.</p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <br>     <p><blockquote><i>#define _GNU_SOURCE</i></blockquote></p>     <p><blockquote><i>#include &lt;getopt.h&gt;</i></blockquote></p>     <br>     <p><blockquote>int main(int argc, char *argv[]) {</blockquote></p>     <p><blockquote> int opt;</blockquote></p>     <p><blockquote><i> struct option_longopts[] = {</i></blockquote></p>     <p><blockquote><i>  {"initialize", 0. NULL, 'i'},</i></blockquote></p>     <p><blockquote><i>  {"file" 1, NULL, 'f'},</i></blockquote></p>     <p><blockquote><i>  {"list", 0, NULL, 'l'},</i></blockquote></p>     <p><blockquote><i> {0, 0, 0, 0}};</i></blockquote></p>     <p><blockquote><i> while ((opt = getopt_long(argc, argv, ":if:lr, longopts, NULL)) != -1) {</i></blockquote></p>     <p><blockquote>  switch(opt) {</blockquote></p>     <p><blockquote>  case 'i':</blockquote></p>     <p><blockquote>  case 'l':</blockquote></p>     <p><blockquote>  case 'r':</blockquote></p>     <p><blockquote>   printf("option: %c\n", opt);</blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  case 'f':</blockquote></p>     <p><blockquote>   printf("filename: %s\n", optarg);</blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  case ':':</blockquote></p>     <p><blockquote>   printf("option needs a value\n");</blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  case '?':</blockquote></p>     <p><blockquote>   printf("unknown option: %c\n", optopt);</blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> for (; optind &lt; argc; optind++)</blockquote></p>     <p><blockquote>  printf("argument: %s\n", argv[optind]);</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p><b>Как это работает</b></p>     <p>Функция <blockquote>getopt_long</blockquote> принимает два дополнительных параметра по сравнению с функцией <blockquote>getopt</blockquote>. Первый из них — массив структур, описывающий длинные опции и сообщающий функции <blockquote>getopt_long</blockquote> способ их обработки. Второй дополнительный параметр — адрес переменной, которая может использоваться как вариант <blockquote>optind</blockquote>, предназначенный для длинных опций; для каждой распознанной длинной опции ее номер в массиве длинных опций может быть записан в эту переменную. В данном примере вам не нужна эта информация, поэтому вы используете <blockquote>NULL</blockquote> в качестве значения второго дополнительного параметра.</p>     <p>Массив длинных опций состоит из ряда структур типа <blockquote>struct option</blockquote>, в каждой из которых описано требуемое поведение длинной опции. Массив должен заканчиваться структурой, содержащей все нули.</p>     <p>Структура длинной опции определена в заголовочном файле getopt.h и должна подключаться с помощью константы <blockquote>_GNU_SOURCE</blockquote>, определенной для того, чтобы разрешить использование функции <blockquote>getopt_long</blockquote>.</p>     <p><blockquote>struct option {</blockquote></p>     <p><blockquote> const char *name;</blockquote></p>     <p><blockquote> int has_arg;</blockquote></p>     <p><blockquote> int *flag;</blockquote></p>     <p><blockquote> int val;</blockquote></p>     <p><blockquote>};</blockquote></p>     <p>Элементы структуры описаны в табл. 4.1.</p>     <br>     <p><b><i>Таблица 4.1.</i></b></p>     <table>      <tr>       <th valign="top">Параметр опции</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>name</blockquote></td>       <td valign="top">Название длинной опции. Сокращения будут приниматься до тех пор, пока они не создадут путаницы при определении названий других опций</td>      </tr>      <tr>       <td valign="top"><blockquote>has_arg</blockquote></td>       <td valign="top">Принимает ли эта опция аргумент. Задайте 0 для опций без аргументов, 1 для опций, у которых должно быть значение, и 2 для опций с необязательным аргументом</td>      </tr>      <tr>       <td valign="top"><blockquote>flag</blockquote></td>       <td valign="top">Задайте <blockquote>NULL</blockquote>, чтобы <blockquote>getopt_long</blockquote> вернула при обнаружении данной опции значение, заданное в <blockquote>val</blockquote>. В противном случае <blockquote>getopt_long</blockquote> возвращает 0 и записывает значение <blockquote>val</blockquote> в переменную, на которую указывает <blockquote>flag</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>val</blockquote></td>       <td valign="top">Значение <blockquote>getopt_long</blockquote> для данной опции, предназначенное для возврата</td>      </tr>     </table>     <p>Для получения сведений о других опциях, связанных с расширениями функции <blockquote>getopt</blockquote> в проекте GNU и родственных функциях, см. страницы интерактивного справочного руководства к функции <blockquote>getopt</blockquote>.</p>              <a name="metkadoc5"><h1>Переменные окружения</h1></a>         <p>Мы обсуждали переменные окружения в<i> главе 2.</i> Это переменные, которые могут использоваться для управления поведением сценариев командной оболочки и других программ. Вы также можете применять их для настройки пользовательской среды. Например, у каждого пользователя есть переменная окружения <blockquote>HOME</blockquote>, определяющая его исходный каталог, стандартное место старта его или ее сеанса. Как вы видели, просмотреть переменные окружения можно из строки приглашения командной оболочки:</p>     <p><blockquote>$ <b>echo $НOМЕ</b></blockquote></p>     <p><blockquote>/home/neil</blockquote></p>     <p>Вы также можете воспользоваться командой оболочки <blockquote>set</blockquote> для получения списка всех переменных окружения.</p>     <p>В спецификации UNIX определено множество стандартных переменных окружения, применяемых для самых разных целей, включая тип терминала, имена редакторов, установленных по умолчанию, названия часовых поясов и т.д. Программа на языке С может получить доступ к переменным окружения с помощью функций <blockquote>putenv</blockquote> и <blockquote>getenv</blockquote>.</p>     <p><blockquote><b>#include &lt;stdlib.h&gt;</b></blockquote></p>     <p><blockquote><b>char *getenv(const char *name);</b></blockquote></p>     <p><blockquote><b>int putenv(const char *string);</b></blockquote></p>     <p>Окружение состоит из строк вида<i> <blockquote>имя=значение</blockquote>.</i> Функция <blockquote>getenv</blockquote> ищет в окружении строку с заданным именем и возвращает значение, ассоциированное с этим именем. Она вернет <blockquote>NULL</blockquote>, если требуемая переменная не существует. Если переменная есть, но ее значение не задано, функция <blockquote>getenv</blockquote> завершится успешно и вернет пустую строку, в которой первый байт равен <blockquote>NULL</blockquote>. Строка, возвращаемая <blockquote>getenv</blockquote>, хранится в статической памяти, принадлежащей функции, поэтому для ее дальнейшего использования вы должны скопировать эту строку в другую, поскольку она может быть перезаписана при последующих вызовах функции <blockquote>getenv</blockquote>. </p>     <p>Функция <blockquote>putenv</blockquote> принимает строку вида <blockquote><i>имя=значение</i></blockquote> и добавляет ее в текущее окружение. Она даст сбой и вернет -1, если не сможет расширить окружение из-за нехватки свободной памяти. Когда это произойдет, переменной <blockquote>errno</blockquote> будет присвоено значение <blockquote>ENOMEM</blockquote>.</p>     <p>В упражнении 4.4 вы напишeте программу для вывода значения любой выбранной вами переменной окружения. У вас также будет возможность задать значение, если вы укажете второй аргумент программы.</p>     <b>Упражнение 4.4. Функции <blockquote>getenv</blockquote> и <blockquote>putenv</blockquote></b>     <p>1. Первые несколько строк после объявления функции <blockquote>main</blockquote> гарантируют корректный вызов программы environ.c с только одним или двумя аргументами:</p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <br>     <p><blockquote>int main(int argc, char *argv[]) {</blockquote></p>     <p><blockquote> char *var, *value;</blockquote></p>     <p><blockquote> if (argc == 1 || argc &gt; 3) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "usage: environ var [value]\n");</blockquote></p>     <p><blockquote>  exit(1);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p>2. Сделав это, вы извлекаете значение переменной из окружения с помощью функции <blockquote>getenv</blockquote>:</p>     <p><blockquote> var = argv[1];</blockquote></p>     <p><blockquote> value = getenv(var);</blockquote></p>     <p><blockquote> if (value)</blockquote></p>     <p><blockquote>  printf("Variable %s has value %s\n", var, value);</blockquote></p>     <p><blockquote> else</blockquote></p>     <p><blockquote>  printf("Variable %s has no value\n", var);</blockquote></p>     <p>3. Далее проверьте, был ли при вызове программы указан второй параметр. Если был, вы задаете значение этого аргумента, конструируя строку вида <blockquote><i>имя=значение</i></blockquote> и затем вызывая функцию <blockquote>putenv</blockquote>:</p>     <p><blockquote> if (argc == 3) {</blockquote></p>     <p><blockquote>  char *string;</blockquote></p>     <p><blockquote>  value = argv[2];</blockquote></p>     <p><blockquote>  string = malloc(strlen(var)+strlen(value)+2);</blockquote></p>     <p><blockquote>  if (!string} {</blockquote></p>     <p><blockquote>   fprintf(stderr, "out of memory\n");</blockquote></p>     <p><blockquote>   exit(1);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  strcpy(string, var);</blockquote></p>     <p><blockquote>  strcat(string, "=");</blockquote></p>     <p><blockquote>  strcat(string, value);</blockquote></p>     <p><blockquote>  printf("Calling putenv with: %s\n", string);</blockquote></p>     <p><blockquote>  if (putenv(string) != 0) {</blockquote></p>     <p><blockquote>   fprintf(stderr, "putenv failed\n");</blockquote></p>     <p><blockquote>   free(string);</blockquote></p>     <p><blockquote>   exit(1);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p>4. В заключение вы узнаете новое значение переменной, вызвав функцию getenv еще раз:</p>     <p><blockquote>  value = getenv(var);</blockquote></p>     <p><blockquote>  if (value)</blockquote></p>     <p><blockquote>   printf("New value of %s is %s\n", var, value);</blockquote></p>     <p><blockquote>  else</blockquote></p>     <p><blockquote>   printf("New value of %s is null??\n", var);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Когда вы выполните эту программу, то сможете увидеть и задать переменные окружения:</p>     <p><blockquote>$ <b>./environ НОМЕ</b></blockquote></p>     <p><blockquote>Variable HOME has value /home/neil</blockquote></p>     <p><blockquote>$ <b>./environ FRED</b></blockquote></p>     <p><blockquote>Variable FRED has no value</blockquote></p>     <p><blockquote>$ <b>./environ FRED hello</b></blockquote></p>     <p><blockquote>Variable FRED has no value</blockquote></p>     <p><blockquote>Calling putenv with: FRED=hello</blockquote></p>     <p><blockquote>New value of FRED is hello</blockquote></p>     <p><blockquote>$ <b>./environ FRED</b></blockquote></p>     <p><blockquote>Variable FRED has no value</blockquote></p>     <p>Обратите внимание на то, что окружение локально по отношению к программе. Изменения, которые вы делаете в программе, не отражаются вне ее, поскольку значения переменных не передаются из дочернего процесса (вашей программы) в родительский (командную оболочку).</p>             <a name="metkadoc6"><h1>Применение переменных окружения</h1></a>     <p>Программы часто применяют переменные окружения для изменения способа своей работы. Пользователи могут задать значения этих переменных окружения либо в их стандартном окружении с помощью файла .profile, читаемого их регистрационной командной оболочкой, использующей специальный файл запуска (rc) оболочки, либо заданием переменных в командной строке командной оболочки. Например,</p>     <p><blockquote>$ <b>./environ FRED</b></blockquote></p>     <p><blockquote>Variable FRED has no value</blockquote></p>     <p><blockquote>$ <b>FRED=hello ./environ FRED</b></blockquote></p>     <p><blockquote>Variable FRED has value hello</blockquote></p>     <p>Командная оболочка принимает начальные присвоения значений переменным как временные изменения переменных окружения. Во второй части предыдущего примера программа <blockquote>environ</blockquote> выполняется в окружении, где у переменной <blockquote>FRED</blockquote> есть значение.</p>     <p>Например, в будущей версии приложения, управляющего базой данных компакт-дисков, вы сможете изменить переменную окружения, скажем <blockquote>CDDB</blockquote>, обозначающую базу данных, которую нужно использовать. Каждый пользователь затем сможет задать собственное значение по умолчанию или применить команду оболочки для задания значения при очередном выполнении приложения:</p>     <p><blockquote>$ <b>CDDB=mycds; export CDDB</b></blockquote></p>     <p><blockquote>$ cdapp</blockquote></p>     <p>или</p>     <p><blockquote>$ <b>CDDB=mycds cdapp</b></blockquote></p>     <blockquote>      <b>Примечание</b>      <p>Переменные окружения — противоречивое благо, и их следует применять с осторожностью. Эти переменные более "закрыты" от пользователя, чем опции командной строки, и это может затруднить отладку. По смыслу переменные окружения подобны глобальным переменным, поэтому они могут изменять поведение программы, что порой приводит к неожиданным результатам.</p>     </blockquote>             <a name="metkadoc7"><h1>Переменная<i> environ</i></h1></a>     <p>Как вы уже знаете, окружение программы формируется из строк вида<i> имя=значение. </i>Этот массив строк становится доступен программе непосредственно из переменной environ, которая объявляется, как</p>     <p><b><blockquote><b>#include &lt;stdlib.h&gt;</b></blockquote></b></p>     <p><b><blockquote><b>extern char **environ;</b></blockquote></b></p>     <p>Выполните упражнение 4.5.</p>     <b>Упражнение 4.5. Переменная <blockquote>environ</blockquote></b>     <p>Далее приведена программа showenv.c, использующая переменную environ для вывода переменных окружения.</p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <br>     <p><blockquote>extern char **environ;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> char **env = environ;</blockquote></p>     <p><blockquote> while (*env) {</blockquote></p>     <p><blockquote>  printf("%s\n", *env);</blockquote></p>     <p><blockquote>  env++;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Когда вы выполните программу в системе Linux, то получите нечто, похожее на следующий вывод, который немного сокращен. Количество, порядок отображения и значения этих переменных зависят от версии операционной системы, применяемой командной оболочки и настроек пользователя в момент выполнения программы.</p>     <p><blockquote>$ <b>./showenv</b></blockquote></p>     <p><blockquote>HOSTNAME=tilde.provider.com</blockquote></p>     <p><blockquote>LOGNAME=neil</blockquote></p>     <p><blockquote>MAIL=/var/spool/mail/neil</blockquote></p>     <p><blockquote>TERM=xterm</blockquote></p>     <p><blockquote>HOSTTYPE=i386</blockquote></p>     <p><blockquote>PATH=/usr/local/bin:/bin:/usr/bin:</blockquote></p>     <p><blockquote>HOME=/usr/neil</blockquote></p>     <p><blockquote>LS_OPTIONS=-N --color=tty -T 0</blockquote></p>     <p><blockquote>SHELL=/bin/bash</blockquote></p>     <p><blockquote>OSTYPE=Linux</blockquote></p>     <p><blockquote>...</blockquote></p>     <p><b>Как это работает</b></p>     <p>Для вывода всего окружения программа в цикле обращается к переменной <blockquote>environ</blockquote> — массиву нуль-терминированных строк.</p>              <a name="metkadoc8"><h1>Время и дата</h1></a>    <p>Программе часто полезно иметь возможность определить время и дату. Возможно, она хочет зарегистрировать длительность собственного выполнения или ей нужно изменять свое поведение в определенные моменты времени. Например, игра может отказываться запускаться в рабочие часы или программа резервного копирования по расписанию хочет дождаться ранних часов, прежде чем начать резервное копирование в автоматическом режиме.</p>    <blockquote>     <b>Примечание</b>     <p>Во всех системах UNIX применяется одна и та же точка отсчета времени и дат: полночь по Гринвичу (GMT) на 1 января 1970 г. Это "начало эпохи UNIX", и ОС Linux — не исключение. Время в системе Linux измеряется в секундах, начиная с этого момента времени. Такой способ обработки аналогичен принятому в системе MS-DOS за исключением того, что эпоха MS-DOS началась в 1980 г. В других системах применяют точки отсчета иных эпох.</p>    </blockquote>    <p>Время задается с помощью типа <blockquote>time_t</blockquote>. Это целочисленный тип, достаточный для хранения дат и времени в секундах. В Linux-подобных системах это тип <blockquote>long integer</blockquote> (длинное целое), определенный вместе с функциями, предназначенными для обработки значений времени, в заголовочном файле time.h.</p>    <blockquote>     <b>Примечание</b>     <p>Не думайте, что для хранения времени достаточно 32 битов. В системах UNIX и Linux, использующих 32-разрядный тип <blockquote>time_t</blockquote>, временное значение "будет превышено" в 2038 г. Мы надеемся, что к тому времени системы перейдут на тип <blockquote>time_t</blockquote>, содержащий более 32 битов. Недавнее широкое внедрение 64-разрядных процессоров превращает это практически в неизбежность.</p>    </blockquote>    <p><blockquote><b>#include &lt;time.h&gt;</b></blockquote></p>    <p><blockquote><b>time_t time(time_t *tloc);</b></blockquote></p>    <p>Вы можете найти низкоуровневое значение времени, вызвав функцию <blockquote>time</blockquote>, которая вернет количество секунд с начала эпохи (упражнение 4.6). Она также запишет возвращаемое значение по адресу памяти, на который указывает параметр <blockquote>tloc</blockquote>, если он — непустой указатель.</p>    <b>Упражнение 4. Функция <blockquote>time</blockquote></b>    <p>Далее для демонстрации функции time приведена простая программа envtime.c.</p>    <p><blockquote>#include &lt;time.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>    <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>    <br>    <p><blockquote>int main() {</blockquote></p>    <p><blockquote> int i;</blockquote></p>    <p><blockquote> time_t the_time;</blockquote></p>    <p><blockquote> for (i = 1; i &lt;= 10; i++) {</blockquote></p>    <p><blockquote>  the_time = time((time_t *)0);</blockquote></p>    <p><blockquote>  printf("The time is %ld\n", the_time);</blockquote></p>    <p><blockquote>  sleep(2);</blockquote></p>    <p><blockquote> }</blockquote></p>    <p><blockquote> exit(0);</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Когда вы запустите программу, она будет выводить низкоуровневое значение времени каждые 2 секунды в течение 20 секунд.</p>    <p><blockquote>$ <b>./anytime</b></blockquote></p>    <p><blockquote>The time is 1179643852</blockquote></p>    <p><blockquote>The time is 1179643854</blockquote></p>    <p><blockquote>The time is 1179643856</blockquote></p>    <p><blockquote>The time is 1179643858</blockquote></p>    <p><blockquote>The time is 1179643860</blockquote></p>    <p><blockquote>The time is 1179643862</blockquote></p>    <p><blockquote>The time is 1179643864</blockquote></p>    <p><blockquote>The time is 1179643866</blockquote></p>    <p><blockquote>The time is 1179643868</blockquote></p>    <p><blockquote>The time is 1179643870</blockquote></p>    <p><b>Как это работает</b></p>    <p>Программа вызывает функцию <blockquote>time</blockquote> с пустым указателем в качестве аргумента, которая возвращает время и дату как количество секунд. Программа засыпает на две секунды и повторяет вызов time в целом 10 раз.</p>    <p>Использование времени и даты в виде количества секунд, прошедших с начала 1970 г., может быть полезно для измерения длительности чего-либо. Вы сможете сосчитать простую разность значений, полученных из двух вызовов функции <blockquote>time</blockquote>. Однако комитет, разрабатывавший стандарт языка ISO/ANSI С, в своих решениях не указал, что тип <blockquote>time_t</blockquote> будет применяться для определения произвольных интервалов времени в секундах, поэтому была придумана функция <blockquote>difftime</blockquote>, которая вычисляет разность в секундах между двумя значениями типа <blockquote>time_t</blockquote> и возвращает ее как величину типа <blockquote>double</blockquote>:</p>    <p><blockquote><b>#include &lt;time.h&gt;</b></blockquote></p>    <p><blockquote><b>double difftime(time_t time1, time_t time2);</b></blockquote></p>    <p>Функция <blockquote>difftime</blockquote> вычисляет разницу между двумя временными значениями и возвращает величину, эквивалентную выражению<i> <blockquote>время1–время2</blockquote>,</i> как число с плавающей точкой. В ОС Linux значение, возвращаемое функцией <blockquote>time</blockquote>, — это количество секунд, которое может обрабатываться, но для максимальной переносимости следует применять функцию <blockquote>difftime</blockquote>.</p>    <p>Для представления времени и даты в более осмысленном (с человеческой точки зрения) виде мы должны преобразовать значение времени в понятные время и дату. Для этого существуют стандартные функции.</p>    <p>Функция <blockquote>gmtime</blockquote> подразделяет низкоуровневое значение времени на структуру, содержащую более привычные поля:</p>    <p><blockquote><b>#include &lt;time.h&gt;</b></blockquote></p>    <p><blockquote><b>struct tm *gmtime(const time_t timeval)</b></blockquote></p>    <p>В структуре <blockquote>tm</blockquote>, как минимум, определены элементы, перечисленные в табл. 4.2.</p>    <br>    <p><b><i>Таблица 4.2</i></b></p>    <table>     <tr>      <th valign="top">Элемент <blockquote>tm</blockquote></th>      <th valign="top">Описание</th>     </tr>     <tr>      <td valign="top"><blockquote>int tm_sec</blockquote></td>      <td valign="top">Секунды, 0–61</td>     </tr>     <tr>      <td valign="top"><blockquote>int tm_min</blockquote></td>      <td valign="top">Минуты, 0–59</td>     </tr>     <tr>      <td valign="top"><blockquote>int tm_hour</blockquote></td>      <td valign="top">Часы, 0–23</td>     </tr>     <tr>      <td valign="top"><blockquote>int tm_mday</blockquote></td>      <td valign="top">День в месяце, 1–31</td>     </tr>     <tr>      <td valign="top"><blockquote>int tm_mon</blockquote></td>      <td valign="top">Месяц в году, 0–11 (January (январь) соответствует 0)</td>     </tr>     <tr>      <td valign="top"><blockquote>int tm_year</blockquote></td>      <td valign="top">Годы, начиная с 1900 г.</td>     </tr>     <tr>      <td valign="top"><blockquote>int tm_wday</blockquote></td>      <td valign="top">День недели, 0–6 (Sunday (воскресенье) соответствует 0)</td>     </tr>     <tr>      <td valign="top"><blockquote>int tm_yday</blockquote></td>      <td valign="top">День в году, 0–365</td>     </tr>     <tr>      <td valign="top"><blockquote>int tm_isdst</blockquote></td>      <td valign="top">Действующее летнее время</td>     </tr>    </table>    <p>Диапазон элемента <blockquote>tm_sec</blockquote> допускает появление время от времени корректировочной секунды или удвоенной корректировочной секунды.</p>    <p>Выполните упражнение 4.7.</p>    <b>Упражнение 4.7. Функция <blockquote>gmtime</blockquote></b>    <p>Далее приведена программа gmtime.с, выводящая текущие время и дату с помощью структуры <blockquote>tm</blockquote> и функции <blockquote>gmtime</blockquote>.</p>    <p><blockquote>#include &lt;time.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>    <br>    <p><blockquote>int main() {</blockquote></p>    <p><blockquote> struct tm *tm_ptr;</blockquote></p>    <p><blockquote> time_t the_time;</blockquote></p>    <p><blockquote> (void)time(&amp;the_time);</blockquote></p>    <p><blockquote> tm_ptr = gmtime(&amp;the_time);</blockquote></p>    <p><blockquote> printf("Raw time is %ld\n", the_time);</blockquote></p>    <p><blockquote> printf("gmtime gives:\n");</blockquote></p>    <p><blockquote> printf("date: %02d/%02d/%02d\n",</blockquote></p>    <p><blockquote>tm_ptr-&gt;tm_year, tm_ptr-&gt;tm_mon+1, tm_ptr-&gt;tm_mday);</blockquote></p>    <p><blockquote> printf("time: %02d:%02d:%02d\n",</blockquote></p>    <p><blockquote>  tm_ptr-&gt;tm_hour, tm_ptr-&gt;tm_min, tm_ptr-&gt;tm_sec);</blockquote></p>    <p><blockquote> exit(0);</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Выполнив эту программу, вы получите хорошее соответствие текущим времени и дате:</p>    <p><blockquote>$ <b>./gmtime; date</b></blockquote></p>    <p><blockquote>Raw time is 1179644196</blockquote></p>    <p><blockquote>gmtime gives:</blockquote></p>    <p><blockquote>date: 107/05/20</blockquote></p>    <p><blockquote>time: 06:56:36</blockquote></p>    <p><blockquote>Sun May 20 07:56:37 BST 2007</blockquote></p>    <p><b>Как это работает</b></p>    <p>Программа вызывает функцию <blockquote>time</blockquote> для получения машинного представления значения времени и затем вызывает функцию gmtime для преобразования его в структуру с удобными для восприятия значениями времени и даты. Она выводит на экран полученные значения с помощью функции <blockquote>printf</blockquote>. Строго говоря, выводить необработанное значение времени таким способом не следует, потому что наличие типа длинного целого не гарантировано во всех системах. Если сразу же после вызова функции gmtime выполнить команду date, можно сравнить оба вывода.</p>    <p>Но здесь у вас возникнет небольшая проблема. Если вы запустите эту программу в часовом поясе, отличном от Greenwich Mean Time (время по Гринвичу) или у вас действует летнее время, как у нас, вы заметите, что время (и, возможно, дата) неправильное. Все дело в том, что функция <blockquote>gmtime</blockquote> возвращает время по Гринвичу (теперь называемое Universal Coordinated Time (всеобщее скоординированное время) или UTC). Системы Linux и UNIX поступают так для синхронизации всех программ и систем в мире. Файлы, созданные в один и тот же момент в разных часовых поясах, будут отображаться с одинаковым временем создания. Для того чтобы посмотреть местное время, следует применять функцию <blockquote>localtime</blockquote>.</p>    <p><blockquote><b>#include &lt;time.h&gt;</b></blockquote></p>    <p><blockquote><b>struct tm *localtime(const time_t *timeval);</b></blockquote></p>    <p>Функция <blockquote>localtime</blockquote> идентична функции <blockquote>gmtime</blockquote> за исключением того, что она возвращает структуру, содержащую значения с поправками на местный часовой пояс и действующее летнее время. Если вы выполните программу <blockquote>gmtime</blockquote>, но замените все вызовы функции <blockquote>gmtime</blockquote> на вызовы <blockquote>localtime</blockquote>, в отчете программы вы увидите правильные время и дату.</p>    <p>Для преобразования разделенной на элементы структуры tm в общее внутреннее значение времени можно применить функцию <blockquote>mktime</blockquote>:</p>    <p><blockquote><b>#include &lt;time.h&gt;</b></blockquote></p>    <p><blockquote><b>time_t mktime(struct tm *timeptr);</b></blockquote></p>    <p>Функция <blockquote>mktime</blockquote> вернет -1, если структура не может быть представлена как значение типа <blockquote>time_t</blockquote>.</p>    <p>Для вывода программой <blockquote>date</blockquote> "дружественных" (в противоположность машинному) времени и даты можно воспользоваться функциями <blockquote>asctime</blockquote> и <blockquote>ctime</blockquote>:</p>    <p><blockquote><b>#include &lt;time.h&gt;</b></blockquote></p>    <p><blockquote><b>char *asctime(const struct tm *timeptr);</b></blockquote></p>    <p><blockquote><b>char *ctime(const time_t *timeval);</b></blockquote></p>    <p>Функция <blockquote>asctime</blockquote> возвращает строку, представляющую время и дату, заданные <blockquote>tm</blockquote>-структурой <blockquote>timeptr</blockquote>. У возвращаемой строки формат, подобный приведенному далее:</p>    <p><blockquote>Sun Jun  9 12:34:56 2007\n\0</blockquote></p>    <p>У нее всегда фиксированный формат длиной 26 символов. Функция <blockquote>ctime</blockquote> эквивалентна следующему вызову:</p>    <p><blockquote>asctime(localtime(timeval))</blockquote></p>    <p>Она принимает необработанное машинное значение времени и преобразует его в местное время.</p>    <p>А теперь выполните упражнение 4.8.</p>    <b>Упражнение 4.8. Функция <blockquote>ctime</blockquote></b>    <p>В этом примере благодаря приведенному далее программному коду вы увидите функцию <blockquote>ctime</blockquote> в действии.</p>    <p><blockquote>#include &lt;time.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>    <br>    <p><blockquote>int main() {</blockquote></p>    <p><blockquote> time_t timeval;</blockquote></p>    <p><blockquote> (void)time(&amp;timeval);</blockquote></p>    <p><blockquote> printf ("The date is: %s", ctime(&amp;timeval));</blockquote></p>    <p><blockquote> exit(0);</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Откомпилируйте и затем запустите на выполнение ctime.c, и вы увидите нечто похожее на приведенные далее строки:</p>    <p><blockquote>$ <b>./ctime</b></blockquote></p>    <p><blockquote>The date is: Sat Jun 9 08:02:08 2007.</blockquote></p>    <p><b>Как это работает</b></p>    <p>Программа ctime.c вызывает функцию <blockquote>time</blockquote> для получения машинного значения времени и дает возможность функции <blockquote>ctime</blockquote> выполнить всю тяжелую работу по преобразованию этого значения в удобочитаемую строку, которую потом и выводит на экран.</p>    <p>Для лучшего управления точным форматированием времени и даты ОС Linux и современные UNIX-подобные системы предоставляют функцию <blockquote>strftime</blockquote>. Она довольно похожа на функцию <blockquote>sprintf</blockquote> для дат и времени и действует аналогичным образом:</p>    <p><blockquote><b>#include &lt;time.h&gt;</b></blockquote></p>    <p><blockquote><b>size_t strftime(char *s, size_t maxsize, const char *format, struct tm *timeptr);</b></blockquote></p>    <p>Функция <blockquote>strftime</blockquote> форматирует время и дату, представленные в структуре <blockquote>tm</blockquote>, на которую указывает параметр, <blockquote>timeptr</blockquote>, и помещает результат в строку <blockquote>s</blockquote>. Эта строка задается длиной <blockquote>maxsize</blockquote> (как минимум) символов. Строка <blockquote>format</blockquote> применяется для управления символами, записываемыми в строку. Как и в функции <blockquote>printf</blockquote>, она содержит обычные символы, которые будут переданы в строку, и спецификаторы преобразований для форматирования элементов времени и даты. В табл. 4.3 перечислены используемые спецификаторы преобразований.</p>    <br>    <p><b><i>Таблица 4.3</i></b></p>    <table>     <tr>      <th valign="top">Спецификатор преобразования</th>      <th valign="top">Описание</th>     </tr>     <tr>      <td valign="top"><blockquote>%a</blockquote></td>      <td valign="top">Сокращенное название дня недели</td>     </tr>     <tr>      <td valign="top"><blockquote>%А</blockquote></td>      <td valign="top">Полное название дня недели</td>     </tr>     <tr>      <td valign="top"><blockquote>%b</blockquote></td>      <td valign="top">Сокращенное название месяца</td>     </tr>     <tr>      <td valign="top"><blockquote>%B</blockquote></td>      <td valign="top">Полное название месяца</td>     </tr>     <tr>      <td valign="top"><blockquote>%c</blockquote></td>      <td valign="top">Дата и время</td>     </tr>     <tr>      <td valign="top"><blockquote>%d</blockquote></td>      <td valign="top">День месяца, 01–31</td>     </tr>     <tr>      <td valign="top"><blockquote>%H</blockquote></td>      <td valign="top">Час, 00–23</td>     </tr>     <tr>      <td valign="top"><blockquote>%I</blockquote></td>      <td valign="top">Час по 12-часовой шкале, 01–12</td>     </tr>     <tr>      <td valign="top"><blockquote>%j</blockquote></td>      <td valign="top">День в году, 001–366</td>     </tr>     <tr>      <td valign="top"><blockquote>%m</blockquote></td>      <td valign="top">Номер месяца в году, 01–12</td>     </tr>     <tr>      <td valign="top"><blockquote>%M</blockquote></td>      <td valign="top">Минуты, 00–59</td>     </tr>     <tr>      <td valign="top"><blockquote>%p</blockquote></td>      <td valign="top">a.m. (до полудня) или p.m. (после полудня)</td>     </tr>     <tr>      <td valign="top"><blockquote>%S</blockquote></td>      <td valign="top">Секунды, 00–59</td>     </tr>     <tr>      <td valign="top"><blockquote>%u</blockquote></td>      <td valign="top">Номер дня недели, 1–7 (1 соответствует понедельнику)</td>     </tr>     <tr>      <td valign="top"><blockquote>%U</blockquote></td>      <td valign="top">Номер недели в году, 01–53 (воскресенье — первый день недели)</td>     </tr>     <tr>      <td valign="top"><blockquote>%V</blockquote></td>      <td valign="top">Номер недели в году, 01–53 (понедельник — первый день недели)</td>     </tr>     <tr>      <td valign="top"><blockquote>%w</blockquote></td>      <td valign="top">Номер дня недели, 0–6 (0 соответствует воскресенью)</td>     </tr>     <tr>      <td valign="top"><blockquote>%x</blockquote></td>      <td valign="top">Дата в региональном формате</td>     </tr>     <tr>      <td valign="top"><blockquote>%X</blockquote></td>      <td valign="top">Время в региональном формате</td>     </tr>     <tr>      <td valign="top"><blockquote>%y</blockquote></td>      <td valign="top">Номер года, меньший 1900</td>     </tr>     <tr>      <td valign="top"><blockquote>%Y</blockquote></td>      <td valign="top">Год</td>     </tr>     <tr>      <td valign="top"><blockquote>%Z</blockquote></td>      <td valign="top">Название часового пояса</td>     </tr>     <tr>      <td valign="top"><blockquote>%%</blockquote></td>      <td valign="top">Символ <blockquote>%</blockquote></td>     </tr>    </table>    <p>Таким образом, обычная дата, такая же, как полученная из программы date, соответствует следующей строке формата функции <blockquote>strftime</blockquote>:</p>    <p><blockquote>"%a %b %d %Н: %М: %S %Y"</blockquote></p>    <p>Для облегчения чтения дат можно использовать функцию <blockquote>strptime</blockquote>, принимающую строку с датой и временем и формирующую структуру <blockquote>tm</blockquote> с теми же датой и временем:</p>    <p><blockquote><b>#include &lt;time.h&gt;</b></blockquote></p>    <p><blockquote><b>char *strptime(const char *buf, const char *format, struct tm *timeptr);</b></blockquote></p>    <p>Строка <blockquote>format</blockquote> конструируется точно так же, как одноименная строка функции <blockquote>strftime</blockquote>. Функций <blockquote>strptime</blockquote> действует аналогично функции <blockquote>sscanf</blockquote>: она сканирует строку в поиске опознаваемых полей и записывает их в переменные. В данном случае это элементы структуры <blockquote>tm</blockquote>, которая заполняется в соответствии со строкой <blockquote>format</blockquote>. Однако спецификаторы преобразований для <blockquote>strptime</blockquote> немного мягче спецификаторов функции <blockquote>strftime</blockquote>. Так, в функции <blockquote>strptime</blockquote> разрешены как сокращенные, так и полные названия дней и месяцев. Любое из этих представлений будет соответствовать спецификатору %a функции <blockquote>strptime</blockquote>. Кроме того, в то время как функция <blockquote>strftime</blockquote> для представления чисел, меньших 10, всегда применяет ведущие нули, <blockquote>strptime</blockquote> считает их необязательными.</p>    <p>Функция <blockquote>strptime</blockquote> возвращает указатель на символ, следующий за последним, обработанным в процессе преобразования. Если она встречает символы, которые не могут быть преобразованы, в этой точке преобразование просто прекращается. Для того чтобы убедиться в том, что в структуру <blockquote>tm</blockquote> записаны значимые данные, вызывающей программе следует проверять, достаточно ли символов строки принято и обработано.</p>    <p>Рассмотрим работу функций на примере (упражнение 4.9).</p>    <b>Упражнение 4.9. Функции <blockquote>strftime</blockquote> и <blockquote>strptime</blockquote></b>    <p>Обратите внимание на выбор спецификаторов преобразований, использованных в следующей программе:</p>    <p><blockquote>#include &lt;time.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>    <br>    <p><blockquote>int main() {</blockquote></p>    <p><blockquote> struct tm *tm_ptr, timestruct;</blockquote></p>    <p><blockquote> time_t the_time;</blockquote></p>    <p><blockquote> char buf[256];</blockquote></p>    <p><blockquote> char *result;</blockquote></p>    <p><blockquote> (void)time(&amp;the_time);</blockquote></p>    <p><blockquote> tm_ptr = localtime(&amp;the_time);</blockquote></p>    <p><blockquote> strftime(buf, 256, "%A %d %B, %I:%S %p", tm_ptr);</blockquote></p>    <p><blockquote> printf("strftime gives: %s\n", buf);</blockquote></p>    <p><blockquote> strcpy(buf, "Thu 26 July 2007, 17:53 will do fine");</blockquote></p>    <p><blockquote> printf("calling strptime with: %s\n", buf);</blockquote></p>    <p><blockquote> tm_ptr = &amp;timestruct;</blockquote></p>    <p><blockquote> result = strptime(buf, "%a %d %b %Y, %R", tm_ptr);</blockquote></p>    <p><blockquote> printf("strptime consumed up to: %s\n", result);</blockquote></p>    <p><blockquote> printf("strptime gives:\n");</blockquote></p>    <p><blockquote> printf ("date: %02d/%02d/%02d\n",</blockquote></p>    <p><blockquote>  tm_ptr-&gt;tm_year % 100, tm_ptr-&gt;tm_mon+1, tm_ptr-&gt;tm_mday);</blockquote></p>    <p><blockquote> printf("time: %02d:%02d\n",</blockquote></p>    <p><blockquote>  tm_ptr-&gt;tm_hour, tm-&gt;ptr-&gt;tm_min);</blockquote></p>    <p><blockquote> exit(0);</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Когда вы откомпилируете и выполните программу strftime.c, то получите следующий результат:</p>    <p><blockquote>$ <b>./strftime</b></blockquote></p>    <p><blockquote>strftime gives: Saturday 09 June, 08:16 AM</blockquote></p>    <p><blockquote>calling strptime with: Thu 26 July 2007, 17:53 will do fine</blockquote></p>    <p><blockquote>strptime concurred up to: will do fine</blockquote></p>    <p><blockquote>strptime gives:</blockquote></p>    <p><blockquote>date: 07/07/26</blockquote></p>    <p><blockquote>time: 17:53</blockquote></p>    <p><b>Как это работает</b></p>    <p>Программа strftime получает текущее местное время с помощью вызовов функций <blockquote>time</blockquote> и <blockquote>localtime</blockquote>. Затем она преобразует его в удобочитаемую форму с помощью функции <blockquote>strftime</blockquote> с подходящим аргументом форматирования. Для демонстрации применения функции <blockquote>strptime</blockquote> программа задает строку, содержащую дату и время, затем вызывает strptime для извлечения необработанных значений времени и даты и выводит их на экран. Спецификатор преобразования <blockquote>%R</blockquote> функции <blockquote>strptime</blockquote> — это сокращенное обозначение комбинации <blockquote>%Н:%M</blockquote>.</p>    <p>Важно отметить, что для успешного просмотра даты функции strptime необходима точная строка формата. Обычно она не может точно обработать даты, считываемые из строк, введенных пользователями, до тех пор, пока не будет строго выверен формат.</p>    <p>Возможно, при компиляции программы strftime.c вы получите предупреждение компилятора. Причина в том, что по умолчанию в библиотеке GNU не объявлена функция <blockquote>strptime</blockquote>. Для устранения проблемы следует явно запросить средства стандарта X/Open, добавив следующую строку перед заголовочным файлом time.h:</p>    <p><blockquote>#define _XOPEN_SOURCE</blockquote></p>          <a name="metkadoc9"><h1>Временные файлы</h1></a>    <p>Зачастую программы нуждаются в возможности использования временного хранилища в виде файлов. В них могут храниться промежуточные результаты вычислений, или резервные копии файлов, сделанные перед выполнением критических операций. Например, приложение для работы с базой данных может применять временный файл при удалении записей. В файле собираются элементы базы данных, нуждающиеся в сохранении, и затем в конце процесса временный файл становится новой базой данных, а исходная база данных удаляется.</p>    <p>У столь популярных временных файлов есть скрытый недостаток. Вы должны следить за тем, чтобы приложения выбирали уникальное имя для временного файла. Если это условие не соблюдается, могут возникнуть проблемы. Поскольку ОС Linux — многозадачная система, другая программа может выбрать то же самое имя, и обе будут мешать друг другу.</p>    <p>Уникальное имя файла генерируется с помощью функции <blockquote>tmpnam</blockquote>:</p>    <p><blockquote><b>#include &lt;stdio.h&gt;</b></blockquote></p>    <p><blockquote><b>char *tmpnam(char *s);</b></blockquote></p>    <p>Функция <blockquote>tmpnam</blockquote> возвращает допустимое имя файла, не совпадающее с именем любого из существующих файлов. Если строка <blockquote>s</blockquote> не равна <blockquote>NULL</blockquote>, в нее будет записано имя файла. Последующие вызовы функции tmpnam будут перезаписывать статическую память, используемую для возвращаемых значений, поэтому важно применять строковый параметр, если функция должна вызываться многократно. Длина строки полагается равной, как минимум, <blockquote>L_tmpnam</blockquote> (обычно около 20) символам. Функция <blockquote>tmpnam</blockquote> может вызываться в одной программе до <blockquote>TMP_MAX</blockquote> (не менее нескольких тысяч) раз, и каждый раз она будет генерировать уникальное имя файла.</p>    <p>Если, временный файл предполагается использовать немедленно, вы можете одновременно назвать его и открыть с помощью функции <blockquote>tmpfile</blockquote>. Это важно, т.к. другая программа может создать файл с именем таким же, как значение, возвращенное функцией <blockquote>tmpnam</blockquote>. Функция <blockquote>tmpfile</blockquote> устраняет эту проблему полностью.</p>    <p><blockquote><b>#include &lt;stdio.h&gt;</b></blockquote></p>    <p><blockquote><b>FILE* tmpfile(void);</b></blockquote></p>    <p>Функция tmpfile возвращает указатель потока, ссылающийся на уникальный временный файл. Файл открыт для чтения и записи (с помощью <blockquote>fopen</blockquote> с флагом <blockquote>w+</blockquote>) и будет автоматически удален, когда закроются все ссылки на него.</p>    <p>В случае возникновения ошибки <blockquote>tmpfile</blockquote> вернет указатель <blockquote>NULL</blockquote> и задаст значение переменной <blockquote>errno</blockquote>.</p>    <p>Давайте посмотрим эти две функции в действии:</p>    <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>    <br>    <p><blockquote>int main() {</blockquote></p>    <p><blockquote> char tmpname[L_tmpnam];</blockquote></p>    <p><blockquote> char* filename;</blockquote></p>    <p><blockquote> FILE *tmpfp;</blockquote></p>    <p><blockquote> filename = tmpnam(tmpname);</blockquote></p>    <p><blockquote> printf("Temporary file name is: %s\n", filename);</blockquote></p>    <p><blockquote> tmpfp = tmpfile();</blockquote></p>    <p><blockquote> if (tmpfp) printf("Opened a temporary file OK\n");</blockquote></p>    <p><blockquote> else perror("tmpfile");</blockquote></p>    <p><blockquote> exit(0);</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Когда вы откомпилируете и выполните программу tmpnam.с, то увидите уникальное имя файла, сгенерированное функцией <blockquote>tmpnam</blockquote>:</p>    <p><blockquote>$ <b>./tmpnam</b></blockquote></p>    <p><blockquote>Temporary file name is: /tmp/file2S64zc</blockquote></p>    <p><blockquote>Opened a temporary file OK</blockquote></p>    <p><b>Как это работает</b></p>    <p>Программа вызывает функцию <blockquote>tmpnam</blockquote> для генерации уникального имени временного файла. Если вы хотите его использовать, нужно быстро его открыть, чтобы минимизировать риск того, что другая программа откроет файл с тем же именем. Вызов функции <blockquote>tmpfile</blockquote> одновременно создает и открывает временный файл, тем самым устраняя этот риск. При компиляции программы, использующей функцию <blockquote>tmpnam</blockquote>, компилятор GNU С может вывести предупреждение о применении этой функции.</p>    <p>В некоторых версиях UNIX предлагается другой способ генерации имен временных файлов — с помощью функций <blockquote>mktemp</blockquote> и <blockquote>mkstemp</blockquote>. Они поддерживаются и ОС Linux и аналогичны функции <blockquote>tmpnam</blockquote> за исключением того, что вы должны задать шаблон имени временного файла, который предоставляет некоторые дополнительные возможности управления местом хранения и именем файла.</p>    <p><blockquote><b>#include &lt;stdlib.h&gt;</b></blockquote></p>    <p><blockquote><b>char *mktemp(char *template);</b></blockquote></p>    <p><blockquote><b>int mkstemp(char *template);</b></blockquote></p>    <p>Функция mktemp создает уникальное имя файла на основе заданного шаблона <blockquote>template</blockquote>. Аргумент <blockquote>template</blockquote> должен быть строкой с шестью завершающими символами <blockquote>Х</blockquote>. <blockquote>mktemp</blockquote> заменяет эти символы <blockquote>Х</blockquote> уникальной комбинацией символов, допустимых в именах файлов. Она возвращает указатель на сгенерированную строку или <blockquote>NULL</blockquote> при невозможности сформировать уникальное имя.</p>    <p>Функция <blockquote>mkstemp</blockquote> аналогична функции <blockquote>tmpfile</blockquote>: она создает и открывает временный файл. Имя файла генерируется так же, как в функции <blockquote>mktemp</blockquote>, но возвращенный результат — открытый низкоуровневый дескриптор файла.</p>    <blockquote>     <b>Примечание</b>     <p>В ваших собственных программах следует всегда применять функции "создать и открыть" <blockquote>tmpfile</blockquote> и <blockquote>mkstemp</blockquote> вместо функций <blockquote>tmpnam</blockquote> и <blockquote>mktemp</blockquote>.</p>    </blockquote>          <a name="metkadoc10"><h1>Информация о пользователе</h1></a>    <p>Все программы в ОС Linux за исключением программы init, запускаются другими программами или пользователями. В<i> главе 11</i> вы узнаете больше о взаимодействии выполняющихся программ или процессов. Пользователи чаще всего запускают программы из командной оболочки, реагирующей на их команды. Вы видели, что в программе можно определить собственное окружение, просматривая переменные окружения и читая системные часы. Программа может также выяснить данные о пользователе, применяющем ее.</p>    <p>Когда пользователь регистрируется в системе Linux, у него или у нее есть имя пользователя и пароль. После того как эти данные проверены, пользователю предоставляется командная оболочка. В системе у пользователя также есть уникальный идентификатор пользователя, называемый UID (user identifier). Каждая программа, выполняемая Linux, запускается от имени пользователя и имеет связанный с ней UID.</p>    <p>Вы можете настроить выполнение программ так, как будто они запускаются другим пользователем. Если у программы есть свой набор прав доступа для UID, она будет выполняться от имени владельца исполняемого файла. Когда выполнена команда su, программа действует так, как будто она запущена суперпользователем. Затем она проверяет право доступа пользователя, изменяет UID на идентификатор назначенной учетной записи и запускает регистрационную командную оболочку данной учетной записи. Этот прием позволяет программе выполняться от имени другого пользователя и часто используется системными администраторами для выполнения задач технического обслуживания системы.</p>    <p>Поскольку UID — это ключевой параметр для идентификации пользователя, начнем с него.</p>    <p>У UID есть свои тип <blockquote>uid_t</blockquote>, определенный в файле sys/types.h. Обычно это короткое целое (small integer). Одни идентификаторы пользователя заранее определены системой, другие создаются системным администратором, когда новые пользователи становятся известны системе. Как правило, идентификаторы пользователей имеют значения, большие 100.</p>    <p><blockquote><b>#include &lt;sys/types.h&gt;</b></blockquote></p>    <p><blockquote><b>#include &lt;unistd.h&gt;</b></blockquote></p>    <p><blockquote><b>uid_t getuid (void);</b></blockquote></p>    <p><blockquote><b>char *getlogin(void);</b></blockquote></p>    <p>Функция <blockquote>getuid</blockquote> возвращает UID, с которым связана программа. Обычно это UID пользователя, запустившего программу.</p>    <p>Функция <blockquote>getlogin</blockquote> возвращает регистрационное имя, ассоциированное с текущим пользователем.</p>    <p>Системный файл /etc/passwd содержит базу данных, имеющую дело с учетными записями пользователей. Он состоит из строк по одной на каждого пользователя, в каждую строку включены имя пользователя, зашифрованный пароль, идентификатор пользователя (UID), идентификатор группы (GID), полное имя, исходный каталог и командная оболочка, запускаемая по умолчанию. Далее приведен пример такой строки:</p>    <p><blockquote>neil:zBqxfqedfpk:500:100:Neil Matthew:/home/neil:/bin/bash</blockquote></p>    <p>Если вы пишете программу, которая определяет UID пользователя, запустившего ее, то можете расширить ее возможности и заглянуть в файл passwd для выяснения регистрационного имени пользователя и его полного имени. Мы не рекомендуем делать это, потому что современные UNIX-подобные системы уходят от применения файлов учетных записей пользователей для повышения безопасности системы. Многие системы, включая Linux, имеют возможность использовать файлы<i> теневых паролей</i> (shadow password), совсем не содержащие пригодной информации о зашифрованных паролях (она часто хранится в файле /etc/shadow, которые обычные пользователи не могут читать). По этой причине определен ряд функций для предоставления эффективного программного интерфейса, позволяющего получать эту пользовательскую информацию.</p>    <p><blockquote><b>#include &lt;sys/types.h&gt;</b></blockquote></p>    <p><blockquote><b>#include &lt;pwd.h&gt;</b></blockquote></p>    <p><blockquote><b>struct passwd *getpwuid(uid_t uid);</b></blockquote></p>    <p><blockquote><b>struct passwd *getpwnam(const char *name);</b></blockquote></p>    <p>Структура базы данных учетных записей пользователей <blockquote>passwd</blockquote> определена в файле pwd.h и включает элементы, перечисленные в табл. 4.4.</p>    <br>    <p><b><i>Таблица 4.4</i></b></p>    <table>     <tr>      <th valign="top">Элемент <blockquote>passwd</blockquote></th>      <th valign="top">Описание</th>     </tr>     <tr>      <td valign="top"><blockquote>char *pw_name</blockquote></td>      <td valign="top">Регистрационное имя пользователя</td>     </tr>     <tr>      <td valign="top"><blockquote>uid_t pw_uid</blockquote></td>      <td valign="top">Номер UID</td>     </tr>     <tr>      <td valign="top"><blockquote>gid_t pw_gid</blockquote></td>      <td valign="top">Номер GID</td>     </tr>     <tr>      <td valign="top"><blockquote>char *pw_dir</blockquote></td>      <td valign="top">Исходный каталог пользователя</td>     </tr>     <tr>      <td valign="top"><blockquote>char *pw_gecos</blockquote></td>      <td valign="top">Полное имя пользователя</td>     </tr>     <tr>      <td valign="top"><blockquote>char *pw_shell</blockquote></td>      <td valign="top">Командная оболочка пользователя, запускаемая по умолчанию</td>     </tr>    </table>    <p>В некоторых системах UNIX может использоваться другое имя для поля с полным именем пользователя: в одних системах это <blockquote>pw_gecos</blockquote>, как в ОС Linux, в других — <blockquote>pw_comment</blockquote>. Это означает, что мы не можем рекомендовать его использование. Обе функции (и <blockquote>getpwuid</blockquote>, и <blockquote>getpwnam</blockquote>) возвращают указатель на структуру <blockquote>passwd</blockquote>, соответствующую пользователю. Пользователь идентифицируется по UID в функции <blockquote>getpwuid</blockquote> и по регистрационному имени в функции <blockquote>getpwnam</blockquote>. В случае ошибки обе функции вернут пустой указатель и установят переменную <blockquote>errno</blockquote>.</p>    <p>Выполните упражнение 4.11.</p>    <b>Упражнение 4.11. Информации о пользователе</b>    <p>В этом упражнении показана программа user.c, извлекающая некоторую информацию о пользователе из базы данных учетных записей.</p>    <p><blockquote>#include &lt;sys/types.h&gt;</blockquote></p>    <p><blockquote>#include &lt;pwd.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>    <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>    <br>    <p><blockquote>int main() {</blockquote></p>    <p><blockquote> uid_t uid;</blockquote></p>    <p><blockquote> gid_t gid;</blockquote></p>    <p><blockquote> struct passwd *pw;</blockquote></p>    <p><blockquote> uid = getuid();</blockquote></p>    <p><blockquote> gid = getgid();</blockquote></p>    <p><blockquote> printf("User is %s\n", getlogin());</blockquote></p>    <p><blockquote> printf("User IDs: uid=%d, gid=%d\n", uid, gid);</blockquote></p>    <p><blockquote> pw = getpwuid(uid);</blockquote></p>    <p><blockquote> printf(</blockquote></p>    <p><blockquote>  "UID passwd entry:\n name=%s, uid=%d, gid=%d, home=%s, shell=%s\n",</blockquote></p>    <p><blockquote>  pw-&gt;pw_name, pw-&gt;pw_uid, pw-&gt;pw_gid, pw-&gt;pw_dir, pw-&gt;pw_shell);</blockquote></p>    <p><blockquote> pw = getpwnam("root");</blockquote></p>    <p><blockquote> printf("root passwd entry:\n");</blockquote></p>    <p><blockquote> printf("name=%s, uid=%d, gid=%d, home=%s, shell=%s\n",</blockquote></p>    <p><blockquote>  pw-&gt;pw_name, pw-&gt;pw_uid, pw-&gt;pw_gid, pw-&gt;pw_dir, pw-&gt;pw_shell);</blockquote></p>    <p><blockquote> exit(0);</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Программа предоставит следующий вывод, который может слегка отличаться в разных версиях Linux и UNIX:</p>    <p><blockquote>$ <b>./user</b></blockquote></p>    <p><blockquote>User is neil</blockquote></p>    <p><blockquote>User IDs: uid=1000, gid=100</blockquote></p>    <p><blockquote>UID passwd entry:</blockquote></p>    <p><blockquote>name=neil, uid=1000, gid=100, home=/home/neil, shell=/bin/bash</blockquote></p>    <p><blockquote>root passwd entry:</blockquote></p>    <p><blockquote>name=root, uid=0, gid=0, home=/root, shell=/bin/bash</blockquote></p>    <p><b>Как это работает</b></p>    <p>Эта программа вызывает функцию <blockquote>getuid</blockquote> для получения UID текущего пользователя, Этот UID применяется в функции <blockquote>getpwuid</blockquote> для получения подробной информации из файла учетных записей пользователей. В качестве альтернативы мы показываем, как для извлечения информации о пользователе можно задать в функции <blockquote>getpwnam</blockquote> имя пользователя <blockquote>root</blockquote>.</p>    <b>Примечание</b>    <p>В исходном коде Linux вы сможете найти в команде <blockquote>id</blockquote> еще один пример-использования функции <blockquote>getuid</blockquote>.</p>    <p>Для просмотра всех данных файла учетных записей пользователей можно воспользоваться функцией <blockquote>getpwent</blockquote>. Она последовательно выбирает строки файла.</p>    <p><blockquote><b>#include &lt;pwd.h&gt;</b></blockquote></p>    <p><blockquote><b>#include &lt;sys/types.h&gt;</b></blockquote></p>    <p><blockquote><b>void endpwent(void);</b></blockquote></p>    <p><blockquote><b>struct passwd *getpwent(void);</b></blockquote></p>    <p><blockquote><b>void setpwent(void);</b></blockquote></p>    <p>Функция <blockquote>getpwent</blockquote> возвращает поочередно информацию о каждом пользователе. Когда не остается ни одного, она возвращает пустой указатель. Для прекращения обработки файла, когда просмотрено достаточно элементов, вы можете применить функцию <blockquote>endpwent</blockquote>. Функция <blockquote>setpwent</blockquote> переустанавливает позицию указателя в файле учетных записей пользователей для начала нового просмотра при следующем вызове функции <blockquote>getpwent</blockquote>. Эти функции действуют так же, как функции просмотра каталога <blockquote>opendir</blockquote>, <blockquote>readdir</blockquote> и <blockquote>closedir</blockquote>, обсуждавшиеся в<i> главе 3.</i></p>    <p>Идентификаторы пользователя и группы (эффективный или действующий и реальный) можно получить с помощью других реже используемых функций:</p>    <p><blockquote><b>#include &lt;sys/types.h&gt;</b></blockquote></p>    <p><blockquote><b>#include &lt;unistd.h&gt;</b></blockquote></p>    <p><blockquote><b>uid_t geteuid(void);</b></blockquote></p>    <p><blockquote><b>gid_t getgid(void);</b></blockquote></p>    <p><blockquote><b>gid_t getegid(void);</b></blockquote></p>    <p><blockquote><b>int setuid(uid_t uid);</b></blockquote></p>    <p><blockquote><b>int setgid(gid_t gid);</b></blockquote></p>    <p>Подробную информацию об идентификаторах группы и эффективных идентификаторах пользователей следует искать на страницах интерактивного справочного руководства системы, хотя, быть может, вы решите, что вам вообще не следует манипулировать ими.</p>    <blockquote>     <b>Примечание</b>     <p>Только суперпользователь может вызывать функции <blockquote>setuid</blockquote> и <blockquote>setgid</blockquote>.</p>    </blockquote>          <a name="metkadoc11"><h1>Информация о компьютере</h1></a>    <p>Программа может установить некоторые подробные сведения о компьютере, на котором выполняется, так же, как она определяет информацию о пользователе. Подобную информацию предоставляет команда <blockquote>uname</blockquote>, в программе на языке С можно использовать для получения этих данных одноименный системный вызов — прочтите о нем в разделе системных вызовов интерактивного справочного руководства (раздел 2) с помощью команды <blockquote>man 2 uname</blockquote>.</p>    <p>Сведения о рабочем компьютере могут оказаться полезными в ряде ситуаций. Вы можете захотеть настроить поведение программы в зависимости от сетевого имени машины, на которой она выполняется, скажем, на студенческом компьютере или машине администратора. Для соблюдения лицензионных соглашений вам может потребоваться ограничить выполнение программы одной машиной. Все это означает, что вам нужен способ определения компьютера, на котором выполняется программа.</p>    <p>Если в системе установлены сетевые компоненты, вы очень легко можете получить сетевое имя компьютера с помощью функции <blockquote>gethostname</blockquote>:</p>    <p><blockquote><b>#include &lt;unistd.h&gt;</b></blockquote></p>    <p><blockquote><b>int gethostname(char *name, size_t namelen);</b></blockquote></p>    <p>Эта функция записывает сетевое имя машины в строку <blockquote>name</blockquote>. Предполагается, что длина строки, как минимум, <blockquote>namelen</blockquote> символов. Функция <blockquote>gethostname</blockquote> возвращает 0 в случае успешного завершения и -1 в противном случае.</p>    <p>Более подробную информацию о рабочем компьютере можно получить с помощью системного вызова <blockquote>uname</blockquote>.</p>    <p><blockquote><b>#include &lt;sys/utsname.h&gt;</b></blockquote></p>    <p><blockquote><b>int uname(struct utsname *name);</b></blockquote></p>    <p>Функция uname записывает информацию о компьютере в структуру, на которую указывает параметр name. Структура типа utsname, определенная в файле sys/utsname.h, обязательно должна включать элементы, перечисленные в табл. 4.5.</p>    <br>    <p><b><i>Таблица 4.5</i></b></p>    <table>     <tr>      <th valign="top">Элемент структуры <blockquote>utsname</blockquote></th>      <th valign="top">Описание</th>     </tr>     <tr>      <td valign="top"><blockquote>char sysname[]</blockquote></td>      <td valign="top">Имя операционной системы</td>     </tr>     <tr>      <td valign="top"><blockquote>char nodename[]</blockquote></td>      <td valign="top">Имя компьютера</td>     </tr>     <tr>      <td valign="top"><blockquote>char release[]</blockquote></td>      <td valign="top">Номер выпуска (релиза) системы</td>     </tr>     <tr>      <td valign="top"><blockquote>char version[]</blockquote></td>      <td valign="top">Номер версии системы</td>     </tr>     <tr>      <td valign="top"><blockquote>char machine[]</blockquote></td>      <td valign="top">Аппаратный тип</td>     </tr>    </table>    <p>В случае успешного завершения функция <blockquote>uname</blockquote> возвращает неотрицательное целое и в противном случае с установленной переменной <blockquote>errno</blockquote> для обозначения любой возникшей ошибки.</p>    <p>Выполните упражнение 4.12.</p>    <b>Упражнение 4.12. Информации о компьютере</b>    <p>Далее приведена программа hostget.c, извлекающая некоторые сведения о рабочем компьютере.</p>    <p><blockquote>#include &lt;sys/utsname.h&gt;</blockquote></p>    <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>    <br>    <p><blockquote>int main() {</blockquote></p>    <p><blockquote> char computer[256];</blockquote></p>    <p><blockquote> struct utsname uts;</blockquote></p>    <p><blockquote> if (gethostname(computer, 255) != 0 || uname(&amp;uts) &lt; 0) {</blockquote></p>    <p><blockquote>  fprintf(stderr, "Could not get host information\n");</blockquote></p>    <p><blockquote>  exit(1);</blockquote></p>    <p><blockquote> }</blockquote></p>    <p><blockquote> printf("Computer host name is %s\n", computer);</blockquote></p>    <p><blockquote> printf("System is %s on %s hardware\n", uts.sysname, uts.machine);</blockquote></p>    <p><blockquote> printf("Nodename is %s\n", uts.nodename);</blockquote></p>    <p><blockquote> printf("Version is %s, %s\n", uts.release, uts.version);</blockquote></p>    <p><blockquote> exit(0);</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Она отобразит следующие зависящие от ОС Linux данные. Если ваша машина включена в сеть, то вы увидите расширенное имя компьютера, включающее обозначение сети:</p>    <p><blockquote>$ <b>./hostget</b></blockquote></p>    <p><blockquote>Computer host name is suse103</blockquote></p>    <p><blockquote>System is Linux on i686 hardware</blockquote></p>    <p><blockquote>Nodename is suse103</blockquote></p>    <p><blockquote>Version is 2.6.20.2-2-default, #1 SMP Fri Mar 9 21:54:10 UTC 2007</blockquote></p>    <p><b>Как это работает</b></p>    <p>Эта программа вызывает функцию <blockquote>gethostname</blockquote> для получения имени рабочего компьютера. В приведенном примере это имя — <blockquote>suse103</blockquote>. Более подробную информацию об этом компьютере на базе Intel Pentium 4 с ОС Linux возвращает системный вызов <blockquote>uname</blockquote>. Учтите, что формат возвращаемых строк зависит от реализации, например, строка с версией системы содержит дату компиляции ядра.</p>    <blockquote>     <b>Примечание</b>     <p>Другой пример применения функции <blockquote>uname</blockquote> вы можете найти в исходном коде Linux для команды <blockquote>uname</blockquote>, которая использует эту функцию.</p>    </blockquote>    <p>Уникальный идентификатор каждого рабочего компьютера можно получить с помощью функции <blockquote>gethostid</blockquote>.</p>    <p><blockquote><b>#include &lt;unistd.h&gt;</b></blockquote></p>    <p><blockquote><b>long gethostid(void);</b></blockquote></p>    <p>Функция <blockquote>gethostid</blockquote> предназначена для возврата уникального значения, характеризующего рабочий компьютер. Менеджеры, следящие за соблюдением лицензионных соглашений, применяют ее для того, чтобы обеспечить функционирование программного обеспечения только на машинах с действующими лицензиями. На рабочих станциях Sun она возвращает номер, установленный в постоянной памяти во время изготовления компьютера и, таким образом, уникальный для системного оборудования. Другие системы, например Linux, возвращают значение на базе интернет-адреса машины, обычно не слишком безопасного для проверки лицензионных прав.</p>          <a name="metkadoc12"><h1>Ведение системных журналов</h1></a>    <p>Многие приложения нуждаются в регистрации своей деятельности. Системные программы очень часто выводят сообщения на консоль или записывают их в регистрационный системный журнал. В этих сообщениях могут регистрироваться ошибки, предупреждения или более общая информация о состоянии системы. Например, программа su может зафиксировать тот факт, что пользователь пытался получить привилегии супер пользователя и потерпел неудачу.</p>    <p>Очень часто зарегистрированные сообщения записываются в системные файлы в каталоге, предоставляемом для этой цели. Это может быть каталог /usr/admor/var/log. При типичной установке ОС Linux все системные сообщения содержатся в файле /var/log/messages, в файл /var/log/mail включены другие регистрируемые сообщения от почтовой системы, а в файле /var/log/debug могут храниться отладочные сообщения. Проверить конфигурацию своей системы можно в файле /etc/syslog.conf или /etc/syslog-ng/syslog-ng.conf в зависимости от версии Linux.</p>    <p>Далее приведены некоторые примеры зарегистрированных сообщений.</p>    <p><blockquote>Mar 2 6 18:25:51 suse103 ifstatus: eth0 device: Advanced Micro Devices [AMD] 79c970 [PCnet32 LANCE] (rev 10)</blockquote></p>    <p><blockquote>Mar 26 18:25:51 suse103 ifstatus: eth0 configuration: eth-id-00:0c:29:0e:91:72</blockquote></p>    <p><blockquote>...</blockquote></p>    <p><blockquote>May 20 06:56:56 suse103 SuSEfirewall2: Setting up rules from /etc/sysconfig/SuSEfirewall2</blockquote></p>    <p><blockquote>...</blockquote></p>    <p><blockquote>May 20 06:56:57 suse103 SuSEfirewall2: batch committing</blockquote></p>    <p><blockquote>...</blockquote></p>    <p><blockquote>May 20 06:56:57 suse103 SuSEfirewall2: Firewall rules successfully set</blockquote></p>    <p><blockquote>...</blockquote></p>    <p><blockquote>Jun 9 09:11:14 suse103 su: (to root) neil on /dev/pts/18 09:50:35</blockquote></p>    <p>В этом выводе показаны виды регистрируемых сообщений. Несколько первых отправлены непосредственно ядром Linux во время его загрузки и обнаружения установленного оборудования. Брандмауэр сообщает о своей перенастройке. И наконец, программа <blockquote>su</blockquote> извещает о том, что доступ с учетной записью суперпользователя получен пользователем neil.</p>    <blockquote>     <b>Примечание</b>     <p>Для просмотра регистрируемых сообщений вы можете запросить права суперпользователя.</p>    </blockquote>    <p>Некоторые системы UNIX не предоставляют файлов с удобными для чтения сообщениями, но они снабжают администраторов средствами для чтения базы данных системных событий. См. подробности в системной документации.</p>    <p>Несмотря на то, что формат и хранение системных сообщений могут отличаться, метод формирования сообщений стандартный. В спецификации UNIX представлен доступный всем программам интерфейс формирования регистрируемых сообщений с помощью функции <blockquote>syslog</blockquote>.</p>    <p><blockquote><b>#include &lt;syslog.h&gt;</b></blockquote></p>    <p><blockquote><b>void syslog(int priority, const char *message, arguments...);</b></blockquote></p>    <p>Функция syslog посылает регистрируемое сообщение средству ведения системного журнала (logging facility). У каждого сообщения есть аргумент <blockquote>priority</blockquote>, полученный поразрядной операцией <blockquote>OR</blockquote> из степени важности сообщения (severity level) и типа программы, формирующей сообщение (facility value). Степень важности определяет необходимые действия, а тип программы фиксирует инициатора сообщения.</p>    <p>Типы программ (из файла syslog.h) включают константу <blockquote>LOG_USER</blockquote>, применяемую для обозначения сообщения, пришедшего из приложения пользователя (по умолчанию), и константы <blockquote>LOG_LOCAL0</blockquote>, <blockquote>LOG_LOCAL1</blockquote>, ..., <blockquote>LOG_LOCAL7</blockquote>, зарезервированные для локального администратора.</p>    <p>В табл. 4.6 перечислены степени важности сообщений в порядке убывания приоритета.</p>    <br>    <p><b><i>Таблица 4.6</i></b></p>    <table>     <tr>      <th valign="top">Приоритет</th>      <th valign="top">Описание</th>     </tr>     <tr>      <td valign="top"><blockquote>LOG_EMERG</blockquote></td>      <td valign="top">Кризисная ситуация</td>     </tr>     <tr>      <td valign="top"><blockquote>LOG_ALERT</blockquote></td>      <td valign="top">Проблема с высоким приоритетом, например, повреждение базы данных</td>     </tr>     <tr>      <td valign="top"><blockquote>LOG_CRIT</blockquote></td>      <td valign="top">Критическая ошибка, например, повреждение оборудования</td>     </tr>     <tr>      <td valign="top"><blockquote>LOG_ERR</blockquote></td>      <td valign="top">Ошибки</td>     </tr>     <tr>      <td valign="top"><blockquote>LOG_WARNING</blockquote></td>      <td valign="top">Предупреждение</td>     </tr>     <tr>      <td valign="top"><blockquote>LOG_NOTICE</blockquote></td>      <td valign="top">Особые обстоятельства, требующие повышенного внимания</td>     </tr>     <tr>      <td valign="top"><blockquote>LOG_INFO</blockquote></td>      <td valign="top">Информационные сообщения</td>     </tr>     <tr>      <td valign="top"><blockquote>LOG_DEBUG</blockquote></td>      <td valign="top">Отладочные сообщения</td>     </tr>    </table>    <p>В зависимости от настройки системы сообщения типа <blockquote>LOG_EMER</blockquote> могут пересылаться всем пользователям системы, сообщения <blockquote>LOG_ALERT</blockquote> могут отправляться по электронной почте администратору, сообщения <blockquote>LOG_DEBUG</blockquote> могут игнорироваться, а сообщения других типов могут записываться в файл. Вы можете написать программу, которая применяет средство регистрации сообщений, просто вызывая функцию <blockquote>syslog</blockquote>, когда вы хотите создать регистрируемое сообщение.</p>    <p>У сообщения, создаваемого <blockquote>syslog</blockquote>, есть заголовок и тело сообщения. Заголовок создается из индикатора типа программы, формирующей сообщение, и даты и времени. Тело сообщения создается из параметра <blockquote>message</blockquote>, передаваемого функции <blockquote>syslog</blockquote>, который действует как строка <blockquote>format</blockquote> функции <blockquote>printf</blockquote>. Остальные аргументы <blockquote>syslog</blockquote> используются в соответствии со спецификаторами преобразований в стиле функции <blockquote>printf</blockquote>, заданными в строке <blockquote>message</blockquote>. Дополнительно может применяться спецификатор <blockquote>%m</blockquote> для включения строки сообщения об ошибке, ассоциированной с текущим значением переменной <blockquote>errno</blockquote>. Эта возможность может оказаться полезной для регистрации сообщений об ошибках.</p>    <p>Выполните упражнение 4.13.</p>    <b>Упражнение 4.13. Применение функции <blockquote>syslog</blockquote></b>    <p>В этой программе осуществляется попытка открыть несуществующий файл.</p>    <p><blockquote>#include &lt;syslog.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>    <br>    <p><blockquote>int main() {</blockquote></p>    <p><blockquote> FILE *f;</blockquote></p>    <p><blockquote> f = fopen("not_here", "r");</blockquote></p>    <p><blockquote> if (!f) syslog(LOG_ERR|LOG_USER, "oops - %m\n");</blockquote></p>    <p><blockquote> exit(0);</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Когда вы откомпилируете и выполните программу syslog.с, то не увидите никакого вывода, но в конце файла /var/log/messages теперь содержится следующая строка:</p>    <p><blockquote>Jun 9 09:24:50 suse103 syslog: oops — No such file or directory</blockquote></p>    <p><b>Как это работает</b></p>    <p>В данной программе вы пытаетесь открыть файл, которого нет. Когда попытка заканчивается неудачно, вы вызываете функцию <blockquote>syslog</blockquote> для записи случившегося в системный журнал.</p>    <p>Обратите внимание на то, что регистрируемое сообщение не указывает, какая программа вызвала средство регистрации; оно просто констатирует тот факт, что была вызвана функция <blockquote>syslog</blockquote> с сообщением. Спецификатор преобразования <blockquote>%m</blockquote> был заменен описанием ошибки, в данном случае сообщающим об отсутствии файла. Это гораздо полезнее, чем простой отчет, содержащий внутренний номер ошибки.</p>    <p>В файле syslog.h определены и другие функции, применяемые для изменения поведения средств ведения системных журналов.</p>    <p>К ним относятся следующие функции:</p>    <p><blockquote><b>#include &lt;syslog.h&gt; void closelog(void);</b></blockquote></p>    <p><blockquote><b>void openlog(const char *ident, int logopt, int facility);</b></blockquote></p>    <p><blockquote><b>int setlogmask(int maskpri);</b></blockquote></p>    <p>Вы можете изменить способ представления ваших регистрируемых сообщений, вызвав функцию <blockquote>openlog</blockquote>. Это позволит задать строку <blockquote>ident</blockquote>, которая будет добавляться к вашим регистрируемым сообщениям. Вы можете применять ее для индикации программы, создавшей сообщение. Параметр <blockquote>facility</blockquote> записывает текущий принятый по умолчанию тип программы, формирующей сообщение, который будет использоваться в последующих вызовах <blockquote>syslog</blockquote>. По умолчанию устанавливается значение <blockquote>LOG_USER</blockquote>. Параметр <blockquote>logopt</blockquote> настраивает поведение будущих вызовов функции <blockquote>syslog</blockquote>. Он представляет собой результат поразрядной операции <blockquote>OR</blockquote> нулевого или большего числа параметров, приведенных в табл. 4.7.</p>    <br>    <p><b><i>Таблица 4.7</i></b></p>    <table>     <tr>      <th valign="top">Параметр <blockquote>logopt</blockquote></th>      <th valign="top">Описание</th>     </tr>     <tr>      <td valign="top"><blockquote>LOG_PID</blockquote></td>      <td valign="top">Включает в сообщения идентификатор процесса, уникальный номер, выделяемый системой каждому процессу</td>     </tr>     <tr>      <td valign="top"><blockquote>LOG_CONS</blockquote></td>      <td valign="top">Посылает сообщения на консоль, если они не могут быть записаны</td>     </tr>     <tr>      <td valign="top"><blockquote>LOG_ODELAY</blockquote></td>      <td valign="top">Открывает средство регистрации сообщений при первом вызове функции <blockquote>syslog</blockquote></td>     </tr>     <tr>      <td valign="top"><blockquote>LOG_NDELAY</blockquote></td>      <td valign="top">Открывает средство регистрации сообщений немедленно, не дожидаясь первого регистрируемого сообщения</td>     </tr>    </table>    <p>Функция <blockquote>openlog</blockquote> выделит и откроет дескриптор файла, который будет применяться для записи в программе ведения системного журнала. Вы сможете закрыть его, вызвав функцию <blockquote>closelog</blockquote>. Имейте в виду, что вам не нужно вызывать функцию <blockquote>openlog</blockquote> перед вызовом <blockquote>syslog</blockquote>, потому что последняя при необходимости самостоятельно откроет средство ведения системного журнала.</p>    <p>Вы можете управлять приоритетом регистрируемых вами сообщений с помощью установки маски регистрации, используя функцию <blockquote>setlogmask</blockquote>. Все будущие вызовы <blockquote>syslog</blockquote> с разными приоритетами, не заданными в маске регистрации, будут отброшены, таким образом, вы сможете, например, использовать маску для отключения сообщений типа <blockquote>LOG_DEBUG</blockquote> без необходимости изменять тело программы.</p>    <p>Вы можете создать маску для регистрируемых сообщений, используя значение <blockquote>LOG_MASK(priority)</blockquote>, создающее маску только для одного приоритета, или значение <blockquote>LOG_UPTO(priority)</blockquote>, создающее маску для всех приоритетов вплоть до заданного.</p>    <p>Выполните упражнение 4.14.</p>    <b>Упражнение 4.14. Маска регистрации (<blockquote>logmask</blockquote>)</b>    <p>В этом примере вы увидите <blockquote>logmask</blockquote> в действии.</p>    <p><blockquote>#include &lt;syslog.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>    <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>    <br>    <p><blockquote>int main() {</blockquote></p>    <p><blockquote> int logmask;</blockquote></p>    <p><blockquote> openlog("logmask", LOG_PID|LOG_CONS, LOG_USER);</blockquote></p>    <p><blockquote> syslog(LOG_INFO, "informative message, pid = %d", getpid());</blockquote></p>    <p><blockquote> syslog(LOG_DEBUG, "debug message, should appear");</blockquote></p>    <p><blockquote> logmask = setlogmask(LOG_UPTO(LOG_NOTICE));</blockquote></p>    <p><blockquote> syslog(LOG_DEBUG, "debug message, should not appear");</blockquote></p>    <p><blockquote>exit(0);</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Программа logmask.c ничего не выводит, но в типичной системе Linux вы увидите в файле /var/log/messages, ближе к концу, следующую строку:</p>    <p><blockquote>Jun 9 09:28:52 suse103 logmask[19339] : informative message, pid = 19339</blockquote></p>    <p>Файл, настроенный на получение регистрируемых сообщений об отладке (в зависимости от настройки регистрации, это чаще всего файл /var/log/debug или иногда файл /var/log/messages), должен содержать следующую строку:</p>    <p><blockquote>Jun 9 09:28:52 susel03 logmask[19339]: debug message, should appear</blockquote></p>    <p><b>Как это работает</b></p>    <p>Программа инициализирует средство ведения системного журнала, названное logmask, и запрашивает включение идентификатора процесса в регистрируемые сообщения. Информирующее сообщение записывается в файл /var/log/messages, а отладочное сообщение — в файл /var/log/debug. Второе отладочное сообщение не появляется, потому что вы вызвали функцию <blockquote>setlogmask</blockquote> с игнорированием всех сообщений с приоритетом ниже <blockquote>LOG_NOTICE</blockquote>. (Учтите, что этот метод не работает в ранних вариантах ядра Linux.)</p>    <p>Если в установленную у вас систему не включена регистрация отладочных сообщений или она настроена иначе, отладочные сообщения могут не появляться. Для разблокирования всех отладочных сообщений и для получения подробностей настройки см. системную документацию, посвященную функции <blockquote>syslog</blockquote> или <blockquote>syslog-ng</blockquote>.</p>    <p>Программа logmask.c также использует функцию <blockquote>getpid</blockquote>, которая, наряду с тесно связанной с ней функцией <blockquote>getppid</blockquote>, определена следующим образом:</p>    <p><blockquote><b>#include &lt;sys/types.h&gt;</b></blockquote></p>    <p><blockquote><b>#include &lt;unistd.h&gt;</b></blockquote></p>    <p><blockquote><b>pid_t getpid(void);pid_t getppid(void);</b></blockquote></p>    <p>Функции возвращают идентификаторы вызвавшего и родительского процессов. Дополнительную информацию об идентификаторах процессов (PID) <i>см. в главе 11.</i></p>          <a name="metkadoc13"><h1>Ресурсы и ограничения</h1></a>    <p>Программы, выполняющиеся в системе Linux, зависят от ограниченности ресурсов. Это могут быть физические ограничения, накладываемые оборудованием (например, памятью), ограничения, связанные с системной политикой (например, разрешенное время процессора) или ограничения реализации (такие как размер типа <blockquote>integer</blockquote> или максимально допустимое количество символов в имени файла). В спецификацию UNIX включены некоторые из этих ограничений, которые может определять приложение. Дальнейшее обсуждение ограничений и последствия их нарушений<i> см. в главе</i> 7.</p>    <p>В заголовочном файле limits.h определены многие именованные константы, представляющие ограничения, налагаемые операционной системой (табл. 4.8).</p>    <br>    <p><b><i>Таблица 4.8</i></b></p>    <table>     <tr>      <th valign="top">Ограничительная константа</th>      <th valign="top">Назначение</th>     </tr>     <tr>      <td valign="top"><blockquote>NAME_MAX</blockquote></td>      <td valign="top">Максимальное число символов в имени файла</td>     </tr>     <tr>      <td valign="top"><blockquote>CHAR_BIT</blockquote></td>      <td valign="top">Количество разрядов в значении типа <blockquote>char</blockquote></td>     </tr>     <tr>      <td valign="top"><blockquote>CHAR_MAX</blockquote></td>      <td valign="top">Максимальное значение типа <blockquote>char</blockquote></td>     </tr>     <tr>      <td valign="top"><blockquote>INT_MAX</blockquote></td>      <td valign="top">Максимальное значение типа <blockquote>int</blockquote></td>     </tr>    </table>    <p>Существует множество других ограничений, полезных приложению, поэтому следует ознакомиться с заголовочными файлами установленной у вас версии системы.</p>    <blockquote>     <b>Примечание</b>     <p>Имейте в виду, что константа <blockquote>NAME_MAX</blockquote> зависит от файловой системы. Для разработки легко переносимого кода следует применять функцию pathconf. Дополнительную информацию о ней см. на страницах интерактивного справочного руководства.</p>    </blockquote>    <p>В заголовочном файле sys/resource.h представлены определения операций над ресурсами. К ним относятся функции для считывания и установки предельных значений для разрешенного размера программы, приоритета выполнения и файловых ресурсов.</p>    <p><blockquote><b>#include &lt;sys/resource.h&gt;</b></blockquote></p>    <p><blockquote><b>int getpriority(int which, id_t who);</b></blockquote></p>    <p><blockquote><b>int setpriority(int which, id_t who, int priority);</b></blockquote></p>    <p><blockquote><b>int getrlimit(int resource, struct rlimit *r_limit);</b></blockquote></p>    <p><blockquote><b>int setrlimit(int resource, const struct rlimit *r_limit);</b></blockquote></p>    <p><blockquote><b>int getrusage(int who, struct rusage *r_usage);</b></blockquote></p>    <p>Здесь <blockquote>id_t</blockquote> — это целочисленный тип, применяемый для идентификаторов пользователя и группы. Структура <blockquote>rusage</blockquote>, указанная в файле sys/resource.h, используется для определения времени центрального процессора (ЦП), затраченного текущей программой. Она должна содержать, как минимум, два элемента (табл. 4.9).</p>    <br>    <p><b><i>Таблица 4.9</i></b></p>    <table>     <tr>      <th valign="top">Элемент структуры <blockquote>rusage</blockquote></th>      <th valign="top">Описание</th>     </tr>     <tr>      <td valign="top"><blockquote>struct timeval ru_utime</blockquote></td>      <td valign="top">Время, использованное пользователем</td>     </tr>     <tr>      <td valign="top"><blockquote>struct timeval ru_stime</blockquote></td>      <td valign="top">Время, использованное системой</td>     </tr>    </table>    <p>Структура <blockquote>timeval</blockquote> определена в файле sys/time.h и содержит поля <blockquote>tv_sec</blockquote> и <blockquote>tv_usec</blockquote>, представляющие секунды и микросекунды соответственно.</p>    <p>Время ЦП, потребляемое программой, делится на время пользователя (время, затраченное самой программой на выполнение собственных инструкций) и системное время (время ЦП, потребляемое операционной системой в интересах программы, т.е. время, затраченное на системные вызовы, выполняющие ввод и вывод или другие системные функции).</p>    <p>Функция <blockquote>getrusage</blockquote> записывает данные о времени ЦП в структуру <blockquote>rusage</blockquote>, на которую указывает параметр <blockquote>r_usage</blockquote>. Параметр <blockquote>who</blockquote> может быть задан одной из констант, приведенных в табл. 4.10.</p>    <br>    <p><b><i>Таблица 4.10</i></b></p>    <table>     <tr>      <th valign="top">Константа <blockquote>who</blockquote></th>      <th valign="top">Описание</th>     </tr>     <tr>      <td valign="top"><blockquote>RUSAGE_SELF</blockquote></td>      <td valign="top">Возвращает данные о потреблении только для текущей программы</td>     </tr>     <tr>      <td valign="top"><blockquote>RUSAGE_CHILDREN</blockquote></td>      <td valign="top">Возвращает данные о потреблении и для дочерних процессов</td>     </tr>    </table>    <p>Мы будем обсуждать дочерние процессы и приоритеты задач в<i> главе 11,</i> но для полноты картины мы здесь упоминаем об их причастности к потреблению системных ресурсов. Пока достаточно сказать, что у каждой выполняющейся программы есть ассоциированный с ней приоритет, и чем выше приоритет программы, тем больше ей выделяется доступного времени ЦП.</p>    <blockquote>     <b>Примечание</b>     <p>Обычные пользователи могут только снижать приоритеты своих программ, а не повышать их.</p>    </blockquote>    <p>Приложения могут определять и изменять свои (и чужие) приоритеты с помощью функций <blockquote>getpriority</blockquote> и <blockquote>setpriority</blockquote>. Процесс, исследуемый или изменяемый с помощью этих функций, может быть задан идентификатором процесса, группы или пользователя. Параметр <blockquote>which</blockquote> описывает, как следует интерпретировать параметр <blockquote>who</blockquote> (табл. 4.11).</p>    <br>    <p><b><i>Таблица 4.11</i></b></p>    <table>     <tr>      <th valign="top">Параметр <blockquote>which</blockquote></th>      <th valign="top">Описание</th>     </tr>     <tr>      <td valign="top"><blockquote>PRIO_PROCESS</blockquote></td>      <td valign="top"><blockquote>who</blockquote> — идентификатор процесса</td>     </tr>     <tr>      <td valign="top"><blockquote>PRIO_PGRP</blockquote></td>      <td valign="top"><blockquote>who</blockquote> — идентификатор группы</td>     </tr>     <tr>      <td valign="top"><blockquote>PRIO_USER</blockquote></td>      <td valign="top"><blockquote>who</blockquote> — идентификатор пользователя</td>     </tr>    </table>    <p>Итак, для определения приоритета текущего процесса вы можете выполнить следующий вызов:</p>    <p><blockquote>priority = getpriority(PRIO_PROCESS, getpid());</blockquote></p>    <p>Функция <blockquote>setpriority</blockquote> позволяет задать новый приоритет, если это возможно.</p>    <p>По умолчанию приоритет равен 0. Положительные значения приоритета применяются для фоновых задач, которые выполняются, только когда нет задачи с более высоким приоритетом, готовой к выполнению. Отрицательные значения приоритета заставляют программу работать интенсивнее, выделяя большие доли доступного времени ЦП. Диапазон допустимых приоритетов — от -20 до +20. Часто это приводит к путанице, поскольку, чем выше числовое значение, тем ниже приоритет выполнения.</p>    <p>Функция <blockquote>getpriority</blockquote> возвращает установленный приоритет в случае успешного завершения или -1 с переменной <blockquote>errno</blockquote>, указывающей на ошибку. Поскольку значение -1 само по себе обозначает допустимый приоритет, переменную <blockquote>errno</blockquote> перед вызовом функции <blockquote>getpriority</blockquote> следует приравнять нулю и при возврате из функции проверить, осталась ли она нулевой. Функция <blockquote>setpriority</blockquote> возвращает 0 в случае успешного завершения и -1 в противном случае.</p>    <p>Предельные величины, заданные для системных ресурсов, можно прочитать и установить с помощью функций <blockquote>getrlimit</blockquote> и <blockquote>setrlimit</blockquote>. Обе они для описания ограничений ресурсов используют структуру общего назначения <blockquote>rlimit</blockquote>. Она определена в файле sys/resource.h и содержит элементы, перечисленные в табл. 4.12.</p>    <br>    <p><b><i>Таблица 4.12</i></b></p>    <table>     <tr>      <th valign="top">Элемент <blockquote>rlimit</blockquote></th>      <th valign="top">Описание</th>     </tr>     <tr>      <td valign="top"><blockquote>rlim_t rlim_cur</blockquote></td>      <td valign="top">Текущее, мягкое ограничение</td>     </tr>     <tr>      <td valign="top"><blockquote>rlim_t rlim_max</blockquote></td>      <td valign="top">Жесткое ограничение</td>     </tr>    </table>    <p>Определенный выше тип <blockquote>rlim_t</blockquote> — целочисленный тип, применяемый для описания уровней ресурсов. Обычно мягкое ограничение — это рекомендуемое ограничение, которое не следует превышать; нарушение этой рекомендации может вызвать возврат ошибок из библиотечных функций. При превышении жесткого ограничения система может попытаться завершить программу, отправив ей сигнал, например, сигнал <blockquote>SIGXCPU</blockquote> при превышении ограничения на потребляемое время ЦП и сигнал <blockquote>SIGSEGV</blockquote> при превышении ограничения на объем данных. В программе можно самостоятельно задать для любых значений собственные мягкие ограничения, не превышающие жесткого ограничения. Допустимо уменьшение жесткого ограничения. Увеличить его может только программа, выполняющаяся с правами суперпользователя.</p>    <p>Ограничить можно ряд системных ресурсов. Эти ограничения описаны в параметре <blockquote>resource</blockquote> функций <blockquote>rlimit</blockquote> и определены в файле sys/resource.h, как показано в табл. 4.13.</p>    <br>    <p><b><i>Таблица 4.13</i></b></p>    <table>     <tr>      <th valign="top">Параметр <blockquote>resource</blockquote></th>      <th valign="top">Описание</th>     </tr>     <tr>      <td valign="top"><blockquote>RLIMIT_CORE</blockquote></td>      <td valign="top">Ограничение размера файла дампа ядра, в байтах</td>     </tr>     <tr>      <td valign="top"><blockquote>RLIMIT_CPU</blockquote></td>      <td valign="top">Ограничение времени ЦП, в секундах</td>     </tr>     <tr>      <td valign="top"><blockquote>RLIMIT_DATA</blockquote></td>      <td valign="top">Ограничение размера сегмента <blockquote>data()</blockquote>, в байтах</td>     </tr>     <tr>      <td valign="top"><blockquote>RLIMIT_FSIZE</blockquote></td>      <td valign="top">Ограничение размера файла, в байтах</td>     </tr>     <tr>      <td valign="top"><blockquote>RLIMIT_NOFILE</blockquote></td>      <td valign="top">Ограничение количества открытых файлов</td>     </tr>     <tr>      <td valign="top"><blockquote>RLIMIT_STACK</blockquote></td>      <td valign="top">Ограничение размера стека, в байтах</td>     </tr>     <tr>      <td valign="top"><blockquote>RLIMIT_AS</blockquote></td>      <td valign="top">Ограничение доступного адресного пространства (стек и данные), в байтах</td>     </tr>    </table>    <p>В упражнении 4.15 показана программа limits.c, имитирующая типичное приложение. Она также задает и нарушает ограничения ресурсов.</p>    <b>Упражнение 4.16. Ограничения ресурсов</b>    <p>1. Включите заголовочные файлы для всех функций, которые вы собираетесь применять в данной программе:</p>    <p><blockquote>#include &lt;sys/types.h&gt; \</blockquote></p>    <p><blockquote>#include &lt;sys/resource.h&gt;</blockquote></p>    <p><blockquote>#include &lt;sys/time.h&gt;</blockquote></p>    <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>    <p><blockquote>#include &lt;math.h&gt;</blockquote></p>    <p>2. Функция типа <blockquote>void</blockquote> записывает 10 000 раз строку во временный файл и затем выполняет некоторые арифметические вычисления для загрузки ЦП:</p>    <p><blockquote>void work() {</blockquote></p>    <p><blockquote> FILE *f;</blockquote></p>    <p><blockquote> int i;</blockquote></p>    <p><blockquote> double x = 4.5;</blockquote></p>    <p><blockquote> f = tmpfile();</blockquote></p>    <p><blockquote> for (i = 0; i &lt; 10000; i++) {</blockquote></p>    <p><blockquote>  fprintf(f, "Do some output\n");</blockquote></p>    <p><blockquote>  if (ferror(f)) {</blockquote></p>    <p><blockquote>   fprintf(stderr, "Error writing to temporary file\n");</blockquote></p>    <p><blockquote>   exit(1);</blockquote></p>    <p><blockquote>  }</blockquote></p>    <p><blockquote> }</blockquote></p>    <p><blockquote> for (i = 0; i &lt; 1000000; i++) x = log(x*x + 3.21);</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>3. Функция <blockquote>main</blockquote> вызывает функцию <blockquote>work</blockquote>, а затем применяет функцию getrusage для определения времени ЦП, использованного <blockquote>work</blockquote>. Эта информация выводится на экран:</p>    <p><blockquote>int main() {</blockquote></p>    <p><blockquote> struct rusage r_usage;</blockquote></p>    <p><blockquote> struct rlimit r_limit;</blockquote></p>    <p><blockquote> int priority;</blockquote></p>    <p><blockquote> work();</blockquote></p>    <p><blockquote> getrusage(RUSAGE_SELF, &amp;r_usage);</blockquote></p>    <p><blockquote> printf("CPU usage: User = %ld.%06ld, System = %ld.%06ld\n",</blockquote></p>    <p><blockquote>  r_usage.ru_utime.tvsec, rusage.ru_utime.tv_usec,</blockquote></p>    <p><blockquote>  r_usage.ru_stime.tv_sec, r_usage.ru_stime.tv_usec);</blockquote></p>    <p>4. Далее она вызывает функции <blockquote>getpriority</blockquote> и <blockquote>getrlimit</blockquote> для выяснения текущего приоритета и ограничений на размер файла соответственно:</p>    <p><blockquote> priority = getpriority(PRIO_PROCESS, getpid());</blockquote></p>    <p><blockquote> printf("Current priority = %d\n", priority);</blockquote></p>    <p><blockquote> getrlimit(RLIMIT_FSIZE, &amp;r_limit);</blockquote></p>    <p><blockquote> printf("Current FSIZE limit: soft = %ld, hard = %ld\n",</blockquote></p>    <p><blockquote>  r_limi t.rlim_cur, r_limit.rlim_max);</blockquote></p>    <p>5. В заключение задайте ограничение размера файла с помощью функции <blockquote>setrlimit</blockquote> и снова вызовите функцию <blockquote>work</blockquote>, которая завершится с ошибкой, т.к. попытается создать слишком большой файл:</p>    <p><blockquote> r_limit.rlim_cur = 2048;</blockquote></p>    <p><blockquote> r_limit.rlim_max = 4096;</blockquote></p>    <p><blockquote> printf("Setting a 2K file size limit\n");</blockquote></p>    <p><blockquote> setrlimit(RLIMIT_FS1ZE, &amp;r_limit);</blockquote></p>    <p><blockquote> work();</blockquote></p>    <p><blockquote> exit(0);</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Выполнив эту программу, вы сможете увидеть, сколько затрачено времени ЦП, и текущий приоритет, с которым программа выполняется. После того как будет задан предельный размер файла, программа не сможет записать во временный файл более 2048 байтов.</p>    <p><blockquote>$ <b>cc -о limits limits.с -lm</b></blockquote></p>    <p><blockquote>$ <b>./limits</b></blockquote></p>    <p><blockquote>CPU usage: User = 0.140008, System = 0.020001</blockquote></p>    <p><blockquote>Current priority = 0</blockquote></p>    <p><blockquote>Current FSIZE limit: soft = -1, hard = -1</blockquote></p>    <p><blockquote>Setting a 2K file size limit</blockquote></p>    <p><blockquote>File size limit exceeded</blockquote></p>    <p>Вы можете изменить приоритет программы, запустив ее с помощью команды <blockquote>nice</blockquote>. Далее показано, как меняется приоритет на значение +10, и в результате программа выполняется немного дольше.</p>    <p><blockquote>$ <b>nice ./limits</b></blockquote></p>    <p><blockquote>CPU usage: User = 0.152009, System = 0.020001</blockquote></p>    <p><blockquote>Current priority = 10</blockquote></p>    <p><blockquote>Current FSIZE limit: soft = -1, hard = -1 </blockquote></p>    <p><blockquote>Setting a 2K file size limit</blockquote></p>    <p><blockquote>File size limit exceeded</blockquote></p>    <p><b>Как это работает</b></p>    <p>Программа limits вызывает функцию <blockquote>work</blockquote> для имитации операций типичной программы. Она выполняет некоторые вычисления и формирует вывод, в данном случае около 150 Кбайт записывается во временный файл. Программа вызывает функции управления ресурсами для выяснения своего приоритета и ограничений на размер файла. В данном случае ограничения размеров файлов не заданы, поэтому можно создавать файл любого размера (если позволяет дисковое пространство). Затем программа задает свое ограничение размера файла, равное примерно 2 Кбайт, и снова пытается выполнить некоторые действия. На этот раз функция <blockquote>work</blockquote> завершается неудачно, поскольку не может создать такой большой временный файл.</p>    <blockquote>     <b>Примечание</b>     <p>Ограничения можно также наложить на программу, выполняющуюся в отдельной командной оболочке с помощью команды <blockquote>ulimit</blockquote> оболочки bash.</p>    </blockquote>    <p>В приведенном примере сообщение об ошибке "Error writing to temporary file" ("Ошибка записи во временный файл") не выводится. Это происходит потому, что некоторые системы (например, Linux 2.2 и более поздние версии) завершают выполнение программы при превышении ограничения ресурса. Делается это с помощью отправки сигнала <blockquote>SIGXFSZ</blockquote>. В<i> главе 11</i> вы узнаете больше о сигналах и способах их применения. Другие системы, соответствующие стандарту POSIX, заставляют функцию, превысившую ограничение, вернуть ошибку.</p>          <a name="metkadoc14"><h1>Резюме </h1></a>    <p>В этой главе вы посмотрели на окружение системы Linux и познакомились с условиями выполнения программ. Вы узнали об аргументах командной строки и переменных окружения — и те, и другие могут применяться для изменения стандартного поведения программы и предоставляют подходящие программные опции.</p>    <p>Вы увидели, как программа может воспользоваться библиотечными функциями для обработки значений даты и времени и получить сведения о себе, пользователе и компьютере, на котором она выполняется.</p>    <p>Программы в ОС Linux, как правило, должны совместно использовать дорогостоящие ресурсы, поэтому в данной главе рассматриваются способы определения имеющихся ресурсов и управления ими. </p>     <br><br>
<center><div align="center"><a href="index.php.html">Оглавление</a></div></center>




<br>
<script type="text/javascript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="https://www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script><br>

<noindex>
<div align="center">
<center>

<!-- SAPE RTB DIV 600x340 -->
<div id="SRTB_507029"></div>
<!-- SAPE RTB END -->

</center>
</div>
</noindex>

</td>
<td width="240" valign="top">

<br>

<div id="menu3">
<ul>
<li><a href="../../alternativnaja_medicina/index.html"><span>Альтернативная медицина</span></a></li>
<li><a href="../../astronomija_i_kosmos/index.html"><span>Астрономия и Космос</span></a></li>
<li><a href="../../biologija/index.html"><span>Биология</span></a></li>
<li><a href="../../voennaja_istorija/index.html"><span>Военная история</span></a></li>
<li><a href="../../geologija_i_geografija/index.html"><span>Геология и география</span></a></li>
<li><a href="../../gosudarstvo_i_pravo/index.html"><span>Государство и право</span></a></li>
<li><a href="../../delovaja_literatura/index.html"><span>Деловая литература</span></a></li>
<li><a href="../../domashnie_zhivotnye/index.html"><span>Домашние животные</span></a></li>
<li><a href="../../domovodstvo/index.html"><span>Домоводство</span></a></li>
<li><a href="../../zdorove/index.html"><span>Здоровье</span></a></li>
<li><a href="../../istorija/index.html"><span>История</span></a></li>
<li><a href="../index.html"><span>Компьютеры и Интернет</span></a></li>
<li><a href="../../kulinarija/index.html"><span>Кулинария</span></a></li>
<li><a href="../../kulturologija/index.html"><span>Культурология</span></a></li>
<li><a href="../../literaturovedenie/index.html"><span>Литературоведение</span></a></li>
<li><a href="../../matematika/index.html"><span>Математика</span></a></li>
<li><a href="../../medicina/index.html"><span>Медицина</span></a></li>
<li><a href="../../nauchnaja_literatura_prochee/index.html"><span>Науч. литер. - прочее</span></a></li>
<li><a href="../../pedagogika/index.html"><span>Педагогика</span></a></li>
<li><a href="../../politika/index.html"><span>Политика</span></a></li>
<li><a href="../../psihologija/index.html"><span>Психология</span></a></li>
<li><a href="../../religiovedenie/index.html"><span>Религиоведение</span></a></li>
<li><a href="../../sad_i_ogorod/index.html"><span>Сад и огород</span></a></li>
<li><a href="../../samosovershenstvovanie/index.html"><span>Самосовершенствование</span></a></li>
<li><a href="../../sdelai_sam/index.html"><span>Сделай сам</span></a></li>
<li><a href="../../sport/index.html"><span>Спорт</span></a></li>
<li><a href="../../tehnicheskie_nauki/index.html"><span>Технические науки</span></a></li>
<li><a href="../../transport_i_aviacija/index.html"><span>Транспорт и авиация</span></a></li>
<li><a href="../../uchebniki/index.html"><span>Учебники</span></a></li>
<li><a href="../../fizika/index.html"><span>Физика</span></a></li>
<li><a href="../../filosofija/index.html"><span>Философия</span></a></li>
<li><a href="../../himija/index.html"><span>Химия</span></a></li>
<li><a href="../../hobbi_i_remesla/index.html"><span>Хобби и ремесла</span></a></li>
<li><a href="../../shpargalki/index.html"><span>Шпаргалки</span></a></li>
<li><a href="../../yezoterika/index.html"><span>Эзотерика</span></a></li>
<li><a href="../../yurisprudencija/index.html"><span>Юриспруденция</span></a></li>
<li><a href="../../jazykoznanie/index.html"><span>Языкознание</span></a></li>
</ul>
</div>

<br>
<div align="center">
<center>
<noindex>

<!-- SAPE RTB DIV 240x400 -->
<div id="SRTB_507028"></div>
<!-- SAPE RTB END -->

</noindex>
</center>
</div>

</td>
</tr>
<tr>
<td colspan="3" align="center">


<hr>
<a href="../../index.html"><span>Главная</span></a> | 
<a rel="sidebar" href="p8.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a> | 
<a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a> | 
<a href="p8.php.html#" onClick="scroll(0,0); return false" title="наверх">Наверх</a>
</td>
</tr>
<tr>
<td colspan="3" valign="top" align="left">
<br>

 



</td>
</tr>
</table>

<noindex>
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter21717787 = new Ya.Metrika({id:21717787,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="http://mc.yandex.ru/watch/21717787" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

</noindex>
</center>
</div></body>
</html>