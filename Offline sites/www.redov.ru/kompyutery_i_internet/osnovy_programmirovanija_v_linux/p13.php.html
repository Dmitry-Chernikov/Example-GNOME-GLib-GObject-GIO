<html>
<head>
<meta http-equiv="Content-Language" content="ru">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<link href="../../0img/style.css" rel="stylesheet" type="text/css" />
<link rel="SHORTCUT ICON" href="http://www.redov.ru/0img/favicon.ico" type="image/x-icon"> 
<title>Глава 9 Средства разработки / Основы программирования в Linux</title>
</head>
<body>
<div align="center">
<center>
<table border="0" cellpadding="0" cellspacing="0" width="1260">
<tr>
<td colspan="3" valign="top" align="left" height="100">
<table border="0" cellpadding="0" cellspacing="0" width="1260" height="100">
<tr>
<td valign="middle" align="center" width="350">
<a href="../../index.html"><img src="../../0img/logo.jpg" width="350" height="100" title="Онлайн библиотека redov.ru"/></a>
</td>
<td valign="middle" align="center" width="910">

<noindex>

<!-- SAPE RTB JS -->
<script
    async="async"
    src="http://cdn-rtb.sape.ru/rtb-b/js/393/2/106393.js"
    type="text/javascript">
</script>
<!-- SAPE RTB END -->

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507025"></div>
<!-- SAPE RTB END -->

</noindex>

</td>
</tr>
</table>
</td>
</tr>
<tr>
<td colspan="3" valign="middle" align="left">

<div id="menu">
<ul>
		<li><a href="../../index.html"><span>Главная</span></a></li>
		<li><a rel="sidebar" href="p13.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a></li>
		<li><a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a></li>
		<li><a href="p13.php.html#" onClick="scroll(0,9999999); return false"><span>Вниз</span></a></li>
</ul>
</div>


</td>
</tr>
<tr>
<td width="240" valign="top" align="center">

<br>
<noindex>
<!-- SAPE RTB DIV 160x600 -->
<div id="SRTB_733378"></div>
<!-- SAPE RTB END -->
</noindex>



</td>
<td valign="top" align="left" style="padding-left: 5; padding-right: 5" width="780">
<br>
<noindex>
<div align="center">

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507027"></div>
<!-- SAPE RTB END -->

</div>
</noindex>
<br>



<li><a href="p13.php.html#metkadoc2">     Проблемы применения многочисленных исходных файлов     </a></li>
<li><a href="p13.php.html#metkadoc3">     Команда<i> make</i> и make-файлы     </a></li>
<li><a href="p13.php.html#metkadoc4">      Синтаксис make-файлов      </a></li>
<li><a href="p13.php.html#metkadoc5">      Опции и параметры <i>make</i>      </a></li>
<li><a href="p13.php.html#metkadoc6">      Комментарии в make-файле      </a></li>
<li><a href="p13.php.html#metkadoc7">      Макросы в make-файле      </a></li>
<li><a href="p13.php.html#metkadoc8">      Множественные задания      </a></li>
<li><a href="p13.php.html#metkadoc9">      Встроенные правила      </a></li>
<li><a href="p13.php.html#metkadoc10">      Суффиксы и шаблоны правил      </a></li>
<li><a href="p13.php.html#metkadoc11">      Управление библиотеками с помощью<i> make</i>      </a></li>
<li><a href="p13.php.html#metkadoc12">      Более сложная тема: make-файлы и подкаталоги      </a></li>
<li><a href="p13.php.html#metkadoc13">      Версия GNU команд<i> make</i> и<i> gcc</i>      </a></li>
<li><a href="p13.php.html#metkadoc14">     Управление исходным кодом     </a></li>
<li><a href="p13.php.html#metkadoc15">      RCS      </a></li>
<li><a href="p13.php.html#metkadoc16">      SCCS      </a></li>
<li><a href="p13.php.html#metkadoc17">      Сравнение RCS и SCCS      </a></li>
<li><a href="p13.php.html#metkadoc18">      CVS      </a></li>
<li><a href="p13.php.html#metkadoc19">      Subversion      </a></li>
<li><a href="p13.php.html#metkadoc20">     Написание интерактивного справочного руководства     </a></li>
<li><a href="p13.php.html#metkadoc21">     Распространение программного обеспечения     </a></li>
<li><a href="p13.php.html#metkadoc22">      Программа <i>patch</i>      </a></li>
<li><a href="p13.php.html#metkadoc23">      Другие утилиты распространения      </a></li>
<li><a href="p13.php.html#metkadoc24">     RPM-пакеты     </a></li>
<li><a href="p13.php.html#metkadoc25">      Работа с файлами RPM-пакетов      </a></li>
<li><a href="p13.php.html#metkadoc26">      Установка RPM-пакетов      </a></li>
<li><a href="p13.php.html#metkadoc27">      Формирование RPM-пакетов      </a></li>
<li><a href="p13.php.html#metkadoc28">     Пакеты других форматов     </a></li>
<li><a href="p13.php.html#metkadoc29">     Среды разработки     </a></li>
<li><a href="p13.php.html#metkadoc30">      KDevelop      </a></li>
<li><a href="p13.php.html#metkadoc31">      Другие среды разработки      </a></li>
<li><a href="p13.php.html#metkadoc32">     Резюме     </a></li>
<a name="metkadoc1"><h1>Глава 9</p>    <p>Средства разработки</h1></a>       <p>В этой главе рассматриваются средства разработки программ, применяемые в ОС Linux, некоторые из них доступны и в ОС UNIX. В дополнение к обязательным составляющим, таким как компиляторы и отладчики, Linux предлагает ряд средств, каждое из которых предназначено для одного вида работы и позволяет разработчику комбинировать эти средства новыми оригинальными способами. Такой подход — часть идеологии UNIX, которую унаследовала ОС Linux. В данной главе рассматривается несколько наиболее важных средств разработки и показан ряд примеров их использования для решения проблем. К этим средствам относятся следующие:</p>    <p>&#9633; команда <blockquote>make</blockquote> и make-файлы;</p>    <p>&#9633; управление исходным программным кодом с помощью RCS и CVS;</p>    <p>&#9633; написание интерактивного руководства;</p>    <p>&#9633; распространение программного обеспечения с помощью <blockquote>patch</blockquote> и <blockquote>tar</blockquote>;</p>    <p>&#9633; среды разработки.</p>          <a name="metkadoc2"><h1>Проблемы применения многочисленных исходных файлов</h1></a>    <p>При написании маленьких программ многие программисты после корректировки просто перестраивают свое приложение, компилируя заново все файлы. Но в случае больших программ такой простой подход порождает проблемы. Время цикла "редактирование — компиляция — тестирование" быстро растет. Даже самому терпеливому программисту хотелось бы избежать перекомпиляции всех файлов при изменении лишь одного из них. </p>    <p>Гораздо более серьезная проблема может возникнуть при создании многочисленных заголовочных файлов и включении их в разные исходные файлы. Предположим, что у вас есть заголовочные файлы a.h, b.h и c.h и исходные файлы на языке С main.c, 2.с и 3.c (мы надеемся, что в реальных проектах вы выберете более удачные имена, чем приведенные здесь). Вы можете столкнуться со следующей ситуацией.</p>    <p><blockquote>/* main.c */</blockquote></p>    <p><blockquote>#include "a.h"</blockquote></p>    <p><blockquote>...</blockquote></p>    <p><blockquote>/* 2.с */</blockquote></p>    <p><blockquote>#include "a.h"</blockquote></p>    <p><blockquote>#include "b.h"</blockquote></p>    <p><blockquote>...</blockquote></p>    <p><blockquote>/* 3.c */</blockquote></p>    <p><blockquote>#include "b.h"</blockquote></p>    <p><blockquote>#include "c.h"</blockquote></p>    <p><blockquote>...</blockquote></p>    <p>Если программист изменяет файл c.h, файлы main.c и 2.с не нужно перекомпилировать, поскольку они не зависят от этого заголовочного файла. Файл 3.с зависит от c.h и, следовательно, должен быть откомпилирован заново, если изменился c.h. Но если был изменен файл b.h, и программист забыл откомпилировать заново файл 2.с, результирующая программа может перестать работать корректно.</p>    <p>Утилита <blockquote>make</blockquote> может решить обе эти проблемы, обеспечивая в случае необходимости перекомпиляцию всех файлов, затронутых изменениями.</p>    <blockquote>     <b>Примечание</b>     <p>Команда <blockquote>make</blockquote> применяется не только для компиляции программ. Ее можно использовать, когда формируются выходные файлы из нескольких входных файлов. Ещё одно ее применение включает обработку документов (такую же, как с помощью программ troff или ТеХ).</p>    </blockquote>          <a name="metkadoc3"><h1>Команда<i> make</i> и make-файлы</h1></a>         <p>Несмотря на то, что у команды <blockquote>make</blockquote> много внутренних сведений и знаний, она не может самостоятельно решить, как скомпоновать ваше приложение. Вы должны предоставить файл, который сообщит ей, как устроено приложение. Этот файл называется<i> make-файлом </i>или файлом сборки.</p>     <p>Make-файл чаще всего расположен в том же каталоге, что и другие исходные файлы проекта. В любой момент времени на вашем компьютере может быть множество make-файлов. Действительно, если у вас большой проект, вы можете управлять им, используя отдельные make-файлы для разных частей проекта.</p>     <p>Сочетание команды <blockquote>make</blockquote> и make-файла — мощное средство управления проектами. Оно часто применяется не только для управления компиляцией исходного программного кода, но и для подготовки интерактивного справочного руководства или установки приложения в нужный каталог.</p>             <a name="metkadoc4"><h1>Синтаксис make-файлов</h1></a>     <p>Make-файл состоит из набора зависимостей и правил. У<i> зависимости</i> есть цель или задание (выходной файл, который нужно создать) и набор исходных файлов, от которых она зависит. Правила или инструкции описывают, как создать выходной файл из зависимых файлов. Обычно цель — это единый исполняемый файл.</p>     <p>Make-файл читается командой <blockquote>make</blockquote>, определяющей выходной файл или файлы, которые должны быть сформированы, и затем сравнивающей даты и время исходных файлов, чтобы решить, какие инструкции нужно вызвать для формирования выходного файла. Часто следует выполнить другие промежуточные задания, прежде чем может быть сформирована заключительная цель. Команда <blockquote>make</blockquote> использует make-файл для определения порядка, в котором должны выполняться задания, и корректной последовательности запуска правил.</p>             <a name="metkadoc5"><h1>Опции и параметры <i>make</i></h1></a>     <p>У программы <blockquote>make</blockquote> есть несколько опций. Наиболее часто применяются следующие:</p>     <p>&#9633; <blockquote>-k</blockquote>, сообщающая <blockquote>make</blockquote> о необходимости продолжать выполнение, если обнаружена ошибка, а не останавливаться при появлении первой проблемы. Эту опцию можно использовать, например, для выявления за один проход всех исходных файлов, которые не могут быть откомпилированы;</p>     <p>&#9633; <blockquote>-n</blockquote>, сообщающая <blockquote>make</blockquote> о необходимости вывода перечня требуемых действий без реального их выполнения;</p>     <p>&#9633; <blockquote>-f &lt;<i>файл</i>&gt;</blockquote>, позволяющая сообщить <blockquote>make</blockquote> о том, какой файл применять как make-файл. Если вы не используете эту опцию, стандартная версия программы <blockquote>make</blockquote> ищет в текущем каталоге первый файл, названный makefile. Если его нет, программа ищет файл, названный Makefile. Но если вы применяете GNU Make, что вероятно в ОС Linux, эта версия программы make сначала ищет файл GNUmakefile до поиска файла makefile и последующего поиска Makefile. В соответствии с соглашением программисты Linux применяют имя Makefile, которое позволяет поместить файл сборки первым в списке файлов каталога, заполненного именами файлов, состоящими из строчных букв. Мы полагаем, что вы не будете использовать имя GNUmakefile, поскольку оно специфично для. реализации GNU программы <blockquote>make</blockquote>.</p>     <p>Для того чтобы заставить команду <blockquote>make</blockquote> выполнить конкретное задание, как правило, собрать исполняемый файл, вы можете передать <blockquote>make</blockquote> имя задания или цели как параметр. Если этого не сделать, программа <blockquote>make</blockquote> попытается выполнить первое задание, указанное в make-файле. Многие программисты указывают в своих make-файлах в качестве первой цели или задания <blockquote>all</blockquote> и затем перечисляют остальные задания, как зависимости для <blockquote>all</blockquote>. Это соглашение делает понятным выбор задания по умолчанию, если не задана конкретная цель. Мы полагаем, что вы будете придерживаться этого соглашения.</p>     <b>Зависимости</b>     <p>Зависимости определяют, как каждый файл в окончательном приложении связан исходными файлами. В программном примере, приведенном ранее в этой главе, вы могли бы установить зависимости, говорящие о том, что вашему окончательному приложению требуются (оно зависит от) main.о, 2.о и 3.o; и также для main.о (main.c и a.h); 2.o (2.с, a.h и b.h) и 3.o (3.c, b.h и c.h). Таким образом, на файл main.о влияют изменения файлов main.c и a.h, и он нуждается в пересоздании с помощью повторной компиляции файла main.c, если был изменен любой из двух указанных файлов.</p>     <p>В make-файл вы записываете эти правила, указывая имя задания, двоеточие, пробелы или табуляции и затем разделенный пробелами или табуляциями перечень файлов, применяемых для создания выходного файла задания. Далее приведен список зависимостей для ранее приведенного примера:</p>     <p><blockquote>myapp: main:о 2.о 3.o</blockquote></p>     <p><blockquote>main.о: main.c a.h</blockquote></p>     <p><blockquote>2.о: 2.с a.h b.h</blockquote></p>     <p><blockquote>3.o: 3.c b.h c.h</blockquote></p>     <p>Список свидетельствует о том, что myapp зависит от main.о, 2.o и 3.o, a main.o зависит от main.c и a.h и т. д.</p>     <p>Данный набор зависимостей формирует иерархию, показывающую, как исходные файлы связаны друг с другом. Вы легко можете увидеть, что если изменяется b.h, то придется пересмотреть 2.o и 3.o, а поскольку 2.o и 3.o будут изменены, вам придется перестроить и myapp.</p>     <p>Если вы хотите собрать несколько файлов, можно использовать фиктивную цель или задание <blockquote>all</blockquote>. Предположим, что ваше приложение состоит из двоичного файла myapp и интерактивного руководства myapp.1. Описать их можно следующей строкой:</p>     <p><blockquote>all: myapp myapp.1</blockquote></p>     <p>И еще раз, если вы не включите задание <blockquote>all</blockquote>, программа <blockquote>make</blockquote> просто создаст выходной файл, первым найденный в make-файле.</p>     <b>Правила</b>     <p>Второй, компонент make-файла — правила или инструкции, описывающие способ создания выходного файла задания. В примере из предыдущего раздела какую команду следует применить после того, как команда <blockquote>make</blockquote> определила, что файл 2.o нуждается в перестройке? Возможно, достаточно простого применения команды <blockquote>gcc -с 2.с</blockquote> (и как вы увидите в дальнейшем, <blockquote>make</blockquote> на самом деле знает много стандартных правил), но что если вы хотите указать каталог include или задать опцию вывода символьной информации для последующей отладки? Сделать это можно, явно определив правила в make-файле.</p>     <blockquote>      <b>Примечание</b>      <p>В данный момент мы должны информировать вас об очень странной и неудачной синтаксической записи, применяемой в make-файлах: разнице между пробелом и табуляцией. Все правила должны представлять собой строки, начинающиеся со знака<i> табуляции;</i> пробел не годится. Так как несколько пробелов и табуляция выглядят почти одинаково и поскольку почти во всех других случаях, касающихся программирования в системе Linux, нет большой разницы между пробелами и табуляциями, это может вызвать проблемы. Кроме того, пробел в конце строки в make-файле может вызвать сбой при выполнении команды <blockquote>make</blockquote>. Тем не менее, это исторический факт и в наше время слишком много make-файлов находится в обращении, чтобы можно было рассчитывать на изменение положения вещей, поэтому будьте внимательны! К счастью, если команда <blockquote>make</blockquote> не работает из-за пропущенной табуляции, это обычно довольно понятно.</p>     </blockquote>     <p>А теперь выполните упражнение 9.1.</p>     <b>Упражнение 9.1. Простой make-файл</b>     <p>Большинство правил или инструкций состоит из простой команды, которая могла бы быть набрана в командной строке. Для примера создайте свой первый make-файл Makefile1:</p>     <p><blockquote>myapp: main.о 2.o 3.o</blockquote></p>     <p><blockquote> gcc -о myapp main.о 2.o 3.o</blockquote></p>     <br>     <p><blockquote>main.о: main.c a.h</blockquote></p>     <p><blockquote> gcc -с main.c</blockquote></p>     <br>     <p><blockquote>2.о: 2.с a.h b.h</blockquote></p>     <p><blockquote> gcc -с 2.с</blockquote></p>     <br>     <p><blockquote>3.o: 3.c b.h c.h</blockquote></p>     <p><blockquote> gcc -с 3.c</blockquote></p>     <p>Запустите команду <blockquote>make</blockquote> с опцией <blockquote>-f</blockquote>, потому что ваш make-файл не назван одним из стандартных имен makefile или Makefile. Если запустить приведенный код в каталоге, не содержащем исходных файлов, будет получено следующее сообщение:</p>     <p><blockquote>$ <b>make -f Makefile1</b></blockquote></p>     <p><blockquote>make: *** No rule to make target 'main.c', needed by 'main.o'. Stop.</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Команда <blockquote>make</blockquote> предположила, что первое задание в make-файле, <blockquote>myapp</blockquote>, — это файл, который вы хотите создать. Затем она просмотрела остальные зависимости и прежде всего определила, что нужен файл, названный main.c. Поскольку вы все еще не создали этот файл и в make-файле не сказано, как он может быть создан, команда <blockquote>make</blockquote> вывела сообщение об ошибке. Итак, создайте исходные файлы и попробуйте снова. Поскольку результат нас не интересует, эти файлы могут быть очень простыми. Заголовочные файлы на самом деле пустые, поэтому вы можете создать их командой <blockquote>touch</blockquote>:</p>     <p><blockquote>$ <b>touch a.h</b></blockquote></p>     <p><blockquote>$ <b>touch b.h</b></blockquote></p>     <p><blockquote>$ <b>touch c.h</b></blockquote></p>     <p>Файл main.c содержит функцию <blockquote>main</blockquote>, вызывающую функции <blockquote>function_two</blockquote> и <blockquote>function_three</blockquote>. В других двух файлах определены функции <blockquote>function_two</blockquote> и <blockquote>function_three</blockquote>. В исходных файлах есть строки <blockquote>#include</blockquote> для соответствующих заголовочных файлов, поэтому они оказываются зависимыми от содержимого включенных файлов заголовков. Это приложение не назовешь выдающимся, но, тем не менее, далее приведены листинги программ:</p>     <p><blockquote>/* main.c */</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include "a.h"</blockquote></p>     <p><blockquote>extern void function_two();</blockquote></p>     <p><blockquote>extern void function_three();</blockquote></p>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> function_two();</blockquote></p>     <p><blockquote> function_three();</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote>/* 2.c */</blockquote></p>     <p><blockquote>#include "a.h"</blockquote></p>     <p><blockquote>#include "b.h"</blockquote></p>     <p><blockquote>void function_two() { }</blockquote></p>     <br>     <p><blockquote>/* 3.с */</blockquote></p>     <p><blockquote>#include "b.h"</blockquote></p>     <p><blockquote>#include "c.h"</blockquote></p>     <p><blockquote>void function_three() { }</blockquote></p>     <p>Теперь попробуйте выполнить команду<b> make</b> еще раз:</p>     <p><blockquote>$ <b>make -f Makefile1</b></blockquote></p>     <p><blockquote>gcc -с main.с gcc -с 2.с</blockquote></p>     <p><blockquote>gcc -с 3.с</blockquote></p>     <p><blockquote>gcc -о myapp main.о 2.о 3.о</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>На этот раз сборка прошла успешно.</p>     <p><b>Как это работает</b></p>     <p>Команда <blockquote>make</blockquote> обработала секцию зависимостей make-файла и определила файлы, которые нужно создать, и порядок их создания. Хотя вы сначала описали, как создать файл myapp, команда <blockquote>make</blockquote> определила правильный порядок создания файлов. Затем она запустила соответствующие команды для создания этих файлов, приведенные вами в секции правил. Команда <blockquote>make</blockquote> выводит на экран выполняемые ею команды. Теперь вы можете протестировать ваш make-файл, чтобы увидеть, корректно ли он обрабатывает изменения в файле b.h:</p>     <p><blockquote>$ <b>touch b.h</b></blockquote></p>     <p><blockquote>$ <b>make -f Makefile1</b></blockquote></p>     <p><blockquote>gcc -c 2.с gcc -с 3.c</blockquote></p>     <p><blockquote>gcc -o myapp main.о 2.о 3.o</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Команда <blockquote>make</blockquote> прочла ваш make-файл, определивший минимальное количество команд, требуемых для повторного построения myapp, и выполнила их в правильной последовательности. Теперь посмотрите, что произойдет, если вы удалите объектный файл:</p>     <p><blockquote>$ <b>rm 2.o</b></blockquote></p>     <p><blockquote>$ <b>make -f Makefile1</b></blockquote></p>     <p><blockquote>gcc -с 2.c</blockquote></p>     <p><blockquote>gcc -о myapp main.о 2.о 3.о</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>И снова команда <blockquote>make</blockquote> правильно определяет нужные действия.</p>             <a name="metkadoc6"><h1>Комментарии в make-файле</h1></a>     <p>Комментарий в make-файле начинается со знака <blockquote>#</blockquote> и продолжается до конца строки. Как и в исходных файлах на языке С, комментарии в make-файлах могут помочь как автору, так и другим пользователям понять, что имелось в виду во время написания данного файла.Sta</p>             <a name="metkadoc7"><h1>Макросы в make-файле</h1></a>     <p>Даже если бы функциональные возможности команды <blockquote>make</blockquote> и make-файлов ограничивались тем, что уже описано, они были бы мощным средством управления проектами с множеством исходных файлов. Но эти средства становятся громоздкими и неповоротливыми в проектах, содержащих большое количество файлов. Поэтому make-файлы предоставляют возможность использовать макросы, позволяющие писать эти файлы в более обобщенном виде.</p>     <p>Макросы в make-файле записываются в виде конструкции <blockquote>MAСRONAME=<i>значение</i></blockquote>, затем ссылаться на значение можно, указав <blockquote>$(MACRONAME)</blockquote> или <blockquote>${MACRONAME}</blockquote>. Некоторые версии <blockquote>make</blockquote> могут также принимать <blockquote>$MACRONAME</blockquote>. Вы можете задать пустое значение макроса, оставив пустой часть строки после знака <blockquote>=</blockquote>.</p>     <p>Макросы часто используют в make-файлах для задания опций компилятора. Обычно во время разработки приложение компилируется без оптимизации и с включенной отладочной информацией. Для окончательной версии приложения, как правило, нужны другие режимы: маленький двоичный файл без какой-либо отладочной информации, работающий как можно быстрее.</p>     <p>Еще одна проблема в файле Makefile1 — жестко заданное имя компилятора <blockquote>gcc</blockquote>. В других UNIX-системах вы, возможно, будете использовать <blockquote>cc</blockquote> или <blockquote>c89</blockquote>. Если когда-нибудь вы захотите перенести ваш make-файл в другую версию UNIX или получите другой компилятор для имеющейся у вас системы, придется изменить несколько строк в вашем make-файле, чтобы заставить его работать. Макросы — хороший способ собрать все эти системнозависимые части и легко изменить их.</p>     <p>Обычно макросы определяются в самом make-файле, но их можно задать и при вызове команды <blockquote>make</blockquote>, если добавить определение макроса, например, <blockquote>make CC=c89</blockquote>. Определения, подобные данному, приведенные в командной строке, переопределяют заданные в make-файле определения. Заданные вне make-файла определения макросов должны передаваться как один аргумент, поэтому исключите пробелы или применяйте кавычки следующим образом: <blockquote>"CC = с89"</blockquote>.</p>     <p>Выполните упражнение 9.2.</p>     <b>Упражнение 9.2. Make-файл с макросом</b>     <p>Далее приведена переработанная версия make-файла с именем Makefile2, в которой применяются макросы:</p>     <p><blockquote>all: myapp</blockquote></p>     <br>     <p><blockquote># Какой компилятор</blockquote></p>     <p><blockquote>СС = gcc</blockquote></p>     <br>     <p><blockquote># Где хранятся файлы include</blockquote></p>     <p><blockquote>INCLUDE = .</blockquote></p>     <br>     <p><blockquote># Опции для процесса разработки</blockquote></p>     <p><blockquote>СFLAGS = -g -Wall -ansi</blockquote></p>     <br>     <p><blockquote># Опции для окончательной версии</blockquote></p>     <p><blockquote># СFLAGS = -О -Wall -ansi</blockquote></p>     <br>     <p><blockquote>myapp: main.о 2.o 3.o</blockquote></p>     <p><blockquote> $(CC) -о myapp main.о 2.o 3.o</blockquote></p>     <br>     <p><blockquote>main.о: main.c a.h</blockquote></p>     <p><blockquote> $(CC) -I$(INCLUDE) $(CFLAGS) -с main.c</blockquote></p>     <br>     <p><blockquote>2.о: 2.c a.h b.h</blockquote></p>     <p><blockquote> $(CC) -I$(INCLUDE) $(CFLAGS) -c 2.c</blockquote></p>     <br>     <p><blockquote>3.o: 3.c b.h c.h</blockquote></p>     <p><blockquote> $(CC) -I$(INCLUDE) $(CFLAGS) -c 3.c</blockquote></p>     <p>Если удалить прошлую версию приложения и создать новую с помощью только что приведенного нового make-файла, вы получите следующее:</p>     <p><blockquote>$ <b>rm *.о myapp</b></blockquote></p>     <p><blockquote>$ <b>make -f Makefile2</b></blockquote></p>     <p><blockquote>gcc -I. -g -Wall -ansi -c main.c</blockquote></p>     <p><blockquote>gcc -I. -g -Wall -ansi -c 2.c</blockquote></p>     <p><blockquote>gcc -I. -g -Wall -ansi -c 3.c</blockquote></p>     <p><blockquote>gcc -o myapp main.о 2.o 3.o</blockquote></p>     <p><blockquote>$</blockquote></p>     <p><b>Как это работает</b></p>     <p>Программа make заменяет ссылки на макросы <blockquote>$(CC)</blockquote>, <blockquote>$(CFLAGS)</blockquote> и <blockquote>$(INCLUDE)</blockquote> соответствующими определениями так же, как компилятор С поступает с директивами <blockquote>#define</blockquote>. Теперь, если вы захотите изменить команду компиляции, вам придется изменить только одну строку make-файла.</p>     <p>У команды <blockquote>make</blockquote> есть несколько специальных внутренних макросов, которые можно применять для того, чтобы еще более сократить make-файлы. В табл. 9.1 мы перечислили наиболее часто используемые из них; в последующих примерах вы увидите их в действии. Подстановка каждого из этих макросов выполняется только перед его использованием, поэтому значение макроса может меняться по мере обработки make-файла. На самом деле в этих макросах было бы очень мало пользы, если бы они действовали иначе.</p>     <p><b><i>Таблица 9.1</i></b></p>     <table>      <tr>       <th valign="top">Макрос</th>       <th valign="top">Определение</th>      </tr>      <tr>       <td valign="top"><blockquote>$?</blockquote></td>       <td valign="top">Список необходимых условий (файлов, от которых зависит выходной файл), измененных позже, чем текущий выходной файл</td>      </tr>      <tr>       <td valign="top"><blockquote>$@</blockquote></td>       <td valign="top">Имя текущего задания</td>      </tr>      <tr>       <td valign="top"><blockquote>$&lt;</blockquote></td>       <td valign="top">Имя текущего файла, от которого зависит выходной</td>      </tr>      <tr>       <td valign="top"><blockquote>$*</blockquote></td>       <td valign="top">Имя без суффикса текущего файла, от которого зависит выходной</td>      </tr>     </table>     <p>Есть еще два полезных специальных символа, которые можно увидеть перед командами в make-файле:</p>     <p>&#9633; символ <blockquote>-</blockquote> заставляет команду <blockquote>make</blockquote> игнорировать любые ошибки. Например, если вы хотели бы создать каталог и при этом игнорировать любые ошибки, скажем, потому что такой каталог уже существует, вы просто ставите знак "минус" перед командой <blockquote>mkdir</blockquote>. Чуть позже в этой главе вы увидите применение символа <blockquote>-</blockquote>;</p>     <p>&#9633; символ <blockquote>@</blockquote> запрещает команде <blockquote>make</blockquote> выводить команду в стандартный файл вывода перед ее выполнением. Этот символ очень удобен, если вы хотите использовать команду <blockquote>echo</blockquote> для вывода некоторых инструкций.</p>             <a name="metkadoc8"><h1>Множественные задания</h1></a>     <p>Часто бывает полезно создать вместо одного выходного файла несколько или собрать несколько групп команд в одном файле. Вы можете сделать это, расширив свой make-файл. В упражнении 9.3 вы добавите задание <blockquote>clean</blockquote> на удаление ненужных объектных файлов, и задание <blockquote>install</blockquote>, перемещающее окончательное приложение в другой каталог.</p>     <p>Далее приведена следующая версия make-файла с именем Makefile3:</p>     <p><blockquote>all: myapp</blockquote></p>     <br>     <p><blockquote># Какой компилятор</blockquote></p>     <p><blockquote>CC = gcc</blockquote></p>     <br>     <p><blockquote><i># Куда установить</i></blockquote></p>     <p><blockquote><i># INSTDIR=/usr/local/bin</i></blockquote></p>     <br>     <p><blockquote># Где хранятся файлы include</blockquote></p>     <p><blockquote>INCLUDE = .</blockquote></p>     <br>     <p><blockquote># Опции для разработки</blockquote></p>     <p><blockquote>CFLAGS = -g -Wall -ansi</blockquote></p>     <br>     <p><blockquote># Опции для рабочей версии</blockquote></p>     <p><blockquote># CFLAGS = -О -Wall -ansi</blockquote></p>     <br>     <p><blockquote>myapp: main.o 2.o 3.o</blockquote></p>     <p><blockquote> $(CC) -о myapp main.о 2.о 3.o</blockquote></p>     <br>     <p><blockquote>main.о: main.c a.h</blockquote></p>     <p><blockquote> $(CC) -I$(INCLUDE) $(CFLAGS) -c main.c</blockquote></p>     <br>     <p><blockquote>2.о: 2.c a.h b.h</blockquote></p>     <p><blockquote> $(CC) -I$(INCLUDE) $(CFLAGS) -c 2.c</blockquote></p>     <br>     <p><blockquote>3.o: 3.c b.h c.h</blockquote></p>     <p><blockquote> $(CC) -I$(INCLUDE) $(CFLAGS) -c 3.c</blockquote></p>     <br>     <p><blockquote><i>clean:</i></blockquote></p>     <p><blockquote><i> -rm main.o 2.o 3.o</i></blockquote></p>     <br>     <p><blockquote><i>install: myapp</i></blockquote></p>     <p><blockquote><i> @if [ -d $(INSTDIR) ]; \</i></blockquote></p>     <p><blockquote><i> then \</i></blockquote></p>     <p><blockquote><i>  cp myapp $(INSTDIR);\</i></blockquote></p>     <p><blockquote><i>  chmod a+x $(INSTDIR)/myapp;\</i></blockquote></p>     <p><blockquote><i>  chmod og-w $(INSTDIR)/myapp;\</i></blockquote></p>     <p><blockquote><i>  echo "Installed in $(INSTDIR)";\</i></blockquote></p>     <p><blockquote><i> else \</i></blockquote></p>     <p><blockquote><i>  echo "Sorry, $(INSTDIR) does not exist";\</i></blockquote></p>     <p><blockquote><i> fi</i></blockquote></p>     <p>В этом make-файле есть несколько вещей, на которые следует обратить внимание. Во-первых, специальная цель <blockquote>all</blockquote>, которая задает только один выходной файл myapp. Следовательно, если вы выполняете <blockquote>make</blockquote> без указания задания, поведение по умолчанию — сборка файла myapp.</p>     <p>Следующая важная особенность относится к двум дополнительным заданиям: <blockquote>clean</blockquote> и <blockquote>install</blockquote>. В задании <blockquote>clean</blockquote> для удаления объектных файлов применяется команда <blockquote>rm</blockquote>. Команда начинается со знака <blockquote>-</blockquote>, тем самым сообщая команде <blockquote>make</blockquote> о необходимости игнорировать результат команды, поэтому <blockquote>make</blockquote> выполнится успешно, даже если объектных файлов нет и команда <blockquote>rm</blockquote> вернет ошибку. Правила для задания <blockquote>clean</blockquote> ни от чего не зависят, остаток строки после <blockquote>clean:</blockquote> пуст. Таким образом, задание всегда считается измененным со времени последнего выполнения, и его правило всегда выполняется, если <blockquote>clean</blockquote> указывается в качестве задания.</p>     <p>Задание <blockquote>install</blockquote> зависит от myapp, поэтому команда <blockquote>make</blockquote> знает, что должна создать myapp перед выполнением других команд задания <blockquote>install</blockquote>. Правила выполнения <blockquote>install</blockquote> состоят из нескольких команд сценария командной оболочки. Поскольку команда <blockquote>make</blockquote> запускает командную оболочку для выполнения правил и применяет новую командную оболочку для каждого правила, следует добавлять обратные слэши, чтобы все команды сценария были в одной логической строке и передавались для выполнения все вместе одному сеансу командной оболочки. Эта команда начинается со знака отменяющего вывод команды в стандартный файл вывода перед выполнением правила.</p>     <p>Задание <blockquote>install</blockquote> выполняет несколько команд одну за другой для установки приложения в указанное расположение. Оно не проверяет успешность выполнения предыдущей команды перед выполнением следующей. Если очень важно, чтобы последующие команды выполнялись только в случае успешного завершения предыдущей, можно написать команды, объединенные с помощью операции <blockquote>&amp;&amp;,</blockquote> как показано далее:</p>     <p><blockquote>@if [ -d $(INSTDIR) ]; \</blockquote></p>     <p><blockquote> then \</blockquote></p>     <p><blockquote> cp myapp $(INSTDIR) &amp;&amp;\</blockquote></p>     <p><blockquote> chmod a+x $(INSTDIR)/myapp &amp;&amp; \</blockquote></p>     <p><blockquote> chmod og-w $(INSTDIR/myapp &amp;&amp; \</blockquote></p>     <p><blockquote> echo "Installed in $(INSTDIR)" ; \</blockquote></p>     <p><blockquote>else \</blockquote></p>     <p><blockquote> echo "Sorry, $(INSTDIR) does not exist"; false ; \</blockquote></p>     <p><blockquote>fi</blockquote></p>     <p>Как вы, вероятно, помните из<i> главы 2, у</i> командной оболочки есть команда <blockquote>and</blockquote>, благодаря которой выполнение последующей команды возможно лишь при успешном завершении предыдущей. В данном примере вас не слишком заботит успешное завершение предыдущих команд, поэтому можно придерживаться более простой формы.</p>     <p>Если вы — обычный пользователь, то у вас может не быть прав на установку новых команд в каталог /usr/local/bin. Можно изменить в make-файле каталог установки, изменить права доступа к этому каталогу или заменить пользователя (с помощью команды <blockquote>su</blockquote>) на root перед запуском <blockquote>make install</blockquote>.</p>     <p><blockquote>$ <b>rm *.о myapp</b></blockquote></p>     <p><blockquote>$ <b>make -f Makefile3</b></blockquote></p>     <p><blockquote>gcc -I. -g -Wall -ansi -c main.c</blockquote></p>     <p><blockquote>gcc -I. -g -Wall -ansi -c 2.c</blockquote></p>     <p><blockquote>gcc -I. -g -Wall -ansi -с 3.c</blockquote></p>     <p><blockquote>gcc -o myapp main.о 2.o 3.o</blockquote></p>     <p><blockquote>$ <b>make -f Makefile3</b></blockquote></p>     <p><blockquote>make: Nothing to be done for 'all'.</blockquote></p>     <p><blockquote>$ <b>rm myapp</b></blockquote></p>     <p><blockquote>$ <b>make -f Makefile3 install</b></blockquote></p>     <p><blockquote>gcc -o myapp main.o 2.o 3.o</blockquote></p>     <p><blockquote>Installed in /usr/local/bin</blockquote></p>     <p><blockquote>$ <b>make -f Makefile3 clean</b></blockquote></p>     <p><blockquote>rm main.о 2.о 3.о</blockquote></p>     <p><blockquote>$</blockquote></p>     <p><b>Как это работает</b></p>     <p>Сначала вы удаляете файл myapp и все объектные файлы. Команда <blockquote>make</blockquote> самостоятельно выбирает задание <blockquote>all</blockquote>, которое приводит к сборке myapp. Затем вы снова запускаете команду <blockquote>make</blockquote>, но т.к. у файла myapp свежая версия, <blockquote>make</blockquote> не делает ничего. Далее вы удаляете файл myapp и выполняете <blockquote>make install</blockquote>. Эта команда создает заново двоичный файл и копирует его в каталог установки. В заключение выполняется команда <blockquote>make clean</blockquote>, удаляющая объектные файлы.</p>             <a name="metkadoc9"><h1>Встроенные правила</h1></a>     <p>До сих пор вы описывали в make-файле подробно, как выполнять каждый шаг. В действительности у команды <blockquote>make</blockquote> есть много встроенных правил, которые существенно упрощают make-файлы, особенно если у вас много исходных файлов. Для того чтобы проверить это, создайте традиционную программу, приветствующую мир:</p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> printf("Hello World\n");</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>He задавая make-файла, попробуйте откомпилировать ее с помощью команды <blockquote>make</blockquote>:</p>     <p><blockquote>$ <b>make foo</b></blockquote></p>     <p><blockquote>сс foo.с -о foo</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Как видите, <blockquote>make</blockquote> знает, как запустить компилятор, хотя в данном случае она выбирает <blockquote>сс</blockquote> вместо <blockquote>gcc</blockquote> (в ОС Linux это нормально, потому что <blockquote>cc</blockquote> — обычно ссылка на <blockquote>gcc</blockquote>). Иногда эти встроенные правила называют<i> подразумеваемыми правилами. </i>Стандартные правила используют макросы, поэтому задавая некоторые новые значения для макросов, вы можете изменить стандартное поведение.</p>     <p><blockquote>$ <b>rm foo</b></blockquote></p>     <p><blockquote>$ <b>make CC=gcc CFLAGS="-Wall -g" foo</b></blockquote></p>     <p><blockquote>gcc -Wall -g foo.с -o foo</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>С помощью опции <blockquote>-p</blockquote> можно попросить команду <blockquote>make</blockquote> вывести на экран встроенные правила. Их так много, что мы не можем привести в книге все встроенные правила, ограничимся коротким фрагментом вывода команды <blockquote>make -p</blockquote> версии GNU, демонстрирующим часть этих правил:</p>     <p><blockquote>OUTPUT_OPTION = -o $@</blockquote></p>     <p><blockquote>COMPILE.с = $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -с</blockquote></p>     <p><blockquote>%.о: %.с</blockquote></p>     <p><blockquote># commands to execute (built-in) :</blockquote></p>     <p><blockquote> $(COMPILE.с) $(OUTPUT_OPTION) $&lt;</blockquote></p>     <p>Теперь, принимая во внимание описанные встроенные правила, вы можете упростить ваш make-файл, удалив правила для создания объектных файлов и оставив только зависимости, таким образом, соответствующая секция make-файла читается просто:</p>     <p><blockquote>main.о: main.c a.h</blockquote></p>     <p><blockquote>2.о: 2.с a.h b.h</blockquote></p>     <p><blockquote>3.o: 3.c b.h c.h</blockquote></p>     <p>Эту версию можно найти в загружаемом из Интернета программном коде, в файле Makefile4.</p>             <a name="metkadoc10"><h1>Суффиксы и шаблоны правил</h1></a>     <p>Встроенные правила, которые вы видели, действуют, используя суффиксы (подобные расширениям файлов в системах Windows и MS-DOS), поэтому команда <blockquote>make</blockquote>, получая файл с одним окончанием, знает, какое правило применять для создания файла с другим окончанием. Чаще всего используется правило для создания файла, заканчивающегося .о, из файла с окончанием .c. Это правило для применения компилятора, компилирующего исходный файл, но не компонующего.</p>     <p>Порой возникает потребность в создании новых правил. Авторы приучили себя работать с исходными файлами, которые необходимо компилировать несколькими разными компиляторами: двумя в среде MS-DOS и <blockquote>gcc</blockquote> в ОС Linux. Для того чтобы осчастливить один из компиляторов MS-DOS, исходные файлы на языке С++, а не С должны иметь расширение cpp. К сожалению, у версии команды <blockquote>make</blockquote>, применяемой в Linux, в то время не было встроенного правила для компиляции файлов с окончанием .cpp. (Существовало правило для суффикса .cc, более распространенного расширения файла на C++ в среде UNIX.)</p>     <p>Следовательно, нужно было либо задавать правило для каждого отдельного исходного файла, либо научить <blockquote>make</blockquote> новому правилу для создания объектных файлов из файлов с расширением cpp. Учитывая, что в том проекте было довольно большое количество исходных файлов, определение нового правила сэкономило бы много времени на наборе и существенно облегчило бы добавление новых исходных файлов в проект.</p>     <p>Для вставки правила с новым суффиксом сначала добавьте строку в make-файл, информирующую команду <blockquote>make</blockquote> о новом суффиксе; далее можно написать правило, используя новый суффикс. Команда <blockquote>make</blockquote> применяет специальную синтаксическую запись</p>     <p><blockquote>.&lt;old_suffix&gt;.&lt;new_suffix&gt;:</blockquote></p>     <p>для определения общего правила создания файлов с новым суффиксом из файлов с тем же основным именем, но старым суффиксом.</p>     <p>Далее приведен фрагмент make-файла с новым общим правилом для компиляции файлов с суффиксом .срр в файлы с суффиксом .о:</p>     <p><blockquote>.SUFFIXES: .cpp</blockquote></p>     <p><blockquote>.cpp.o:</blockquote></p>     <p><blockquote> $ (CC) -xc++ $(CFLAGS) -I$(INCLUDE) -с $&lt;</blockquote></p>     <p>Особая зависимость <blockquote>.cpp.o:</blockquote> информирует команду <blockquote>make</blockquote> о том, что следующие правила предназначены для трансляции файла с суффиксом .cpp в файлы с суффиксом .о. При написании этой зависимости применяются имена специальных макросов, поскольку неизвестны реальные имена файлов, которые будут транслироваться. Для того чтобы понять это правило, нужно просто вспомнить, что символы <blockquote>$&lt;</blockquote> заменяются начальным именем файла (со старым суффиксом). Имейте в виду, что вы сообщили <blockquote>make</blockquote> только о том, как получить из файла с суффиксом .cpp файл с суффиксом .о; как из объектного файла получить двоичный исполняемый файл, команда <blockquote>make</blockquote> уже знает.</p>     <p>После запуска команда <blockquote>make</blockquote> применяет ваше новое правило для получения из файла bar.cpp файла bar.o; далее она использует свои встроенные правила для превращения файла с суффиксом .о в исполняемый файл. Дополнительный флаг <blockquote>-xc++</blockquote> должен сообщить программе <blockquote>gcc</blockquote> о том, что она имеет дело с исходным файлом на языке C++.</p>     <p>В наши дни команда <blockquote>make</blockquote> знает, как работать с исходными файлами на С++ с расширениями cpp, но данный метод полезен для преобразования файла одного типа в файл другого типа.</p>     <p>Самые последние версии команды make включают в себя альтернативную синтаксическую запись для достижения того же эффекта и многое другое. Например, правила с шаблонами используют знак подстановки <blockquote>%</blockquote> для сопоставления имен файлов и не полагаются на одни лишь расширения этих имен.</p>     <p>Далее приведено правило с шаблоном, эквивалентное предыдущему правилу с суффиксом .cpp:</p>     <p><blockquote>%.cpp: %o</blockquote></p>     <p><blockquote> $(СС) -xc++ $(CFLAGS) -I$(INCLUDE) -с $&lt;</blockquote></p>             <a name="metkadoc11"><h1>Управление библиотеками с помощью<i> make</i></h1></a>     <p>Когда вы работаете над большими проектами, часто удобно управлять компиляцией нескольких программных единиц с помощью<i> библиотеки.</i> Библиотеки — это файлы, в соответствии с соглашением имеющие расширение a (archive) и содержащие коллекцию объектных файлов. Для работы с библиотеками у команды make есть специальная синтаксическая запись, которая существенно облегчает управление ими.</p>     <p>Синтаксическая запись <blockquote>lib(file.о)</blockquote> означает объектный файл file.o, хранящийся в библиотеке lib.а. У команды <blockquote>make</blockquote> есть встроенное правило для управления библиотеками, которое обычно эквивалентно приведенному далее фрагменту:</p>     <p><blockquote>.с.а:</blockquote></p>     <p><blockquote> $(CC) -с $(CFLAGS)</blockquote></p>     <p><blockquote> $&lt; $(AR) $(ARFLAGS) $@ $*.о</blockquote></p>     <p>Макросы <blockquote>$(AR)</blockquote> и <blockquote>$(ARFLAGS)</blockquote> подразумевают команду <blockquote>ar</blockquote> и опции <blockquote>rv</blockquote> соответственно. Довольно краткая синтаксическая запись информирует команду <blockquote>make</blockquote> о том, что для включения файла .с в библиотеку .а следует применить два следующих правила:</p>     <p>&#9633; первое правило говорит о том, что команда <blockquote>make</blockquote> должна откомпилировать исходный файл и сформировать объектный файл;</p>     <p>&#9633; второе правило предписывает применить команду <blockquote>ar</blockquote> для модификации библиотеки, заключающейся в добавлении нового объектного файла.</p>     <p>Итак, если у вас есть библиотека fud, содержащая файл bas.o, в первом правиле <blockquote>$&lt;</blockquote> заменяется именем bas.c. Во втором правиле <blockquote>$@</blockquote> заменяется именем библиотеки <blockquote>fud.а</blockquote> и <blockquote>$*</blockquote> заменяется именем <blockquote>bas</blockquote>.</p>     <p>Выполните упражнение 9.4.</p>     <b>Упражнение 9.4. Управление библиотекой</b>     <p>Правила управления библиотеками очень просто применять на практике. В этом упражнении вы измените свое приложение, сохранив файлы 2.o и 3.o в библиотеке mylib.a. Make-файл потребует лишь нескольких изменений и его новый вариант Makefile5 будет выглядеть следующим образом:</p>     <p><blockquote>all: myapp</blockquote></p>     <br>     <p><blockquote># Какой компилятор</blockquote></p>     <p><blockquote>CC = gcc</blockquote></p>     <br>     <p><blockquote># Куда установить</blockquote></p>     <p><blockquote>INSTDIR = /usr/local/bin</blockquote></p>     <br>     <p><blockquote># Где хранятся файлы include</blockquote></p>     <p><blockquote>INCLUDE =</blockquote></p>     <br>     <p><blockquote># Опции для разработки</blockquote></p>     <p><blockquote>CFLAGS = -g -Wall -ansi</blockquote></p>     <br>     <p><blockquote># Опции для рабочей версии</blockquote></p>     <p><blockquote># CFLAGS = -O -Wall -ansi</blockquote></p>     <br>     <p><blockquote><i># Локальные библиотеки</i></blockquote></p>     <p><blockquote><i>MYLIB = mylib.a</i></blockquote></p>     <br>     <p><blockquote><i>myapp: main.o $(MYLIB)</i></blockquote></p>     <p><blockquote><i> $(CC) -o myapp main.o $(MYLIB)</i></blockquote></p>     <br>     <p><blockquote><i>$(MYLIB): $(MYLIB)(2.o) $(MYLIB)(3.o)</i></blockquote></p>     <p><blockquote><i>main.o: main.c a.h</i></blockquote></p>     <p><blockquote><i>2.o: 2.c a.h b.h</i></blockquote></p>     <p><blockquote><i>3.o: 3.c b.h c.h</i></blockquote></p>     <br>     <p><blockquote><i>clean:</i></blockquote></p>     <p><blockquote><i> -rm main.o 2.o 3.o $(MYLIB)</i></blockquote></p>     <br>     <p><blockquote>install: myapp</blockquote></p>     <p><blockquote> @if [ -d $(INSTDIR) ]; \</blockquote></p>     <p><blockquote> then \</blockquote></p>     <p><blockquote>  cp myapp $(INSTDIR);\</blockquote></p>     <p><blockquote>  chmod a+x $(INSTDIR)/myapp;\</blockquote></p>     <p><blockquote>  chmod og-w $(INSTDIR)/myapp;\</blockquote></p>     <p><blockquote>  echo "Installed in $(INSTDIR)";\</blockquote></p>     <p><blockquote> else \</blockquote></p>     <p><blockquote>  echo "Sorry, $(INSTDIR) does not exist";\</blockquote></p>     <p><blockquote> fi</blockquote></p>     <p>Обратите внимание на то, как вы разрешили правилам по умолчанию выполнить большую часть работы. Теперь проверьте новую версию make-файла:</p>     <p><blockquote>$ <b>rm -f myapp *.o mylib.a</b></blockquote></p>     <p><blockquote>$ <b>make -f Makefile5</b></blockquote></p>     <p><blockquote>gcc -g -Wall -ansi -с -o main.о main.c</blockquote></p>     <p><blockquote>gcc -g -Wall -ansi -с -o 2.о 2.c</blockquote></p>     <p><blockquote>ar rv mylib.a 2.o</blockquote></p>     <p><blockquote>a - 2.o</blockquote></p>     <p><blockquote>gcc -g -Wall -ansi -с -о 3.o 3.c</blockquote></p>     <p><blockquote>ar rv mylib.a 3.o</blockquote></p>     <p><blockquote>a - 3.о</blockquote></p>     <p><blockquote>gcc -o myapp main.о mylib.a</blockquote></p>     <p><blockquote>$ <b>touch c.h</b></blockquote></p>     <p><blockquote>$ <b>make -f Makefile5</b></blockquote></p>     <p><blockquote>gcc -g -Wall -ansi -с -о 3.o 3.c</blockquote></p>     <p><blockquote>ar rv mylib.a 3.o </blockquote></p>     <p><blockquote>r - 3.о</blockquote></p>     <p><blockquote>gcc -o myapp main.о mylib.a</blockquote></p>     <p><blockquote>$</blockquote></p>     <p><b>Как это работает</b></p>     <p>Сначала вы удаляете все объектные файлы и библиотеку и разрешаете команде <blockquote>make</blockquote> создать файл myapp, что она и делает, откомпилировав и создав библиотеку перед тем, как компоновать файл main.о с библиотекой для создания исполняемого файла myapp. Далее вы тестируете зависимость для файла 3.o, которая информирует команду <blockquote>make</blockquote> о том, что, если меняется файл c.h, файл 3.c следует заново откомпилировать. Она делает это корректно, откомпилировав файл и обновив библиотеку перед перекомпоновкой, создающей новую версию исполняемого файла myapp.</p>             <a name="metkadoc12"><h1>Более сложная тема: make-файлы и подкаталоги</h1></a>     <p>При работе над большими проектами порой бывает удобно отделить от основных файлов файлы, формирующие библиотеку, и поместить их в подкаталог. С помощью команды <blockquote>make</blockquote> можно сделать это двумя способами.</p>     <p>Во-первых, можно создать в подкаталоге второй make-файл для компиляции файлов, сохранения их в библиотеке и последующего копирования библиотеки на уровень вверх, в основной каталог. При этом в основном make-файле, хранящемся в каталоге более высокого уровня, есть правило формирования библиотеки, в котором описан запуск второго make-файла следующим образом:</p>     <p><blockquote>mylib.a:</blockquote></p>     <p><blockquote> (cd mylibdirectory;$(MAKE))</blockquote></p>     <p>Это правило гласит, что вы всегда должны пытаться создать mylib.a с помощью команды <blockquote>make</blockquote>. Когда <blockquote>make</blockquote> инициирует правило создания библиотеки, она изменяет каталог на mylibdirectory и затем запускает новую команду <blockquote>make</blockquote> для управления библиотекой. Поскольку для этого запускается новая командная оболочка, программа, применяющая make-файл, не выполняет команду <blockquote>cd</blockquote>. А командная оболочка, запущенная для выполнения правила построения библиотеки, находится в другом каталоге. Скобки обеспечивают выполнение всего процесса в одной командной оболочке.</p>     <p>Второй способ заключается в применении нескольких макросов в одном make-файле. Дополнительные макросы генерируются добавлением символа <blockquote>D</blockquote> для каталога или символа <blockquote>F</blockquote> для имени файла к тем макросам, которые мы уже обсуждали. Вы можете переписать встроенное правило с суффиксами .с.о</p>     <p><blockquote>.c.o:</blockquote></p>     <p><blockquote> $(СС) $(CFLAGS) -с $(@D)/$(&lt;F) -о $(@D)/$(@F)</blockquote></p>     <p>для компиляции файлов в подкаталоге и сохранения в нем объектных файлов. Затем вы обновляете библиотеку в текущем каталоге с помощью зависимости и правила, наподобие приведенных далее:</p>     <p><blockquote>mylib.a: mydir/2.o mydir/3.о</blockquote></p>     <p><blockquote> ar -rv mylib.a $?</blockquote></p>     <p>Вы должны решить, какой из способов предпочтительнее в вашем проекте. Многие проекты просто избегают применения подкаталогов, но это может привести к непомерному разрастанию исходного каталога. Как видно из только что приведенного краткого обзора, команду <blockquote>make</blockquote> можно использовать с подкаталогами и сложность возрастает при этом лишь незначительно.</p>             <a name="metkadoc13"><h1>Версия GNU команд<i> make</i> и<i> gcc</i></h1></a>     <p>Для GNU-команды <blockquote>make</blockquote> и GNU-компилятора <blockquote>gcc</blockquote> существуют две интересные дополнительные опции.</p>     <p>&#9633; Первая — опция <blockquote>-j<i>N</i></blockquote> ("jobs") команды <blockquote>make</blockquote>. Она позволяет <blockquote>make</blockquote> выполнять <i><blockquote><i>N</i></blockquote> </i>команд одновременно. Там, где несколько разных частей проекта могут компилироваться независимо, команда <blockquote>make</blockquote> запускает несколько правил в одно и то же время. В зависимости от конфигурации вашей системы эта возможность может существенно сократить время, затраченное на перекомпиляцию. Если у вас много исходных файлов, может быть стоит воспользоваться этой опцией. Как правило, небольшие числа, например <blockquote>-j3</blockquote>, — хорошая отправная точка. Если вы делите компьютер с другими пользователями, применяйте эту опцию с осторожностью. Другие пользователи могут не одобрить запуск большого количества процессов при каждой вашей компиляции!</p>     <p>&#9633; Второе полезное дополнение — опция <blockquote>-MM</blockquote> для <blockquote>gcc</blockquote>. Она формирует список зависимостей в форме, подходящей для команды <blockquote>make</blockquote>. В проекте со значительным числом исходных файлов, каждый из которых содержит разные комбинации заголовочных файлов, бывает трудно (но крайне важно) корректно определить зависимости. Если сделать каждый исходный файл зависимым от всех заголовочных файлов, иногда вы будете компилировать файлы напрасно. С другой стороны, если вы пропустите какие-то зависимости, возникнет еще более серьезная проблема, поскольку в этом случае вы не откомпилируете заново те файлы, которые нуждаются в перекомпиляции.</p>     <p>Выполните упражнение 9.5.</p>     <b>Упражнение 9.5. Использование <blockquote>gcc -MM</blockquote></b>     <p>В этом упражнении вы примените опцию <blockquote>-MM</blockquote> в программе <blockquote>gcc</blockquote> для генерации списка зависимостей вашего примера:</p>     <p><blockquote>$ <b>gcc -MM main.с 2.с 3.с</b></blockquote></p>     <p><blockquote>main.о: main.c a.h</blockquote></p>     <p><blockquote>2.о: 2.с a.h b.h</blockquote></p>     <p><blockquote>3.o: 3.с b.h c.h</blockquote></p>     <p><blockquote>$</blockquote></p>     <p><b>Как это работает</b></p>     <p>Компилятор <blockquote>gcc</blockquote> просто просматривает исходные файлы, ищет заголовочные файлы и выводит требующиеся строки зависимостей в формате, готовом к вставке в make- файл. Вы должны лишь сохранить вывод во временном файле и затем вставить его в make-файл, чтобы иметь безошибочный набор зависимостей. Если вы пользуетесь копией, полученной от <blockquote>gcc</blockquote>, для появления ошибок в ваших зависимостях просто нет оснований!</p>     <p>Если вы хорошо знакомы с make-файлами, можно попробовать применить средство <blockquote>makedepend</blockquote>, которое выполняет функцию, аналогичную опции <blockquote>-MM</blockquote>, но вставляет полученный список зависимостей в конец реального заданного вами make-файла.</p>     <p>Перед завершением темы make-файлов, быть может, стоит подчеркнуть, что не следует ограничивать применение make-файлов только компиляцией кода и созданием библиотек. Их можно использовать для автоматизации любой задачи, в которой есть последовательность команд, формирующих из входного файла некоторого типа выходной файл. Типичным "некомпиляционным" применением может быть вызов программ <blockquote>awk</blockquote>, или <blockquote>sed</blockquote> для обработки некоторых файлов или генерация интерактивного справочного руководства. Вы можете автоматизировать практически любую обработку файлов, если на основании информации о дате и времени модификации файла можете определить, какие из файлов были изменены.</p>     <p>Другая возможность управления вашими сборками или на самом деле другой способ автоматизации задач — утилита ANT. Это средство на базе языка Java, использующее файлы конфигурации, написанные на языке XML. Ее обычно не применяют в ОС Linux для автоматизации создания исполняемых файлов из файлов на языке С, поэтому мы не будем обсуждать ее в книге. Более подробную информацию об ANT можно найти на Web-сайте <b>http://ant.apache.org/.</b></p>              <a name="metkadoc14"><h1>Управление исходным кодом</h1></a>         <p>Если вы ушли от простых проектов и особенно если несколько человек работает над проектом, управление изменениями, вносимыми в исходные файлы, становится важной составляющей, которая позволяет избежать конфликтных корректировок и отслеживать сделанные изменения.</p>     <p>В среде UNIX есть несколько широко распространенных систем управления исходными файлами:</p>     <p>&#9633; SCCS (Source Code Control System);</p>     <p>&#9633; RCS (Revision Control System);</p>     <p>&#9633; CVS (Concurrent Version System);</p>     <p>&#9633; Subversion.</p>     <p>SCCS первоначально была системой управления исходным кодом, введенной компанией AT&amp;T в версии System V ОС UNIX, а сейчас она — часть стандарта X/Open. RCS была разработана позже как бесплатная замена SCCS и распространяется Фондом бесплатного программного обеспечения (Free Software foundation). RCS функционально очень похожа на SCCS, но с интуитивно более понятным интерфейсом и некоторыми дополнительными опциями, поэтому система SCCS по большей части вытеснена RCS.</p>     <p>Утилиты RCS обычно включены в дистрибутивы Linux или же их можно загрузить из Интернета вместе с исходными файлами с Web-сайта Фонда бесплатного программного обеспечения со страницы <b>http://directory.fsf.org/rcs.html.</b></p>     <p>CVS — более передовая, чем SCCS или RCS, система, которая может быть инструментом для совместных разработок на базе Интернета. Ее можно найти в большинстве дистрибутивов Linux или по адресу <b>http://www.nongnu.org/cvs/</b>. У этой системы два существенных преимущества по сравнению с RCS: ее можно применять в сетевых соединениях и она допускает параллельные разработки.</p>     <p>Subversion — новое детище, входящее в блок, проектируемый для замены системы CVS когда-нибудь в будущем. Начальную страницу Web-сайта этой системы можно найти по адресу <b>http://www.subversion.org.</b></p>     <p>В этой главе мы сосредоточимся на системах RCS и CVS; выбор RCS объясняется легкостью ее использования в индивидуальных проектах, хорошей интегрированностью с командой make, a CVS выбрана потому, что это самая популярная форма управления исходным кодом, применяемая в совместных проектах. Мы также кратко сравним команды RCS с командами SCCS, поскольку последняя обладает статусом стандарта POSIX, и некоторые пользовательские команды CVS с командами системы Subversion.</p>             <a name="metkadoc15"><h1>RCS</h1></a>     <p>Revision Control System (RCS, система управления версиями) содержит ряд команд для управления исходными файлами. Она функционирует, отслеживая исходный файл по мере его изменения и сохраняя единый файл со списком изменений, достаточно подробным для того, чтобы можно было воссоздать любую предыдущую версию файла. Система также позволяет хранить комментарии, связанные с каждым изменением, которые могут оказаться полезными, если вы оглядываетесь назад, изучая хронологию изменений файла.</p>     <p>По мере продвижения проекта вы можете регистрировать в файле отдельно каждое значительное изменение или исправление ошибки и сохранять комментарии к каждому изменению. Это может оказаться очень полезным при просмотре изменений, внесенных в файл, проверке фрагментов с исправленными ошибками, и иногда возможно и внесенными ошибками!</p>     <p>Поскольку RCS сохраняет только различия между версиями, она эффективно использует дисковое пространство. Кроме того, система позволяет получить предыдущие версии в случае ошибочного удаления.</p>     <b>Команда<i> rcs</i></b>     <p>Для иллюстрации сказанного начните с начальной версии файла, которым хотите управлять. В данном случае давайте использовать файл important.c, который начинает существование как копия файла foo.с со следующим комментарием, добавленным в начало файла:</p>     <p><blockquote>/*</blockquote></p>     <p><blockquote> Это важный файл для управления данным проектом.</blockquote></p>     <p><blockquote> В нем реализована каноническая программа "Hello World".</blockquote></p>     <p><blockquote>*/</blockquote></p>     <p>Первая задача — инициализировать RCS-контроль над файлом с помощью команды <blockquote>rcs</blockquote>. Команда <blockquote>rcs -i</blockquote> инициализирует файл RCS-управления.</p>     <p><blockquote>$ <b>rcs -i important.с</b></blockquote></p>     <p><blockquote>RCS file: important.с,v</blockquote></p>     <p><blockquote>enter description, terminated with single '.' or end of file:</blockquote></p>     <p><blockquote>NOTE: This is NOT the log message!</blockquote></p>     <p><blockquote>&gt;&gt; <b>This is an important demonstration file</b></blockquote></p>     <p><blockquote>&gt;&gt; <b>.</b></blockquote></p>     <p><blockquote>done</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Разрешается применять множественные строки комментариев. Завершите строку приглашения одиночной точкой (<blockquote>.</blockquote>) в самой строке или набрав символ конца файла, обычно комбинацией клавиш &lt;Ctrl&gt;+&lt;D&gt;.</p>     <p>После этой команды <blockquote>rcs</blockquote> создается новый предназначенный только для чтения (read-only) файл с расширением v.</p>     <p><blockquote>$ <b>ls -l</b></blockquote></p>     <p><blockquote>-rw-r--r-- 1 neil users 225 2007-07-09 07:52 important.c</blockquote></p>     <p><blockquote>-r--r--r-- 1 neil users 105 2007-07-09 07:52 important.с,v</blockquote></p>     <p><blockquote>$</blockquote></p>     <blockquote>      <b>Примечание</b>      <p>Если вы предпочитаете сохранять RCS-файлы в отдельном каталоге, просто создайте подкаталог с именем RCS перед первым применением команды <blockquote>rcs</blockquote>. Все команды <blockquote>rcs</blockquote> будут автоматически использовать подкаталог RCS для RCS-файлов.</p>     </blockquote>     <b>Команда <i>сi</i></b>     <p>Теперь вы можете выполнить регистрируемый ввод в RCS-файл (check-in) вашего файла с помощью команды <blockquote>ci</blockquote> для сохранения его текущей версии.</p>     <p><blockquote>$ <b>ci important.с</b></blockquote></p>     <p><blockquote>important.c,v &lt;-- important.c</blockquote></p>     <p><blockquote>initial revision: 1.1</blockquote></p>     <p><blockquote>done</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Если вы забыли выполнить первой команду <blockquote>rcs -i</blockquote>, RCS запросит описание файла. Если теперь заглянуть в каталог, то можно увидеть, что файл important.c удален.</p>     <p><blockquote>$ ls -l</blockquote></p>     <p><blockquote>-r--r--r-- 1 neil users 443 2007-07-07 07:54 important.с,v</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Содержимое файла и управляющая информация хранятся в RCS-файле important.c,v.</p>     <b>Команда<i> со</i></b>     <p>Если вы хотите изменить файл, прежде всего его надо извлечь (check out). Если нужно просто прочитать файл, можно применить команду со для повторного создания текущей версии файла и изменения ее прав доступа на read-only (только чтение). Если же файл нужно редактировать, следует<i> заблокировать</i> файл с помощью команды <blockquote>со -l</blockquote>. Причина заключается в том, что в командных проектах важно быть уверенным в том, что в определенный момент времени только один человек корректирует данный файл. Вот почему только у одной копии данной версии файла есть право на запись. Когда файл извлечен в каталог с правом на запись, RCS-файл блокируется. Заблокируйте копию файла</p>     <p><blockquote>$ <b>со -l important.c</b></blockquote></p>     <p><blockquote>important.с,v --&gt; important.c</blockquote></p>     <p><blockquote>revision 1.1 (locked) done</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>и загляните в каталог:</p>     <p><blockquote>$ <b>ls -l</b></blockquote></p>     <p><blockquote>-rw-r--r-- 1 neil users 225 2007-07-09 07:55 important.c</blockquote></p>     <p><blockquote>-r--r--r-- 1 neil users 453 2007-07-09 07:55 important.с,v</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Теперь у вас появился файл для редактирования и внесения новых изменений. Выполните корректировку, сохраните новую версию и используйте команду <blockquote>ci</blockquote> еще раз для сохранения изменений. Секция вывода в файле important.c теперь следующая:</p>     <p><blockquote>printf("Hello World\n");</blockquote></p>     <p><blockquote>printf("This is an extra line added later\n");</blockquote></p>     <p>Примените <blockquote>ci</blockquote> следующим образом:</p>     <p><blockquote>$ <b>ci important.с</b></blockquote></p>     <p><blockquote>important.с,v &lt;-- important.c</blockquote></p>     <p><blockquote>new revision: 1.2;</blockquote></p>     <p><blockquote>previous revision: 1.1</blockquote></p>     <p><blockquote>enter log message, terminated with single or end of file:</blockquote></p>     <p><blockquote>&gt;&gt; <b>Added an extra line to be printed out.</b></blockquote></p>     <p><blockquote>&gt;&gt; <b>.</b></blockquote></p>     <p><blockquote>done</blockquote></p>     <p><blockquote>$</blockquote></p>     <blockquote>      <b>Примечание</b>      <p>Для записи изменений и сохранения блокировки, разрешающей пользователю продолжить работу с файлом, следует вызвать команду <blockquote>ci</blockquote> с опцией <blockquote>-l</blockquote>. Файл будет автоматически снова извлечен в каталог для того же самого пользователя.</p>     </blockquote>     <p>Вы сохранили обновленную версию файла. Если сейчас заглянуть в каталог, можно увидеть, что файл important.c снова удален.</p>     <p><blockquote>$ <b>ls -l</b></blockquote></p>     <p><blockquote>-r--r--r-- 1 neil users 635 2007-07-09 07:55 important.с,v</blockquote></p>     <p><blockquote>$</blockquote></p>     <b>Команда<i> rlog</i></b>     <p>Часто бывает полезно просмотреть сводку изменений, внесенных в файл. Сделать это можно с помощью команды <blockquote>rlog</blockquote>.</p>     <p><blockquote>$ <b>rlog important.с</b></blockquote></p>     <p><blockquote>RCS file: important.c,v</blockquote></p>     <p><blockquote>Working file: important.c</blockquote></p>     <p><blockquote>head: 1.2</blockquote></p>     <p><blockquote>branch:</blockquote></p>     <p><blockquote>locks: strict</blockquote></p>     <p><blockquote>access list:</blockquote></p>     <p><blockquote>symbolic names:</blockquote></p>     <p><blockquote>keyword substitution: kv</blockquote></p>     <p><blockquote>total revisions: 2; selected revisions: 2</blockquote></p>     <p><blockquote>description:</blockquote></p>     <p><blockquote>This is an important demonstration file</blockquote></p>     <p><blockquote>------------------------</blockquote></p>     <p><blockquote>revision 1.2</blockquote></p>     <p><blockquote>date: 2007/07/09 06:57:33; author: neil; state: Exp; lines: +1 -0</blockquote></p>     <p><blockquote>Added an extra line to be printed out.</blockquote></p>     <p><blockquote>------------------------</blockquote></p>     <p><blockquote>revision 1.1</blockquote></p>     <p><blockquote>date: 2007/07/09 06:54:36; author: neil; state: Exp;</blockquote></p>     <p><blockquote>Initial revision</blockquote></p>     <p><blockquote>==================================================================</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>В первой части дается описание файла и опций, используемых командой <blockquote>rcs</blockquote>. Далее команда <blockquote>rlog</blockquote> перечисляет версии файла, начиная с самой свежей, вместе с текстом, который вы вводите при сохранении версии. <blockquote>lines:+1-0</blockquote> в версии 1.2 информирует вас о том, что была вставлена одна строка и ни одна строка не была удалена.</p>     <blockquote>      <b>Примечание</b>      <p>Учтите, что время модификации файла записывается без учета летнего времени, чтобы избежать проблем при переводе часов.</p>     </blockquote>     <p>Теперь, если вы хотите вернуть первую версию файла, можно запросить команду <blockquote>со</blockquote>, указав нужную версию.</p>     <p><blockquote>$ <b>со -r1.1 important.c</b></blockquote></p>     <p><blockquote>important.с,v --&gt; important.c</blockquote></p>     <p><blockquote>revision 1.1</blockquote></p>     <p><blockquote>done</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>У команды <blockquote>ci</blockquote> тоже есть опция <blockquote>-r</blockquote>, которая присваивает номеру версии заданное значение. Например, команда</p>     <p><blockquote>ci -r2 important.c</blockquote></p>     <p>сохранит файл important.c как версию 2.1. Обе системы, RCS и SCCS, по умолчанию используют 1 как наименьший номер версии.</p>     <b>Команда <i>rcsdiff</i></b>     <p>Если вы хотите знать, чем отличаются две версии, можно применить команду <blockquote>rcsdiff</blockquote>:</p>     <p><blockquote>$ <b>rcsdiff -r1.1 -r1.2 important.c</b></blockquote></p>     <p><blockquote>=================================================</blockquote></p>     <p><blockquote>RCS file: important.c,v</blockquote></p>     <p><blockquote>retrieving revision 1.1</blockquote></p>     <p><blockquote>retrieving revision 1.2</blockquote></p>     <p><blockquote>diff -r1.1 -r1.2</blockquote></p>     <p><blockquote>11a12</blockquote></p>     <p><blockquote>&gt; printf("This is an extra line added later\n");</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Вывод информирует вас о том, что была добавлена одна строка после исходной строки 11.</p>     <b>Обозначение версий</b>     <p>Система RCS может применять специальные строки (макросы) внутри исходного файла, помогающие отслеживать изменения. Наиболее популярны два макроса: <blockquote>$RCSfile$</blockquote> и <blockquote>$Id$</blockquote>. Макрос <blockquote>$RCSfile$</blockquote> замещается именем файла, а макрос <blockquote>$Id$</blockquote> — строкой, обозначающей версию. Полный список поддерживаемых специальных строк можно найти в интерактивном руководстве. Макросы замещаются, когда версия файла извлекается из RCS-файла, и обновляются автоматически, когда версия регистрируется и сохраняется в RCS-файле.</p>     <p>Давайте в третий раз изменим файл и добавим несколько таких макросов:</p>     <p><blockquote>$ <b>со -l important.с</b></blockquote></p>     <p><blockquote>important.c,v --&gt; important.с</blockquote></p>     <p><blockquote>revision 1.2 (locked)</blockquote></p>     <p><blockquote>done</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Отредактируйте файл в соответствии с приведенным далее кодом:</p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <br>     <p><blockquote>/*</blockquote></p>     <p><blockquote> Это важный файл для управления данным проектом.</blockquote></p>     <p><blockquote> В нем реализована каноническая программа "Hello World".</blockquote></p>     <p><blockquote> Filename: $RCSfile$</blockquote></p>     <p><blockquote>*/</blockquote></p>     <p><blockquote>static char *RCSinfo = "$Id$";</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> printf ("Hello World\n");</blockquote></p>     <p><blockquote> printf("This is an extra line added later\n");</blockquote></p>     <p><blockquote> printf("This file is under RCS control. Its ID is\n%s\n", RCSinfo);</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Теперь сохраните эту версию и посмотрите, как RCS управляет специальными строками:</p>     <p><blockquote>$ <b>ci important.с</b></blockquote></p>     <p><blockquote>important.с,v &lt;-- important.c</blockquote></p>     <p><blockquote>new revision: 1.3;</blockquote></p>     <p><blockquote>previous revision: 1.2</blockquote></p>     <p><blockquote>enter log message, terminated with single '.' or end of file:</blockquote></p>     <p><blockquote>&gt;&gt; <b>Added $RCSfile$ and $Id$ strings</b></blockquote></p>     <p><blockquote>&gt;&gt; <b>.</b></blockquote></p>     <p><blockquote>done</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Если заглянете в каталог, то найдете только RCS-файл.</p>     <p><blockquote>$ <b>ls -l</b></blockquote></p>     <p><blockquote>-r--r--r-- 1 neil users 907 2007-07-09 08:07 important.с,v</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Если вы извлечете текущую версию исходного файла (с помощью команды <blockquote>со</blockquote>) и просмотрите его, то увидите, что макросы раскрыты:</p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <br>     <p><blockquote>/*</blockquote></p>     <p><blockquote> Это важный файл для управления данным проектом.</blockquote></p>     <p><blockquote> В нем реализована каноническая программа "Hello World".</blockquote></p>     <p><blockquote> Filename: $RCSfile: important.с,v $</blockquote></p>     <p><blockquote><i>*/</i></blockquote></p>     <p><blockquote>static char *RCSinfo = "$Id: important.c,v 1.3 2007/07/09. 07:07:08 neil Exp $";</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> printf("Hello World\n");</blockquote></p>     <p><blockquote> printf("This is an extra line added later\n");</blockquote></p>     <p><blockquote> printf("This file is under RCS control. Its ID is\n%s\n", RCSinfo);</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>А теперь выполните упражнение 9.6.</p>     <b>Упражнение 9.6. GNU-версия <blockquote>make</blockquote> с RCS</b>     <p>У команды <blockquote>make</blockquote> версии GNU есть несколько встроенных правил для управления RCS-файлами. В этом примере вы увидите, как работать с отсутствующим исходным файлом.</p>     <p><blockquote>$ <b>rm -f important.с</b></blockquote></p>     <p><blockquote>$ <b>make important</b></blockquote></p>     <p><blockquote>со important.с,v important.c</blockquote></p>     <p><blockquote>important.с,v --&gt; important.c</blockquote></p>     <p><blockquote>revision 1.3</blockquote></p>     <p><blockquote>done</blockquote></p>     <p><blockquote>сс -c important.c -o important.о сс important.о -о important</blockquote></p>     <p><blockquote>rm important.о important.с</blockquote></p>     <p><blockquote>$</blockquote></p>     <p><b>Как это работает</b></p>     <p>У команды <blockquote>make</blockquote> есть стандартное правило для создания файла без расширения с помощью компиляции файла с тем же именем и расширением с. Второе стандартное правило разрешает <blockquote>make</blockquote> создать файл important.c из файла important.c,v, используя RCS. Поскольку нет файла с именем important.c, команда <blockquote>make</blockquote> создала файл с расширением с, получив последнюю версию файла с помощью команды <blockquote>со</blockquote>. После компиляции она навела порядок, удалив файл important.c.</p>     <b>Команда<i> ident</i></b>     <p>Команду <blockquote>ident</blockquote> можно применять для поиска версии файла, которая содержит строку <blockquote>$Id$</blockquote>. Поскольку вы сохранили строку в переменной, она появляется и в результирующем исполняемом файле. Может оказаться так, что, если вы включили специальные строки в исходный код, но никогда не обращаетесь к ним, компилятор из соображений оптимизации удалит их. Эту проблему можно обойти, добавив в исходный код несколько фиктивных обращений к ним, хотя по мере улучшения компиляторов делать это становится все труднее!</p>     <p>Далее показан простой пример того, как можно использовать команду <blockquote>ident</blockquote> для двойной проверки RCS-версии исходного файла, применяемого для формирования исполняемого файла (упражнение 9.7).</p>     <b>Упражнение 9.7. Команда <blockquote>ident</blockquote></b>     <p><blockquote>$ <b>./important</b></blockquote></p>     <p><blockquote>Hello World</blockquote></p>     <p><blockquote>This is an extra line added later</blockquote></p>     <p><blockquote>This file is under RCS control. Its ID is</blockquote></p>     <p><blockquote>$Id: important.c,v 1.3 2007/07/09 07:07:08 neil Exp $</blockquote></p>     <p><blockquote>$ <b>ident important</b></blockquote></p>     <p><blockquote>important:</blockquote></p>     <p><blockquote>$Id: important.c,v 1.3 2007/07/09 07 :07 :08 neil Exp $</blockquote></p>     <p><blockquote>$</blockquote></p>     <p><b>Как это работает</b></p>     <p>Выполняя программу, вы показываете строку, включенную в исполняемый файл. Далее вы демонстрируете, как команда <blockquote>ident</blockquote> может извлечь из исполняемого файла строки вида <blockquote>$Id$</blockquote>.</p>     <p>Этот метод применения RCS и строк вида <blockquote>$Id$</blockquote>, включаемых в исполняемые файлы, может быть очень мощным средством определения версии файла, содержащей ошибку, о которой сообщил пользователь. RCS-файлы (или SCCS) можно применять как часть средства отслеживания в проекте проблем, о которых сообщается, и способов их устранения. Если вы продаете программное обеспечение или даже отдаете его бесплатно, очень важно знать, что изменилось между двумя выпущенными версиями.</p>     <p>Если вас интересует дополнительная информация, на странице <blockquote>rcsintro</blockquote> интерактивного руководства в дополнение к стандартному руководству по RCS приведено введение в систему RCS. В него также включены страницы, посвященные отдельным командам, таким как <blockquote>ci</blockquote>, <blockquote>со</blockquote> и т.д.</p>             <a name="metkadoc16"><h1>SCCS</h1></a>     <p>Система SCCS предлагает средства, очень похожие на средства системы RCS. Преимущество системы SCCS лишь в том, что она определена в стандарте X/Open, поэтому все версии UNIX известных производителей должны ее поддерживать. С практической точки зрения система RCS предпочтительнее, она легко переносится на разные платформы и распространяется бесплатно. Поэтому, если у вас UNIX-подобная система, независимо от ее отображения на стандарт X/Open, вы сможете получить для нее и установить в ней систему RCS. По этой причине мы не будем описывать далее в книге систему SCCS, лишь приведем краткое сравнение команд, имеющих аналоги в обеих системах.</p>             <a name="metkadoc17"><h1>Сравнение RCS и SCCS</h1></a>     <p>Трудно провести прямую аналогию между командами двух систем, поэтому табл. 9.2 следует рассматривать как краткий указатель. У команд, перечисленных в таблице, разные опции для выполнения одних и тех же задач. Если вы должны применять систему SCCS, следует найти соответствующие опции, но, по крайней мере, вы будете знать, где их искать.</p>     <br>     <p><b><i>Таблица 9.2</i></b></p>     <table>      <tr>       <th valign="top">RCS</th>       <th valign="top">SCCS</th>      </tr>      <tr>       <td valign="top"><blockquote>rcs</blockquote></td>       <td valign="top"><blockquote>admin</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>ci</blockquote></td>       <td valign="top"><blockquote>delta</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>со</blockquote></td>       <td valign="top"><blockquote>get</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>rcsdiff</blockquote></td>       <td valign="top"><blockquote>sccsdiff</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>ident</blockquote></td>       <td valign="top"><blockquote>what</blockquote></td>      </tr>     </table>     <p>В дополнение к только что перечисленным командам у команды <blockquote>sссs</blockquote> одноименной системы есть некоторое пересечение с командами <blockquote>rcs</blockquote> и <blockquote>со</blockquote> системы RCS. Например, команды <blockquote>sссs edit</blockquote> и <blockquote>sссs create</blockquote> эквивалентны командам <blockquote>со -l</blockquote> и <blockquote>rcs -i</blockquote> соответственно.</p>             <a name="metkadoc18"><h1>CVS</h1></a>     <p>Альтернатива применения системы RCS для управления изменениями в файлах — система CVS, которая означает<i> Concurrent Versions System</i> (система параллельных версий). CVS стала очень популярной, может быть, потому, что у нее есть одно явное преимущество по сравнению с системой RCS: на практике CVS используется в Интернете, а не только в совместно используемом локальном каталоге как RCS. В системе CVS также разрешены параллельные разработки, т. е. многие программисты могут работать с одним и тем же файлом одновременно, в то время как RCS разрешает лишь одному пользователю работать с конкретным файлом в определенный момент времени. Команды CVS похожи на команды RCS, поскольку первоначально CVS была разработана как внешний интерфейс RCS.</p>     <p>Поскольку она способна гибко функционировать в сети, система CVS подходит для применения в тех случаях, когда у разработчиков есть единственная связь — через Интернет. Многие проекты Linux и GNU используют систему CVS, чтобы помочь разработчикам координировать их работу. В основном использование CVS для управления удаленными файлами аналогично применению системы для обработки локальных файлов.</p>     <p>В этой главе мы кратко рассмотрим основы системы CVS, чтобы вы могли начать работать с локальными репозитариями и понимали, как получить копию самых свежих исходных файлов проекта, если сервер CVS доступен в Интернете. Дополнительная информация хранится в руководстве по CVS, написанном Пером Седерквистом (Per Cederqvist) и др. и доступном по адресу <b>http://ximbiot.com/cvs/manual/,</b> там вы найдете файлы FAQ (часто задаваемые вопросы) и другие полезные файлы.</p>     <p>Прежде всего, вы должны создать репозитарий или хранилище, в котором CVS будет хранить свои управляющие файлы и основные копии файлов, управляемые ею. У репозитария древовидная структура, поэтому можно применять один репозитарий для хранения целиком всей структуры каталогов, предназначенных не только для одного проекта, но и для нескольких проектов. Для несвязанных проектов можно использовать и отдельные репозитарий. В следующих разделах вы увидите, как сообщить системе CVS о том, какой репозитарий применять.</p>     <b>Локальное использование CVS</b>     <p>Начните с создания репозитария. Для простоты пусть это будет локальный репозитарий, и поскольку вы будете использовать только один, удобно поместить его в каталог /usr/local. В большинстве дистрибутивов Linux все обычные пользователи являются членами группы users, поэтому примените ее как группу репозитария, чтобы у всех пользователей был доступ к нему.</p>     <p>Как суперпользователь создайте каталог для репозитария:</p>     <p><blockquote># <b>mkdir /usr/local/repository</b></blockquote></p>     <p><blockquote># <b>chgrp users /usr/local/repository</b></blockquote></p>     <p><blockquote># <b>chmod g+w /usr/local/repository</b></blockquote></p>     <p>И превратившись снова в обычного пользователя, инициализируйте его как репозитарий CVS. У вас должно быть право на запись в каталог usr/local/repository, если вы не входите в группу обычных пользователей.</p>     <p><blockquote>$ <b>cvs -d /usr/local/repository init</b></blockquote></p>     <p>Опция <blockquote>-d</blockquote> информирует CVS о том, где вы хотите создать репозитарий.</p>     <p>После создания репозитария можно сохранить начальные версии файлов проекта в системе CVS. Но в этот момент можно сэкономить на наборе. У всех команд <blockquote>cvs</blockquote> есть два способа поиска каталога системы CVS. Во-первых, они ищут опцию <blockquote>-d &lt;<i>путь</i>&gt;</blockquote> в командной строке (как и в команде <blockquote>init</blockquote>), если опций <blockquote>-d</blockquote> нет, ищется переменная окружения <blockquote>CVSROOT</blockquote>. Вместо постоянного применения опции -а вы задаете переменную окружения. Приведенную далее команду можно использовать, если в качестве командной оболочки вы применяете bash:</p>     <p><blockquote>$ <b>export CVSROOT=/usr/local/repository</b></blockquote></p>     <p>Прежде всего, вы изменяете каталог, в котором находится проект; далее вы сообщаете CVS о необходимости импортировать все файлы проекта в этот каталог. Для системы CVS проект — это любая коллекция связанных файлов и каталогов. Обычно она включает все файлы, необходимые для создания приложения. Термин <i>"импорт"</i> означает передачу всех файлов под контроль системы CVS и копирование их в CVS-репозитарий. В данном примере у вас есть каталог cvs-sp (простой проект CVS), содержащий два файла — hello.c и Makefile.</p>     <p><blockquote>$ <b>cd cvs-sp</b></blockquote></p>     <p><blockquote>$ <b>ls -l</b></blockquote></p>     <p><blockquote>-rw-r--r-- 1 neil users 68  2003-02-15 11:07 Makefile</blockquote></p>     <p><blockquote>-rw-r--r-- 1 neil users 109 2003-02-15 11:04 hello.c</blockquote></p>     <p>Команда импорта в CVS (<blockquote>cvs import</blockquote>) применяется следующим образом: </p>     <p><blockquote>$ <b>cvs import -m"Initial version of Simple Project" wrox/chap9-cvs wrox start</b></blockquote></p>     <p>Это заклинание заставляет CVS импортировать все файлы в текущий каталог (cvs-sp) и передает системе регистрационное сообщение (log message).</p>     <p>Аргумент <blockquote>wrox/chap9-cvs</blockquote> информирует CVS о том, где относительно корня дерева CVS сохранять новый проект. Напоминаем, что при желании в одном репозитарии можно хранить несколько проектов. Параметр <blockquote>wrox</blockquote> — тег поставщика, применяемый для идентификации автора первоначальной версии импортируемых файлов, а <blockquote>start</blockquote> — тег версии. Теги версии можно применять для идентификации в виде группы наборов связанных файлов, создающих конкретную версию приложения. Система CVS отвечает строками</p>     <p><blockquote>N wrox/chap9-cvs/hello.c</blockquote></p>     <p><blockquote>N wrox/chap9-cvs/Makefile</blockquote></p>     <p><blockquote>Nо conflicts created by this import</blockquote></p>     <p>информируя вас о том, что два файла импортированы корректно.</p>     <p>Сейчас самое время проверить возможность извлечения ваших файлов из системы CVS. Вы можете создать каталог junk и вернуть в него файлы, чтобы убедиться в том, что все нормально:</p>     <p><blockquote>$ <b>mkdir junk</b></blockquote></p>     <p><blockquote>$ <b>cd junk</b></blockquote></p>     <p><blockquote>$ <b>cvs checkout wrox/chap9-cvs</b></blockquote></p>     <p><blockquote>U wrox/chap9-cvs/Makefile</blockquote></p>     <p><blockquote>U wrox/chap9-cvs/hello.с</blockquote></p>     <p>Вы указываете CVS тот же путь, что и при копировании файлов в репозитарий. Система CVS создает в текущем каталоге каталог wrox/chap9-cvs и помещает туда файлы.</p>     <p>Теперь вы готовы внести некоторые изменения в ваш проект. Отредактируйте файл hello.c в каталоге wrox/chap9-cvs, вставив в него строку</p>     <p><blockquote>printf("Have a nice day\n");</blockquote></p>     <p>Затем откомпилируйте заново и выполните программу, чтобы убедиться в том, что все в порядке:</p>     <p><blockquote>$ <b>make</b></blockquote></p>     <p><blockquote>сс hello.c -о hello</blockquote></p>     <p><blockquote>$ <b>./hello</b></blockquote></p>     <p><blockquote>Hello World</blockquote></p>     <p><blockquote>Have a nice day</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Вы можете спросить у системы CVS о том, что изменилось в проекте. Не нужно сообщать CVS, какой именно файл вас интересует, она может работать со всем каталогом одновременно.</p>     <p><blockquote>$ <b>cvs diff</b></blockquote></p>     <p>CVS отвечает следующими строками:</p>     <p><blockquote>cvs diff: Diffing</blockquote></p>     <p><blockquote>Index: hello.c</blockquote></p>     <p><blockquote>========================================================</blockquote></p>     <p><blockquote>RCS file: /usr/local/repository/wrox/chap9-cvs/hello.c,v</blockquote></p>     <p><blockquote>retrieving revision 1.1.1.1</blockquote></p>     <p><blockquote>diff -r1.1.1.1 hello.c</blockquote></p>     <p><blockquote>6a7</blockquote></p>     <p><blockquote>&gt; printf("Have a nice day\n");</blockquote></p>     <p>Вы довольны внесенным изменением и хотите зафиксировать его в CVS.</p>     <p>Когда вы фиксируете изменение с помощью системы CVS, она запускает редактор, позволяющий вам ввести регистрационное сообщение. У вас есть возможность задать переменную окружения <blockquote>CVSEDITOR</blockquote> для запуска определенного редактора перед выполнением команды <blockquote>commit</blockquote>:</p>     <p><blockquote>$ <b>cvs commit</b></blockquote></p>     <p>CVS сообщает о том, что она сохраняет:</p>     <p><blockquote>cvs commit: Examining</blockquote></p>     <p><blockquote>Checking in hello.c;</blockquote></p>     <p><blockquote>/usr/local/repository/wrox/chap9-cvs/hello.c,v &lt;-- hello.c</blockquote></p>     <p><blockquote>new revision: 1.2; previous revision: 1.1</blockquote></p>     <p><blockquote>done</blockquote></p>     <p>Теперь вы можете запросить систему CVS об изменениях в проекте со времени его первого сохранения в репозитарии. Запросите набор изменений в каталоге wrox/chap9-cvs, начиная с версии 1.1 (начальная версия):</p>     <p><blockquote>$ <b>cvs rdiff -r1.1 wrox/chap9-cvs</b></blockquote></p>     <p>Система CVS сообщает следующие подробности:</p>     <p><blockquote>cvs rdiff: Diffing wrox/chap9-cvs</blockquote></p>     <p><blockquote>Index: wrox/chap9-cvs/hello.c</blockquote></p>     <p><blockquote>diff -с wrox/chap9-cvs/hello.с:1.1 wrox/chap9-cvs/hello.с:1.2</blockquote></p>     <p><blockquote>*** wrox/chap9-cvs/hello.с:1.1 Mon Jul 9 09:37:13 2007</blockquote></p>     <p><blockquote>--- wrox/chap9-cvs/hello.с Mon Jul 9 09:44:36 2007</blockquote></p>     <p><blockquote>************</blockquote></p>     <p><blockquote>*** 4,8 ****</blockquote></p>     <p><blockquote>--- 4,9 ---</blockquote></p>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> printf("Hello World\n");</blockquote></p>     <p><blockquote>+ printf("Have a nice day\n");</blockquote></p>     <p><blockquote> exit (EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Предположим, что у вас есть копия, извлеченная из системы CVS в локальный каталог на время, и вы хотите обновить файлы в вашем локальном каталоге, которые корректировались другими пользователями, а вы сами их не редактировали. CVS может сделать это для вас, применив команду <blockquote>update</blockquote>. Перейдите на верхний уровень пути, в данном случае в каталог, содержащий каталог wrox, и выполните следующую команду:</p>     <p><blockquote>$ <b>cvs update -Pd wrox/chap9-cv3</b></blockquote></p>     <p>CVS обновит файлы, извлекая из репозитария файлы, измененные другими пользователями, а не вами, и помещая их в ваш локальный каталог. Конечно, некоторые изменения могут оказаться несовместимыми с вашими, но это проблема, над которой вам придется потрудиться. Система CVS хороша, но она не умеет творить чудеса!</p>     <p>К этому моменту вы уже увидели, что использование CVS очень похоже на применение RCS. Но у нее есть существенное отличие, о котором мы пока не. упоминали, — способность функционировать в сети без смонтированной файловой системы.</p>     <b>Доступ к CVS по сети</b>     <p>Вы сообщили системе CVS, где находится репозитарий, применяя опцию <blockquote>-d</blockquote> в каждой команде или установив переменную окружения <blockquote>CVSROOT</blockquote>. Если вы хотите действовать через сеть, то просто используете расширенную синтаксическую запись для этого параметра. Например, во время написания книги все исходные файлы разработки GNOME (GNU Network Object Model Environment, сетевая объектная среда GNU — популярная графическая настольная система с открытым исходным кодом) были доступны в Интернете благодаря системе CVS. Вам нужно только задать месторасположение подходящего CVS-репозитария, указав некоторую сетевую информацию перед спецификатором пути к нему.</p>     <p>Другим примером может служить указание на CVS-репозитарий Web-стандартов консорциума W3C, значение переменной <blockquote>CVSROOT</blockquote> при этом должно быть равно <blockquote>:pserver:anonymous@dev.w3.org:/sources/public</blockquote>. Оно информирует систему CVS о том, что для доступа к репозитарию применяется аутентификация (pserver) с паролем и что репозитарий находится на сервере по адресу<b> dev.w3.org.</b></p>     <p>Прежде чем получить доступ к исходным файлам, следует зарегистрироваться следующим образом:</p>     <p><blockquote>$ <b>export CVSROOT=:pserver:anonymous@dev.w3.org:/sources/public</b></blockquote></p>     <p><blockquote>$ <b>cvs login</b></blockquote></p>     <p>Когда появится приглашение для ввода пароля, введите <blockquote>anonymous</blockquote>.</p>     <p>Теперь вы готовы применять команды cvs во многом так же, как при работе с локальным каталогом, за исключением того, что следует добавлять опцию <blockquote>-z3</blockquote> ко всем командам <blockquote>cvs</blockquote>, чтобы добиться сжатия для экономии полосы пропускания сети.</p>     <p>Если вы хотите получить исходные файлы HTML-валидатора W3C (системы проверки допустимости HTML-файлов), наберите приведенную далее команду:</p>     <p><blockquote>$ <b>cvs -z3 checkout validator</b></blockquote></p>     <p>Если хотите сделать доступным в сети собственный репозитарий, необходимо запустить CVS-сервер на своей машине. Сделать это следует с помощью супердемона <blockquote>xinetd</blockquote> или <blockquote>inetd</blockquote> в зависимости от конфигурации вашей ОС Linux. Для применения <blockquote>хinetd</blockquote> отредактируйте файл /etp/xinetd.d/cvs, указав в нем местоположение CVS-репозитария, и воспользуйтесь средством настройки системы для активизации и запуска сервиса cvs. Для применения супердемона <blockquote>inetd</blockquote> просто добавьте строку в файл etc/inetd.conf и перезапустите <blockquote>inetd</blockquote>. Далее приведена необходимая строка:</p>     <p><blockquote>2401 stream tcp nowait root /usr/bin/cvs cvs -b /usr/bin --allow-root=/usr/local/repository pserver</blockquote></p>     <p>Она информирует <blockquote>inetd</blockquote> об автоматическом запуске CVS-сеанса для клиентов, подключающихся к порту 2401, стандартному порту CVS-сервера. Дополнительную информацию о запуске сетевых сервисов с помощью супердемона <blockquote>inetd</blockquote> см. в интерактивном справочном руководстве к <blockquote>inetd</blockquote> и inetd.conf.</p>     <p>Для использования системы CVS с вашим репозитарием и сетевым доступом к нему вы должны задать соответствующее значение переменной окружения <blockquote>CVSROOT</blockquote>. Например,</p>     <p><blockquote>$ <b>export CVSFOOT=:pserver:neil@localhost:/usr/local/repository</b></blockquote></p>     <p>В этом коротком разделе мы смогли дать лишь поверхностное описание функциональных возможностей системы CVS. Если вы хотите основательно познакомиться с этой системой, настоятельно рекомендуем установить локальный репозитарий для экспериментов, найти расширенную документацию по CVS и получать удовольствие! Помните, что это система с открытым кодом, поэтому, если вы столкнулись с непонятными действиями программы или (что невероятно, но возможно) думаете, что обнаружили ошибку, всегда можно получить исходный программный код и изучить его самостоятельно. Начальная страница CVS расположена по адресу <b>http://ximbiot.com/cvs/cvshome/</b>.</p>     <b>Внешние интерфейсы CVS</b>     <p>Для доступа к CVS-репозитариям существует множество графических внешних интерфейсов. Может быть, их лучшую коллекцию для разных операционных систем можно найти на Web-сайте <b>http://www.wincvs.org/.</b> Там есть клиентское программное обеспечение для ОС Windows, Macintosh и, конечно, Linux.</p>     <p>Клиентская часть CVS позволяет создавать репозитарий и управлять им, включая удаленный доступ к репозитариям по сети.</p>     <p>На рис. 9.1 показана хронология работы с нашим простым приложением, отображенная WinCVS на сетевом клиенте под управлением ОС Windows.</p>     <img src="image034.jpg"/>     <p><b>Рис. 9.1</b></p>             <a name="metkadoc19"><h1>Subversion</h1></a>     <p>Subversion разработана как система управления версиями, представляющая собой отличную замену системы CVS в сообществе разработчиков и пользователей программного обеспечения с открытым исходным кодом. Она проектировалась как "улучшенная CVS", о чем говорится на исходной странице Subversion Web-сайта <b>http://subversion.tigris.org/,</b> и, следовательно, обладает большей частью функциональных возможностей системы CVS и очень похожим работающим интерфейсом.</p>     <p>Популярность Subversion определенно растет, особенно в среде совместно разрабатываемых проектов, в которых над созданием приложения многие программисты работают вместе в Интернете. Большинство пользователей Subversion подключаются к сетевому репозитарию, настроенному менеджерами, разрабатываемого проекта. Эта система не так широко используется для управления индивидуальными или небольшими групповыми проектами, для них система CVS все еще остается основным применяемым средством.</p>     <p>В табл. 9.3 сравниваются основные команды в системах CVS и Subversion, эквивалентные друг другу.</p>     <br>     <p><b><i>Таблица 9.3</i></b></p>     <table>      <tr>       <th valign="top">CVS</th>       <th valign="top">Subversion</th>      </tr>      <tr>       <td valign="top"><blockquote>cvs -d /usr/local/repository init</blockquote></td>       <td valign="top"><blockquote>svnadmin create /usr/local/repository</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>cvs import wrox/chap9-cvs</blockquote></td>       <td valign="top"><blockquote>svn import cvs-sp file:///usr/local/repository/trunk</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>cvs checkout wrox/chap9-cvs</blockquote></td>       <td valign="top"><blockquote>svn checkout file:///usr/local/repository/trunk cvs-sp</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>cvs diff</blockquote></td>       <td valign="top"><blockquote>svn diff</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>cvs rdiff</blockquote></td>       <td valign="top"><blockquote>svn diff tag1 tag2</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>cvs update</blockquote></td>       <td valign="top"><blockquote>svn status -u</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>cvs commit</blockquote></td>       <td valign="top"><blockquote>svn commit</blockquote></td>      </tr>     </table>     <p>Полную документацию системы Subversion см. в интерактивной книге "Version Control with Subversion" ("Управление версиями с помощью Subversion") на Web-сайте <b>http://svnbook.red-bean.com/.</b></p>              <a name="metkadoc20"><h1>Написание интерактивного справочного руководства</h1></a>    <p>Если вы как часть задачи разрабатываете новую команду, вам следует создать интерактивное справочное руководство, описывающее ее работу. Как вы уже вероятно заметили, макет большинства страниц такого руководства следует жестко заданному шаблону следующего вида:</p>    <p>&#9633; Header (Заголовок);</p>    <p>&#9633; Name (Имя);</p>    <p>&#9633; Synopsis (Краткий обзор);</p>    <p>&#9633; Description (Описание);</p>    <p>&#9633; Options (Опции);</p>    <p>&#9633; Files (Файлы);</p>    <p>&#9633; See also (См. также);</p>    <p>&#9633; Bugs (Ошибки).</p>    <p>Вы можете пропустить разделы, которые не важны. Часто в конце справочного руководства появляется раздел "Author" (Автор).</p>    <p>Страницы справочного руководства в системах UNIX форматируются утилитой <blockquote>nroff</blockquote> или, как в большинстве систем Linux эквивалентом проекта GNU, утилитой <blockquote>groff</blockquote>. Обе они — разработки на основе более ранней команды <blockquote>roff</blockquote> или <blockquote>run-off</blockquote>. Вход утилиты <blockquote>nroff</blockquote> или <blockquote>groff</blockquote> — обычный текстовый файл за исключением того, что на первый взгляд синтаксис его непостижимо труден.</p>    <p>Без паники! Самый легкий способ написания новой программы в среде UNIX — начать с уже имеющейся программы и приспособить ее для своих целей, так же нужно поступать и с интерактивным справочным руководством.</p>    <p>В задачу данной книги не входит подробное объяснение множества опций, команд и макросов, которые может применять команда <blockquote>groff</blockquote> (или <blockquote>nroff</blockquote>). Вместо этого мы представляем простой шаблон, который вы можете позаимствовать и переделать в интерактивное справочное руководство для своего приложения.</p>    <p>Далее приведен исходный код страницы справочного руководства для приложения myapp, хранящийся в файле myapp.1.</p>    <p><blockquote>.TH MYAPP 1</blockquote></p>    <p><blockquote>.SH NAME</blockquote></p>    <p><blockquote>Myapp \- A simple demonstration application that does very little.</blockquote></p>    <p><blockquote>.SH SYNOPSIS</blockquote></p>    <p><blockquote>.В myapp</blockquote></p>    <p><blockquote>[\-option ...]</blockquote></p>    <p><blockquote>.SH DESCRIPTION</blockquote></p>    <p><blockquote>.PP</blockquote></p>    <p><blockquote>\fImyapp\fP is a complete application that does nothing useful.</blockquote></p>    <p><blockquote>.PP</blockquote></p>    <p><blockquote>It was written for demonstration purposes.</blockquote></p>    <p><blockquote>.SH OPTIONS</blockquote></p>    <p><blockquote>.PP</blockquote></p>    <p><blockquote>It doesn't have any, but let's pretend, to make this template complete:</blockquote></p>    <p><blockquote>.TP</blockquote></p>    <p><blockquote>.BI \-option</blockquote></p>    <p><blockquote>If there was an option, it would not be -option.</blockquote></p>    <p><blockquote>.SH RESOURCES</blockquote></p>    <p><blockquote>.PP</blockquote></p>    <p><blockquote>myapp uses almost no resources.</blockquote></p>    <p><blockquote>.SR DIAGNOSTICS</blockquote></p>    <p><blockquote>The program shouldn't output anything, so if you find it doing so there's</blockquote></p>    <p><blockquote>probably something wrong. The return value is zero.</blockquote></p>    <p><blockquote>.SH SEE ALSO</blockquote></p>    <p><blockquote>The only other program we know with this little functionality is the</blockquote></p>    <p><blockquote>ubiquitous hello world application.</blockquote></p>    <p><blockquote>.SH COPYRIGHT</blockquote></p>    <p><blockquote>myapp is Copyright (c) 2007 Wiley Publishing, Inc.</blockquote></p>    <p><blockquote>This program is, free software; you can redistribute it and/or modify</blockquote></p>    <p><blockquote>it under the terms of the GNU General Public License as published by</blockquote></p>    <p><blockquote>the Free Software Foundation; either version 2 of the License, or</blockquote></p>    <p><blockquote>(at your option) any later version.</blockquote></p>    <p><blockquote>This program is distributed in the hope that it will be useful,</blockquote></p>    <p><blockquote>but WITHOUT ANY WARRANTY; without even the implied warranty of</blockquote></p>    <p><blockquote>MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</blockquote></p>    <p><blockquote>GNU General Public License for more details.</blockquote></p>    <p><blockquote>You should have received a copy of the GNU General Public License</blockquote></p>    <p><blockquote>along, with this program; if not, write to the Free Software</blockquote></p>    <p><blockquote>Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 021111307 USA.</blockquote></p>    <p><blockquote>.SH BUGS</blockquote></p>    <p><blockquote>There probably are some, but we don't know what they are yet.</blockquote></p>    <p><blockquote>.SH AUTHORS</blockquote></p>    <p><blockquote>Neil Matthew and Rick Stones</blockquote></p>    <p>Как видите, макрос вводится с помощью точки (.) в начале строки и, как правило, дается в сокращенном виде. 1 в конце первой строки — номер раздела руководства, в который помещается команда. Поскольку команды располагаются в разделе 1, именно туда мы и помещаем наше новое приложение.</p>    <p>Вы сможете сгенерировать собственное интерактивное руководство, изменив приведенную страницу и изучив исходный код других страниц. Можно также посмотреть в архиве на Web-странице <b>http://www.tldp.org/</b> часть Linux Documentation Project (Проект документирования Linux) "Linux Man Page mini-HowTo" ("Краткое руководство по написанию страниц интерактивного руководства в Linux"), написанную Дженс Швейкхардт (Jens Schweikhardt).</p>    <p>Имея исходный текст страницы справочного руководства, можно обработать его утилитой <blockquote>groff</blockquote>. Команда <blockquote>groff</blockquote> обычно формирует текст ASCII (<blockquote>-Tascii</blockquote>) или выходной файл PostScript (<blockquote>-Tps</blockquote>). С помощью опции <blockquote>-man</blockquote> сообщите <blockquote>groff</blockquote>, что это страница интерактивного справочного руководства, и будут загружены специальные макроопределения, относящиеся к страницам интерактивного руководства.</p>    <p><blockquote>$ <b>groff -Tascii -man myapp.1</b></blockquote></p>    <p>У этой команды следующий вывод.</p>    <p><blockquote>MYAPP(1)                                                                 MYAPP(1)</blockquote></p>    <p><blockquote><b>NAME</b></blockquote></p>    <p><blockquote>       Myapp — A simple demonstration application that does very</blockquote></p>    <p><blockquote>       little.</blockquote></p>    <br>    <p><blockquote><b>SYNOPSIS</b></blockquote></p>    <p><blockquote><b>       myapp</b> [-option ...]</blockquote></p>    <br>    <p><blockquote><b>DESCRIPTION</b></blockquote></p>    <p><blockquote>       myapp is a complete application that does nothing useful.</blockquote></p>    <br>    <p><blockquote>       It was written for demonstration purposes.</blockquote></p>    <p><blockquote><b>OPTIONS</b></blockquote></p>    <p><blockquote>       It doesn't have any, but let's pretend, to make this temp-</blockquote></p>    <p><blockquote>       late complete:</blockquote></p>    <br>    <p><blockquote><b>       -option</b></blockquote></p>    <p><blockquote>              If there was an option, it would not be -option.</blockquote></p>    <br>    <p><blockquote><b>RESOURCES</b></blockquote></p>    <p><blockquote>      myapp uses almost no resources.</blockquote></p>    <br>    <p><blockquote><b>DIAGNOSTICS</b></blockquote></p>    <p><blockquote>       The program shouldn't output anything, so if you find it</blockquote></p>    <p><blockquote>       doing so there's probably something wrong. The return</blockquote></p>    <p><blockquote>       value is zero.</blockquote></p>    <br>    <p><blockquote><b>SEE ALSO</b></blockquote></p>    <p><blockquote>       The only other program we know with this little func-</blockquote></p>    <p><blockquote>       tionality is the ubiquitous Hello World application.</blockquote></p>    <br>    <p><blockquote><b>COPYRIGHT</b></blockquote></p>    <p><blockquote>      myapp is Copyright (c) 2007 Wiley Publishing, Inc.</blockquote></p>    <p><blockquote>      This program is free software; you can redistribute it</blockquote></p>    <p><blockquote>      and/or modify it under the terms of the GNU General Public</blockquote></p>    <p><blockquote>      License as published by the Free Software Foundation;</blockquote></p>    <p><blockquote>      either version 2 of the License, or (at your option) any</blockquote></p>    <p><blockquote>      later version.</blockquote></p>    <p><blockquote>      This program is distributed in the hope that it will be</blockquote></p>    <p><blockquote>      useful, but WITHOUT ANY WARRANTY; without even the implied</blockquote></p>    <p><blockquote>      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR</blockquote></p>    <p><blockquote>      PURPOSE. See the GNU General Public License for more</blockquote></p>    <p><blockquote>      details.</blockquote></p>    <br>    <p><blockquote>1</blockquote></p>    <p><blockquote>MYAPP(1)                                                           MYAPP(1)</blockquote></p>    <p><blockquote>       You should have received a copy of the GNU General Public</blockquote></p>    <p><blockquote>       License along with this program; if not, write to the Free</blockquote></p>    <p><blockquote>       Software Foundation, Inc., 59 Temple Place — Suite 330</blockquote></p>    <p><blockquote>       Boston, MA 02111-1307, USA</blockquote></p>    <p><blockquote><b>BUGS</b></blockquote></p>    <p><blockquote>       There probably are some, but we don't know what they are yet.</blockquote></p>    <p><blockquote><b>AUTHORS</b></blockquote></p>    <p><blockquote>       Neil Matthew and Rick Stones</blockquote></p>    <p>Теперь, когда интерактивное руководство протестировано, необходимо указать для него исходный файл. Команда <blockquote>man</blockquote>, показывающая страницы руководства, использует переменную окружения <blockquote>MANPATH</blockquote> для поиска нужных страниц. Вы можете поместить новую страницу в каталог локальных страниц интерактивного руководства или прямо в системный каталог /usr/man/man1.</p>    <p>Когда кто-нибудь в первый раз запросит эту страницу интерактивного справочного руководства, команда <blockquote>man</blockquote> автоматически отформатирует ее и отобразит. Некоторые версии <blockquote>man</blockquote> могут автоматически генерировать и сохранять заранее отформатированные (возможно, сжатые) текстовые ASCII-версии страниц интерактивного справочного руководства, чтобы ускорить в дальнейшем выполнение запросов на вывод одной и той же страницы.</p>          <a name="metkadoc21"><h1>Распространение программного обеспечения</h1></a>         <p>Главная задача, возникающая при распространении программного обеспечения, — гарантия того, что в дистрибутив включены все файлы правильных версий. К счастью, интернет-сообщество программистов выработало ряд очень надежных методов, которые прошли долгий путь, устраняя возникавшие проблемы. К этим методам относятся следующие:</p>     <p>&#9633; создание стандартными средствами, имеющимися на всех машинах с ОС Linux, единого пакета, включающего файлы всех компонентов;</p>     <p>&#9633; правляемая нумерация версий пакетов;</p>     <p>&#9633; соглашение по именованию файлов, требующее включения номера версии в файл пакета, чтобы пользователи могли легко увидеть, с какой версией они работают;</p>     <p>&#9633; применение подкаталогов в пакете, чтобы при извлечении файлов из него они помешались в отдельный каталог, и не возникали сомнения по поводу содержимого пакета.</p>     <p>Эволюция этих методов была направлена на облегчение распространения программ и повышение надежности этого процесса. Легкость установки программы — это другой вопрос, поскольку она зависит от программы и системы, в которой устанавливается программа, но, по крайней мере, вы будете уверены в том, что у вас корректные файлы всех компонентов.</p>             <a name="metkadoc22"><h1>Программа <i>patch</i></h1></a>     <p>Когда программы распространяются, почти неизбежно пользователи обнаруживают в них ошибки или у автора возникает желание внести в программу усовершенствования и обновления. Если авторы распространяют программы в виде двоичных файлов, в этом случае они часто просто отправляют новые версии двоичных файлов. Иногда (всегда чаще, чем хотелось бы) производители просто выпускают новую версию программы, часто с невразумительным описанием этой новой версии и недостаточной информацией о внесенных изменениях.</p>     <p>С другой стороны, отличный выход — распространение вашего программного обеспечения в виде исходного программного кода, это позволит пользователям увидеть, как вы реализовали алгоритмы и как применяли функции. Кроме того, у пользователей появится возможность проконтролировать, что именно делает программа, и повторно использовать фрагменты исходного кода (при условии соблюдения лицензионного соглашения).</p>     <p>Однако при объеме кода ядра Linux, равного десяткам мегабайтов сжатого исходного программного кода, доставка обновленного набора исходных файлов потребует значительных ресурсов при том, что, возможно, реально в новой версии будет изменен лишь небольшой процент этого исходного кода.</p>     <p>К счастью, для решения этой проблемы существует утилита <blockquote>patch</blockquote>. Она была написана Ларри Уоллом (Larry Wall), также автором языка программирования Perl. Команда <blockquote>patch</blockquote> позволяет распространять только различия между двумя версиями, так что любой обладатель файла версии 1 и файла отличий версии 2 от версии 1 сможет применить команду <blockquote>patch</blockquote> для генерации на своей машине версии 2.</p>     <p>Если вы начинаете с файла версии 1</p>     <p><blockquote>This is file one</blockquote></p>     <p><blockquote>line 2</blockquote></p>     <p><blockquote>line 3</blockquote></p>     <p><blockquote>there is no line 4, this is line 5</blockquote></p>     <p><blockquote>line 6</blockquote></p>     <p>и затем создаете версию 2</p>     <p><blockquote>This is file two</blockquote></p>     <p><blockquote>line 2</blockquote></p>     <p><blockquote>line 3</blockquote></p>     <p><blockquote>line 4</blockquote></p>     <p><blockquote>line 5</blockquote></p>     <p><blockquote>line 6</blockquote></p>     <p><blockquote>a new line 8</blockquote></p>     <p>с помощью команды <blockquote>diff</blockquote> можно создать список отличий:</p>     <p><blockquote>$ <b>diff file1.c file2.с &gt; diffs</b></blockquote></p>     <p>Файл diffs содержит следующие строки:</p>     <p><blockquote>1c1</blockquote></p>     <p><blockquote>&lt; This is file one</blockquote></p>     <p><blockquote>--</blockquote></p>     <p><blockquote>&gt; This is file two</blockquote></p>     <p><blockquote>4c4, 5</blockquote></p>     <p><blockquote>&lt; there is no line 4, this is line 5</blockquote></p>     <p><blockquote>--</blockquote></p>     <p><blockquote>&gt; line 4</blockquote></p>     <p><blockquote>&gt; line 5</blockquote></p>     <p><blockquote>5a7</blockquote></p>     <p><blockquote>&gt; a new line 8</blockquote></p>     <p>На самом деле это набор команд редактора для превращения одного файла в другой. Предположим, что у вас есть файл file1.c и файл diffs. Вы можете обновить свой файл с помощью команды <blockquote>patch</blockquote> следующим образом:</p>     <p><blockquote>$ <b>patch file1.c diffs</b></blockquote></p>     <p><blockquote>Hmm... Looks like a normal diff to me...</blockquote></p>     <p><blockquote>Patching file file1.c using Plan A...</blockquote></p>     <p><blockquote>Hunk #1 succeeded at 1.</blockquote></p>     <p><blockquote>Hunk #2 succeeded at 4.</blockquote></p>     <p><blockquote>Hunk #3 succeeded at 7.</blockquote></p>     <p><blockquote>done</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Команда <blockquote>patch</blockquote> сделала file1.c таким же, как файл file2.c.</p>     <p>У команды <blockquote>patch</blockquote> есть еще один фокус: возможность отказа от внесенных изменений. Предположим, что вам не понравились изменения, и вы хотите вернуться назад к file1 с. Нет ничего проще; всего лишь воспользуйтесь командой <blockquote>patch</blockquote> еще раз, добавив опцию <blockquote>-R</blockquote> (обратная корректировка).</p>     <p><blockquote>$ <b>patch -R file1.c diffs</b></blockquote></p>     <p><blockquote>Hmm... Looks like a normal diff to me...</blockquote></p>     <p><blockquote>Patching file file1.c using Plan A...</blockquote></p>     <p><blockquote>Hunk #1 succeeded at 1.</blockquote></p>     <p><blockquote>Hunk #2 succeeded at 4.</blockquote></p>     <p><blockquote>Hunk #3 succeeded at 6.</blockquote></p>     <p><blockquote>done$</blockquote></p>     <p>Файл file1.с возвращен в свое исходное состояние.</p>     <p>У команды <blockquote>patch</blockquote> есть и другие опции, но лучше всего на входе команды решить, что вы хотите сделать, а затем "выполнить верное действие". Если вдруг команда <blockquote>patch</blockquote> завершается аварийно, она создает файл с расширением rej, содержащий фрагменты, которые невозможно было исправить.</p>     <p>Когда вы работаете с корректировками программного обеспечения, полезно применять опцию <blockquote>diff -с</blockquote>, формирующую "окружающий контекст". Она включает несколько строк перед каждым изменением и после него, так что команда <blockquote>patch</blockquote> сможет проверить контекстные соответствия перед внесением изменений. Кроме того, в этом случае легче читать исправленный файл.</p>     <blockquote>      <b>Примечание</b>      <p>Если вы нашли и исправили ошибку в программе, легче, точнее и вежливее отправить автору исправленный файл, а не просто описание исправления.</p>     </blockquote>             <a name="metkadoc23"><h1>Другие утилиты распространения</h1></a>     <p>Программы Linux и исходный код обычно распространяются в виде файлов с именами, в которые включен номер версии, и расширениями tar.gz или tgz. Это сжатые программой <blockquote>gzip</blockquote> файлы TAR (tape archive, архивы лент), также называемые "tarballs" (клубки архивов tar). Если применить обычную команду <blockquote>tar</blockquote>, обрабатывать эти файлы придется в два этапа. Приведенный далее код создает сжатый программой <blockquote>gzip</blockquote> файл TAR вашего приложения:</p>     <p><blockquote>$ <b>tar cvf myapp-1.0.tar main.c 2.c 3.c *.h myapp.1 Makefile5</b></blockquote></p>     <p><blockquote>main.c</blockquote></p>     <p><blockquote>2.c</blockquote></p>     <p><blockquote>3.c</blockquote></p>     <p><blockquote>a.h</blockquote></p>     <p><blockquote>b.h</blockquote></p>     <p><blockquote>c.h</blockquote></p>     <p><blockquote>myapp.1</blockquote></p>     <p><blockquote>Makefile5</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Теперь у вас есть файл TAR:</p>     <p><blockquote>$ <b>ls -l *.tar</b></blockquote></p>     <p><blockquote>-rw-r--r-- 1 neil users  10240 2007-07-09 11:23 myapp-1.0.tar</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Сделать его меньше можно с помощью программы сжатия <blockquote>gzip</blockquote>:</p>     <p><blockquote>$ <b>gzip myapp-1.0.tar $ ls -l *.gz</b></blockquote></p>     <p><blockquote>-rw-r--r-- 1 neil users 1648 2007-07-09 11:23 myapp-1.0.tar.gz</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Как видите, в результате впечатляющее уменьшение размера. Файл tar.gz можно в дальнейшем переименовать, оставив просто расширение tgz.</p>     <p><blockquote>$ <b>mv myapp-1.0.tar.gz myapp_v1.tgz</b></blockquote></p>     <p>Практика задания имен, заканчивающихся точкой и тремя символами, — уступка программному обеспечению, работающему в ОС Windows, которое в отличие от программ для ОС Linux и UNIX сильно зависит от наличия корректного расширения файла. Для того чтобы получить свои файлы обратно, удалите сжатие и опять извлеките их из файла, полученного с помощью <blockquote>tar</blockquote>:</p>     <p><blockquote>$ <b>mv myapp_v1.tgz myapp-1.0.tar.gz</b></blockquote></p>     <p><blockquote>$ <b>gzip -d myapp-1.0.tar.gz</b></blockquote></p>     <p><blockquote>$ <b>tar xvf myapp-1.0.tar</b></blockquote></p>     <p><blockquote>main.с</blockquote></p>     <p><blockquote>2.c</blockquote></p>     <p><blockquote>3.c</blockquote></p>     <p><blockquote>a.h</blockquote></p>     <p><blockquote>b.h</blockquote></p>     <p><blockquote>c.h</blockquote></p>     <p><blockquote>myapp.1</blockquote></p>     <p><blockquote>Makefile5</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>С версией GNU программы tar все еще проще — вы можете создать сжатый архив за один шаг:</p>     <p><blockquote>$ <b>tar zcvf myapp_v1.tgz main.c 2.c 3.c *.h myapp.1 Makefile5</b></blockquote></p>     <p><blockquote>main.c</blockquote></p>     <p><blockquote>2.c</blockquote></p>     <p><blockquote>3.c</blockquote></p>     <p><blockquote>a.h</blockquote></p>     <p><blockquote>b.h</blockquote></p>     <p><blockquote>c.h</blockquote></p>     <p><blockquote>myapp.1</blockquote></p>     <p><blockquote>Makefile5</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Также легко вы можете развернуть файл:</p>     <p><blockquote>$ <b>tar zxvf myapp_v1.tgz</b></blockquote></p>     <p><blockquote>main.c</blockquote></p>     <p><blockquote>2.с</blockquote></p>     <p><blockquote>3. с</blockquote></p>     <p><blockquote>a. h</blockquote></p>     <p><blockquote>b. h c.h</blockquote></p>     <p><blockquote>myapp.1</blockquote></p>     <p><blockquote>Makefile5</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Если хотите увидеть содержимое архива, не извлекая его, следует вызвать программу <blockquote>tar</blockquote> с несколько иной опцией: <blockquote>tar ztvf</blockquote>.</p>     <p>В предыдущих примерах мы применяли <blockquote>tar</blockquote>, описывая только необходимые опции. Теперь дадим краткий обзор команды и нескольких самых популярных опций. Как вы видели в примерах, у команды следующая базовая синтаксическая запись:</p>     <p><blockquote>tar [<i>опции</i>] [<i>список_файлов</i>]</blockquote></p>     <p>Первый элемент списка файлов — выходной файл, и хотя мы работали с файлами, он может быть и устройством. Другие элементы списка в зависимости от опций команды добавляются в новый или существующий архив.</p>     <p>Список файлов также может включать каталоги, в этом случае по умолчанию в файл включаются все подкаталоги. Если вы извлекаете файлы, нет необходимости задавать имена, т.к. программа <blockquote>tar</blockquote> сохраняет полные пути.</p>     <p>В этом разделе использовалось шесть комбинаций разных опций:</p>     <p>&#9633; <blockquote>с</blockquote> — создает новый архив;</p>     <p>&#9633; <blockquote>f</blockquote> — определяет, что выходной файл — не устройство, а файл;</p>     <p>&#9633; <blockquote>t</blockquote> — перечисляет содержимое архива без реального извлечения элементов;</p>     <p>&#9633; <blockquote>v</blockquote> (verbose) — по ходу выполнения tar выводит сообщения;</p>     <p>&#9633; <blockquote>х</blockquote> — извлекает файлы из архива;</p>     <p>&#9633; <blockquote>z</blockquote> — пропускает архив GNU tar через программу gzip (сжимает его или убирает сжатие).</p>     <p>У команды <blockquote>tar</blockquote> есть еще множество опций, позволяющих улучшить управление действиями команды и создаваемыми ею архивами. Дополнительную информацию о программе <blockquote>tar</blockquote> см. на страницах интерактивного справочного руководства.</p>              <a name="metkadoc24"><h1>RPM-пакеты</h1></a>         <p>Диспетчер RPM-пакетов или RPM появился как создатель формата упаковки в дистрибутиве Linux Red Hat (и первоначально назывался Red Hat Package Manager). С того времени формат RPM превратился в общепринятый формат упаковки в разных дистрибутивах Linux, включая. SUSE Linux. Он также был выбран как официальный формат упаковки проектом по стандартизации операционных систем на базе Linux Linux Standards Base или LSB, см. Web-сайт <b>www.linuxbase.org.</b></p>     <p>К основным достоинствам RPM относятся следующие.</p>     <p>&#9633; Этот диспетчер широко распространен. Многие дистрибутивы Linux могут, по меньшей мере, устанавливать RPM-пакеты или использовать формат RPM как собственный формат упаковки файлов. Кроме того, RPM перенесен на многие другие операционные системы.</p>     <p>&#9633; Он позволяет устанавливать RPM-пакеты с помощью одной команды. Вы также можете устанавливать пакеты автоматически, т.к. формат RPM разработан для необслуживаемого применения. Удалить или обновить пакет также можно одной командой.</p>     <p>&#9633; Вы работаете с одним файлом. RPM-пакет хранился в едином файле, облегчая тем самым перенос пакета из одной системы в другую.</p>     <p>&#9633; RPM автоматически выполняет проверку зависимостей. RPM-система включает в себя базу данных всех пакетов, установленных вами, вместе с данными о том, что каждый пакет дает вашей системе и информацией о требованиях каждого пакета.</p>     <p>&#9633; RPM-пакеты разработаны для формирования исполняемых файлов из исходных, позволяя вам воспроизводить сборку. Диспетчер RPM поддерживает средства ОС Linux, например, команду patch для внесения изменений в программный код в процессе компиляции.</p>             <a name="metkadoc25"><h1>Работа с файлами RPM-пакетов</h1></a>     <p>Любой RPM-пакет хранится в файле с расширением rpm. Файлы пакетов, как правило, соблюдают соглашение об именовании, предлагающее следующую структуру имени:</p>     <p><i><blockquote><i>name-version-release.architecture.</i>rpm</blockquote></i></p>     <p>В этой структуре <blockquote><i>name</i></blockquote> содержит групповое имя пакета, например, mysql для базы данных MySQL или make для средства компиляции и компоновки <blockquote>make</blockquote>. В элементе <i>version</i> указывается номер версии программного обеспечения, например, версия 5.0.41 для MySQL. Элемент <i><blockquote><i>release</i></blockquote></i> хранит номер, который определяет, какой вариант или выпуск RPM указанной версии программного обеспечения содержится в файле. Это важно, потому что RPM-пакеты собираются набором инструкций (которые будут обсуждаться в <i>разд. "Создание RPM-файла spec" далее в этой главе</i>). Номер выпуска позволяет отслеживать изменения в инструкциях сборки.</p>     <p>Элемент <i><blockquote><i>architecture</i></blockquote></i> содержит спецификатор для архитектуры компьютера, на которую рассчитана программа, например, i386 для Intel-системы. Для откомпилированных программ этот элемент очень важен, поскольку исполняемый файл, созданный для процессора SPARC, вполне вероятно, не будет работать на процессоре Intel. Архитектура может задаваться обобщенно, например <blockquote>sparc</blockquote> для процессоров SPARC, или более конкретно, например <blockquote>sparcv9</blockquote> для v9 SPARC или <blockquote>athlon</blockquote> для процессора AMD Athlon. Пока вы не переопределите этот элемент, RPM-система не даст вам установить пакеты, предназначенные для компьютера с другой архитектурой.</p>     <p>Элемент <i><blockquote><i>architecture</i></blockquote></i> может также содержать специальные значения: <blockquote>noarch</blockquote> для пакетов, не относящихся к архитектуре определенного типа, таких как файлы документации, программы на языке Java, модули на языке Perl, и <blockquote>src</blockquote> для RPM-пакета с исходными файлами. RPM-пакеты с исходными файлами содержат тексты программ и инструкции по сборке для построения двоичного RPM-пакета. Большинство RPM-пакетов, предлагаемых для загрузки, для удобства заранее собраны в расчете на компьютеры с архитектурой определенного типа. Вы сможете найти тысячи программ для системы Linux в виде заранее собранных и готовых к установке RPM-пакетов. Это убережет вас от трудностей компиляции.</p>     <p>Кроме того, некоторые пакеты так сильно зависят от конкретных версий, что проще загрузить заранее собранный пакет, чем тестировать все его компоненты вручную. Например, пакеты для беспроводных сетей стандарта 802.11b однажды пришли собранными для конкретных уровней исправлений ядра определенных дистрибутивов Linux, один из них — пакет kernel-wlan-ng-modules-rh9.18-0.2.0-7-athlon.rpm, который включал в себя модули ядра для дистрибутива Red Hat 9.0 с ядром а2.4.20-18 в системе на базе процессора AMD Athlon.</p>             <a name="metkadoc26"><h1>Установка RPM-пакетов</h1></a>     <p>Для установки RPM-пакета запустите команду <blockquote>rpm</blockquote>. Формат очень простой:</p>     <p><blockquote>rpm -Uhv <i>name-version-release.architecture.</i>rpm</blockquote></p>     <p>Например,</p>     <p><blockquote>$ <b>rpm -Uhv MySQL-server-5.0.41-0.glibc23.i386.rpm</b></blockquote></p>     <p>Эта команда устанавливает (или при необходимости обновляет) пакет сервера СУРБД MySQL для системы на базе Intel x86.</p>     <p>Команда <blockquote>rpm</blockquote> обеспечивает большую часть взаимодействия пользователя с RPM-системой. Вы можете узнать, установлен ли пакет, с помощью следующей команды:</p>     <p><blockquote>$ <b>rpm -qa xinetd</b></blockquote></p>     <p><blockquote>xinetd-2.3.14-40</blockquote></p>             <a name="metkadoc27"><h1>Формирование RPM-пакетов</h1></a>     <p>Для создания RPM-пакета выполните команду <blockquote>rpmbuild</blockquote>. Процесс относительно прост. Вы должны сделать следующее:</p>     <p>1. Собрать программное обеспечение, которое хотите поместить в пакет.</p>     <p>2. Создать файл spec, описывающий, как собирать пакет.</p>     <p>3. Сформировать пакете помощью команды <blockquote>rpmbuild</blockquote>.</p>     <p>Поскольку создание RPM-пакета может быть очень сложным, мы будем придерживаться в этой главе простого примера, достаточного для распространения приемлемого приложения в виде исходного или двоичного файла. Более таинственные опции и поддержку пакетов, полученных с помощью файлов исправлений (patches), мы оставим любознательным читателям. Для получения дополнительной информации изучите страницу интерактивного справочного руководства, посвященную программе rpm, или справочное руководство RPM HOWTO (обычно хранящееся в каталоге /usr/share/doc). Кроме того, прочтите книгу Эрика Фостера-Джонсона (Eric Foster-Johnson) "Red Hat RPM Guide" ("Справочник по Red Hat RPM"), доступную в интерактивном режиме на Web-сайте <b>http://docs.fedoraproject.org/drafts/rpm-guide-en/.</b></p>     <p>Последующие разделы соответствуют трем шагам, необходимым для создания пакета тривиального приложения myapp.</p>     <b>Сбор программного обеспечения</b>     <p>Первый этап в создании RPM-пакета — сбор программного обеспечения, которое вы хотите поместить в пакет. Чаще всего у вас есть исходный программный код приложения, файл сборки, например make-файл, и, возможно, страница интерактивного справочного руководства.</p>     <p>Самый легкий способ собрать это программное обеспечение — упаковать файлы в сжатый tar-файл. Назовите файл архива именем приложения и укажите в нем номер версии, например, myapp-1.0.tar.gz.</p>     <p>Вы можете откорректировать ранее созданный make-файл Makefile6, добавив новое задание на упаковку файлов в сжатый файл архива. Окончательная версия make-файла, названная просто Makefile, выглядит следующим образом:</p>     <p><blockquote>all: myapp</blockquote></p>     <br>     <p><blockquote># Какой компилятор</blockquote></p>     <p><blockquote>CC = gcc</blockquote></p>     <br>     <p><blockquote># Где хранятся файлы include</blockquote></p>     <p><blockquote>INCLUDE = .</blockquote></p>     <br>     <p><blockquote># Опции для разработки</blockquote></p>     <p><blockquote>CFLAGS = -g -Wall -ansi</blockquote></p>     <br>     <p><blockquote># Опции для рабочей версии</blockquote></p>     <p><blockquote># CFLAGS = -О -Wall -ansi</blockquote></p>     <br>     <p><blockquote># Локальные библиотеки</blockquote></p>     <p><blockquote>MYLIB = mylib.a</blockquote></p>     <br>     <p><blockquote>myapp: main.о $(MYLIB)</blockquote></p>     <p><blockquote> $(CC) -о myapp main.о $(MYLIB)</blockquote></p>     <br>     <p><blockquote>$(MYLIB) : $(MYLIB)(2.o) $(MYLIB)(3.о)</blockquote></p>     <p><blockquote>main.о: main.c a.h</blockquote></p>     <p><blockquote>2.o: 2.с a.h b.h</blockquote></p>     <p><blockquote>3.o: 3.c b.h c.h</blockquote></p>     <br>     <p><blockquote>clean:</blockquote></p>     <p><blockquote> -rm main.о 2.о 3.o $(MYLIB)</blockquote></p>     <br>     <p><blockquote><i>dist: myapp-1.0.tar.gz</i></blockquote></p>     <br>     <p><blockquote><i>myapp-1.0.tar.gz: myapp myapp.1</i></blockquote></p>     <p><blockquote><i> -rm -rf myapp-1.0</i></blockquote></p>     <p><blockquote><i> mkdir myapp-1.0</i></blockquote></p>     <p><blockquote><i> cp *.c *.h *.1 Makefile myapp-1.0</i></blockquote></p>     <p><blockquote><i> tar zcvf $@ myapp-1.0</i></blockquote></p>     <p>Задание <blockquote>myapp-1.0.tar.gz</blockquote> в make-файле формирует сжатый архив (tarball) из исходных файлов нашего простого примера приложения. Этот код вставлен для простоты в задание <blockquote>dist</blockquote>, в котором вызываются те же команды. Для создания файла архива выполните следующую команду:</p>     <p><blockquote>$ <b>make dist</b></blockquote></p>     <p>Далее нужно скопировать файл myapp-1.0.tar.gz в каталог RPM-пакетов SOURCES, обычно в системе Red Hat Linux это каталог /usr/src/redhat/SOURCES, а в системе SUSE Linux — /usr/src/packages/SOURCES. Например:</p>     <p><blockquote>$ <b>cp myapp-1.0.tar.gz /usr/src/redhat/SOURCES</b></blockquote></p>     <p>RPM-система полагает, что исходные файлы находятся в каталоге SOURCES в виде tar-файлов. (Есть и другие опции, но эта самая простая.) SOURCES — это один из каталогов, на которые рассчитывает RPM-система.</p>     <p>RPM-система полагается на пять каталогов, приведенных в табл. 9.4.</p>     <br>     <p><b><i>Таблица 9.4</i></b></p>     <table>      <tr>       <th valign="top">RPM-каталог</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top">BUILD</td>       <td valign="top">Команда <blockquote>rpmbuild</blockquote> создает программное обеспечение в этом каталоге</td>      </tr>      <tr>       <td valign="top">RPMS</td>       <td valign="top">Команда <blockquote>rpmbuild</blockquote> хранит в этом каталоге созданные ею двоичные файлы</td>      </tr>      <tr>       <td valign="top">SOURCES</td>       <td valign="top">В этот каталог следует поместить исходные файлы для вашего приложения</td>      </tr>      <tr>       <td valign="top">SPECS</td>       <td valign="top">В этот каталог следует помещать файлы spec для всех RPM-пакетов, которые вы планируете создать, хотя это и не обязательно</td>      </tr>      <tr>       <td valign="top">SRPMS</td>       <td valign="top">Команда <blockquote>rpmbuild</blockquote> помещает в этот каталог RPM-пакеты из исходных файлов</td>      </tr>     </table>     <p>У каталога RPMS обычно есть ряд подкаталогов, определяющих тип архитектуры системы, например такие, как приведенные далее (для системы с архитектурой Intel х86).</p>     <p><blockquote>$ <b>ls RPMS</b></blockquote></p>     <p><blockquote>athlon</blockquote></p>     <p><blockquote>i386</blockquote></p>     <p><blockquote>i486</blockquote></p>     <p><blockquote>i586</blockquote></p>     <p><blockquote>i686</blockquote></p>     <p><blockquote>noarch</blockquote></p>     <p>В системах Red Hat Linux по умолчанию предполагается, что RPM-пакеты создаются в каталоге /usr/src/redhat.</p>     <blockquote>      <b>Примечание</b>      <p>Этот каталог специфичен для системы Red Hat Linux. В других дистрибутивах Linux используются иные каталоги, например каталог /usr/src/packages.</p>     </blockquote>     <p>После того как исходные файлы для вашего RPM-пакета будут собраны вместе, нужно создать файл spec, описывающий, как именно команда rpmbuild должна создать ваш пакет.</p>     <b>Создание RPM-файла spec</b>     <p>Создание файла spec может оказаться непростым занятием при наличии тысяч опций, поддерживаемых RPM-системой. Можно воспользоваться простым примером из этого раздела, которого будет достаточно для большинства создаваемых вами пакетов. Кроме того, можно скопировать команды из других файлов spec.</p>     <blockquote>      <b>Примечание</b>      <p>Хорошими источниками примеров файлов spec служат другие RPM-пакеты. Посмотрите RPM-пакеты исходных файлов, хранящиеся в файлах с окончанием .src.rpm. Установите эти RPM-пакеты и просмотрите их файлы spec. Вы найдете гораздо более сложные примеры, чем те, которые вам когда-либо понадобятся. Интересные примеры можно найти среди файлов spec, предназначенных для пакетов anonftp, telnet, vnc и sendmail.</p>     </blockquote>     <p>Кроме того, разработчики RPM-системы мудро решили не пытаться заменить популярные средства построения программ, такие как <blockquote>make</blockquote> или <blockquote>configure</blockquote>. RPM-система содержит много средств быстрого доступа, позволяющих воспользоваться make-файлами и сценариями <blockquote>configure</blockquote>.</p>     <p>В данном примере вы создаете файл spec для простого приложения myapp. Назовите его myapp.spec. Начинает файл spec с набора определения имени, номера версии и другой информации о вашем пакете. Например,</p>     <p><blockquote>Vendor:       Wrox Press</blockquote></p>     <p><blockquote>Distribution: Any</blockquote></p>     <p><blockquote>Name:         myapp</blockquote></p>     <p><blockquote>Version:      1.0</blockquote></p>     <p><blockquote>Release:      1</blockquote></p>     <p><blockquote>Packager:     neil@provider.com</blockquote></p>     <p><blockquote>License:      Copyright 2007 Wiley Publishing, Inc</blockquote></p>     <p><blockquote>Group:        Applications/Media</blockquote></p>     <p>Эту секция RPM-файла spec часто называют заголовком. В ней содержатся наиболее важные параметры <blockquote>Name</blockquote>, <blockquote>Version</blockquote> и <blockquote>Release</blockquote>. В нашем примере имя — myapp, номер версии — 1.0 и номер выпуска или сборки RPM-пакета — 1, т.к. эта ваша первая попытка создания RPM-пакета.</p>     <p>Параметр <blockquote>Group</blockquote> применяется для облегчения графической инсталляции программ, сортируя тысячи приложений для системы Linux по типам. Элемент <blockquote>Distribution</blockquote> важен, если вы создаете пакет для одного дистрибутива Linux, например, Red Hat или SUSE Linux.</p>     <p>Неплохо добавить в ваш файл spec комментарии. Как и сценарии командной оболочки, и make-файлы, команда <blockquote>rpmbuild</blockquote> считает комментарием любую строку, начинающуюся с символа <blockquote>#</blockquote>. Например:</p>     <p><blockquote># Это строка комментария.</blockquote></p>     <p>Для того чтобы помочь пользователям решить, нужно ли им устанавливать ваш пакет, предоставьте секции <blockquote>Summary</blockquote> и <blockquote>%description</blockquote> (обратите внимание на несогласованность RPM-синтаксиса, применяющего знак процента перед обозначением секции описания). Например, свой пакет вы можете описать следующим образом:</p>     <p><blockquote>Summary:    Trivial application</blockquote></p>     <br>     <p><blockquote>%description</blockquote></p>     <p><blockquote>MyApp Trivial Application</blockquote></p>     <p><blockquote>A trivial application used to demonstrate development tools.</blockquote></p>     <p><blockquote>This version pretends it requires MySQL at or above 3.23.</blockquote></p>     <p><blockquote>Authors: Neil Matthew and Richard Stones</blockquote></p>     <p>Секция <blockquote>%description</blockquote> может состоять (и обычно состоит) из нескольких строк.</p>     <p>Файл spec может содержать сопутствующую информацию и о том, какие возможности предоставляет ваш пакет, и о том, от чего он зависит. (Вы также можете определить, от чего зависит пакет исходных файлов, например, указать специальные заголовочные файлы, необходимые для компиляции.)</p>     <p>Параметр <blockquote>Provides</blockquote> определяет возможности, предоставляемые вашей системой. Например:</p>     <p><blockquote>Provides: goodness</blockquote></p>     <p>В примере утверждается, что пакет предоставляет вымышленную функциональную возможность, именуемую <blockquote>goodness</blockquote> (ценные свойства). RPM-система также автоматически добавляет элемент <blockquote>Provides</blockquote> к имени пакета, в данном случае myapp. Параметры Provides полезны в случае множественных пакетов, предоставляющих одну и ту же функциональную возможность. Например, пакет Web-сервера Apache предоставляет средство webserver. Другие пакеты, например Thy, могут предоставлять то же средство. (Для облегчения работы с конфликтующими пакетами RPM-система позволяет задавать также информацию с помощью элементов Conflicts и Obsoletes.)</p>     <p>Наиболее важная сопутствующая информация определяется в параметрах <blockquote>Requires</blockquote>. Вы можете указать все пакеты, необходимые для функционирования вашего пакета. Например, Web-серверу требуется сетевой пакет и пакет безопасности. В нашем примере вы задаете необходимость СУРБД MySQL версии 3.23 или более свежей. Синтаксическая запись приведена далее:</p>     <p><blockquote>Requires: mysql &gt;= 3.23</blockquote></p>     <p>Если вам нужна СУРБД MySQL любой версии, можно задать параметр следующим образом:</p>     <p><blockquote>Requires: mysql</blockquote></p>     <p>RPM-система не разрешит пользователям устанавливать пакеты, если не установлены пакеты, необходимые для их работы. (Правда, пользователи могут переопределить это поведение.)</p>     <p>RPM-система автоматически добавляет зависимые элементы, например /bin/sh для сценариев командной оболочки, интерпретатор Perl для сценариев на языке Perl и любые совместно используемые библиотеки (файлы с расширением so), которые вызывает ваше приложение. Каждая новая версия RPM-системы включает все новые средства для автоматической проверки зависимостей.</p>     <p>После задания требований необходимо определить исходные файлы, формирующие ваше приложение. Для большинства приложений можно просто скопировать следующую строку:</p>     <p><blockquote>source: %{name}-%{version}.tar.gz</blockquote></p>     <p>Синтаксическая запись <blockquote>%{name}</blockquote> ссылается на RPM-макрос, в данном случае имя пакета. Поскольку ранее вы задали имя myapp, команда <blockquote>rpmbuild</blockquote> заменит <blockquote>%{name}</blockquote> на <blockquote>myapp</blockquote> и аналогично заменит <blockquote>%{version}</blockquote> на <blockquote>1.0</blockquote>, для того чтобы использовать для построения файл с именем myapp-1.0.tar.gz. Искать этот файл она будет в каталоге SOURCES, описанном ранее.</p>     <p>В примере задается параметр <blockquote>Buildroot</blockquote>, определяющий место установки пакета. Вы можете скопировать в ваши пакеты следующую строку:</p>     <p><blockquote>Buildroot: %{_tmppath}/%{name}-%{version}-root</blockquote></p>     <p>После того как параметр <blockquote>Buildroot</blockquote> задан, устанавливайте ваши приложения в каталог из параметра <blockquote>Buildroot</blockquote>. Можно использовать удобную переменную <blockquote>$RPM_BUILD_ROOT</blockquote>, которая задается для всех сценариев командной оболочки в файле spec.</p>     <p>После задания всех этих характеристик пакета далее нужно определить, как собирать пакет. Для этого есть четыре основные секции: <blockquote>%prep</blockquote>, <blockquote>%build</blockquote>, <blockquote>%install</blockquote> и <blockquote>%clean</blockquote>.</p>     <p>Судя по имени, секция <blockquote>%prep</blockquote> предназначена для подготовки сборки. В большинстве случаев вы можете выполнить приведенный далее макрос <blockquote>%setup</blockquote> с параметром <blockquote>-q</blockquote> для перевода его в режим без вывода сообщений:</p>     <p><blockquote>%prep</blockquote></p>     <p><blockquote>%setup -q</blockquote></p>     <p>Секция <blockquote>%build</blockquote> собирает ваше приложение. В большинстве случаев можно применять простую команду <blockquote>make</blockquote>. Например:</p>     <p><blockquote>%build</blockquote></p>     <p><blockquote>make</blockquote></p>     <p>Это один из способов, которым RPM-система использует уже проделанную вами работу по созданию make-файла.</p>     <p>Секция <blockquote>%install</blockquote> устанавливает ваше приложение, интерактивное справочное руководство и любые файлы поддержки. Вы можете применить RPM-макрос <blockquote>%makeinstall</blockquote>, который вызывает задание <blockquote>install</blockquote> make-файла. Тем не менее, в данном случае установим файлы вручную, чтобы продемонстрировать дополнительные RPM-макросы:</p>     <p><blockquote>%install</blockquote></p>     <p><blockquote>mkdir -р $RPM_BUILD_ROOT%{_bindir}</blockquote></p>     <p><blockquote>mkdir -p $RPM_BUILD_ROOT%{_mandir}</blockquote></p>     <p><blockquote>install -m755 myapp $RPM_BUILD_ROOT%{_bindir}/myapp</blockquote></p>     <p><blockquote>install -m755 myapp.1 $RPM_BUILD_ROOT%{_mandir}/myapp.1</blockquote></p>     <p>В этом примере при необходимости создаются каталоги для файлов, а затем устанавливаются исполняемый файл myapp и интерактивное справочное руководство myapp.1. Переменная окружения <blockquote>$RPM_BUILD_ROOT</blockquote> содержит местоположение <blockquote>Buildroot</blockquote>, заданное ранее. Макросы <blockquote>%{_bindir}</blockquote> и <blockquote>%{_mandir}</blockquote> замещаются текущим каталогом двоичных файлов и каталогом страниц интерактивного справочного руководства соответственно.</p>     <blockquote>      <b>Примечание</b>      <p>Если вы пользуетесь сценарием configure для создания make-файла, все разнообразные каталоги в нем будут заданы должным образом. В большинстве случаев вам не придется задать все команды установки вручную, как. показано в предыдущем примере.</p>     </blockquote>     <p>Задание <blockquote>%clean</blockquote> удаляет файлы, созданные командой <blockquote>rpmbuild</blockquote>. Например:</p>     <p><blockquote>%clean</blockquote></p>     <p><blockquote>rm -rf $RPM_BUILD_ROOT</blockquote></p>     <p>После описания построения пакета следует задать все файлы, которые будут устанавливаться. RPM-система очень строга на этот счет. Она и должна быть строгой для того, чтобы иметь возможность отследить должным образом каждый файл в каждом пакете. В секции <blockquote>%files</blockquote> перечисляются имена всех файлов, включаемых в пакет. В данном случае у нас только два файла предназначены для распространения в двоичном пакете: исполняемый файл myapp и страница интерактивного справочного руководства myapp.1. Например:</p>     <p><blockquote>%files</blockquote></p>     <p><blockquote>%{_bindir}/myapp</blockquote></p>     <p><blockquote>%{_mandir}/myapp.1</blockquote></p>     <p>RPM-система может выполнять сценарий до и после установки вашего пакета. Например, если ваш пакет — процесс-демон, для его запуска, возможно, нужна корректировка сценариев установки системы. Сделайте это с помощью сценария <blockquote>%post</blockquote>. Далее приведен простой пример, отправляющий сообщение по электронной почте:</p>     <p><blockquote>%post</blockquote></p>     <p><blockquote>mail root -s "myapp installed — please register" &lt;/dev/null</blockquote></p>     <p>Поищите примеры в серверных RPM-файлах spec.</p>     <p>Далее приводится полный файл spec для вашего простого приложения.</p>     <p><blockquote>#</blockquote></p>     <p><blockquote># spec file for package myapp (Version 1.0)</blockquote></p>     <p><blockquote>#</blockquote></p>     <p><blockquote>Vendor:       Wrox Press</blockquote></p>     <p><blockquote>Distribution: Any</blockquote></p>     <p><blockquote>Name:         myapp</blockquote></p>     <p><blockquote>Version:      1.0</blockquote></p>     <p><blockquote>Release:      1</blockquote></p>     <p><blockquote>Packager:     neil@provider.com</blockquote></p>     <p><blockquote>License:      Copyright 2007 Wiley Publishing, Inc.</blockquote></p>     <p><blockquote>Group:        Applications/Media</blockquote></p>     <br>     <p><blockquote>Provides:     goodness</blockquote></p>     <p><blockquote>Requires:     mysql &gt;=3.23</blockquote></p>     <br>     <p><blockquote>Buildroot:    %{_tmppath}/%{name}-%{version}-root</blockquote></p>     <p><blockquote>source:       %{name}-%{version}.tar.gz</blockquote></p>     <br>     <p><blockquote>Summary:      Trivial application</blockquote></p>     <p><blockquote>%description</blockquote></p>     <p><blockquote>MyApp Trivial Application</blockquote></p>     <p><blockquote>A trivial application used to demonstrate development tools.</blockquote></p>     <p><blockquote>This version pretends it requires MySQL at or above 3.23.</blockquote></p>     <p><blockquote>Authors: Neil Matthew and Richard Stones</blockquote></p>     <br>     <p><blockquote>%prep</blockquote></p>     <p><blockquote>%setup -q</blockquote></p>     <br>     <p><blockquote>%build</blockquote></p>     <p><blockquote>make</blockquote></p>     <br>     <p><blockquote>%install</blockquote></p>     <p><blockquote>mkdir -p $RPM_BUILD_ROOT%{bindir}</blockquote></p>     <p><blockquote>mkdir -p $RPM_BUILD_ROOT%{_mandir}</blockquote></p>     <p><blockquote>install -m755 myapp $RPM_BUILD_ROOT%{_bindir}/myapp</blockquote></p>     <p><blockquote>install -m755 myapp.1 $RPM_BUILD_ROOT%{_mandir}/myapp.1</blockquote></p>     <br>     <p><blockquote>%clean</blockquote></p>     <p><blockquote>rm -rf $RPM_BUILD_ROOT</blockquote></p>     <br>     <p><blockquote>%post</blockquote></p>     <p><blockquote>mail root -s "myapp installed — please register" &lt;/dev/null</blockquote></p>     <br>     <p><blockquote>%files</blockquote></p>     <p><blockquote>%{_bindir}/myapp</blockquote></p>     <p><blockquote>%{_mandir}/myapp.1</blockquote></p>     <p>Теперь вы готовы к формированию RPM-пакета.</p>     <b>Создание RPM-пакета с помощью <i>rpmbuild</i></b>     <p>Создаются пакеты с помощью команды <blockquote>rpmbuild</blockquote> со следующей синтаксической записью:</p>     <p><blockquote>rpmbuild -b<i>BuildStage spec_file</i></blockquote></p>     <p>Опция <blockquote>-b</blockquote> заставляет <blockquote>rpmbuild</blockquote> создать RPM-пакет. Дополнительная опция <blockquote>BuildStage</blockquote> — специальный код, информирующий команду <blockquote>rpmbuild</blockquote> о том, как далеко она может зайти в процессе создания. В табл. 9.5 перечислены опции команды.</p>     <br>     <p><b><i>Таблица 9.5</i></b></p>     <table>      <tr>       <th valign="top">Опция</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>-ba</blockquote></td>       <td valign="top">Создавать и двоичный, и исходный RPM-пакет</td>      </tr>      <tr>       <td valign="top"><blockquote>-bb</blockquote></td>       <td valign="top">Создавать двоичный RPM-пакет</td>      </tr>      <tr>       <td valign="top"><blockquote>-bc</blockquote></td>       <td valign="top">Компилировать программу, но не создавать полный RPM-пакет</td>      </tr>      <tr>       <td valign="top"><blockquote>-bp</blockquote></td>       <td valign="top">Подготовиться к созданию двоичного RPM-пакета</td>      </tr>      <tr>       <td valign="top"><blockquote>-bi</blockquote></td>       <td valign="top">Создать двоичный RPM-пакет и установить его</td>      </tr>      <tr>       <td valign="top"><blockquote>-bl</blockquote></td>       <td valign="top">Проверить список файлов RPM-пакета</td>      </tr>      <tr>       <td valign="top"><blockquote>-bs</blockquote></td>       <td valign="top">Создать только RPM-пакет исходных файлов</td>      </tr>     </table>     <p>Для создания двоичного RPM-пакета и пакета исходных файлов используйте опцию <blockquote>-ba</blockquote>. RPM-пакет исходных файлов позволит создать повторно двоичный RPM- пакет.</p>     <p>Скопируйте RPM-файл spec в корректный каталог SOURCES, поместив его рядом с исходным файлом приложения:</p>     <p><blockquote>$ <b>cp myapp.spec /usr/src/redhat/SOURCES</b></blockquote></p>     <p>Далее приведен вывод, сопровождающий создание пакета в системе SUSE Linux, пакеты в которой создаются из каталога /usr/src/packages/SOURCES:</p>     <p><blockquote>$ <b>rpmbuild -ba myapp.spec</b></blockquote></p>     <p><blockquote>Executing(%prep): /bin/sh -e /var/tmp/rpm-tmp.47290</blockquote></p>     <p><blockquote>+ umask 022</blockquote></p>     <p><blockquote>+ cd /usr/src/packages/BUILD</blockquote></p>     <p><blockquote>+ cd /usr/src/packages/BUILD</blockquote></p>     <p><blockquote>+ rm -rf myapp-1.0</blockquote></p>     <p><blockquote>+ /usr/bin/gzip -dc /usr/src/packages/SOURCES/myapp-1.0.tar.gz</blockquote></p>     <p><blockquote>+ tar -xf -</blockquote></p>     <p><blockquote>+ STATUS=0</blockquote></p>     <p><blockquote>+ '[' 0 -ne 0 '] '</blockquote></p>     <p><blockquote>+ cd myapp-1.0</blockquote></p>     <p><blockquote>++ /usr/bin/id -u</blockquote></p>     <p><blockquote>+ '[' 1000 = 0 ']'</blockquote></p>     <p><blockquote>++ /usr/bin/id -u</blockquote></p>     <p><blockquote>+ '[' 1000 = 0 ']'</blockquote></p>     <p><blockquote>+ /bin/chmod -Rf a+rX, u+w, g-w, o-w</blockquote></p>     <p><blockquote>+ exit 0</blockquote></p>     <p><blockquote>Executing(%build): /bin/sh -e /var/tmp/rpm-tmp.99663</blockquote></p>     <p><blockquote>+ umask 022</blockquote></p>     <p><blockquote>+ cd /usr/src/packages/BUILD</blockquote></p>     <p><blockquote>+ /bin/rm -rf /var/tmp/myapp-1.0-root</blockquote></p>     <p><blockquote>++ dirname /var/tmp/myapp-1.0-root</blockquote></p>     <p><blockquote>+ /bin/mkdir -p /var/tmp</blockquote></p>     <p><blockquote>+ /bin/mkdir /var/tmp/myapp-1.0-root</blockquote></p>     <p><blockquote>+ cd myapp-1.0 + make</blockquote></p>     <p><blockquote>gcc -g -Wall -ansi -с -o main.о main.c</blockquote></p>     <p><blockquote>gcc -g -Wall -ansi -с -o 2.o 2.c</blockquote></p>     <p><blockquote>ar rv mylib.a 2.o</blockquote></p>     <p><blockquote>ar: creating mylib.a</blockquote></p>     <p><blockquote>a - 2.о</blockquote></p>     <p><blockquote>gcc -g -Wall -ansi -с -o 3.o 3.c</blockquote></p>     <p><blockquote>ar rv mylib.a 3.o</blockquote></p>     <p><blockquote>a — 3.o</blockquote></p>     <p><blockquote>gcc -o myapp main.о mylib.a</blockquote></p>     <p><blockquote>+ exit 0</blockquote></p>     <p><blockquote>Executing(%install): /bin/sh -e /var/tmp/rpm-tmp.47320</blockquote></p>     <p><blockquote>+ umask 022</blockquote></p>     <p><blockquote>+ cd /usr/src/packages/BUILD</blockquote></p>     <p><blockquote>+ cd myapp-1.0</blockquote></p>     <p><blockquote>+ mkdir -p /var/tmp/myapp-1.0-root/usr/bin</blockquote></p>     <p><blockquote>+ mkdir -p /var/tmp/myapp-1.0-root/usr/share/man</blockquote></p>     <p><blockquote>+ install -m755 myapp /var/tmp/myapp-1.0-root/usr/bin/myapp</blockquote></p>     <p><blockquote>+ install -m755 myapp.1 /var/tmp/myapp-1.0-root/usr/share/man/myapp.1</blockquote></p>     <p><blockquote>+ RPM_BUILD_ROOT=/var/tmp/myapp-1.0-root</blockquote></p>     <p><blockquote>+ export RPM_BUILD_ROOT</blockquote></p>     <p><blockquote>+ test -x /usr/sbin/Check -a 1000 = 0 -o</blockquote></p>     <p><blockquote> -x /usr/sbin/Check -a '!' -z /var/tmp/myapp-1.0-root</blockquote></p>     <p><blockquote>+ echo 'I call /usr/sbin/Check...'</blockquote></p>     <p><blockquote>I call /usr/sbin/Check...</blockquote></p>     <p><blockquote>+ /usr/sbin/Check</blockquote></p>     <p><blockquote>-rwxr-xr-x 1 neil users 926 2007-07-09 13:35 /var/tmp/myapp-1.0-root/ /usr/share/man/myapp.1.gz</blockquote></p>     <p><blockquote>Checking permissions and ownerships — using the permissions files</blockquote></p>     <p><blockquote> /tmp/Check.perms.017506</blockquote></p>     <p><blockquote>setting /var/tmp/myapp-1.0-root/ to root:root 0755 (wrong owner/group neil:users)</blockquote></p>     <p><blockquote>setting /var/tmp/myapp-1.0-root/usr to root:root 0755. (wrong owner/group neil:users)</blockquote></p>     <p><blockquote>+ /usr/lib/rpm/brp-compress</blockquote></p>     <p><blockquote>+ /usr/lib/rpm/brp-symlink</blockquote></p>     <p><blockquote>Processing files: myapp-1.0-1</blockquote></p>     <p><blockquote>Finding Provides: /usr/lib/rpm/find-provides myapp</blockquote></p>     <p><blockquote>Finding Requires: /usr/lib/rpm/find-requires myapp</blockquote></p>     <p><blockquote>Finding Supplements: /usr/lib/rpm/find-supplements myapp</blockquote></p>     <p><blockquote>Provides: goodness</blockquote></p>     <p><blockquote>Requires(interp): /bin/sh</blockquote></p>     <p><blockquote>Requires(rpmlib): rpmlib(PayloadFilesHavePrefix) &lt;= 4.0-1</blockquote></p>     <p><blockquote> rpmlib (CompressedFileNames) &lt;= 3.0.4-1</blockquote></p>     <p><blockquote>Requires(post): /bin/sh</blockquote></p>     <p><blockquote>Requires: mysql &gt;= 3.23 libc.so.6 libc.so.6 (GLIBC 2.0)</blockquote></p>     <p><blockquote>Checking for unpackaged file(s): /usr/lib/rpm/check-files /var/tmp/myapp-1.0-root</blockquote></p>     <p><blockquote>Wrote: /usr/src/packages/SRPMS/myapp-1.0-1.src.rpm</blockquote></p>     <p><blockquote>Wrote: /usr/src/packages/RPMS/i586/myapp-1.0-1.i586.rpm</blockquote></p>     <p><blockquote>Executing(%clean): /bin/sh -e /var/tmp/rpm-tmp.10065</blockquote></p>     <p><blockquote>+ umask 022</blockquote></p>     <p><blockquote>+ cd /usr/src/packages/BUILD</blockquote></p>     <p><blockquote>+ cd myapp-1.0</blockquote></p>     <p><blockquote>+ rm -rf /var/tmp/myapp-1.0-root</blockquote></p>     <p><blockquote>+ exit 0</blockquote></p>     <p>Когда сборка будет закончена, вы должны увидеть два пакета: двоичный RPM-пакет в подкаталоге с названием типа архитектуры, например i586 каталога RPMS, и RPM-пакет исходных файлов в каталоге SRPMS.</p>     <p>У файла двоичного RPM-пакета будет имя, похожее на следующее:</p>     <p><blockquote>myapp-1.0-1.i586.rpm</blockquote></p>     <p>У вашей системы может быть другая архитектура.</p>     <p>Имя файла RPM-пакета исходных файлов будет следующим:</p>     <p><blockquote>myapp-1.0-1.src.rpm</blockquote></p>     <blockquote>      <b>Примечание</b>      <p>Пакеты должен устанавливать суперпользователь. Создавать пакеты от имени пользователя root нет необходимости, если у вас есть права на запись в каталоги RPM-системы, обычно это каталоги /usr/src/redhat. Как правило, не следует создавать RPM-пакеты как пользователь root, потому что в файле spec могут быть команды, способные повредить вашу систему.</p>     </blockquote>              <a name="metkadoc28"><h1>Пакеты других форматов</h1></a>    <p>Несмотря на то, что RPM — популярный способ распространения приложений, позволяющий пользователям управлять установкой и деинсталляцией пакетов, существуют и конкурирующие пакеты. Некоторое программное обеспечение все еще распространяется в виде сжатых программой <blockquote>gzip</blockquote> tar-файлов (tgz). Обычно инсталляция состоит из распаковки архива во временный каталог и затем выполнения сценария непосредственно установки.</p>    <p>Дистрибутивы Linux Debian и на основе Debian (а также некоторые другие) поддерживают другой формат упаковки, по функциональности похожий на RPM и именуемый dpkg. Утилита dpkg дистрибутива Debian распаковывает и устанавливает файлы пакета, обычно имеющие расширение deb. Если вам нужно распространять приложение как файл пакета с расширением deb, можно преобразовать RPM-пакет в формат dpkg с помощью утилиты Alien. Дополнительную информацию о ней можно найти на Web-сайте <b>http://kitenet.net/programs/alien/.</b></p>          <a name="metkadoc29"><h1>Среды разработки</h1></a>         <p>Почти все средства, рассматриваемые до сих пор в этой главе, по существу представляют собой средства режима командной строки. У разработчиков, работавших в ОС Windows, несомненно есть опыт работы с интегрированными средами разработки (IDE, Integrated Development Environment). IDE — это графическая оболочка, в которой собраны вместе все или некоторые средства, необходимые для создания, отладки и выполнения приложения. Обычно она как минимум содержит редактор, обозреватель файлов и средство для выполнения приложения и перехвата результата. В более полные среды включена поддержка генерации исходных файлов на базе шаблонов, разработанных для приложений определенных типов, интеграция с системой управления исходным программным кодом и автоматическое документирование.</p>     <p>В следующих разделах мы рассмотрим одну такую IDE, KDevelop, и упомянем другие IDE, доступные для ОС Linux сегодня. Эти среды разработки активно развиваются, и лучшие из них начинают конкурировать с коммерческими предложениями.</p>             <a name="metkadoc30"><h1>KDevelop</h1></a>     <p>KDevelop — это IDE для программ на языках С и С++. Она обеспечивает особую поддержку при создании приложений, выполняющихся в среде K Desktop Environment (KDE), одном из двух основных современных пользовательских графических интерфейсов в системах Linux. Ее можно использовать и для проектов других типов, включая простые программы на языке С.</p>     <p>KDevelop — бесплатное программное обеспечение, выпускаемое в соответствии с требованиями Общедоступной лицензии проекта GNU (General Public License, GPL), и имеющееся во многих дистрибутивах Linux. Самую свежую версию можно загрузить с Web-сайта <b>http://www.kdevelop.org.</b> Проекты, созданные с помощью среды KDevelop, по умолчанию следуют стандартам, принятым для проектов GNU. Например, они будут применять утилиту <blockquote>autoconf</blockquote> для генерации make-файлов, которые специально приспособлены к среде, для которой формируются. Это означает, что проект готов к распространению в виде исходного кода, который с большой вероятностью будет успешно откомпилирован в других системах.</p>     <p>Проекты KDevelop также содержат шаблоны для создания документации, текст лицензии GPL и общие инструкции по установке. Количество файлов, генерируемых при создании проекта KDevelop, может испугать, но познакомьтесь с кем-нибудь, кто загружал из Интернета и компилировал типовое приложение GPL.</p>     <img src="image035.jpg"/>     <p><b>Рис. 9.2</b> </p>     <br>     <p>В среде KDevelop существует поддержка систем CVS и Subversion для управления исходным программным кодом, и приложения могут редактироваться и отлаживаться без выхода из среды разработки. На рис. 9.2 и 9.3 показано стандартное приложение на С в среде KDevelop (еще одна программа, приветствующая мир), которое редактируется и выполняется.</p>     <img src="image036.jpg"/>     <p><b>Рис. 9.3</b> </p>             <a name="metkadoc31"><h1>Другие среды разработки</h1></a>     <p>Для ОС Linux имеется в наличии иди разрабатывается множество других редакторов и IDE, как бесплатных, так и коммерческих. Несколько самых интересных приведено в табл. 9.6.</p>     <br>     <p><b><i>Таблица 9.6</i></b></p>     <table>      <tr>       <th valign="top">Среда разработки</th>       <th valign="top">Тип</th>       <th valign="top">URL программного продукта</th>      </tr>      <tr>       <td valign="top">Eclipse</td>       <td valign="top">Платформа на базе языка Java и IDE</td>       <td valign="top"><b>http://www.eclipse.org</b></td>      </tr>      <tr>       <td valign="top">Anjuta</td>       <td valign="top">IDE для пользовательского графического интерфейса GNOME</td>       <td valign="top"><b>http://anjuta.sourceforge.net/</b></td>      </tr>      <tr>       <td valign="top">QtEZ</td>       <td valign="top">IDE для пользовательского графического интерфейса KDE</td>       <td valign="top"><b>http://projects.uid0.sk/qtez/</b></td>      </tr>      <tr>       <td valign="top">SlickEdit</td>       <td valign="top">Коммерческий редактор кода с поддержкой многих языков</td>       <td valign="top"><b>http://www.slickedit.com/</b></td>      </tr>     </table>              <a name="metkadoc32"><h1>Резюме</h1></a>    <p>В этой главе вы увидели лишь несколько средств ОС Linux, делающих разработку и распространение программ управляемыми. Первое и, может быть, самое важное — вы применили команду <blockquote>make</blockquote> и make-файлы для управления множественными исходными файлами. Далее вы познакомились с управлением исходным программным кодом с помощью систем RCS и CVS, которые позволяют отслеживать изменения в процессе разработки программ. Затем вы рассмотрели распространение программ с помощью команды <blockquote>patch</blockquote>, совместного применения команд <blockquote>tar</blockquote> и <blockquote>gzip</blockquote> и RPM-пакетов. В заключение вы бросили взгляд на одно из средств, IDE KDevelop, немного облегчающее цикл разработки программы, включающий редактирование, выполнение и отладку. </p>     <br><br>
<center><div align="center"><a href="index.php.html">Оглавление</a></div></center>




<br>
<script type="text/javascript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="https://www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script><br>

<noindex>
<div align="center">
<center>

<!-- SAPE RTB DIV 600x340 -->
<div id="SRTB_507029"></div>
<!-- SAPE RTB END -->

</center>
</div>
</noindex>

</td>
<td width="240" valign="top">

<br>

<div id="menu3">
<ul>
<li><a href="../../alternativnaja_medicina/index.html"><span>Альтернативная медицина</span></a></li>
<li><a href="../../astronomija_i_kosmos/index.html"><span>Астрономия и Космос</span></a></li>
<li><a href="../../biologija/index.html"><span>Биология</span></a></li>
<li><a href="../../voennaja_istorija/index.html"><span>Военная история</span></a></li>
<li><a href="../../geologija_i_geografija/index.html"><span>Геология и география</span></a></li>
<li><a href="../../gosudarstvo_i_pravo/index.html"><span>Государство и право</span></a></li>
<li><a href="../../delovaja_literatura/index.html"><span>Деловая литература</span></a></li>
<li><a href="../../domashnie_zhivotnye/index.html"><span>Домашние животные</span></a></li>
<li><a href="../../domovodstvo/index.html"><span>Домоводство</span></a></li>
<li><a href="../../zdorove/index.html"><span>Здоровье</span></a></li>
<li><a href="../../istorija/index.html"><span>История</span></a></li>
<li><a href="../index.html"><span>Компьютеры и Интернет</span></a></li>
<li><a href="../../kulinarija/index.html"><span>Кулинария</span></a></li>
<li><a href="../../kulturologija/index.html"><span>Культурология</span></a></li>
<li><a href="../../literaturovedenie/index.html"><span>Литературоведение</span></a></li>
<li><a href="../../matematika/index.html"><span>Математика</span></a></li>
<li><a href="../../medicina/index.html"><span>Медицина</span></a></li>
<li><a href="../../nauchnaja_literatura_prochee/index.html"><span>Науч. литер. - прочее</span></a></li>
<li><a href="../../pedagogika/index.html"><span>Педагогика</span></a></li>
<li><a href="../../politika/index.html"><span>Политика</span></a></li>
<li><a href="../../psihologija/index.html"><span>Психология</span></a></li>
<li><a href="../../religiovedenie/index.html"><span>Религиоведение</span></a></li>
<li><a href="../../sad_i_ogorod/index.html"><span>Сад и огород</span></a></li>
<li><a href="../../samosovershenstvovanie/index.html"><span>Самосовершенствование</span></a></li>
<li><a href="../../sdelai_sam/index.html"><span>Сделай сам</span></a></li>
<li><a href="../../sport/index.html"><span>Спорт</span></a></li>
<li><a href="../../tehnicheskie_nauki/index.html"><span>Технические науки</span></a></li>
<li><a href="../../transport_i_aviacija/index.html"><span>Транспорт и авиация</span></a></li>
<li><a href="../../uchebniki/index.html"><span>Учебники</span></a></li>
<li><a href="../../fizika/index.html"><span>Физика</span></a></li>
<li><a href="../../filosofija/index.html"><span>Философия</span></a></li>
<li><a href="../../himija/index.html"><span>Химия</span></a></li>
<li><a href="../../hobbi_i_remesla/index.html"><span>Хобби и ремесла</span></a></li>
<li><a href="../../shpargalki/index.html"><span>Шпаргалки</span></a></li>
<li><a href="../../yezoterika/index.html"><span>Эзотерика</span></a></li>
<li><a href="../../yurisprudencija/index.html"><span>Юриспруденция</span></a></li>
<li><a href="../../jazykoznanie/index.html"><span>Языкознание</span></a></li>
</ul>
</div>

<br>
<div align="center">
<center>
<noindex>

<!-- SAPE RTB DIV 240x400 -->
<div id="SRTB_507028"></div>
<!-- SAPE RTB END -->

</noindex>
</center>
</div>

</td>
</tr>
<tr>
<td colspan="3" align="center">


<hr>
<a href="../../index.html"><span>Главная</span></a> | 
<a rel="sidebar" href="p13.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a> | 
<a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a> | 
<a href="p13.php.html#" onClick="scroll(0,0); return false" title="наверх">Наверх</a>
</td>
</tr>
<tr>
<td colspan="3" valign="top" align="left">
<br>

 



</td>
</tr>
</table>

<noindex>
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter21717787 = new Ya.Metrika({id:21717787,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="http://mc.yandex.ru/watch/21717787" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

</noindex>
</center>
</div></body>
</html>