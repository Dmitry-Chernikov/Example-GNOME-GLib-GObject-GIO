<html>
<head>
<meta http-equiv="Content-Language" content="ru">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<link href="../../0img/style.css" rel="stylesheet" type="text/css" />
<link rel="SHORTCUT ICON" href="http://www.redov.ru/0img/favicon.ico" type="image/x-icon"> 
<title>Глава 3 Работа с файлами / Основы программирования в Linux</title>
</head>
<body>
<div align="center">
<center>
<table border="0" cellpadding="0" cellspacing="0" width="1260">
<tr>
<td colspan="3" valign="top" align="left" height="100">
<table border="0" cellpadding="0" cellspacing="0" width="1260" height="100">
<tr>
<td valign="middle" align="center" width="350">
<a href="../../index.html"><img src="../../0img/logo.jpg" width="350" height="100" title="Онлайн библиотека redov.ru"/></a>
</td>
<td valign="middle" align="center" width="910">

<noindex>

<!-- SAPE RTB JS -->
<script
    async="async"
    src="http://cdn-rtb.sape.ru/rtb-b/js/393/2/106393.js"
    type="text/javascript">
</script>
<!-- SAPE RTB END -->

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507025"></div>
<!-- SAPE RTB END -->

</noindex>

</td>
</tr>
</table>
</td>
</tr>
<tr>
<td colspan="3" valign="middle" align="left">

<div id="menu">
<ul>
		<li><a href="../../index.html"><span>Главная</span></a></li>
		<li><a rel="sidebar" href="p7.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a></li>
		<li><a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a></li>
		<li><a href="p7.php.html#" onClick="scroll(0,9999999); return false"><span>Вниз</span></a></li>
</ul>
</div>


</td>
</tr>
<tr>
<td width="240" valign="top" align="center">

<br>
<noindex>
<!-- SAPE RTB DIV 160x600 -->
<div id="SRTB_733378"></div>
<!-- SAPE RTB END -->
</noindex>



</td>
<td valign="top" align="left" style="padding-left: 5; padding-right: 5" width="780">
<br>
<noindex>
<div align="center">

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507027"></div>
<!-- SAPE RTB END -->

</div>
</noindex>
<br>



<li><a href="p7.php.html#metkadoc2">     Структура файла в Linux     </a></li>
<li><a href="p7.php.html#metkadoc3">      Каталоги      </a></li>
<li><a href="p7.php.html#metkadoc4">      Файлы и устройства      </a></li>
<li><a href="p7.php.html#metkadoc5">     Системные вызовы и драйверы устройств     </a></li>
<li><a href="p7.php.html#metkadoc6">     Библиотечные функции     </a></li>
<li><a href="p7.php.html#metkadoc7">     Низкоуровневый доступ к файлам     </a></li>
<li><a href="p7.php.html#metkadoc8">      <i>write</i>      </a></li>
<li><a href="p7.php.html#metkadoc9">      <i>read</i>      </a></li>
<li><a href="p7.php.html#metkadoc10">      <i>open</i>      </a></li>
<li><a href="p7.php.html#metkadoc11">      Исходные права доступа      </a></li>
<li><a href="p7.php.html#metkadoc12">      Другие системные вызовы для управления файлами      </a></li>
<li><a href="p7.php.html#metkadoc13">     Стандартная библиотека ввода/вывода     </a></li>
<li><a href="p7.php.html#metkadoc14">      <i>fopen</i>      </a></li>
<li><a href="p7.php.html#metkadoc15">      <i>fread</i>      </a></li>
<li><a href="p7.php.html#metkadoc16">      <i>fwrite</i>      </a></li>
<li><a href="p7.php.html#metkadoc17">      <i>fclose</i>      </a></li>
<li><a href="p7.php.html#metkadoc18">      <i>fflush</i>      </a></li>
<li><a href="p7.php.html#metkadoc19">      <i>fseek</i>      </a></li>
<li><a href="p7.php.html#metkadoc20">      <i>fgetc, getc</i> и <i>getchar</i>      </a></li>
<li><a href="p7.php.html#metkadoc21">      <i>fputc, putc</i> и <i>putchar</i>      </a></li>
<li><a href="p7.php.html#metkadoc22">      <i>fgets</i> и <i>gets</i>      </a></li>
<li><a href="p7.php.html#metkadoc23">     Форматированные ввод и вывод     </a></li>
<li><a href="p7.php.html#metkadoc24">      <i>printf, fprintf</i> и <i>sprintf</i>      </a></li>
<li><a href="p7.php.html#metkadoc25">      <i>scanf, fscanf</i> и <i>sscanf</i>      </a></li>
<li><a href="p7.php.html#metkadoc26">      Другие потоковые функции      </a></li>
<li><a href="p7.php.html#metkadoc27">      Ошибки потока      </a></li>
<li><a href="p7.php.html#metkadoc28">      Потоки и дескрипторы файлов      </a></li>
<li><a href="p7.php.html#metkadoc29">     Ведение файлов и каталогов     </a></li>
<li><a href="p7.php.html#metkadoc30">      <i>chmod</i>      </a></li>
<li><a href="p7.php.html#metkadoc31">      <i>chown</i>      </a></li>
<li><a href="p7.php.html#metkadoc32">      <i>unlink, link</i> и <i>symlink</i>      </a></li>
<li><a href="p7.php.html#metkadoc33">      <i>mkdir</i> и <i>rmdir</i>      </a></li>
<li><a href="p7.php.html#metkadoc34">      <i>chdir</i> и <i>getcwd</i>      </a></li>
<li><a href="p7.php.html#metkadoc35">     Просмотр каталогов     </a></li>
<li><a href="p7.php.html#metkadoc36">      <i>opendir</i>      </a></li>
<li><a href="p7.php.html#metkadoc37">      <i>readdir</i>      </a></li>
<li><a href="p7.php.html#metkadoc38">      <i>telldir</i>      </a></li>
<li><a href="p7.php.html#metkadoc39">      <i>seekdir</i>      </a></li>
<li><a href="p7.php.html#metkadoc40">      <i>closedir</i>      </a></li>
<li><a href="p7.php.html#metkadoc41">     Ошибки      </a></li>
<li><a href="p7.php.html#metkadoc42">      <i>strerror</i>      </a></li>
<li><a href="p7.php.html#metkadoc43">      <i>perror</i>      </a></li>
<li><a href="p7.php.html#metkadoc44">     Файловая система procfs     </a></li>
<li><a href="p7.php.html#metkadoc45">     Более сложные приемы: <i>fcntl </i>и <i>mmap</i>     </a></li>
<li><a href="p7.php.html#metkadoc46">      <i>fcntl</i>      </a></li>
<li><a href="p7.php.html#metkadoc47">      <i>mmap</i>      </a></li>
<li><a href="p7.php.html#metkadoc48">     Резюме     </a></li>
<a name="metkadoc1"><h1>Глава 3</p>    <p>Работа с файлами</h1></a>       <p>В этой главе будут рассматриваться файлы и каталоги ОС Linux и способы работы с ними. Вы научитесь создавать файлы, открывать и читать их, писать в них и удалять их. Вы также узнаете, как программы могут обрабатывать каталоги (например, создавать, просматривать и удалять их). После сделанного в предыдущей главе отступления, посвященного командным оболочкам, теперь вы начнете программировать на языке С.</p>    <p>Прежде чем перейти к способам обработки файлового ввода/вывода в системе Linux, мы дадим краткий обзор понятий, связанных с файлами, каталогами и устройствами. Для управления файлами и каталогами вам придется выполнять системные вызовы (аналог Windows API в системах UNIX и Linux), но, кроме того, для обеспечения более эффективного управления файлами существует большой набор библиотечных функций стандартной библиотеки ввода/вывода (stdio).</p>    <p>Большую часть главы мы посвятим работе с различными вызовами, необходимыми для обработки файлов и каталогов. Таким образом, в данной главе будут обсуждаться разные темы, связанные с файлами:</p>    <p>&#9633; файлы и устройства;</p>    <p>&#9633; системные вызовы;</p>    <p>&#9633; библиотечные функции;</p>    <p>&#9633; низкоуровневый доступ к файлу;</p>    <p>&#9633; управление файлами;</p>    <p>&#9633; стандартная библиотека ввода/вывода;</p>    <p>&#9633; форматированный ввод и вывод;</p>    <p>&#9633; сопровождение файлов и каталогов;</p>    <p>&#9633; просмотр каталогов;</p>    <p>&#9633; ошибки;</p>    <p>&#9633; файловая система /proc;</p>    <p>&#9633; более сложные приемы — <blockquote>fcntl</blockquote> и <blockquote>mmap</blockquote>.</p>          <a name="metkadoc2"><h1>Структура файла в Linux</h1></a>         <p>Вы можете спросить: "Зачем вы останавливаетесь на структуре файла? Я уже знаком с ней." Дело в том, что в среде Linux, как и UNIX, файлы особенно важны, поскольку они обеспечивают простую и согласованную взаимосвязь со службами операционной системы и устройствами. В ОС Linux <i>файл — это все что угодно. </i>Ну, или почти все!</p>     <p>Это означает, что в основном программы могут обрабатывать дисковые файлы, последовательные порты, принтеры и другие устройства точно так же, как они используют файлы. Мы расскажем о некоторых исключениях, таких как сетевые подключения, в<i> главе 15,</i> но в основном вы должны будете применять пять базовых функций: <blockquote>open</blockquote>, <blockquote>close</blockquote>, <blockquote>read</blockquote>, <blockquote>write</blockquote> и <blockquote>ioctl</blockquote>.</p>     <p>Каталоги — тоже специальный тип файлов. В современных версиях UNIX, включая Linux, даже суперпользователь не пишет непосредственно в них. Обычно все пользователи для чтения каталогов применяют интерфейс <blockquote>opendir/readdir</blockquote>, и им нет нужды знать подробности реализации каталогов в системе. Позже в этой главе мы вернемся к специальным функциям работы с каталогами.</p>     <p>Действительно, в ОС Linux почти все представлено в виде файлов или может быть доступно с помощью специальных файлов. И основная идея сохраняется даже, несмотря на то, что существуют в силу необходимости небольшие отличия от известных и любимых вами традиционных файлов. Давайте рассмотрим особые случаи, о которых мы уже упоминали.</p>             <a name="metkadoc3"><h1>Каталоги</h1></a>     <p>Помимо содержимого у файла есть имя и набор свойств, или "административная информация", т.е. дата создания/модификации файла и права доступа к нему. Свойства хранятся в<i> файловом индексе</i> (inode), специальном блоке данных файловой системы, который также содержит сведения о длине файла и месте хранения файла на диске. Система использует номер файлового индекса; для нашего удобства структуру каталога также называют файлом.</p>     <p>Каталог — это файл, содержащий номера индексов и имена других файлов. Каждый элемент каталога — ссылка на файловый индекс; удаляя имя файла, вы удаляете ссылку. (Номер индекса файла можно увидеть с помощью команды <blockquote>ln -i</blockquote>.) Применяя команду <blockquote>ln</blockquote>, вы можете создать ссылки на один и тот же файл в разных каталогах.</p>     <p>Когда вы удаляете файл, удаляется элемент каталога для этого файла, и количество ссылок на файл уменьшается на единицу. Данные файла могут быть все еще доступны благодаря другим ссылкам на этот же файл. Когда число ссылок на файл (число, идущее после прав доступа в команде <blockquote>ls -l</blockquote>) становится равно нулю, индекс файла и блоки данных, на которые он ссылается, больше не используются и помечаются как свободные.</p>     <p>Файлы помещаются в каталоги, которые могут содержать подкаталоги. Так формируется хорошо знакомая иерархия файловой системы. Пользователь, скажем neil, обычно хранит файлы в исходном (home) каталоге, возможно /home/neil, с подкаталогами для хранения электронной почты, деловых писем, служебных программ и т.д. Имейте в виду, что у многих командных оболочек систем UNIX и Linux есть отличное обозначение для указания начала пути в вашем исходном каталоге: символ "тильда" (~). Для другого пользователя наберите <blockquote>~user</blockquote>. Как вы знаете, исходные каталоги пользователей — это, как правило, подкаталоги каталога более высокого уровня, создаваемого специально для этой цели, в нашем случае это каталог /home.</p>     <blockquote>      <b>Примечание</b>      <p>К сожалению, функции стандартной библиотеки при указании имени файла как параметра не понимают сокращенного обозначения с помощью тильды, поэтому в ваших программах следует всегда явно задавать полное имя файла.</p>     </blockquote>     <p>Каталог /home в свою очередь является подкаталогом корневого каталога /, расположенного на верхнем уровне иерархии и содержащего все системные файлы и подкаталоги. В корневой каталог обычно включен каталог /bin для хранения системных программ (бинарных файлов), каталог /etc, предназначенный для хранения системных файлов конфигурации, и каталог /lib для хранения системных библиотек. Файлы, представляющие физические устройства и предоставляющие интерфейс для этих устройств, принято помещать в каталог /dev. На рис. 3.1 показана в качестве примера часть типичной файловой системы Linux. Мы рассмотрим структуру файловой системы Linux более подробно в<i> главе 18,</i> когда будем обсуждать стандарт файловой системы Linux (Linux File System Standard).</p>     <img src="image008.jpg"/>     <p><b>Рис. 3.1</b> </p>             <a name="metkadoc4"><h1>Файлы и устройства</h1></a>     <p>Даже физические устройства очень часто представляют (отображают) с помощью файлов. Например, будучи суперпользователем, вы можете смонтировать дисковод IDE CD-ROM как файл:</p>     <p><blockquote># <b>mount -t iso9660 /dev/hdc /mnt/cdrom</b></blockquote></p>     <p><blockquote># <b>cd /mnt/cdrom</b></blockquote></p>     <p>который выбирает устройство CD-ROM (в данном случае вторичное ведущее (secondary master) устройство IDE, которое загружается как /dev/hdc во время начального запуска системы; у устройств других типов будут другие элементы каталога /dev) и монтирует его текущее содержимое как файловую структуру в каталоге /mnt/cdrom. Затем вы перемещаетесь по каталогам компакт-диска как обычно, конечно за исключением того, что их содержимое доступно только для чтения.</p>     <p>В системах UNIX и Linux есть три важных файла устройств: /dev/console, /dev/tty и /dev/null.</p>     <b><i>dev/console</i></b>     <p>Это устройство представляет системную консоль. На него часто отправляются сообщения об ошибках и диагностическая информация. У всех систем UNIX есть выделенный терминал или экран для получения сообщений консоли. Иногда он может быть выделенным печатающим терминалом. На современных рабочих станциях и в ОС Linux обычно это активная виртуальная консоль, а под управлением графической среды X Window это устройство станет специальным окном консоли на экране.</p>     <b><i>/dev/tty</i></b>     <p>Специальный файл /dev/tty — это псевдоним (логическое устройство) управляющего терминала (клавиатуры и экрана или окна) процесса, если таковой есть. (Например, у процессов и сценариев, автоматически запускаемых системой, не будет управляющего терминала, следовательно, они не смогут открыть файл /dev/tty.)</p>     <p>Там где этот файл, /dev/tty может применяться, он позволяет программе писать непосредственно пользователю независимо от того, какой псевдотерминал или аппаратный терминал он использует. Это полезно при перенаправлении стандартного вывода. Примером может служить отображение содержимого длинного каталога в виде группы страниц с помощью команды <blockquote>ls -R | more</blockquote>, в которой у программы more есть пользовательская подсказка для каждой новой страницы вывода. Вы узнаете больше о файле /dev/tty в<i> главе 5</i>.</p>     <p>Учтите, что существует только одно устройство /dev/console, и в то же время может существовать много разных физических устройств, к которым можно обратиться с помощью файла dev/tty.</p>     <b><i>/dev/null</i></b>     <p>Файл /dev/null — это фиктивное устройство. Весь вывод, записанный на это устройство, отбрасывается. Когда устройство читается, немедленно возвращается конец файла, поэтому данное устройство можно применять с помощью команды cp как источник пустых файлов. Нежелательный вывод очень часто перенаправляется на dev/null.</p>     <p><blockquote>$ <b>echo do not want to see this &gt;/dev/null</b></blockquote></p>     <p><blockquote>$ <b>cp /dev/null empty_file</b></blockquote></p>     <blockquote>      <b>Примечание</b>      <p>Другой способ создания пустых файлов — применение команды <blockquote>touch &lt;<i>имя файла&gt;</i></blockquote><i>, </i>изменяющей время модификации файла или создающей новый файл при отсутствии файла с заданным именем. Хотя она и не очищает содержимое обрабатываемого файла.</p>     </blockquote>     <p>В каталоге /dev можно найти и другие устройства, такие как дисководы жестких дисков и флоппи-дисководы, коммуникационные порты, ленточные накопители, дисководы CD-ROM, звуковые карты и некоторые устройства, представляющие внутреннюю структуру системы. Есть даже устройство /dev/zero, действующее как источник нулевых байтов для создания файлов, заполненных нулями. Для доступа к некоторым из этих устройств вам понадобятся права супер пользователя; обычные пользователи не могут писать программы, непосредственно обращающиеся к низкоуровневым устройствам, таким как накопители жестких дисков. Имена файлов устройств могут быть в разных системах различными. В дистрибутивах ОС Linux обычно есть приложения, выполняемые от имени суперпользователя и управляющие устройствами, которые иначе будут недоступны, например, mount для монтируемых пользователями файловых систем.</p>     <p>Устройства делятся на<i> символьные</i> и<i> блочные.</i> Отличие заключается в том, что к некоторым устройствам следует обращаться поблочно. Обычно только блочные устройства, такие как жесткие диски, поддерживают определенный тип файловой системы.</p>     <p>В этой главе мы сосредоточимся на дисковых файлах и каталогах. Другому устройству, пользовательскому терминалу, будет посвящена<i> глава 5.</i></p>              <a name="metkadoc5"><h1>Системные вызовы и драйверы устройств</h1></a>    <p>Вы можете обращаться к файлам и устройствам и управлять ими, применяя небольшой набор функций. Эти функции, известные как<i> системные вызовы</i>, непосредственно представляются системой UNIX (и Linux) и служат интерфейсом самой операционной системы.</p>    <p>В сердце операционной системы, ее ядре, есть ряд<i> драйверов устройств.</i> Они представляют собой коллекцию низкоуровневых интерфейсов для управления оборудованием системы. Например, в ней есть драйвер устройства для ленточного накопителя, который знает, как запустить ленту, перемотать ее вперед и назад, прочитать ее и записать на нее и т.д. Ему известно, что на ленту следует писать данные блоками определенного размера. Поскольку ленты — по природе своей устройства с последовательным доступом, драйвер не может обращаться непосредственно к блокам ленты, сначала он должен перемотать ленту до нужного места. Точно так же низкоуровневый драйвер накопителя жесткого диска будет записывать на диск в каждый момент времени только целое число дисковых секторов, но сможет прямо обратиться к любому нужному блоку диска, поскольку диск — это устройство с произвольным доступом.</p>    <p>Для формирования одинакового интерфейса драйверы устройств включают в себя все аппаратно-зависимые свойства. Уникальные аппаратные средства обычно доступны через системный вызов <blockquote>ioctl</blockquote> (I/O control, управление вводом/выводом).</p>    <p>Файлы устройств из каталога /dev используются одинаково: они могут открываться, читаться, на них можно записывать и их можно закрывать. Например, один и тот вызов <blockquote>open</blockquote>, используемый для доступа к обычному файлу, применяется для обращения к пользовательскому терминалу, принтеру или ленточному накопителю.</p>    <p>К низкоуровневым функциям или системным вызовам, используемым для обращения к драйверам устройств, относятся следующие:</p>    <p>&#9633; <blockquote>open</blockquote> — открывает файл или устройство;</p>    <p>&#9633; <blockquote>read</blockquote> — читает из открытого файла или устройства;</p>    <p>&#9633; <blockquote>write</blockquote> — пишет в файл или устройство;</p>    <p>&#9633; <blockquote>close</blockquote> — закрывает файл или устройство;</p>    <p>&#9633; <blockquote>ioctl</blockquote> — передает управляющую информацию драйверу устройства.</p>    <p>Системный вызов <blockquote>ioctl</blockquote> применяется для аппаратно-зависимого управления (как альтернатива стандартного ввода/вывода), поэтому он у каждого устройства свой. Например, вызов <blockquote>ioctl</blockquote> может применяться для перемотки ленты в ленточном накопителе или установки характеристик управления потоками последовательного порта. Этим объясняется необязательная переносимость <blockquote>ioctl</blockquote> с машины на машину. Кроме того, у каждого драйвера определен собственный набор команд <blockquote>ioctl</blockquote>.</p>    <p>Этот системный вызов, как и другие, обычно описывается в разделе 2 интерактивного справочного руководства. Прототипы функций со списком параметров и типом возвращаемого функцией значения, используемые в системных вызовах, а также связанные с ними директивы <blockquote>#define</blockquote> с определением констант представлены в файлах <blockquote>include</blockquote>. Нужные для каждого системного вызова дополнения будут подключаться с описаниями отдельных вызовов.</p>          <a name="metkadoc6"><h1>Библиотечные функции</h1></a>    <p>Проблема использования низкоуровневых системных вызовов непосредственно для ввода и вывода заключается в том, что они могут быть очень неэффективны. Почему? Ответ может быть следующим.</p>    <p>&#9633; При выполнении системных вызовов существуют эксплуатационные издержки. Поэтому системные вызовы требуют больше затрат по сравнению с библиотечными функциями, т.к. ОС Linux вынуждена переключаться с выполнения вашего программного кода на собственный код ядра и затем возвращаться к выполнению вашей программы. Было бы неплохо стараться свести к минимуму применение системных вызовов в программе и заставлять каждый такой вызов выполнять максимально возможный объем работы, например, считывать и записывать за один раз большие объемы данных, а не одиночные символы.</p>    <p>&#9633; У оборудования есть ограничения, накладываемые на размер блока данных, которые могут быть считаны или записаны в любой конкретный момент времени. У ленточных накопителей, например, часто есть размер блока для записи, скажем 10 Кбайт, поэтому, если вы попытаетесь записать количество информации, не кратное 10 Кбайт, накопитель переместит ленту к следующему блоку в 10 Кбайт, оставив на ленте пустоты.</p>    <p>Для формирования высокоуровневого интерфейса для устройств и дисковых файлов дистрибутив Linux (и UNIX) предоставляет ряд стандартных библиотек. Они представляют собой коллекции функций, которые вы можете включать в свои программы для решения подобных проблем. Хорошим примером может послужить стандартная библиотека ввода/вывода, обеспечивающая буферизованный вывод. Вы сможете эффективно записывать блоки данных разных размеров, применяя библиотечные функции, которые будут выполнять низкоуровневые системные вызовы, снабжая их полными блоками, как только данные станут доступны. Это существенно снижает издержки системных вызовов.</p>    <p>Библиотечные функции, как правило, описываются в разделе 3 интерактивного справочного руководства и часто снабжаются стандартным файлом директивы <blockquote>include</blockquote>, связанным с ними, например, файл stdio.h для стандартной библиотеки ввода/вывода.</p>    <p>Для обобщения материала последних нескольких разделов на рис. 3.2 приведена схема системы Linux, на которой показано, где расположены различные функции работы с файлами относительно пользователя, драйверов устройств, ядра системы и оборудования.</p>    <img src="image009.jpg"/>    <p><b>Рис. 3.2</b></p>          <a name="metkadoc7"><h1>Низкоуровневый доступ к файлам</h1></a>         <p>У каждой выполняющейся программы, называемой<i> процессом,</i> есть ряд связанных с ней дескрипторов файлов. Существуют короткие целые (small integer) числа, которые можно использовать для обращения к открытым файлам и устройствам. Количество дескрипторов зависит от конфигурации системы. Когда программа запускается, у нее обычно уже открыты три подобных дескриптора. К ним относятся следующие:</p>     <p>&#9633; 0 — стандартный ввод;</p>     <p>&#9633; 1 — стандартный вывод;</p>     <p>&#9633; 2 — стандартный поток ошибок.</p>     <p>Вы можете связать с файлами и устройствами другие дескрипторы файлов, используя системный вызов open, который уже обсуждался вкратце. Дескрипторы файлов, открытые автоматически, уже позволяют вам создавать простые программы с помощью вызова <blockquote>write</blockquote>.</p>             <a name="metkadoc8"><h1><i>write</i></h1></a>     <p>Системный вызов <blockquote>write</blockquote> предназначен для записи из <blockquote>buf</blockquote> первых <blockquote>nbytes</blockquote> байтов в файл, ассоциированный с дескриптором <blockquote>fildes</blockquote>. Он возвращает количество реально записанных байтов, которое может быть меньше <blockquote>nbytes</blockquote>, если в дескрипторе файла обнаружена ошибка или дескриптор файла, расположенный на более низком уровне драйвера устройства, чувствителен к размеру блока. Если функция возвращает 0, это означает, что ничего не записано; если она возвращает -1, в системном вызове <blockquote>write</blockquote> возникла ошибка, которая описывается в глобальной переменной <blockquote>errno</blockquote>,</p>     <p>Далее приведена синтаксическая запись.</p>     <p><blockquote><b>#include &lt;unistd.h&gt;</b></blockquote></p>     <p><blockquote><b>size_t write(int fildes, const void *buf, size_t nbytes);</b></blockquote></p>     <p>Благодаря полученным знаниям вы можете написать свою первую программу, simple_write.c:</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> if ((write(1, "Here is some data\n", 18)) != 18)</blockquote></p>     <p><blockquote>  write(2, "A write error has occurred on file descriptor 1\n", 46);</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Эта программа просто помещает сообщение в стандартный вывод. Когда она завершается, все открытые дескрипторы файлов автоматически закрываются, и вам не нужно закрывать их явно. Но в случае буферизованного вывода это не так.</p>     <p><blockquote>$ <b>./simple_write</b></blockquote></p>     <p><blockquote>Here is some data</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>И еще одно маленькое замечание: вызов <blockquote>write</blockquote> может сообщить о том, что записал меньше байтов, чем вы просили. Это не обязательно ошибка. В ваших программах вам придется для выявления ошибок проверить переменную <blockquote>errno</blockquote> и еще раз вызвать <blockquote>write</blockquote> для записи оставшихся данных.</p>             <a name="metkadoc9"><h1><i>read</i></h1></a>     <p>Системный вызов <blockquote>read</blockquote> считывает до <blockquote>nbytes</blockquote> байтов данных из файла, ассоциированного с дескриптором файла <blockquote>fildes</blockquote>, и помещает их в область данных <blockquote>buf</blockquote>. Он возвращает количество действительно прочитанных байтов, которое может быть меньше требуемого количества. Если вызов <blockquote>read</blockquote> возвращает 0, ему нечего считывать; он достиг конца файла. Ошибка при вызове заставляет его вернуть -1.</p>     <p><blockquote><b>#include &lt;unistd.h&gt;</b></blockquote></p>     <p><blockquote><b>size_t read(int fildes, void *buf, size_t nbytes);</b></blockquote></p>     <p>Программа simple_read.c копирует первые 128 байтов стандартного ввода в стандартный вывод. Она копирует все вводимые данные, если их меньше 128 байтов.</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> char buffer[128];</blockquote></p>     <p><blockquote> int nread;</blockquote></p>     <p><blockquote> nread = read(0, buffer, 128);</blockquote></p>     <p><blockquote> if (nread == -1)</blockquote></p>     <p><blockquote>  write(2, "A read error has occurred\n", 26);</blockquote></p>     <p><blockquote> if ((write(1, buffer, nread)) != nread)</blockquote></p>     <p><blockquote>  write(2, <i>"A</i> write error has occurred\n", 27);</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Если вы выполните программу, то получите следующий результат:</p>     <p><blockquote>$ echo <b>hello there | ./simple_read</b></blockquote></p>     <p><blockquote>hello there</blockquote></p>     <p><blockquote>$ <b>./simple_read &lt; draft1.txt</b></blockquote></p>     <p><blockquote>Files</blockquote></p>     <p><blockquote>In this chapter we will be looking at files and directories and how to</blockquote></p>     <p><blockquote>manipulate them. We will learn how to create files, $</blockquote></p>     <p>Первое выполнение программы с помощью команды <blockquote>echo</blockquote> формирует некоторый ввод программы, который по каналу передается в вашу программу. Во втором выполнении вы перенаправляете ввод из файла draft1.txt. В этом случае вы видите первую часть указанного файла, появляющуюся в стандартном выводе.</p>     <blockquote>      <b>Примечание</b>      <p>Обратите внимание на то, что знак подсказки или приглашения командной оболочки появляется в конце последней строки вывода, поскольку в этом примере 128 байтов не формируют целое число строк.</p>     </blockquote>             <a name="metkadoc10"><h1><i>open</i></h1></a>     <p>Для создания дескриптора нового файла вы должны применить системный вызов <blockquote>open</blockquote>.</p>     <p><blockquote><b>#include &lt;fcntl.h&gt;</b></blockquote></p>     <p><blockquote><b>#include &lt;sys/types.h&gt;</b></blockquote></p>     <p><blockquote><b>#include &lt;sys/stat.h&gt;</b></blockquote></p>     <br>     <p><blockquote><b>int open(const char *path, int oflags);</b></blockquote></p>     <p><blockquote><b>int open(const char *path, int oflags, mode_t mode);</b></blockquote></p>     <blockquote>      <b>Примечание</b>      <p>Строго говоря, для использования вызова <blockquote>open</blockquote> вы не должны включать файлы sys/types.h и sys/stat.h в системах, удовлетворяющих стандартам POSIX, но они могут понадобиться в некоторых системах UNIX.</p>     </blockquote>     <p>Не вдаваясь в подробности, скажем, что вызов <blockquote>open</blockquote> устанавливает путь к файлу или устройству. Если установка прошла успешно, он возвращает дескриптор файла, который может применяться в системных вызовах <blockquote>read</blockquote>, <blockquote>write</blockquote> и др. Дескриптор файла уникален и не используется совместно другими процессами, которые могут в данный момент выполняться. Если файл открыт одновременно в двух программах, они поддерживают отдельные дескрипторы файла. Если они обе пишут в файл, то продолжат запись с того места, где остановились. Их данные не чередуются, но данные одной программы могут быть записаны поверх данных другой. У каждой программы свое представление о том, какая порция файла (каково смещение текущей позиции в файле) прочитана или записана. Вы можете помешать нежелательным накладкам такого сорта с помощью блокировки файла, которая будет обсуждаться в<i> главе</i> 7.</p>     <p>Имя открываемого файла или устройства передается как параметр <blockquote>path</blockquote>; параметр <blockquote>oflags</blockquote> применяется для указания действий, предпринимаемых при открытии файла.</p>     <p>Параметр <blockquote>oflags</blockquote> задается как комбинация обязательного режима доступа к файлу и других необязательных режимов. Системный вызов <blockquote>open</blockquote> должен задавать один из режимов доступа к файлу, указанных в табл. 3.1.</p>     <br>     <p><b><i>Таблица 3.1</i></b></p>     <table>      <tr>       <th valign="top">Режим</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>О_RDONLY</blockquote></td>       <td valign="top">Открытие только для чтения</td>      </tr>      <tr>       <td valign="top"><blockquote>О_WRONLY</blockquote></td>       <td valign="top">Открытие только для записи</td>      </tr>      <tr>       <td valign="top"><blockquote>O_RDWR</blockquote></td>       <td valign="top">Открытие для чтения и записи</td>      </tr>     </table>     <p>Вызов может также включать в параметр <blockquote>oflags</blockquote> комбинацию (с помощью побитовой операции <blockquote>OR</blockquote>) следующих необязательных режимов:</p>     <p>&#9633; <blockquote>O_APPEND</blockquote> — помещает записываемые данные в конец файла;</p>     <p>&#9633; <blockquote>O_TRUNC</blockquote> — задает нулевую длину файла, отбрасывая существующее содержимое;</p>     <p>&#9633; <blockquote>O_CREAT</blockquote> — при необходимости создает файл с правами доступа, заданными в параметре <blockquote>mode</blockquote>;</p>     <p>&#9633; <blockquote>O_EXCL</blockquote> — применяется с режимом <blockquote>O_CREAT</blockquote>, который гарантирует, что вызывающая программа создаст файл. Вызов <blockquote>open</blockquote> атомарный, т.е. он выполняется только одним вызовом функции. Это предотвращает одновременное создание файла двумя программами. Если файл уже существует, <blockquote>open</blockquote> завершится неудачно.</p>     <p>Другие возможные значения параметра <blockquote>oflags</blockquote> описаны на странице интерактивного справочного руководства, посвященной open; ее можно найти в разделе 2 руководства (примените команду <blockquote>man 2 open</blockquote>).</p>     <p>Вызов <blockquote>open</blockquote> возвращает новый дескриптор файла (всегда неотрицательное целое) в случае успешного завершения или -1 в случае неудачи, в последнем случае open также задает глобальную переменную <blockquote>errno</blockquote>,чтобы показать причину неудачи. Мы рассмотрим <blockquote>errno</blockquote> более подробно в одном из последующих разделов. У нового дескриптора файла всегда наименьший неиспользованный номер дескриптора, свойство, которое может оказаться очень полезным в некоторых обстоятельствах. Например, если программа закрывает свой стандартный вывод, а затем снова вызывает open, будет повторно использован дескриптор файла с номером 1 и стандартный вывод будет успешно перенаправлен в другой файл или на другое устройство.</p>     <p>Существует также системный вызов <blockquote>creat</blockquote>, стандартизованный POSIX, но он применяется не часто. Он не только создает файл, как можно ожидать; но также и открывает его. Такой вызов эквивалентен вызову <blockquote>open</blockquote> с параметром <blockquote>oflags</blockquote>, равным <blockquote>O_CREAT|О_WRONLY|O_TRUNC</blockquote>.</p>     <p>Количество файлов, одновременно открытых в любой выполняющейся программе, ограничено. Предельное значение обычно определяется константой <blockquote>OPEN_MAX</blockquote> в файле limits.h и меняется от системы к системе, но стандарт POSIX требует, чтобы оно было не меньше 16. Это значение само по себе может быть ограничено в соответствии с предельными значениями локальной системы, поскольку программа не сможет всегда иметь возможность держать открытыми такое количество файлов. В ОС Linux это предельное значение можно изменять во время выполнения и поэтому <blockquote>OPEN_MAX</blockquote> уже не константа. Как правило, ее начальное значение равно 256.</p>             <a name="metkadoc11"><h1>Исходные права доступа</h1></a>     <p>Когда вы создаете файл, применяя флаг <blockquote>O_CREAT</blockquote> в системном вызове open, вы должны использовать форму с тремя параметрами. Третий параметр <blockquote>mode</blockquote> формируется из флагов, определенных в заголовочном файле sys/stat.h и соединенных поразрядной операцией <blockquote>OR</blockquote>. К ним относятся:</p>     <p>&#9633; <blockquote>S_IRUSR</blockquote> — право на чтение, владелец;</p>     <p>&#9633; <blockquote>S_IWUSR</blockquote> — право на запись, владелец;</p>     <p>&#9633; <blockquote>S_IXUSR</blockquote> — право на выполнение, владелец;</p>     <p>&#9633; <blockquote>S_IRGRP</blockquote> — право на чтение, группа;</p>     <p>&#9633; <blockquote>S_IWGRP</blockquote> — право на запись, группа;</p>     <p>&#9633; <blockquote>S_IXGRP</blockquote> — право на выполнение, группа;</p>     <p>&#9633; <blockquote>S_IROTH</blockquote> — право на чтение, остальные;</p>     <p>&#9633; <blockquote>S_IWOTH</blockquote> — право на запись, остальные;</p>     <p>&#9633; <blockquote>S_IXOTH</blockquote> — право на выполнение, остальные.</p>     <p>Например, вызов</p>     <p><blockquote>open("myfile", O_CREAT, S_IRUSR|S_IXOTH);</blockquote></p>     <p>в результате приведет к созданию файла с именем myfile с правом на чтение для владельца и правом на выполнение для остальных и только с этими правами доступа.</p>     <p><blockquote>$ <b>ls -ls myfile</b></blockquote></p>     <p><blockquote>0 -r-------х 1 neil software 0 Sep 22 08:11 myfile*</blockquote></p>     <p>Есть пара факторов, способных повлиять на права доступа к файлу. Во-первых, заданные права применяются, только если файл создается. Во-вторых, на права доступа к созданному файлу оказывает воздействие маска пользователя (заданная командой командной оболочки, <blockquote>umask</blockquote>). Значение параметра <blockquote>mode</blockquote>, заданное в вызове <blockquote>open</blockquote>, на этапе выполнения объединяется с помощью операции <blockquote>AND</blockquote> с инвертированной маской пользователя. Например, если заданы маска пользователя 001 и в параметре <blockquote>mode</blockquote> флаг <blockquote>S_IXOTH</blockquote>, у созданного файла не будет права на выполнение для "остальных", т.к. маска пользователя указывает на то, что это право не должно предоставляться. Флаги в вызовах <blockquote>open</blockquote> и <blockquote>creat</blockquote> являются на самом деле запросами на установку прав доступа. Будут ли предоставлены запрошенные права, зависит от значения <blockquote>umask</blockquote> во время выполнения.</p>     <b><i>umask</i></b>     <p><blockquote>umask</blockquote> — это системная переменная, содержащая маску для прав доступа к файлу, которые будут применяться при создании файла. Вы можете изменить значение переменной, выполнив команду <blockquote>umask</blockquote>, предоставляющую новое значение. Значение этой переменной представляет собой трёхзнаковое восьмеричное число. Каждая цифра — результат объединения с помощью операций <blockquote>OR</blockquote> значений 1, 2 или 4 (табл. 3.2). Отдельные цифры указывают на права доступа "пользователя", "группы" и "остальных" соответственно.</p>     <br>     <p><b><i>Таблица 3.2</i></b></p>     <table>      <tr>       <th valign="top">Цифра</th>       <th valign="top">Значение</th>       <th valign="top">Смысл</th>      </tr>      <tr>       <td rowspan="4" valign="top">1</td>       <td valign="top">0</td>       <td valign="top">Никакие права пользователя не отвергнуты</td>      </tr>      <tr>       <td valign="top">4</td>       <td valign="top">Право пользователя на чтение отвергается</td>      </tr>      <tr>       <td valign="top">2</td>       <td valign="top">Право пользователя на запись отвергается</td>      </tr>      <tr>       <td valign="top">1</td>       <td valign="top">Право пользователя на выполнение отвергается</td>      </tr>      <tr>       <td rowspan="4" valign="top">2</td>       <td valign="top">0</td>       <td valign="top">Никакие права группы не отвергнуты</td>      </tr>      <tr>       <td valign="top">4</td>       <td valign="top">Право группы на чтение отвергается</td>      </tr>      <tr>       <td valign="top">2</td>       <td valign="top">Право группы на запись отвергается</td>      </tr>      <tr>       <td valign="top">1</td>       <td valign="top">Право группы на выполнение отвергается</td>      </tr>      <tr>       <td rowspan="4" valign="top">3</td>       <td valign="top">0</td>       <td valign="top">Никакие права остальных не отвергнуты</td>      </tr>      <tr>       <td valign="top">4</td>       <td valign="top">Право остальных на чтение отвергается</td>      </tr>      <tr>       <td valign="top">2</td>       <td valign="top">Право остальных на запись отвергается</td>      </tr>      <tr>       <td valign="top">1</td>       <td valign="top">Право остальных на выполнение отвергается</td>      </tr>     </table>     <p>Например, для блокирования права "группы" на запись и выполнение и права "остальных" на запись переменная umask должна была бы быть следующей (табл. 3.3).</p>     <br>     <p><b><i>Таблица 3.3</i></b></p>     <table>      <tr>       <th valign="top">Цифра</th>       <th valign="top">Значение</th>      </tr>      <tr>       <td valign="top">1</td>       <td valign="top">0</td>      </tr>      <tr>       <td rowspan="2" valign="top">2</td>       <td valign="top">2</td>      </tr>      <tr>       <td valign="top">1</td>      </tr>      <tr>       <td valign="top">3</td>       <td valign="top">2</td>      </tr>     </table>     <p>Значения каждой цифры объединяются операциями <blockquote>OR</blockquote>, поэтому для получения значения второй цифры нужна операция <blockquote>2 | 1</blockquote>, дающая в результате <blockquote>3</blockquote>. Результирующее значение <blockquote>umask</blockquote> — 032.</p>     <p>Когда вы создаете файл с помощью системного вызова open или creat, параметр mode сравнивается с текущим значением переменной <blockquote>umask</blockquote>. Любой бит, установленный в параметре <blockquote>mode</blockquote> и одновременно в переменной <blockquote>umask</blockquote>, удаляется. В результате пользователи могут настроить свое окружение, например, потребовав не создавать никаких файлов с правом на запись для остальных, даже если программа, создающая файл, требует предоставить такое право. Это не мешает программе или пользователю впоследствии применить команду <blockquote>chmod</blockquote> (или системный вызов <blockquote>chmod</blockquote> в программе), чтобы добавить право на запись для остальных, но поможет защитить пользователей, избавив их от необходимости проверять и задавать права доступа для всех новых файлов.</p>     <b><i>close</i></b>     <p>Системный вызов <blockquote>close</blockquote> применяется для разрыва связи файлового дескриптора <blockquote>fildes</blockquote> с его файлом. Дескриптор файла после этого может использоваться повторно. Вызов возвращает 0 в случае успешного завершения и -1 при возникновении ошибки.</p>     <p><blockquote><b>#include &lt;unistd.h&gt;</b></blockquote></p>     <p><blockquote><b>int close (int fildes);</b></blockquote></p>     <blockquote>      <b>Примечание</b>      <p>В некоторых случаях проверка возвращаемого значения вызова <blockquote>close</blockquote> бывает очень важна. Некоторые файловые системы, особенно с сетевой структурой, могут не сообщать об ошибке записи в файл до тех пор, пока файл не будет закрыт, потому что при выполнении записи могло отсутствовать подтверждение действительной записи данных.</p>     </blockquote>     <b><i>ioctl</i></b>     <p>Системный вызов <blockquote>ioctl</blockquote> напоминает набор всякой всячины. Он предоставляет интерфейс для управления поведением устройств и их дескрипторов и настройки базовых сервисов. У терминалов, дескрипторов файлов, сокетов и даже ленточных накопителей могут быть определенные для них вызовы <blockquote>ioctl</blockquote> и вам необходимо обращаться за подробной информацией к страницам справочного руководства, относящимся к конкретным устройствам. В стандарте POSIX определены только вызовы <blockquote>ioctl</blockquote> для потоков, которые не обсуждаются в этой книге. Далее приведена синтаксическая запись вызова.</p>     <p><blockquote><b>#include &lt;unistd.h&gt;</b></blockquote></p>     <p><blockquote><b>int ioctl(int fildes, int cmd, ...)</b></blockquote></p>     <p>Вызов <blockquote>ioctl</blockquote> выполняет операцию, указанную в аргументе <blockquote>cmd</blockquote>, над объектом, заданным в дескрипторе <blockquote>fildes</blockquote>. У вызова может быть необязательный третий аргумент, зависящий от функций, поддерживаемых конкретным устройством.</p>     <p>Например, следующий вызов <blockquote>ioctl</blockquote> в ОС Linux включает световые индикаторы клавиатуры (LEDs).</p>     <p><blockquote>ioctl(tty_fd, KDSETLED, LED_NUM|LED_CAP|LED_SCR);</blockquote></p>     <p>Выполните упражнения 3.1 и 3.2.</p>     <b>Упражнение 3.1. Программа копирования файла</b>     <p>Теперь вы знаете достаточно о системных вызовах <blockquote>open</blockquote>, <blockquote>read</blockquote> и <blockquote>write</blockquote>, чтобы написать простенькую программу copy_system.c для посимвольного копирования одного файла в другой.</p>     <p>В данной главе мы проделаем это несколькими способами для того, чтобы сравнить эффективность разных методов. Для краткости предположим, что входной файл существует, а выходной — нет, и что все операции чтения и записи завершаются успешно. Конечно, в реальных программах вам придется убедиться в том, что эти предположения верны!</p>     <p>1. Сначала вам нужно создать тестовый входной файл размером, скажем, 1 Мбайт и именем file.in.</p>     <p>2. Далее откомпилируйте программу copy_system.c.</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/stat.h&gt;</blockquote></p>     <p><blockquote>#include &lt;fcntl.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> char c;</blockquote></p>     <p><blockquote> int in, out;</blockquote></p>     <p><blockquote> in = open("file.in", O_RDONLY);</blockquote></p>     <p><blockquote> put = open("file.out", O_WRONLY|O_CREAT, S_IRUSR|S_IWUSR);</blockquote></p>     <p><blockquote> while(read(in, &amp;c, 1) == 1) write(out, &amp;c, 1);</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <blockquote>      <b>Примечание</b>      <p>Имейте в виду, что строка <blockquote>#include &lt;unistd.h&gt;</blockquote> должна быть первой, поскольку она определяет флаги, касающиеся соответствия стандарту POSIX и способные повлиять на другие включенные в <blockquote>#include</blockquote> файлы.</p>     </blockquote>     <p>3. Выполнение программы даст результат, похожий на следующий:</p>     <p><blockquote>$ <b>TIMEPORMAT="" time ./copy_system</b></blockquote></p>     <p><blockquote>4.67user 146.90system 2:32.57elapsed 99%CPU</blockquote></p>     <p><blockquote>...</blockquote></p>     <p><blockquote>$ <b>ls -ls file.in file.out</b></blockquote></p>     <p><blockquote>1029 -rw-r--r-- 1 neil users 1048576 Sep 17 10:46 file.in</blockquote></p>     <p><blockquote>1029 -rw------- 1 neil users 1048576 Sep 17 10:51 file.out</blockquote></p>     <p><b>Как это работает</b></p>     <p>Вы используете команду <blockquote>time</blockquote> для определения времени выполнения программы. В ОС Linux переменная <blockquote>TIMEFORMAT</blockquote> применяется для переопределения принятого по умолчанию в стандарте POSIX формата вывода времени, в который не включено время использования ЦПУ. Как видите, что в этой очень старой системе входной файл file.in размером 1 Мбайт был успешно скопирован в файл file.out, созданный с правами на чтение/запись только для владельца. Копирование заняло две с половиной минуты и затратило фактически все доступное время ЦПУ. Программа так медлительна потому, что вынуждена была выполнить более двух миллионов системных вызовов.</p>     <p>В последние годы ОС Linux продемонстрировала огромные успехи в повышении производительности системных вызовов и файловой системы. Для сравнения аналогичный тест с применением ядра 2.6 занял чуть менее 14 секунд:</p>     <p><blockquote>$ <b>TIMEFORMAT="" time ./copy_system</b></blockquote></p>     <p><blockquote>2.08user 10.59system 0:13.74elapsed 92%CPU</blockquote></p>     <p><blockquote>...</blockquote></p>     <b>Упражнение 3.2. Вторая версия программы кодирования файла</b>     <p>Вы можете добиться лучших результатов, копируя блоки большего размера. Взгляните на модифицированную программу copy_block.c, которая копирует файл блоками в 1 Кбайт и снова использует системные вызовы.</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/stat.h&gt;</blockquote></p>     <p><blockquote>#include &lt;fcntl.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote><i> char block[1024];</i></blockquote></p>     <p><blockquote> int in, out;</blockquote></p>     <p><blockquote> int nread;</blockquote></p>     <p><blockquote> in = open("file.in", O_RDONLY);</blockquote></p>     <p><blockquote> out = open("file.out", O_WRONLY|O_CREAT, S_IRUSR|S_IWUSR);</blockquote></p>     <p><blockquote><i> while((nread = read(in, block, sizeof(block))) &gt; 0)</i></blockquote></p>     <p><blockquote><i>  write(out, block, nread);</i></blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Теперь испытайте программу, но сначала удалите старый выходной файл.</p>     <p><blockquote>$ <b>rm file.out</b></blockquote></p>     <p><blockquote>$ <b>TIMEFORMAT="" time ./copy_block</b></blockquote></p>     <p><blockquote>0.00user 0.02system 0:00.04elapsed 78%CPU</blockquote></p>     <p><blockquote>...</blockquote></p>     <p><b>Как это работает</b></p>     <p>Теперь программа выполняется только сотые доли секунды, поскольку ей требуется около 2000 системных вызовов. Конечно, это время очень зависит от системы, но оно показывает, что системные вызовы сопряжены с поддающимися измерению издержками, поэтому их применение стоит оптимизировать.</p>             <a name="metkadoc12"><h1>Другие системные вызовы для управления файлами</h1></a>     <p>Существует ряд других системных вызовов, оперирующих низкоуровневыми дескрипторами файлов. Они позволяют программе контролировать использование файла, возвращая информацию о его состоянии,</p>     <b><i>lseek</i></b>     <p>Системный вызов <blockquote>lseek</blockquote> задает указатель текущей позиции чтения/записи дескриптора файла, т.е. вы можете применять его для установки в файле места, с которого будет происходить следующее считывание или на которое будет производиться следующая запись. Вы можете задать указатель на абсолютную позицию файла или позицию, относительно текущего положения указателя или конца файла.</p>     <p><blockquote><b>#include &lt;unistd.h&gt;</b></blockquote></p>     <p><blockquote><b>#include &lt;sys/types.h&gt;</b></blockquote></p>     <p><blockquote><b>off_t lseek(int fildes, off_t offset, int whence);</b></blockquote></p>     <p>Параметр <blockquote>offset</blockquote> применяется для указания позиции, а параметр <blockquote>whence</blockquote> определяет способ применения <blockquote>offset</blockquote> и может принимать следующие значения:</p>     <p><b>&#9633;</b> <blockquote>SEEK_SET</blockquote> — <blockquote>offset</blockquote> задает абсолютную позицию;</p>     <p>&#9633; <blockquote>SEEK_CUR</blockquote> — <blockquote>offset</blockquote> задается относительно текущей позиции;</p>     <p>&#9633; <blockquote>SEEK_END</blockquote> — <blockquote>offset</blockquote> задается относительно конца файла.</p>     <p>Вызов <blockquote>lseek</blockquote> возвращает величину параметра <blockquote>offset</blockquote> в байтах, измеряемую от начала файла, для которого установлен указатель, или -1 в случае неудачного завершения. Тип данных <blockquote>off_t</blockquote>, применяемый для параметра <blockquote>offset</blockquote> в операциях поиска, — зависящий от реализации тип <blockquote>integer</blockquote> (целое), определенный в файле sys/types.h.</p>     <b><i>fstat, stat</i> и <i>lstat</i></b>     <p>Системный вызов <blockquote>fstat</blockquote> возвращает информацию о состоянии файла, ассоциированного с открытым дескриптором файла. Эта информация записывается в структуру <blockquote>buf</blockquote>, адрес которой передается как параметр.</p>     <p>Далее приведена синтаксическая запись вызовов.</p>     <p><blockquote><b>#include &lt;unistd.h&gt;</b></blockquote></p>     <p><blockquote><b>#include &lt;sys/stat.h&gt;</b></blockquote></p>     <p><blockquote><b>#include &lt;sys/types.h&gt;</b></blockquote></p>     <p><blockquote><b>int fstat(int fildes, struct stat *buf);</b></blockquote></p>     <p><blockquote><b>int stat(const char *path, struct stat *buf);</b></blockquote></p>     <p><blockquote><b>int lstat(const char *path, struct stat *buf);</b></blockquote></p>     <blockquote>      <b>Примечание</b>      <p>Учтите, что включение файла sys/types.h не обязательное, но мы рекомендуем включать его при использовании системных вызовов, поскольку некоторые из их определений применяют для стандартных типов псевдонимы, которые могут измениться когда-нибудь.</p>      <p>Родственные функции <blockquote>stat</blockquote> и <blockquote>lstat</blockquote> возвращают информацию о состоянии названного файла. Они возвращают те же результаты за исключением того, что файл является символической ссылкой. Вызов <blockquote>lstat</blockquote> возвращает данные о самой ссылке, а вызов <blockquote>stat</blockquote> — о файле, на который ссылка указывает.</p>     </blockquote>     <p>Элементы вызываемой структуры stat могут меняться в разных UNIX-подобных системах, но обязательно включают перечисленные в табл. 3.4 элементы.</p>     <br>     <p><b><i>Таблица 3.4</i></b></p>     <table>      <tr>       <th valign="top">Элемент структуры <blockquote>stat</blockquote></th>       <th valign="top"> Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>st_mode</blockquote></td>       <td valign="top">Права доступа к файлу и сведения о типе файла</td>      </tr>      <tr>       <td valign="top"><blockquote>st_ino</blockquote></td>       <td valign="top">Индекс, ассоциированный с файлом</td>      </tr>      <tr>       <td valign="top"><blockquote>st_dev</blockquote></td>       <td valign="top">Устройство, на котором размещен файл</td>      </tr>      <tr>       <td valign="top"><blockquote>st_uid</blockquote></td>       <td valign="top">Идентификатор (user identity) владельца файла</td>      </tr>      <tr>       <td valign="top"><blockquote>st_gid</blockquote></td>       <td valign="top">Идентификатор группы (group identity) владельца файла</td>      </tr>      <tr>       <td valign="top"><blockquote>st_atime</blockquote></td>       <td valign="top">Время последнего обращения</td>      </tr>      <tr>       <td valign="top"><blockquote>st_ctime</blockquote></td>       <td valign="top">Время последнего изменения прав доступа, владельца, группы или объема</td>      </tr>      <tr>       <td valign="top"><blockquote>st_mtime</blockquote></td>       <td valign="top">Время последней модификации содержимого</td>      </tr>      <tr>       <td valign="top"><blockquote>st_nlink</blockquote></td>       <td valign="top">Количество жестких ссылок на файл</td>      </tr>     </table>     <p>У флагов <blockquote>st_mode</blockquote>, возвращаемых в структуре <blockquote>stat</blockquote>, также есть ряд ассоциированных макросов в заголовочном файле sys/stat.h. В эти макросы включены имена флагов для прав доступа и типов файлов и некоторые маски, помогающие проверять специфические типы и права.</p>     <p>Флаги прав доступа такие же, как в системном вызове <blockquote>open</blockquote>, описанном ранее. Для флагов типов файла включены следующие имена:</p>     <p>&#9633; <blockquote>S_IFBLK</blockquote> — блочное устройство;</p>     <p>&#9633; <blockquote>S_IFDIR</blockquote> — каталог;</p>     <p>&#9633; <blockquote>S_IFCHR</blockquote> — символьное устройство;</p>     <p>&#9633; <blockquote>S_IFIFO</blockquote> — FIFO (именованный канал);</p>     <p>&#9633; <blockquote>S_IFREG</blockquote> — обычный файл;</p>     <p>&#9633; <blockquote>S_IFLNK</blockquote> — символическая ссылка.</p>     <p>Для других флагов режима файла включены следующие имена:</p>     <p>&#9633; <blockquote>S_ISUID</blockquote> — элемент получает setUID при выполнении;</p>     <p>&#9633; <blockquote>S_ISGUID</blockquote> — элемент получает setGID при выполнении.</p>     <p>Для масок, интерпретирующих флаги <blockquote>st_mode</blockquote>, включены следующие имена:</p>     <p><b>&#9633;</b> <blockquote>S_IFMT</blockquote> — тип файла;</p>     <p><b>&#9633;</b> <blockquote>S_IRWXU</blockquote> — права пользователя на чтение/запись/выполнение;</p>     <p>&#9633; <blockquote>S_IRWXG</blockquote> — права группы на чтение/запись/выполнение;</p>     <p>&#9633; <blockquote>S_IRWXO</blockquote> — права остальных на чтение/запись/выполнение.</p>     <p>Существует ряд макросов, помогающих определить типы файлов. Они просто сравнивают надлежащим образом установленные флаги режима файла с подходящим флагом, типа устройства. К ним относятся следующие:</p>     <p>&#9633; <blockquote>S_ISBLK</blockquote> — проверка для блочного файла;</p>     <p>&#9633; <blockquote>S_ISCHR</blockquote> — проверка для символьного файла;</p>     <p>&#9633; <blockquote>S_ISDIR</blockquote> — проверка для каталога;</p>     <p>&#9633; <blockquote>S_ISFIFO</blockquote> — проверка для FIFO;</p>     <p>&#9633; <blockquote>S_ISREG</blockquote> — проверка для обычного файла;</p>     <p>&#9633; <blockquote>S_ISLNK</blockquote> — проверка для символической ссылки.</p>     <p>Например, для проверки того, что файл не является каталогом и у него есть права на выполнение только для владельца и больше никаких других прав, вы можете воспользоваться следующим тестом;</p>     <p><blockquote>struct stat statbuf;</blockquote></p>     <p><blockquote>mode_t modes;</blockquote></p>     <p><blockquote>stat("filename", &amp;statbuf);</blockquote></p>     <p><blockquote>modes = statbuf.st_mode;</blockquote></p>     <p><blockquote>if (!S_ISDIR(modes) &amp;&amp; (modes &amp; S_IRWXU) = S_IXUSR)</blockquote></p>     <p><blockquote>...</blockquote></p>     <b><i>dup</i> и <i>dup2</i></b>     <p>Системные вызовы <blockquote>dup</blockquote> позволяют дублировать дескриптор файла, предоставляя два или несколько разных дескрипторов, обращающихся к одному и тому же файлу. Эта возможность может применяться для чтения и записи в разные части файла. Системный вызов <blockquote>dup</blockquote> дублирует файловый дескриптор <blockquote>fildes</blockquote> и возвращает новый дескриптор. Системный вызов <blockquote>dup2</blockquote> умело копирует один дескриптор файла в другой, задавая дескриптор, применяемый для копии.</p>     <p>Далее приведена синтаксическая запись для вызовов.</p>     <p><blockquote><b>#include &lt;unistd.h&gt;</b></blockquote></p>     <p><blockquote><b>int dup(int fildes);</b></blockquote></p>     <p><blockquote><b>int dup2(int fildes, int fildes2);</b></blockquote></p>     <p>Эти вызовы могут оказаться полезными в случае нескольких процессов, взаимодействующих через именованные каналы. Более глубоко мы рассмотрим системные вызовы <blockquote>dup</blockquote> в<i> главе 13.</i></p>              <a name="metkadoc13"><h1>Стандартная библиотека ввода/вывода</h1></a>         <p>Стандартная библиотека ввода/вывода (stdio) и ее заголовочный файл stdio.h предоставляют универсальный интерфейс для системных вызовов ввода/вывода нижнего уровня. Библиотека, теперь часть языка С стандарта ANSI, в отличие от системных вызовов, с которыми вы встречались ранее, включает много сложных функций для форматирования вывода и просмотра ввода. Она также обеспечивает необходимые условия буферизации для устройств.</p>     <p>Во многих случаях эта библиотека используется так же, как низкоуровневые дескрипторы файлов. Вы должны открыть файл для установления пути доступа. Это действие возвращает значение, применяемое как параметр в других функциях библиотеки ввода/вывода. Эквивалент низкоуровневого дескриптора файла называется <i>потоком</i> и реализуется как указатель на структуру <blockquote>FILE*</blockquote>.</p>     <blockquote>      <b>Примечание</b>      <p>Не путайте эти потоки файлов с потоками ввода/вывода в языке С++ и механизмом STREAMS, описывающим взаимодействие процессов и введенным в системе AT&amp;T UNIX System V Release 3, который не рассматривается в данной книге. Для получения дополнительной информации о средствах STREAMS обратитесь к спецификации X/Open (по адресу <b>http://www.opengroup.org)</b> и руководству по программированию AT&amp;T STREAMS Programming Guide, поставляемому с системой System V.</p>     </blockquote>     <p>Три файловых потока открываются автоматически при старте программы. К ним относятся stdin, stdout и stderr. Эти потоки объявлены в файле stdio.h и представляют вывод, ввод и стандартный поток ошибок, которым соответствуют низкоуровневые файловые дескрипторы 0, 1 и 2.</p>     <p>В данном разделе мы рассмотрим следующие функции:</p>     <p>&#9633; <blockquote>fopen</blockquote>, <blockquote>fclose</blockquote>;</p>     <p>&#9633; <blockquote>fread</blockquote>, <blockquote>fwrite</blockquote>;</p>     <p>&#9633; <blockquote>fflush</blockquote>;</p>     <p>&#9633; <blockquote>fseek</blockquote>;</p>     <p>&#9633; <blockquote>fgetc</blockquote>, <blockquote>getc</blockquote>, getchar;</p>     <p>&#9633; <blockquote>fputc</blockquote>, <blockquote>putc</blockquote>, <blockquote>putchar</blockquote>;</p>     <p>&#9633; <blockquote>fgets</blockquote>, <blockquote>gets</blockquote>;</p>     <p>&#9633; <blockquote>printf</blockquote>, <blockquote>fprintf</blockquote> и <blockquote>sprintf</blockquote>;</p>     <p>&#9633; <blockquote>scanf</blockquote>, <blockquote>fscanf</blockquote> и <blockquote>sscanf</blockquote>;</p>     <p>&#9633; <blockquote>fopen</blockquote>.</p>             <a name="metkadoc14"><h1><i>fopen</i></h1></a>     <p>Библиотечная функция f<blockquote>o</blockquote>pen — это аналог низкоуровневого системного вызова <blockquote>open</blockquote>. Она используется в основном для файлов и терминального, ввода и вывода. Там, где нужно явное управление устройствами, больше подойдут системные вызовы, поскольку они устраняют потенциальные нежелательные побочные эффекты применения библиотек, например, в случае буферизации ввода/вывода.</p>     <p>Далее приведена синтаксическая запись функции:</p>     <p><blockquote><b>#include &lt;stdio.h&gt;</b></blockquote></p>     <p><blockquote><b>FILE *fopen(const char *filename, const char *mode);</b></blockquote></p>     <p>Функция <blockquote>fopen</blockquote> открывает файл, заданный в параметре <blockquote>filename</blockquote>, и ассоциирует с ним поток. Параметр <blockquote>mode</blockquote> описывает, как файл должен быть открыт. Он задается одной из следующих строк:</p>     <p>&#9633; "<blockquote>r</blockquote>" или "<blockquote>rb</blockquote>" — открыть только для чтения;</p>     <p>&#9633; "<blockquote>w</blockquote>" или "<blockquote>wb</blockquote>" — открыть для записи, укоротить до нулевой длины;</p>     <p>&#9633; "<blockquote>а</blockquote>" или "<blockquote>ab</blockquote>" — открыть для записи, дописывать в конец файла;</p>     <p>&#9633; "<blockquote>r+</blockquote>" или "<blockquote>rb+</blockquote>" или "<blockquote>r+b</blockquote>" — открыть для изменения (чтение и запись);</p>     <p>&#9633; "<blockquote>w+</blockquote>" или "<blockquote>wb+</blockquote>" или "<blockquote>w+b</blockquote>" — открыть для изменения, укоротить до нулевой длины;</p>     <p>&#9633; "<blockquote>a+</blockquote>" или "<blockquote>ab+</blockquote>" или "<blockquote>а+b</blockquote>" — открыть для изменения, дописывать в конец файла. Символ <blockquote>b</blockquote> означает, что файл бинарный, а не текстовый.</p>     <blockquote>      <b>Примечание</b>      <p>В отличие от MS-DOS, системы UNIX и Linux не делают различий между текстовыми и бинарными файлами. UNIX и Linux обрабатывают их одинаково с эффективностью обработки бинарных файлов. Важно также учесть, что параметр <blockquote>mode</blockquote> должен быть строкой, а не символом. Всегда применяйте двойные кавычки, а не апострофы.</p>     </blockquote>     <p>В случае успешного завершения функция <blockquote>fopen</blockquote> возвращает ненулевой указатель на структуру <blockquote>FILE*</blockquote>. В случае сбоя она вернет значение <blockquote>NULL</blockquote>, определенное в файле stdio.h.</p>     <p>Количество доступных потоков ограничено, как и число дескрипторов файлов. Реальное предельное значение содержится в определенной в файле stdio.h константе <blockquote>FOPEN_MAX</blockquote> и всегда не менее 8, а в ОС Linux обычно 16.</p>             <a name="metkadoc15"><h1><i>fread</i></h1></a>     <p>Библиотечная функция <blockquote>fread</blockquote> применяется для чтения данных из файлового потока. Данные считываются из потока <blockquote>stream</blockquote> в буфер данных, заданный в параметре <blockquote>ptr</blockquote>. Функции <blockquote>fread</blockquote> и <blockquote>fwrite</blockquote> имеют дело с записями данных. Записи описываются размером <blockquote>size</blockquote> и количеством передаваемых записей <blockquote>nitems</blockquote>. Функция возвращает количество записей (а не байтов), успешно считанных в буфер данных. При достижении конца файла может быть возвращено меньше записей, чем <blockquote>nitems</blockquote>, вплоть до нуля.</p>     <p>Далее приведена синтаксическая запись функции:</p>     <p><blockquote><b>#include &lt;stdio.h&gt;</b></blockquote></p>     <p><blockquote><b>size_t fread(void *ptr, size_t size, size_t nitems, FILE *stream);</b></blockquote></p>     <p>Как и в других функциях стандартного ввода/вывода, записывающих данные в буфер, выделять место для данных и проверять ошибки должен программист. См. также функции <blockquote>ferror</blockquote> и <blockquote>feof</blockquote> далее в этой главе.</p>             <a name="metkadoc16"><h1><i>fwrite</i></h1></a>     <p>Интерфейс библиотечной функции <blockquote>fwrite</blockquote> аналогичен интерфейсу функции <blockquote>fread</blockquote>. Она принимает записи данных из заданного буфера данных и записывает их в поток вывода. Функция возвращает количество успешно записанных записей.</p>     <p>Далее приведена синтаксическая запись функции:</p>     <p><blockquote><b>#include &lt;stdio.h&gt;</b></blockquote></p>     <p><blockquote><b>size_t fwrite(const void *ptr, size_t size, size_t nitems, FILE *stream);</b></blockquote></p>     <blockquote>      <b>Примечание</b>      <p>Имейте в виду, что функции <blockquote>fread</blockquote> и <blockquote>fwrite</blockquote> не рекомендуется применять со структурированными данными. Частично проблема заключается в том, что файлы, записанные функцией fwrite, могут быть непереносимыми между машинами с разной архитектурой.</p>     </blockquote>             <a name="metkadoc17"><h1><i>fclose</i></h1></a>     <p>Библиотечная функция <blockquote>fclose</blockquote> закрывает заданный поток stream, заставляя записать все незаписанные данные. Важно применять функцию <blockquote>fclose</blockquote>, поскольку библиотека stdio будет использовать буфер для данных. Если программе нужна уверенность в том, что все данные записаны, следует вызвать <blockquote>fclose</blockquote>. Имейте в виду, что функция <blockquote>fclose</blockquote> вызывается автоматически для всех файловых потоков, которые все еще открыты к моменту нормального завершения программы, но при этом у вас, конечно же, не будет возможности проверить ошибки, о которых сообщает <blockquote>fclose</blockquote>.</p>     <p>Далее приведена синтаксическая запись функции:</p>     <p><blockquote><b>#include &lt;stdio.h&gt;</b></blockquote></p>     <p><blockquote><b>int fclose(FILE* stream);</b></blockquote></p>             <a name="metkadoc18"><h1><i>fflush</i></h1></a>     <p>Библиотечная функция <blockquote>fflush</blockquote> вызывает немедленную запись всех данных файлового потока, ждущих выполнения операции записи. Вы можете применять ее, например, чтобы убедиться, что интерактивное приглашение отправлено на терминал до того, как делается попытка считать ответ. Эта функция также полезна, если вы хотите, прежде чем продолжить выполнение, убедиться в том, что важные данные помещены на диск. Ее можно применять в некоторых случаях при отладке программы, чтобы быть уверенным в том, что программа действительно записывает данные, а не зависла. При вызове функции <blockquote>fclose</blockquote> выполняется неявная операция <blockquote>fflush</blockquote>, поэтому перед <blockquote>fclose</blockquote> не нужно вызывать функцию <blockquote>fflush</blockquote>. </p>     <p>Далее приведена синтаксическая запись функции:</p>     <p><blockquote><b>#include &lt;stdio.h&gt;</b></blockquote></p>     <p><blockquote><b>int fflush(FILE *stream);</b></blockquote></p>             <a name="metkadoc19"><h1><i>fseek</i></h1></a>     <p>Функция <blockquote>fseek</blockquote> — это эквивалент для файлового потока системного вызова <blockquote>lseek</blockquote>. Она задает в <blockquote>stream</blockquote> позицию для следующей операции чтения этого потока или записи в него. Значения и смысл параметров <blockquote>offset</blockquote> и <blockquote>whence</blockquote> такие же, как у ранее описанных одноименных параметров вызова <blockquote>lseek</blockquote>. Но там, где <blockquote>lseek</blockquote> возвращает <blockquote>off_t</blockquote>, функция <blockquote>fseek</blockquote> возвращает целое число: 0, если выполнилась успешно, и -1 при аварийном завершении с ошибкой, указанной в переменной <blockquote>errno</blockquote>. Какое поле деятельности для стандартизации!</p>     <p>Далее приведена синтаксическая запись функции:</p>     <p><blockquote><b>#include &lt;stdio.h&gt;</b></blockquote></p>     <p><blockquote><b>int fseek(FILE *stream, long int offset, int whence);</b></blockquote></p>             <a name="metkadoc20"><h1><i>fgetc, getc</i> и <i>getchar</i></h1></a>     <p>Функция <blockquote>fgetc</blockquote> возвращает из файлового потока следующий байт как символ. Когда она достигает конца файла или возникает ошибка, функция возвращает <blockquote>EOF</blockquote>. Для того чтобы различить эти два случая, следует применять функции <blockquote>ferror</blockquote> или <blockquote>feof</blockquote>.</p>     <p>Далее приведена синтаксическая запись функций:</p>     <p><blockquote><b>#include &lt;stdio.h&gt;</b></blockquote></p>     <p><blockquote><b>int fgetc(FILE *stream);</b></blockquote></p>     <p><blockquote><b>int getc(FILE *stream);</b></blockquote></p>     <p><blockquote><b>int getchar();</b></blockquote></p>     <p>Функция <blockquote>getc</blockquote> эквивалентна <blockquote>fgetc</blockquote> за исключением того, что может быть реализована как макрос. В этом случае аргумент <blockquote>stream</blockquote> может определяться несколько раз, поэтому он лишен побочных эффектов (например, не затронет переменные). К тому же вы не можете гарантировать возможности применения адреса <blockquote>getc</blockquote> как указателя функции.</p>     <p>Функция <blockquote>getchar</blockquote> эквивалентна вызову функции <blockquote>getc(stdin)</blockquote> и читает следующий символ из стандартного ввода.</p>             <a name="metkadoc21"><h1><i>fputc, putc</i> и <i>putchar</i></h1></a>     <p>Функция <blockquote>fputc</blockquote> записывает символ в файловый поток вывода. Она возвращает записанное значение или <blockquote>EOF</blockquote> в случае аварийного завершения.</p>     <p><blockquote><b>#include &lt;stdio.h&gt;</b></blockquote></p>     <p><blockquote><b>int fputc(int с, FILE *stream); int putc(int c, FILE *stream); int putchar(int c);</b></blockquote></p>     <p>Как и в случае функций <blockquote>fgetc/getc</blockquote>, функция <blockquote>putc</blockquote> — эквивалент <blockquote>fputc</blockquote>, но может быть реализована как макрос.</p>     <p>Функция <blockquote>putchar</blockquote> — то же самое, что вызов <blockquote>putc(с, stdout)</blockquote>, записывающий один символ в стандартный вывод. Имейте в виду, что функция <blockquote>putchar</blockquote> принимает, а функция <blockquote>getchar</blockquote> возвращает символы как данные типа <blockquote>int</blockquote>, а не <blockquote>char</blockquote>. Это позволяет индикатору конца файла (<blockquote>EOF</blockquote>) принимать значение -1, лежащее вне диапазона кодов символов.</p>             <a name="metkadoc22"><h1><i>fgets</i> и <i>gets</i></h1></a>     <p>Функция <blockquote>fgets</blockquote> читает строку из файла ввода <blockquote>stream</blockquote>.</p>     <p><blockquote><b>#include &lt;stdio.h&gt;</b></blockquote></p>     <p><blockquote><b>char *fgets(char *s, int n, FILE *stream);</b></blockquote></p>     <p><blockquote><b>char *gets(char *s);</b></blockquote></p>     <p>Функция <blockquote>fgets</blockquote> пишет символы в строку, заданную указателем <blockquote>s</blockquote>, до тех пор, пока не встретится новая строка, либо не будет передано <blockquote>n-1</blockquote> символов, либо не будет достигнут конец файла. Любая встретившаяся новая строка передается в строку, принимающую символы, и добавляется завершающий нулевой байт <blockquote>\0</blockquote>. Любой вызов передает максимум <blockquote>n-1</blockquote> символов, т.к. должен быть вставлен нулевой байт, обозначающий конец строки и увеличивающий общее количество до n байтов.</p>     <p>При успешном завершении функция <blockquote>fgets</blockquote> возвращает указатель на строку <blockquote>s</blockquote>. Если поток указывает на конец файла, она устанавливает индикатор <blockquote>EOF</blockquote> для потока и возвращает пустой указатель. Если возникает ошибка чтения, <blockquote>fgets</blockquote> возвращает пустой указатель и устанавливает значение переменной <blockquote>errno</blockquote>, соответствующее типу ошибки.</p>     <p>Функция <blockquote>gets</blockquote> аналогична <blockquote>fgets</blockquote> за исключением того, что она читает из стандартного ввода и отбрасывает любые обнаруженные обозначения новой строки. Функция добавляет завершающий нулевой байт в принимающую строку.</p>     <blockquote>      <b>Примечание</b>      <p>Учтите, что функция <blockquote>gets</blockquote> не ограничивает количество символов, которые могут передаваться, поэтому она может переполнить свой пересылочный буфер. По этой причине вам следует избегать применения этой функции и заменять ее функцией <blockquote>fgets</blockquote>. Многие проблемы безопасности порождены функциями в программах, сделанных для переполнения буфера тем или иным способом. Это одна из таких функций, поэтому будьте осторожны!</p>     </blockquote>              <a name="metkadoc23"><h1>Форматированные ввод и вывод</h1></a>         <p>Для создания вывода управляемого вида существует ряд библиотечных функций, с которыми вы, возможно, знакомы, если программируете на языке С. К ним относятся функция <blockquote>printf</blockquote> и родственные функции для вывода значений в файловый поток, а также <blockquote>scanf</blockquote> и другие функции для чтения значений из файлового потока.</p>             <a name="metkadoc24"><h1><i>printf, fprintf</i> и <i>sprintf</i></h1></a>     <p>Семейство функций <blockquote>printf</blockquote> форматирует и выводит переменное число аргументов разных типов. Способ их представления в потоке вывода управляется параметром <blockquote>format</blockquote>, являющимся строкой с обычными символами и кодами, называемыми<i> спецификаторами преобразований,</i> указывающими, как и куда выводить остальные аргументы.</p>     <p><blockquote><b>#include &lt;stdio.h&gt;</b></blockquote></p>     <p><blockquote><b>int printf(const char *format, ...);</b></blockquote></p>     <p><blockquote><b>int sprintf(char *s, const char *format, ...);</b></blockquote></p>     <p><blockquote><b>int fprintf(FILE * stream, const char *format, ...);</b></blockquote></p>     <p>Функция <blockquote>printf</blockquote> выводит результат в стандартный вывод. Функция <blockquote>fprintf</blockquote> выводит результат в заданный файловый поток <blockquote>stream</blockquote>. Функция <blockquote>sprintf</blockquote> записывает результат и завершающий нулевой символ в строку <blockquote>s</blockquote>, передаваемую как параметр. Эта строка должна быть достаточно длинной, чтобы вместить весь вывод функции.</p>     <p>У семейства <blockquote>printf</blockquote> есть и другие члены, обрабатывающие свои аргументы различными способами. См. подробную информацию на страницах интерактивного руководства.</p>     <p>Обычные символы передаются в вывод без изменений. Спецификаторы преобразований заставляют функцию <blockquote>printf</blockquote> выбирать и форматировать дополнительные аргументы, передаваемые как параметры. Спецификаторы всегда начинаются с символа <blockquote>%</blockquote>. Далее приведен простой пример:</p>     <p><blockquote>printf("Some numbers: %d, %d, and &amp;d\n", 1, 2, 3);</blockquote></p>     <p>Он порождает в стандартном выводе следующую строку.</p>     <p><blockquote>Some numbers: 1, 2, and 3</blockquote></p>     <p>Для вывода символа <blockquote>%</blockquote> следует применять последовательность <blockquote>%%</blockquote>, чтобы не путать его со спецификатором преобразования.</p>     <p>Далее перечислены наиболее часто применяемые спецификаторы преобразований:</p>     <p><b>&#9633;</b> <blockquote>%d</blockquote>, <blockquote>%i</blockquote> — выводить целое как десятичное число;</p>     <p>&#9633; <blockquote>%о</blockquote>, <blockquote>%x</blockquote> — выводить целое как восьмеричное, шестнадцатеричное число;</p>     <p><b>&#9633;</b> <blockquote>%с</blockquote> — выводить символ;</p>     <p>&#9633; <blockquote>%s</blockquote> — выводить строку;</p>     <p>&#9633; <blockquote>%f</blockquote> — выводить число с плавающей точкой (одинарной точности);</p>     <p><b>&#9633;</b> <blockquote>%e</blockquote> — выводить число с двойной точностью в формате фиксированной длины;</p>     <p><b>&#9633;</b> <blockquote>%g</blockquote> — выводить число двойной точности в общем формате.</p>     <p>Очень важно, чтобы число и тип аргументов, передаваемых функции <blockquote>printf</blockquote>, соответствовали спецификаторам преобразования в строке <blockquote>format</blockquote>. Необязательный спецификатор размера применяется для обозначения типа целочисленных аргументов.</p>     <p>Он может быть равен <blockquote>h</blockquote>, например, <blockquote>%hd</blockquote> для обозначения типа <blockquote>short int</blockquote> (короткие целые), или <blockquote>l</blockquote>, например, <blockquote>%ld</blockquote> для обозначения типа <blockquote>long int</blockquote> (длинные целые). Некоторые компиляторы могут проверять эти установки <blockquote>printf</blockquote>, но они ненадежны. Если вы применяете компилятор GNU gcc, можно вставить для этого в команду компиляции опцию <blockquote>-Wformat</blockquote>.</p>     <p>Далее приведен еще один пример:</p>     <p><blockquote>char initial = 'А';</blockquote></p>     <p><blockquote>char *surname = "Matthew";</blockquote></p>     <p><blockquote>double age = 13.5;</blockquote></p>     <br>     <p><blockquote>printf("Hello Mr %c %s, aged %g\n", initial, surname, age);</blockquote></p>     <p>Будет выводиться следующая информация:</p>     <p><blockquote>Hello Mr A Matthew, aged 13.5</blockquote></p>     <p>Вы можете добиться большего при выводе элементов с помощью спецификаторов полей. Они расширяют возможности спецификаторов преобразований, управляя расположением элементов при выводе. Обычно задается количество десятичных разрядов для числа с плавающей точкой или величина пробельных отступов, обрамляющих строку.</p>     <p>Спецификаторы полей задаются в виде чисел, следующих в спецификаторах преобразований непосредственно за знаком <blockquote>%</blockquote>. В табл. 3.5 приведены дополнительные примеры использования спецификаторов преобразований и результирующий вывод. Для большей ясности мы применяем знак вертикальной черты, чтобы показать границы вывода.</p>     <br>     <p><b><i>Таблица 3.5</i></b></p>     <table>      <tr>       <th valign="top">Формат</th>       <th valign="top">Аргумент</th>       <th valign="top">Вывод</th>      </tr>      <tr>       <td valign="top"><blockquote>%10s</blockquote></td>       <td valign="top"><blockquote>"Hello"</blockquote></td>       <td valign="top"><blockquote>|     Hello|</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>%-10s</blockquote></td>       <td valign="top"><blockquote>"Hello"</blockquote></td>       <td valign="top"><blockquote>|Hello     |</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>%10d</blockquote></td>       <td valign="top"><blockquote>1234</blockquote></td>       <td valign="top"><blockquote>|      1234|</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>%-10d</blockquote></td>       <td valign="top"><blockquote>1234</blockquote></td>       <td valign="top"><blockquote>|1234      |</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>%010d</blockquote></td>       <td valign="top"><blockquote>1234</blockquote></td>       <td valign="top"><blockquote>|0000001234|</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>%10.4f</blockquote></td>       <td valign="top"><blockquote>12.34</blockquote></td>       <td valign="top"><blockquote>|   12.3400|</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>%*s</blockquote></td>       <td valign="top"><blockquote>10, "Hello"</blockquote></td>       <td valign="top"><blockquote>|     Hello|</blockquote></td>      </tr>     </table>     <p>Все приведенные примеры выводятся в поле шириной 10 символов. Обратите внимание на то, что отрицательная ширина поля означает выравнивание элемента по левому краю в пределах поля. Переменная ширина поля обозначается символом "звездочка" (<blockquote>*</blockquote>). В этом случае следующий аргумент применяется для задания ширины. Ведущий ноль указывает на вывод элемента с ведущими нулями. В соответствии со стандартом POSIX функция <blockquote>printf</blockquote> не обрезает поля; наоборот она расширяет поле, чтобы вместить в него аргумент. Например, если вы попытаетесь вывести строку большей длины, чем заданное поле, ширина поля будет увеличена (табл. 3.6).</p>     <br>     <p><b><i>Таблица 3.6</i></b></p>     <table>      <tr>       <th valign="top">Формат</th>       <th valign="top">Аргумент</th>       <th valign="top">Вывод</th>      </tr>      <tr>       <td valign="top"><blockquote>%10s</blockquote></td>       <td valign="top"><blockquote>"HelloTherePeeps"</blockquote></td>       <td valign="top"><blockquote>|HelloTherePeeps|</blockquote></td>      </tr>     </table>     <p>Функции семейства <blockquote>printf</blockquote> возвращают целое число, равное количеству выведенных символов. В случае функции <blockquote>sprintf</blockquote> в него не включается завершающий нуль-символ. При наличии ошибок эти функции возвращают отрицательное значение и задают переменную <blockquote>errno</blockquote>.</p>             <a name="metkadoc25"><h1><i>scanf, fscanf</i> и <i>sscanf</i></h1></a>     <p>Семейство функций <blockquote>scanf</blockquote> действует аналогично функциям группы <blockquote>printf</blockquote> за исключением того, что эти функции читают элементы из потока и помещают их в переменные, адреса которых им передаются как параметры-указатели. Для управления преобразованиями ввода функции применяют строку format аналогичным образом и используют многие спецификаторы преобразований функций группы <blockquote>printf</blockquote>.</p>     <p><blockquote><b>#include &lt;stdio.h&gt;</b></blockquote></p>     <p><blockquote><b>int scanf(const char *format, ...);</b></blockquote></p>     <p><blockquote><b>int fscanf(FILE *stream, const char *format, ...);</b></blockquote></p>     <p><blockquote><b>int sscanf(const char *s, const char *format, ...);</b></blockquote></p>     <p>Очень важно, чтобы переменные, используемые для хранения значений, считываемых функциями <blockquote>scanf</blockquote>, имели корректный тип и точно соответствовали строке формата. Если это не так, используемая память может быть искажена и программа может завершиться аварийно. При этом не будет обнаружено никаких ошибок компиляции. Если повезет, вы можете получить предупреждающее сообщение!</p>     <p>Строка <blockquote>format</blockquote> функции <blockquote>scanf</blockquote> и других функций этого семейства, как и в случае функции <blockquote>printf</blockquote>, содержит как обычные символы, так и спецификаторы преобразований. Но обычные символы применяются для задания символов, которые должны присутствовать во вводе.</p>     <p>Рассмотрим простой пример:</p>     <p><blockquote>int num;</blockquote></p>     <p><blockquote>scanf("Hello %d", &amp;num);</blockquote></p>     <p>Вызов функции <blockquote>scanf</blockquote> будет успешным, только если следующие пять символов в стандартном вводе — <blockquote>Hello</blockquote>. Затем, если следующие символы формируют распознаваемое десятичное число, оно будет считано и присвоено переменной <blockquote>num</blockquote>. Пробел в строке формата при вводе применяется для игнорирования во вводном файле всех пробельных символов (пробелы, табуляции, переводы страницы и переходы на новую строку) между спецификаторами преобразований. Это означает, что вызов, <blockquote>scanf</blockquote> будет успешным и поместит 1234 в переменную <blockquote>num</blockquote> в случае следующих двух вариантов ввода.</p>     <p><blockquote>Hello    1234</blockquote></p>     <p><blockquote>Hellol234</blockquote></p>     <p>Пробельные символы обычно игнорируются во вводе, когда начинается преобразование. Это означает, что строка формата <blockquote>%d</blockquote> будет продолжать чтение из вводного файла, пропуская пробелы и переходы на новую строку до тех пор, пока будет продолжаться цифровая последовательность. Если ожидаемые символы отсутствуют, преобразование аварийно завершается и выполнение функции прекращается.</p>     <blockquote>      <b>Примечание</b>      <p>Если не соблюдать осторожность, могут возникнуть проблемы. В вашей программе может появиться бесконечный цикл, если во вводе оставить нецифровой символ при считывании целых чисел.</p>     </blockquote>     <p>К другим спецификаторам преобразований относятся следующие:</p>     <p><b>&#9633;</b> <blockquote>%d</blockquote> — считывание десятичного целого;</p>     <p><b>&#9633;</b> <blockquote>%o</blockquote>, <blockquote>%x</blockquote> — считывание восьмеричного, шестнадцатеричного целого;</p>     <p><b>&#9633;</b> <blockquote>%f</blockquote>, <blockquote>%e</blockquote>, <blockquote>%g</blockquote> — считывание числа с плавающей запятой;</p>     <p><b>&#9633;</b> <blockquote>%c</blockquote> — считывание символа (пробельный символ не пропускается);</p>     <p>&#9633; <blockquote>%s</blockquote> — считывание строки;</p>     <p>&#9633; <blockquote>%[]</blockquote> — считывание множества символов (см. последующее обсуждение);</p>     <p>&#9633; <blockquote>%%</blockquote> — считывание знака <blockquote>%</blockquote>.</p>     <p>Как и в случае <blockquote>printf</blockquote>, у спецификаторов преобразований функции <blockquote>scanf</blockquote> есть ширина поля, ограничивающая объем ввода. Спецификатор размера (<blockquote>h</blockquote> для коротких или <blockquote>l</blockquote> для длинных целых) показывает, короче или длиннее стандартного получаемый аргумент. Таким образом, <blockquote>%hd</blockquote> обозначает число типа <blockquote>short int</blockquote>, <blockquote>%ld</blockquote> — число типа <blockquote>long int</blockquote> и <blockquote>%lg</blockquote> — число с плавающей точкой двойной точности.</p>     <p>Спецификатор, начинающийся со звездочки, указывает на то, что элемент игнорируется. Это значит, что информация не сохраняется, и, следовательно, для ее получения не нужна переменная.</p>     <p>Применяйте спецификатор <blockquote>%c</blockquote> для чтения одиночного символа во вводе. Он не пропускает начальные пробельные символы.</p>     <p>Используйте спецификатор <blockquote>%s</blockquote> для чтения строк, но будьте осторожны. Он пропускает ведущие пробельные символы, но останавливается перед первым пробельным символом, встретившимся в строке, поэтому лучше применять его для чтения слов, а не целых строк. Кроме того, длина строки, которую он может прочесть, ограничивается только спецификатором ширины поля, поэтому принимающая строка должна быть достаточной для хранения самой длинной строки из вводного потока.</p>     <p>Лучше применять спецификатор ширины поля или комбинацию функций <blockquote>fgets</blockquote> и <blockquote>sscanf</blockquote> для считывания строки ввода, а затем просматривать ее. Это защитит от возможных переполнений буфера, которые может спровоцировать злонамеренный пользователь.</p>     <p>Применяйте спецификатор <blockquote>%[]</blockquote> для чтения строки, составленной из символов, включенных в множество. Формат <blockquote>%[A-Z]</blockquote> будет читать строку из прописных букв латинского алфавита. Если в множестве первый символ — знак вставки (<blockquote>^</blockquote>), то спецификатор считывает строку, состоящую из символов, не входящих в множество. Итак, для того чтобы прочитать строку с пробелами, но остановиться на первой запятой, примените спецификатор <blockquote>%[^, ]</blockquote>.</p>     <p>Если задана следующая строка ввода:</p>     <p><blockquote>Hello, 1234, 5.678, X, string to the end of the line</blockquote></p>     <p>приведенный далее вызов <blockquote>scanf</blockquote> корректно считает четыре элемента:</p>     <p><blockquote>char s[256];</blockquote></p>     <p><blockquote>int n;</blockquote></p>     <p><blockquote>float f;</blockquote></p>     <p><blockquote>char c;</blockquote></p>     <br>     <p><blockquote>scanf("Hello, %d, %g, %c, %[^\n]", &amp;n, &amp;f, &amp;c, s);</blockquote></p>     <p>Функции семейства <blockquote>scanf</blockquote> возвращают количество успешно считанных элементов. Оно может быть нулевым, если сбой возник при чтении первого элемента. Если достигнут конец ввода прежде, чем найдено соответствие первому элементу, возвращается <blockquote>EOF</blockquote>. Если в файловом потоке возникает ошибка чтения, устанавливается флаг ошибки потока и тип ошибки задается в переменной <blockquote>errno</blockquote>. Более подробную информацию<i> см. в разд. "Ошибки потока" далее в этой главе.</i></p>     <p>Функция <blockquote>scanf</blockquote> и другие члены семейства, как правило, не высоко ценятся в основном по трем причинам:</p>     <p>&#9633; традиционно их реализации полны ошибок;</p>     <p>&#9633; в использовании эти функции не гибки;</p>     <p><b>&#9633;</b> они могут привести к созданию программного кода, в котором трудно решить, что подвергать синтаксическому анализу.</p>     <p>В качестве альтернативы попытайтесь применять другие функции, такие как <blockquote>fread</blockquote> или <blockquote>fgets</blockquote>, для чтения строк ввода, а затем воспользуйтесь строковыми функциями для разделения введенной строки на нужные элементы.</p>             <a name="metkadoc26"><h1>Другие потоковые функции</h1></a>     <p>В библиотеке stdio существует ряд других функций, использующих потоки как параметры или стандартные потоки <blockquote>stdin</blockquote>, <blockquote>stdout</blockquote>, <blockquote>stderr</blockquote>:</p>     <p>&#9633; <blockquote>fgetpos</blockquote> — возвращает текущую позицию в файловом протоке;</p>     <p>&#9633; <blockquote>fsetpos</blockquote> — устанавливает текущую позицию в файловом потоке;</p>     <p>&#9633; <blockquote>ftell</blockquote> — возвращает величину текущего смещения файла в потоке;</p>     <p>&#9633; <blockquote>rewind</blockquote> — сбрасывает текущую позицию файла в потоке и переводит ее в начало файла;</p>     <p>&#9633; <blockquote>freopen</blockquote> — повторно использует файловый поток;</p>     <p>&#9633; <blockquote>setvbuf</blockquote> — задает схему буферизации для потока;</p>     <p>&#9633; <blockquote>remove</blockquote> — эквивалент функции <blockquote>unlink</blockquote>, до тех пор пока параметр <blockquote>path</blockquote> не является каталогом, в этом случае она эквивалентна функции <blockquote>rmdir</blockquote>.</p>     <p>Эти библиотечные функции описаны на страницах интерактивного справочного руководства в разделе 3.</p>     <p>Вы можете использовать функции обработки файловых потоков для повторной реализации с их помощью программы копирования файлов. Взгляните на программу copy_stdio.c в упражнении 3.3.</p>     <b>Упражнение 3.3. Третья версия программы копирования файлов</b>     <p>Эта программа очень похожа на предыдущие версии, но посимвольное копирование выполняется с помощью вызовов функций, заданных в файле stdio.h:</p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int c; </blockquote></p>     <p><blockquote> FILE *in, *out;</blockquote></p>     <p><blockquote> in = fopen("file.in", "r");</blockquote></p>     <p><blockquote> out = fopen("file.out", "w");</blockquote></p>     <p><blockquote> while((c = fgetc(in)) != EOF) fputc(c, out);</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Выполнив эту программу, как прежде, вы получите:</p>     <p><blockquote>$ <b>TIMEFORMAT="" time ./copy_stdio</b></blockquote></p>     <p><blockquote>0.06user 0.02system 0:00.11elapsed 81%CPU</blockquote></p>     <p><b>Как это работает</b></p>     <p>На этот раз программа выполняется 0,11 с, не так быстро, как низкоуровневая блочная версия, но значительно быстрее другой посимвольной версии. Это произошло потому, что библиотека stdio поддерживает внутренний буфер в структуре <blockquote>FILE</blockquote>, и низкоуровневые системные вызовы выполняются, только когда буфер заполняется. Не ленитесь экспериментировать, тестируя программный код построчного и блочного копирования с помощью stdio, чтобы увидеть, как они действуют в случае проверенных нами трех примеров.</p>             <a name="metkadoc27"><h1>Ошибки потока</h1></a>     <p>Для обозначения ошибок многие функции библиотеки stdio применяют значения за пределами допустимых, например, пустые указатели или константу <blockquote>EOF</blockquote>. В этих случаях ошибка указывается во внешней переменной <blockquote>errno</blockquote>.</p>     <p><blockquote><b>#include &lt;errno.h&gt;</b></blockquote></p>     <p><blockquote><b>extern int errno;</b></blockquote></p>     <blockquote>      <b>Примечание</b>      <p>Имейте в виду, что многие функции могут изменять значение <blockquote>errno</blockquote>. Оно достоверно, только когда функция закончилась неудачно. Вам следует проверять это значение сразу же, как функция сообщила о сбое. Прежде чем использовать его, скопируйте это значение в другую переменную, поскольку функции вывода, такие как <blockquote>fprintf</blockquote>, могут сами изменять <blockquote>errno</blockquote>.</p>     </blockquote>     <p>Вы можете также запросить состояние файлового потока, чтобы выяснить, возникла ли ошибка или достигнут конец файла.</p>     <p><blockquote><b>#include &lt;stdio.h&gt;</b></blockquote></p>     <p><blockquote><b>int ferror(FILE *stream);</b></blockquote></p>     <p><blockquote><b>int feof(FILE *stream);</b></blockquote></p>     <p><blockquote><b>void clearerr(FILE *stream);</b></blockquote></p>     <p>Функция <blockquote>ferror</blockquote> проверяет индикатор ошибок потока и возвращает ненулевое значение, если индикатор установлен, и ноль в противном случае.</p>     <p>Функция <blockquote>feof</blockquote> проверяет индикатор конца файла в потоке и возвращает ненулевое значение, если индикатор установлен, или ноль в противном случае. Применяйте ее следующим образом:</p>     <p><blockquote>if (feof(some_stream))</blockquote></p>     <p><blockquote> /* Мы в конце */</blockquote></p>     <p>Функция <blockquote>clearerr</blockquote> очищает индикаторы конца файла и ошибки для потока, на который указывает параметр <blockquote>stream</blockquote>. Она не возвращает никакого значения, и для нее не определены никакие ошибки. Вы можете применять эту функцию для сброса состояния ошибки в потоках. Примером может быть возобновление записи в поток после разрешения проблемы, связанной с ошибкой "disk full" (диск заполнен).</p>             <a name="metkadoc28"><h1>Потоки и дескрипторы файлов</h1></a>     <p>Каждый файловый поток ассоциирован с низкоуровневым дескриптором файла. Вы можете смешивать операции низкоуровневого ввода/вывода с высокоуровневыми потоковыми операциями, но это, как правило, неразумно, потому что трудно предсказать эффект от применения буферизации.</p>     <p><blockquote><b>#include &lt;stdio.h&gt;</b></blockquote></p>     <p><blockquote><b>int fileno(FILE *stream);</b></blockquote></p>     <p><blockquote><b>FILE *fdopen(int fildes, const char *mode);</b></blockquote></p>     <p>Вы можете определить, какой низкоуровневый дескриптор файла применяется для файлового потока, вызвав функцию <blockquote>fileno</blockquote>. Она возвращает дескриптор файла для заданного потока или -1 в случае сбоя. Эта функция полезна при необходимости низкоуровневого доступа к открытому потоку, например для вызова функции <blockquote>fstat</blockquote> применительно к этому потоку.</p>     <p>Можно создать новый поток файла на основе дескриптора файла, открытого только для чтения, применив функцию <blockquote>fdopen</blockquote>. По существу, эта функция предоставляет буферы stdio для уже открытого файлового дескриптора, это может быть самый легкий вариант объяснения ее назначения.</p>     <p>Функция <blockquote>fdopen</blockquote> действует так же, как функция <blockquote>fopen</blockquote>, но в отличие от имени файла она принимает в качестве параметра низкоуровневый дескриптор файла. Это может пригодиться, если вы используете вызов open для создания файла, может быть для более тонкого управления правами доступа, но хотите применить поток для записи в файл. Параметр mode такой же, как у функции <blockquote>fopen</blockquote> и должен быть совместим с режимами доступа к файлу, установленными при первоначальном открытии файла. Функция <blockquote>fdopen</blockquote> возвращает новый файловый поток или <blockquote>NULL</blockquote> в случае неудачного завершения.</p>              <a name="metkadoc29"><h1>Ведение файлов и каталогов</h1></a>         <p>Стандартные библиотеки и системные вызовы обеспечивают полный контроль над созданием и ведением файлов и каталогов.</p>             <a name="metkadoc30"><h1><i>chmod</i></h1></a>     <p>С помощью системного вызова <blockquote>chmod</blockquote> вы можете изменять права доступа к файлу или каталогу. Он лежит в основе программы командной оболочки <blockquote>chmod</blockquote>.</p>     <p>Далее приведена синтаксическая запись вызова:</p>     <p><blockquote><b>#include &lt;sys/stat.h&gt;</b></blockquote></p>     <p><blockquote><b>int chmod(const char *path, mode_t mode);</b></blockquote></p>     <p>Права доступа к файлу, заданному параметром <blockquote>path</blockquote>, изменяются в соответствии со значением параметра <blockquote>mode</blockquote>. Режим файла <blockquote>mode</blockquote> задается как в системном вызове open с помощью поразрядной операции <blockquote>OR</blockquote>, формирующей требуемые права доступа. Если программе не даны соответствующие полномочия, только владелец файла и суперпользователь могут изменять права доступа к файлу.</p>             <a name="metkadoc31"><h1><i>chown</i></h1></a>     <p>Суперпользователь может изменить владельца файла с помощью системного вызова chown.</p>     <p><blockquote><b>#include &lt;sys/types.h&gt; #include &lt;unistd.h&gt;</b></blockquote></p>     <p><blockquote><b>int chown(const char *path, uid_t owner, gid_t group);</b></blockquote> </p>     <p>В вызове применяются числовые значения идентификаторов (ID) нового пользователя и группы (взятые из системных вызовов <blockquote>getuid</blockquote> и <blockquote>getgid</blockquote>) и системная величина, используемая для ограничения пользователей, имеющих разрешение изменять владельца файла. Владелец и группа файла изменяются, если заданы соответствующие полномочия.</p>     <blockquote>      <b>Примечание</b>      <p>Стандарт POSIX в действительности допускает существование систем, в которых несуперпользователи могут изменять права владения файлом. Все "правильные" с точки зрения POSIX системы не допускают этого, но строго говоря, это расширение стандарта (в FIPS 151-2). Все виды систем, с которыми мы имеем дело в этой книге, подчиняются спецификации XSI (X/Open System Interface) и соблюдают на деле правила владения.</p>     </blockquote>             <a name="metkadoc32"><h1><i>unlink, link</i> и <i>symlink</i></h1></a>     <p>С помощью вызова <blockquote>unlink</blockquote> вы можете удалить файл.</p>     <p>Системный вызов <blockquote>unlink</blockquote> удаляет запись о файле в каталоге и уменьшает на единицу счетчик ссылок на файл. Он возвращает 0, если удаление ссылки прошло успешно, и -1 в случае ошибки. Для выполнения вызова у вас должны быть права на запись и выполнение в каталоге, хранящем ссылку на файл.</p>     <p><blockquote><b>#include &lt;unistd.h&gt;</b></blockquote></p>     <p><blockquote><b>int unlink(const char *path);</b></blockquote></p>     <p><blockquote><b>int link(const char *path1, const char *path2);</b></blockquote></p>     <p><blockquote><b>int symlink(const char *path1, const char *path2);</b></blockquote></p>     <p>Если счетчик становится равен нулю и файл не открыт ни в одном процессе, он удаляется. В действительности элемент каталога всегда удаляется немедленно, а место, занятое содержимым файла, не очищается до тех пор, пока последний процесс (если таковой существует) не закроет файл. Этот вызов использует программа <blockquote>rm</blockquote>. Дополнительные ссылки, предоставляющие альтернативные имена файла, обычно создаются программой <blockquote>ln</blockquote>. Вы можете программно создать новые ссылки на файл с помощью системного вызова <blockquote>link</blockquote>.</p>     <blockquote>      <b>Примечание</b>      <p>Создание файла с помощью вызова <blockquote>open</blockquote> и последующее обращение к <blockquote>unlink</blockquote> для этого файла — трюк, применяемый некоторыми программистами для создания временных или транзитных файлов. Эти файлы доступны программе, только пока они открыты; и будут удалены автоматически, когда программа завершится, и файлы будут закрыты.</p>     </blockquote>     <p>Системный вызов <blockquote>link</blockquote> создает новую ссылку на существующий файл <blockquote>path1</blockquote>. Новый элемент каталога задается в <blockquote>path2</blockquote>. Символические ссылки можно создавать аналогичным образом с помощью системного вызова <blockquote>symlink</blockquote>. Имейте в виду, что символические ссылки на файл не увеличивают значение счетчика ссылок и таким образом, в отличие от обычных (жестких) ссылок, не мешают удалению файла.</p>             <a name="metkadoc33"><h1><i>mkdir</i> и <i>rmdir</i></h1></a>     <p>Вы можете создавать и удалять каталоги, применяя системные вызовы <blockquote>mkdir</blockquote> и <blockquote>rmdir</blockquote>.</p>     <p><blockquote><b>#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;</b></blockquote></p>     <p><blockquote><b>int mkdir(const char *path, mode_t mode);</b></blockquote></p>     <p>Системный вызов <blockquote>mkdir</blockquote> используется для создания каталогов и эквивалентен программе <blockquote>mkdir</blockquote>. Вызов <blockquote>mkdir</blockquote> формирует новый каталог с именем, указанным в параметре <blockquote>path</blockquote>. Права доступа к каталогу передаются в параметре mode и задаются как опция о <blockquote>O_CREAT</blockquote> в системном вызове open и также зависят от переменной <blockquote>umask</blockquote>.</p>     <p><blockquote><b>#include &lt;unistd.h&gt;</b></blockquote></p>     <p><blockquote><b>int rmdir(const char *path);</b></blockquote></p>     <p>Системный вызов <blockquote>rmdir</blockquote> удаляет каталоги, но только если они пустые. Программа <blockquote>rmdir</blockquote> использует этот системный вызов для выполнения аналогичной работы.</p>             <a name="metkadoc34"><h1><i>chdir</i> и <i>getcwd</i></h1></a>     <p>Программа может перемещаться по каталогам во многом так же, как пользователь перемещается по файловой системе. Как вы применяете в командной оболочке команду <blockquote>cd</blockquote> для смены каталога, так и программа может использовать системный вызов <blockquote>chdir</blockquote>.</p>     <p><blockquote><b>#include &lt;unistd.h&gt;</b></blockquote></p>     <p><blockquote><b>int chdir(const char *path);</b></blockquote></p>     <p>Программа может определить свой текущий рабочий каталог, вызвав функцию <blockquote>getcwd</blockquote>.</p>     <p><blockquote><b>#include &lt;unistd.h&gt;</b></blockquote></p>     <p><blockquote><b>char *getcwd(char *buf, size_t size);</b></blockquote></p>     <p>Функция <blockquote>getcwd</blockquote> записывает имя текущего каталога в заданный буфер <blockquote>buf</blockquote>. Она возвращает <blockquote>NULL</blockquote>, если имя каталога превысит размер буфера (ошибка <blockquote>ERANGE</blockquote>), заданный в параметре <blockquote>size</blockquote>. В случае успешного завершения она возвращает <blockquote>buf</blockquote>.</p>     <p>Функция <blockquote>getcwd</blockquote> может также вернуть значение <blockquote>NULL</blockquote>, если во время выполнения программы каталог удален (<blockquote>EINVAL</blockquote>) или изменились его права доступа (<blockquote>EACCESS</blockquote><b>).</b></p>              <a name="metkadoc35"><h1>Просмотр каталогов</h1></a>         <p>Широко распространенная проблема систем Linux — просмотр каталогов, т.е. определение файлов, размещенных в конкретном каталоге. В программах командной оболочки она решается легко — просто скомандуйте оболочке выполнить подстановку в выражении с метасимволами. В прошлом в разных вариантах UNIX был разрешен программный доступ к низкоуровневой структуре файловой системы. Вы все еще можете открывать каталог как обычный файл и непосредственно считывать элементы каталога, но разные структуры файловых систем и реализации сделали такой подход непереносимым с машины на машину. Был разработан стандартный комплект библиотечных функций, существенно упрощающий просмотр каталогов.</p>     <p>Функции работы с каталогами объявлены в заголовочном файле dirent.h. В них используется структура <blockquote>DIR</blockquote> как основа обработки каталогов. Указатель на эту структуру, называемый потоком каталога (<blockquote>DIR*</blockquote>), действует во многом так же, как действует поток файла (<blockquote>FILE*</blockquote>) при работе с обычным файлом. Элементы каталога возвращаются в структурах dirent, также объявленных в файле dirent.h, поскольку никому не следует изменять поля непосредственно в структуре <blockquote>DIR</blockquote>.</p>     <p>Мы рассмотрим следующие функции:</p>     <p><b>&#9633;</b> <blockquote>opendir</blockquote>, <blockquote>closedir</blockquote>;</p>     <p>&#9633; <blockquote>readdir</blockquote>;</p>     <p>&#9633; <blockquote>telldir</blockquote>;</p>     <p>&#9633; <blockquote>seekdir</blockquote>;</p>     <p>&#9633; <blockquote>closedir</blockquote>.</p>             <a name="metkadoc36"><h1><i>opendir</i></h1></a>     <p>Функция <blockquote>opendir</blockquote> открывает каталог и формирует поток каталога. Если она завершается успешно, то возвращает указатель на структуру <blockquote>DIR</blockquote>, которая будет использоваться для чтения элементов каталога.</p>     <p><blockquote><b>#include &lt;sys/types.h&gt;</b></blockquote></p>     <p><blockquote><b>#include &lt;dirent.h&gt;</b></blockquote></p>     <p><blockquote><b>DIR *opendir(const char *name);</b></blockquote></p>     <p>В случае неудачи функция opendir возвращает пустой указатель. Имейте в виду, что для доступа к самому каталогу поток каталога использует низкоуровневый дескриптор файла, поэтому opendir может дать сбой, если открыто слишком много файлов.</p>             <a name="metkadoc37"><h1><i>readdir</i></h1></a>     <p>Функция <blockquote>readdir</blockquote> возвращает указатель на структуру, содержащую следующий элемент каталога в потоке каталога <blockquote>dirp</blockquote>. Успешные вызовы <blockquote>readdir</blockquote> возвращают следующие элементы каталогов. При возникновении ошибки и в конце каталога <blockquote>readdir</blockquote> возвращает <blockquote>NULL</blockquote>. Системы, удовлетворяющие стандарту POSIX, возвращая <blockquote>NULL</blockquote>, не меняют переменную <blockquote>errno</blockquote> в случае достижения конца каталога и устанавливают ее значение, если обнаружена ошибка.</p>     <p><blockquote><b>#include &lt;sys/types.h&gt;</b></blockquote></p>     <p><blockquote><b>#include &lt;dirent.h&gt;</b></blockquote></p>     <p><blockquote><b>struct dirent *readdir(DIR *dirp);</b></blockquote></p>     <p>Просмотр каталога с помощью функции <blockquote>readdir</blockquote> не гарантирует формирование списка всех файлов (и подкаталогов) в каталоге, если в это время выполняются другие процессы, создающие и удаляющие файлы в каталоге.</p>     <p>В состав структуры <blockquote>dirent</blockquote>, содержащей реквизиты элемента каталога, входят следующие компоненты.</p>     <p>&#9633; <blockquote>ino_t d_ino</blockquote> — индекс файла;</p>     <p>&#9633; <blockquote>char d_name[]</blockquote> — имя файла.</p>     <p>Для выяснения других реквизитов файла в каталоге вам необходимо вызвать <blockquote>stat</blockquote>, который мы обсуждали ранее.</p>             <a name="metkadoc38"><h1><i>telldir</i></h1></a>     <p>Функция <blockquote>telldir</blockquote> возвращает значение, регистрирующее текущую позицию в потоке каталога. Вы можете использовать ее в последующих вызовах функции <blockquote>seekdir</blockquote> для переустановки просмотра каталога, начиная с текущей позиции.</p>     <p><blockquote><b>#include &lt;sys/types.h&gt;</b></blockquote></p>     <p><blockquote><b>#include &lt;dirent.h&gt;</b></blockquote></p>     <p><blockquote><b>long int telldir(DIR *dirp);</b></blockquote></p>             <a name="metkadoc39"><h1><i>seekdir</i></h1></a>     <p>Функция <blockquote>seekdir</blockquote> устанавливает указатель на элемент каталога в потоке каталога, заданном в параметре <blockquote>dirp</blockquote>. Значение параметра <blockquote>loc</blockquote>, применяемого для установки позиции, следует получить из предшествующего вызова функции <blockquote>telldir</blockquote>.</p>     <p><blockquote><b>#include &lt;sys/types.h&gt;</b></blockquote></p>     <p><blockquote><b>#include &lt;dirent.h&gt;</b></blockquote></p>     <p><blockquote><b>void seekdir (DIR *dirp, long int loc);</b></blockquote></p>             <a name="metkadoc40"><h1><i>closedir</i></h1></a>     <p>Функция <blockquote>closedir</blockquote> закрывает поток каталога и освобождает ресурсы, выделенные ему. Она возвращает 0 в случае успеха и -1 при наличии ошибки.</p>     <p><blockquote><b>#include &lt;sys/types.h&gt;</b></blockquote></p>     <p><blockquote><b>#include &lt;dirent.h&gt;</b></blockquote></p>     <p><blockquote><b>int closedir(DIR *dirp);</b></blockquote></p>     <p>В приведенной далее программе printdir.c (упражнение 3.4) вы соберете вместе множество функций обработки файлов для создания простого перечня содержимого каталога. Каждый файл представлен отдельной строкой. У каждого подкаталога есть имя, за которым следует слэш, и файлы, содержащиеся в подкаталоге, выводятся с отступом шириной в четыре пробела.</p>     <p>Программа превращает каталог в подкаталоги, чтобы у найденных файлов были пригодные для использования имена, т.е. они могут передаваться непосредственно в функцию opendir. Программа будет давать сбои при просмотре структур с большим числом уровней вложенности, поскольку есть ограничение на разрешенное число открытых потоков каталогов.</p>     <p>Мы могли бы сделать программу более универсальной, принимая в качестве аргумента командной строки начальную точку просмотра.</p>     <p>Для того чтобы познакомиться с методами повышения универсальности программ, посмотрите исходный код таких утилит Linux, как <blockquote>ls</blockquote> и <blockquote>find</blockquote>.</p>     <b>Упражнение 3.4. Программа просмотра каталога</b>     <p>1. Начните с соответствующих заголовочных файлов и функции <blockquote>printdir</blockquote>, которая выводит содержимое текущего каталога. Она будет рекурсивно вызываться для вывода подкаталогов, применяя параметр <blockquote>depth</blockquote> для задания отступа.</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;dirent.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/stat.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <br>     <p><blockquote>void printdir(char *dir, int depth) {</blockquote></p>     <p><blockquote> DIR *dp;</blockquote></p>     <p><blockquote> struct dirent *entry;</blockquote></p>     <p><blockquote> struct stat statbuf;</blockquote></p>     <p><blockquote> if ((dp = opendir(dir)) == NULL) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "cannot open directory: %s\n", dir);</blockquote></p>     <p><blockquote>  return;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> chdir(dir);</blockquote></p>     <p><blockquote> while((entry = readdir(dp)) != NULL) {</blockquote></p>     <p><blockquote>  lstat(entry-&gt;d_name, &amp;statbuf);</blockquote></p>     <p><blockquote>  if (S_ISDIR(statbuf.st_mode)) {</blockquote></p>     <p><blockquote>   /* Находит каталог, но игнорирует . и .. */</blockquote></p>     <p><blockquote>   if (strcmp(".", entry-&gt;d_name) == 0 || strcmp("..", entry-&gt;d_name) == 0)</blockquote></p>     <p><blockquote>    continue;</blockquote></p>     <p><blockquote>   printf("%*s%s/\n", depth, "", entry-&gt;d_name);</blockquote></p>     <p><blockquote>   /* Рекурсивный вызов с новый отступом */</blockquote></p>     <p><blockquote>   printdir(entry-&gt;d_name, depth+4);</blockquote></p>     <p><blockquote>  } else printf("%*s%s\n", depth, " ", entry-&gt;d_name);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> chdir("..");</blockquote></p>     <p><blockquote> closedir(dp);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>2. Теперь переходите к функции <blockquote>main</blockquote>.</p>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> /* Обзор каталога /home */</blockquote></p>     <p><blockquote> printf("Directory scan of /home:\n");</blockquote></p>     <p><blockquote> printdir("/home", 0);</blockquote></p>     <p><blockquote> printf("done.\n");</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Программа просматривает исходные каталоги и формирует вывод, похожий на приведенный далее (отредактированный для краткости). Для того чтобы заглянуть в каталоги других пользователей, вам могут понадобиться права доступа суперпользователя.</p>     <p><blockquote>$ <b>./printdir</b></blockquote></p>     <p><blockquote>Directory scan of /home:</blockquote></p>     <p><blockquote>neil/</blockquote></p>     <p><blockquote>    .Xdefaults</blockquote></p>     <p><blockquote>    .Xmodmap</blockquote></p>     <p><blockquote>    .Xresources</blockquote></p>     <p><blockquote>    .bash_history</blockquote></p>     <p><blockquote>    .bashrc</blockquote></p>     <p><blockquote>    .kde/</blockquote></p>     <p><blockquote>        share/</blockquote></p>     <p><blockquote>            apps/</blockquote></p>     <p><blockquote>                konqueror/</blockquote></p>     <p><blockquote>                    dirtree/</blockquote></p>     <p><blockquote>                        public_html.desktop</blockquote></p>     <p><blockquote>                    toolbar/</blockquote></p>     <p><blockquote>                        bookmarks.xml</blockquote></p>     <p><blockquote>                        konq_history</blockquote></p>     <p><blockquote>                    kdisplay/</blockquote></p>     <p><blockquote>                        color-schemes/</blockquote></p>     <p><blockquote>    BLP4e/</blockquote></p>     <p><blockquote>        Gnu_Public_License</blockquote></p>     <p><blockquote>        chapter04/</blockquote></p>     <p><blockquote>            argopt.с</blockquote></p>     <p><blockquote>            args.с</blockquote></p>     <p><blockquote>        chapter03/</blockquote></p>     <p><blockquote>            file.out</blockquote></p>     <p><blockquote>            mmap.с</blockquote></p>     <p><blockquote>            printdir</blockquote></p>     <p><blockquote>done.</blockquote></p>     <p><b>Как это работает</b></p>     <p>Большинство операций сосредоточено в функции <blockquote>printdir</blockquote>. После некоторой начальной проверки ошибок с помощью функции <blockquote>opendir</blockquote>, проверяющей наличие каталога, <blockquote>printdir</blockquote> выполняет вызов функции <blockquote>chdir</blockquote> для заданного каталога. До тех пор пока элементы, возвращаемые функцией <blockquote>readdir</blockquote>, не нулевые, программа проверяет, не является ли очередной элемент каталогом. Если нет, она печатает элемент-файл с отступом, равным <blockquote>depth</blockquote>.</p>     <p>Если элемент — каталог, вы встречаетесь с рекурсией. После игнорирования элементов <blockquote>.</blockquote> и <blockquote>..</blockquote> (текущего и родительского каталогов) функция <blockquote>printdir</blockquote> вызывает саму себя и повторяет весь процесс снова. Как она выбирается из этих повторений? Как только цикл <blockquote>while</blockquote> заканчивается, вызов <blockquote>chdir("..")</blockquote> возвращает программу вверх по дереву каталогов, и предыдущий перечень можно продолжать. Вызов <blockquote>closedir(dp)</blockquote> гарантирует, что количество открытых потоков каталогов не больше того, которое должно быть.</p>     <p>Для того чтобы составить представление об окружении в системе Linux, обсуждаемом в<i> главе 4,</i> познакомьтесь с одним из способов, повышающих универсальность программы. Рассматриваемая программа ограничена, потому что привязана каталогу /home. Следующие изменения в функции <blockquote>main</blockquote> могли бы превратить эту программу в полезный обозреватель каталогов:</p>     <p><blockquote>int main(int argc, char* argv[]) {</blockquote></p>     <p><blockquote> char *topdir = ".";</blockquote></p>     <p><blockquote> if (argc &gt;= 2) topdir = argv[1];</blockquote></p>     <p><blockquote> printf("Directory scan of %s\n", topdir);</blockquote></p>     <p><blockquote> printdir(topdir, 0);</blockquote></p>     <p><blockquote> printf("done.\n");</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Три строки изменены и пять добавлено, но это уже универсальная утилита с необязательным параметром, содержащим имя каталога, по умолчанию равным текущему каталогу. Вы можете выполнять ее с помощью следующей командной строки:</p>     <p><blockquote>$ <b>./printdir2 /usr/local | more</b></blockquote></p>     <p>Вывод будет разбит на страницы, и пользователь сможет листать их. Таким образом, у него появится маленький удобный универсальный обозреватель дерева каталогов. Приложив минимум усилий, вы могли бы добавить статистический показатель использования пробелов, предельную глубину отображения и т.д.</p>              <a name="metkadoc41"><h1>Ошибки </h1></a>         <p>Как вы видели, многие системные вызовы и функции, описанные в этой главе, могут завершиться аварийно по ряду причин. Когда это происходит, они указывают причину сбоя, задавая значение внешней переменной <blockquote>errno</blockquote>. Многие стандартные библиотеки используют эту переменную как стандартный способ оповещения о возникших проблемах. Стоит повторить, что программа должна проверять переменную errno сразу же после возникновения проблемы в функции, поскольку errno может быть изменена следующей вызванной функцией, даже если она завершилась нормально.</p>     <p>Имена констант и варианты ошибок перечислены в заголовочном файле errno.h. К ним относятся следующие:</p>     <p>&#9633; <blockquote>EPERM</blockquote> — Operation not permitted (операция не разрешена);</p>     <p>&#9633; <blockquote>ENOENT</blockquote> — No such file or directory (нет такого файла или каталога);</p>     <p>&#9633; <blockquote>EINTR</blockquote> — Interrupted system call (прерванный системный вызов);</p>     <p>&#9633; <blockquote>EIO</blockquote> — I/O Error (ошибка ввода/вывода);</p>     <p>&#9633; <blockquote>EBUSY</blockquote> — Device or resource busy (устройство или ресурс заняты);</p>     <p>&#9633; <blockquote>EEXIST</blockquote> — File exists (файл существует);</p>     <p>&#9633; <blockquote>EINVAL</blockquote> — Invalid argument (неверный аргумент);</p>     <p>&#9633; <blockquote>EMFILE</blockquote> — Too many open files (слишком много открытых файлов);</p>     <p>&#9633; <blockquote>ENODEV</blockquote> — No such device (нет такого устройства);</p>     <p>&#9633; <blockquote>EISDIR</blockquote> — Is a directory (это каталог);</p>     <p>&#9633; <blockquote>ENOTDIR</blockquote> — Isn't a directory (это не каталог).</p>     <p>Есть пара полезных функций, сообщающих об ошибках при их возникновении: <blockquote>strerror</blockquote> и <blockquote>perror</blockquote>.</p>             <a name="metkadoc42"><h1><i>strerror</i></h1></a>     <p>Функция <blockquote>strerror</blockquote> преобразует номер ошибки в строку, описывающую тип возникшей ошибки. Она может быть полезна для регистрации условий, вызывающих ошибку.</p>     <p>Далее приведена ее синтаксическая запись:</p>     <p><blockquote><b>#include &lt;string.h&gt;</b></blockquote></p>     <p><blockquote><b>char *strerror(int errnum);</b></blockquote></p>             <a name="metkadoc43"><h1><i>perror</i></h1></a>     <p>Функция <blockquote>perror</blockquote> также превращает текущую ошибку в виде, представленном в переменной <blockquote>errno</blockquote>, в строку и выводит ее в стандартный поток ошибок. Ей предшествует сообщение, заданное в строке <blockquote>s</blockquote> (если указатель не равен <blockquote>NULL</blockquote>), за которым следуют двоеточие и пробел.</p>     <p>Далее приведена синтаксическая запись функции:</p>     <p><blockquote><b>#include &lt;stdio.h&gt;</b></blockquote></p>     <p><blockquote><b>void perror(const char *s);</b></blockquote></p>     <p>Например, вызов</p>     <p><blockquote>perror("program");</blockquote></p>     <p>может дать следующий результат в стандартном потоке ошибок:</p>     <p><blockquote>program: Too many open files</blockquote></p>              <a name="metkadoc44"><h1>Файловая система procfs</h1></a>    <p>Ранее в этой главе мы уже писали о том, что ОС Linux обрабатывает многие вещи как файлы, и в файловой системе есть ряд элементов для аппаратных устройств. Эти файлы /dev применяются для доступа к оборудованию особыми методами с помощью низкоуровневых системных вызовов.</p>    <p>Программные драйверы, управляющие оборудованием, часто могут настраиваться определенными способами или сообщать информацию. Например, контроллер жесткого диска может настраиваться на применение определенного режима DMA. Сетевая карта может обладать функциональными возможностями для оповещения об установке высокоскоростного дуплексного соединения.</p>    <p>В прошлом для связи с драйверами устройств применялись утилиты общего назначения. Например, hdparm использовалась для настройки некоторых параметров диска, a ifconfig могла сообщить сетевую статистику. В недавнем прошлом появилась тенденция, направленная на обеспечение более подходящего способа доступа к информации драйвера и, как расширение, включающая взаимодействие с различными элементами ядра Linux.</p>    <p>ОС Linux предоставляет специальную файловую систему procfs, которая обычно доступна в виде каталога /proc. Она содержит много специальных файлов, обеспечивающих высокоуровневый доступ к информации драйвера и ядра. Приложения, выполняющиеся с корректными правами доступа, могут читать эти файлы для получения информации и записывать в них устанавливаемые параметры.</p>    <p>Набор файлов в каталоге /proc меняется от системы к системе, и с каждым новым выпуском Linux появляются новые файлы, дополнительные драйверы и средства поддержки файловой системы procfs. В этом разделе мы рассмотрим некоторые из самых широко распространенных файлов и кратко обсудим их применение.</p>    <p>В перечень каталога /proc на компьютере, использовавшемся для написания этой главы, включены следующие элементы:</p>    <p><blockquote>1/     10514/ 20254/ 6/    9057/ 9623/     ide/       mtrr</blockquote></p>    <p><blockquote>10359/ 10524/ 29/    698/  9089/ 9638/     interrupts net/</blockquote></p>    <p><blockquote>10360/ 10530/ 983/   699/  9118/ acpi/     iomem      partitions</blockquote></p>    <p><blockquote>10381/ 10539/ 3/     710/  9119/ asound/   ioports    scsi/</blockquote></p>    <p><blockquote>10438/ 10541/ 30/    711/  9120/ buddyinfo irq/       self@</blockquote></p>    <p><blockquote>10441/ 10555/ 3069/  742/  9138/ bus/      kallsyms   slabinfo</blockquote></p>    <p><blockquote>10442/ 10688/ 3098/  7808/ 9151/ cmdline   kcore      splash</blockquote></p>    <p><blockquote>10478/ 10689/ 3099/  7813/ 92/   config.gz keys       stat</blockquote></p>    <p><blockquote>10479/ 10784/ 31/    8357/ 9288/ cpuinfo   key-users  swaps</blockquote></p>    <p><blockquote>10482/ 113/   3170/  8371/ 93/   crypto    kmsg       sys/</blockquote></p>    <p><blockquote>10484/ 115/   3171/  840/  9355/ devices   loadavg    sysrq-trigger</blockquote></p>    <p><blockquote>10486/ 116/   3177/  8505/ 9407/ diskstats locks      sysvipc/</blockquote></p>    <p><blockquote>10495/ 1167/  32288/ 8543/ 9457/ dma       mdstat     tty/</blockquote></p>    <p><blockquote>10497/ 1168/  3241/  8547/ 9479/ driver/   meminfo    uptime</blockquote></p>    <p>Во многих случаях файлы могут только читаться и дают информацию о состоянии. Например, /proc/cpuinfo предоставляет сведения о доступных процессорах:</p>    <p><blockquote>$ <b>cat /proc/cpuinfo</b></blockquote></p>    <p><blockquote>processor    : 0</blockquote></p>    <p><blockquote>vendor_id     : GenuineIntel</blockquote></p>    <p><blockquote>cpu family    : 15</blockquote></p>    <p><blockquote>model         : 2</blockquote></p>    <p><blockquote>model name    : Intel(R) Pentium(R) 4 CPU 2.66GHz</blockquote></p>    <p><blockquote>stepping      : 8</blockquote></p>    <p><blockquote>cpu MHz       : 2665.923</blockquote></p>    <p><blockquote>cache size    : 512 KB</blockquote></p>    <p><blockquote>fdiv_bug      : no</blockquote></p>    <p><blockquote>hlt_bug       : no</blockquote></p>    <p><blockquote>f00f_bug      : no</blockquote></p>    <p><blockquote>coma_bug      : no</blockquote></p>    <p><blockquote>fpu           : yes</blockquote></p>    <p><blockquote>fpu_exception : yes</blockquote></p>    <p><blockquote>cpuid level   : 2</blockquote></p>    <p><blockquote>wp            : yes</blockquote></p>    <p><blockquote>flags         : fpu vme de pse tsc msr рае mce cx8 apic sep mtrr pge mca cmov</blockquote></p>    <p><blockquote>pat pse36 clflush dts acpi mmx fxsr sse sse2 ss up</blockquote></p>    <p><blockquote>bogomips      : 5413.47</blockquote></p>    <p><blockquote>clflush size  : 64</blockquote></p>    <p>Файлы /proc/meminfo и /рroc/version предоставляют данные об использовании оперативной памяти и версии ядра соответственно:</p>    <p><blockquote>$ cat<b> /proc/meminfo</b></blockquote></p>    <p><blockquote>MemTotal:     776156 kB</blockquote></p>    <p><blockquote>MemFree:       28528 kB</blockquote></p>    <p><blockquote>Buffers:      191764 kB</blockquote></p>    <p><blockquote>Cached:       369520 kB</blockquote></p>    <p><blockquote>SwapCached:       20 kB</blockquote></p>    <p><blockquote>Active:       406912 kB</blockquote></p>    <p><blockquote>Inactive:     274320 kB</blockquote></p>    <p><blockquote>HighTotal:         0 kB</blockquote></p>    <p><blockquote>HighFree:          0 kB</blockquote></p>    <p><blockquote>LowTotal:     776156 kB</blockquote></p>    <p><blockquote>LowFree:       28528 kB</blockquote></p>    <p><blockquote>SwapTotal:   1164672 kB</blockquote></p>    <p><blockquote>SwapFree:    1164652 kB</blockquote></p>    <p><blockquote>Dirty:            68 kB</blockquote></p>    <p><blockquote>Writeback:         0 kB</blockquote></p>    <p><blockquote>AnonPages:     95348 kB</blockquote></p>    <p><blockquote>Mapped:        49044 kB</blockquote></p>    <p><blockquote>Slab:          57848 kB</blockquote></p>    <p><blockquote>SReclaimable:  48008 kB</blockquote></p>    <p><blockquote>SUnreclaim:     9840 kB</blockquote></p>    <p><blockquote>PageTables:     1500 kB</blockquote></p>    <p><blockquote>NFS_Unstable:      0 kB</blockquote></p>    <p><blockquote>Bounce:            0 kB</blockquote></p>    <p><blockquote>CommitLimit: 1552748 kB</blockquote></p>    <p><blockquote>Committed_AS: 189680 kB</blockquote></p>    <p><blockquote>VmallocTotal: 245752 kB</blockquote></p>    <p><blockquote>VmallocUsed:   10572 kB</blockquote></p>    <p><blockquote>VmallocChunk: 234556 kB</blockquote></p>    <p><blockquote>HugePages_Total:   0</blockquote></p>    <p><blockquote>HugePages_Free:    0</blockquote></p>    <p><blockquote>HugePages_Rsvd:    0</blockquote></p>    <p><blockquote>Hugepagesize:   4096 kB</blockquote></p>    <p><blockquote>$ <b>cat /proc/version</b></blockquote></p>    <p><blockquote>Linux version 2.6.20.2-2-default (geeko@buildhost) (gcc version 4.1.3 20070218 (prerelease) (SUSE Linux)) #1 SMP Fri Mar 9 21:54:10 UTC 2007</blockquote></p>    <p>Информация, выводимая этими файлами, генерируется при каждом чтении файла. Поэтому повторное чтение файла meminfo в более поздний момент времени даст результаты с точностью до секунд.</p>    <p>Получить дополнительную информацию от специальных функций ядра можно в подкаталогах каталога /proc. Например, статистику использования сетевых сокетов вы можете узнать из /proc/net/sockstat:</p>    <p><blockquote>$ <b>cat /proc/net/sockstat</b></blockquote></p>    <p><blockquote>sockets: used 285</blockquote></p>    <p><blockquote>TCP: inuse 4 orphan 0 tw 0 alloc 7 mem 1</blockquote></p>    <p><blockquote>UDP: inuse 3</blockquote></p>    <p><blockquote>UDPLITE: inuse 0</blockquote></p>    <p><blockquote>RAW: inuse 0</blockquote></p>    <p><blockquote>FRAG: inuse 0 memory 0</blockquote></p>    <p>В некоторые элементы каталога /proc можно производить запись, а не только читать их. Например, общее количество файлов, которые могут быть открыты одновременно всеми выполняющимися программами, — это параметр ядра Linux. Текущее значение можно прочитать из /proc/sys/fs/file-max:</p>    <p><blockquote>$ <b>cat /proc/sys/fs/file-max</b></blockquote></p>    <p><blockquote>76593</blockquote></p>    <p>В данном случае задана величина <blockquote>76593</blockquote>. Если вам нужно увеличить это значение, вы можете сделать это, записав его в тот же файл. Это действие может потребоваться при выполнении специального комплекса программ, например, системы управления базой данных, которая использует много таблиц, что потребует одновременного открытия большого числа файлов.</p>    <blockquote>     <b>Примечание</b>     <p>Для записи в файлы /proc требуются права доступа суперпользователя. При записи в эти файлы нужно быть предельно внимательным; при записи неподходящих данных возможно возникновение серьезных проблем, включая крах системы и потерю данных.</p>    </blockquote>    <p>Для увеличения предельного значения одновременно обрабатываемых в системе файлов до 80000 вы можете просто записать новое предельное значение в файл file-max.</p>    <p><blockquote># echo <b>80000 &gt;/proc/sys/fs/file-max</b></blockquote></p>    <p>Теперь, повторно прочитав файл, вы увидите новое значение:</p>    <p><blockquote>$ <b>cat /proc/sys/fs/file-max</b></blockquote></p>    <p><blockquote>80000</blockquote></p>    <p>Подкаталоги каталога /proc с числовыми именами применяются для обеспечения доступа к информации о выполняющихся программах. В<i> главе 11</i> вы узнаете больше о том, что программы выполняются как процессы.</p>    <p>Сейчас только отметьте, что у каждого процесса есть уникальный идентификатор: число в диапазоне от 1 до почти 32 000. Команда ps предоставляет список выполняющихся в данный момент процессов. Например, когда писалась эта глава:</p>    <p><blockquote>neil@susel03:~/BLP4e/chapter03&gt; <b>ps -а</b></blockquote></p>    <p><blockquote>  PID TTY       TIME CMD</blockquote></p>    <p><blockquote> 9118 pts/1 00:00:00 ftp</blockquote></p>    <p><blockquote> 9230 pts/1 00:00:00 ps</blockquote></p>    <p><blockquote>10689 pts/1 00:00:01</blockquote></p>    <p><blockquote>bash neil@susel03:~/BLP4e/chapter03&gt;</blockquote></p>    <p>Вы видите несколько сеансов терминалов, запустивших командную оболочку bash и сеанс передачи файла, выполняющий программу <blockquote>ftp</blockquote>. Просмотрев каталог /proc, вы получите более подробную информацию о сеансе <blockquote>ftp</blockquote>.</p>    <p>В данном случае для ftp задан идентификатор процесса <blockquote>9118</blockquote>, поэтому вы должны заглянуть в каталог /proc/9118 для получения подробной информации о нем:</p>    <p><blockquote>$ <b>ls -l /proc/9118</b></blockquote></p>    <p><blockquote>total 0</blockquote></p>    <p><blockquote>0 dr-xr-xr-x 2 neil users 0 2007-05-20 07:43 attr</blockquote></p>    <p><blockquote>0 -r-------- 1 neil users 0 2007-05-20 07:43 auxv</blockquote></p>    <p><blockquote>0 -r--r--r-- 1 neil users 0 2007-05-20 07:35 cmdline</blockquote></p>    <p><blockquote>0 -r--r--r-- 1 neil users 0 2007-05-20 07:43 cpuset</blockquote></p>    <p><blockquote>0 lrvxrwxrwx 1 neil users 0 2007-05-20 07:43 cwd -&gt; /home/neil/BLP4e/chapter03</blockquote></p>    <p><blockquote>0 -r-------- 1 neil users 0 2007-05-20 07:43 environ</blockquote></p>    <p><blockquote>0 lrwxrwxrwx 1 neil users 0 2007-05-20 07:43 exe -&gt; /usr/bin/pftp</blockquote></p>    <p><blockquote>0 dr-x------ 2 neil users 0 2007-05-20 07:19 fd</blockquote></p>    <p><blockquote>0 -rw-r--r-- 1 neil users 0 2007-05-20 07:43 loginuid</blockquote></p>    <p><blockquote>0 -r--r--r-- 1 neil users 0 2007-05-20 07:43 maps</blockquote></p>    <p><blockquote>0 -rw------- 1 neil users 0 2007-05-20 07:43 mem</blockquote></p>    <p><blockquote>0 -r--r--r-- 1 neil users 0 2007-05-20 07:43 mounts</blockquote></p>    <p><blockquote>0 -r-------- 1 neil users 0 2007-05-20 07:43 mountstats</blockquote></p>    <p><blockquote>0 -rw-r--r-- 1 neil users 0 2007-05-20 07:43 oom_adj</blockquote></p>    <p><blockquote>0 -r--r--r-- 1 neil users 0 2007-05-20 07:43 oom_score</blockquote></p>    <p><blockquote>0 lrwxrwxrwx 1 neil users 0 2007-05-20 07:43 root -&gt; /</blockquote></p>    <p><blockquote>0 -rw------- 1 neil users 0 2007-05-20 07:43 seccomp</blockquote></p>    <p><blockquote>0 -r--r--r-- 1 neil users 0 2007-05-20 07:43 smaps</blockquote></p>    <p><blockquote>0 -r--r--r-- 1 neil users 0 2007-05-20 07:33 stat</blockquote></p>    <p><blockquote>0 -r--r--r-- 1 neil users 0 2007-05-20 07:43 statm</blockquote></p>    <p><blockquote>0 -r--r--r-- 1 neil users 0 2007-05-20 07:33 status</blockquote></p>    <p><blockquote>0 dr-xr-xr-x 3 neil users 0 2007-05-20 07:43 task</blockquote></p>    <p><blockquote>0 -r--r--r-- 1 neil users 0 2007-05-20 07:43 wchan</blockquote></p>    <p>В данном перечне вы видите разные специальные файлы, способные сообщить вам, что происходит с процессом.</p>    <p>Можно сказать, что выполняется программа /usr/bin/pftp, и ее текущий рабочий каталог — home/neil/BLP4e/chapter03. Есть возможность прочитать другие файлы из этого каталога, чтобы увидеть командную строку, применяемую для запуска программы, а также ее окружение. Файлы cmdline и environ предоставляют эту информацию в виде последовательности нуль-терминированных строк, поэтому вам следует соблюдать осторожность при их просмотре. Более подробно окружение ОС Linux мы обсудим в<i> главе 4.</i></p>    <p><blockquote>$ <b>od -с /proc/9118/cmdline</b></blockquote></p>    <p><blockquote>0000000 f  t  p \0  1  9  2  .  1  6  8  .  0  .  1  2</blockquote></p>    <p><blockquote>0000020 \0</blockquote></p>    <p><blockquote>0000021</blockquote></p>    <p>Из полученного вывода видно, что <blockquote>ftp</blockquote> была запущена из командной строки <blockquote>ftp 192.163.0.12</blockquote>.</p>    <p>Подкаталог fd предоставляет информацию об открытых дескрипторах файлов, используемых процессом. Эти данные могут быть полезны при определении количества файлов, одновременно открытых программой. На каждый открытый дескриптор приходится один элемент; имя его соответствует номеру дескриптора. В нашем случае, как мы и ожидали, у программы <blockquote>ftp</blockquote> есть открытые дескрипторы 0, 1, 2 и 3. Они включают стандартные дескрипторы ввода, вывода и потока ошибок плюс подключение к удаленному серверу.</p>    <p><blockquote>$ <b>ls /proc/9118/fd</b></blockquote></p>    <p><blockquote>0 1 2 3</blockquote></p>          <a name="metkadoc45"><h1>Более сложные приемы: <i>fcntl </i>и <i>mmap</i></h1></a>         <p>Теперь мы коснемся приемов, которые вы можете пропустить, поскольку они редко используются. Признавая это, мы помещаем их в книгу просто для вашего сведения, потому что применение описываемых средств может предоставить простые решения для замысловатых проблем.</p>             <a name="metkadoc46"><h1><i>fcntl</i></h1></a>     <p>Системный вызов <blockquote>fcntl</blockquote> предоставляет дополнительные методы обработки низкоуровневых дескрипторов файлов:</p>     <p><blockquote><b>#include &lt;fcntl.h&gt;</b></blockquote></p>     <p><blockquote><b>int fcntl(int fildes, int cmd);</b></blockquote></p>     <p><blockquote><b>int fcntl(int fildes, int cmd, long arg);</b></blockquote></p>     <p>С помощью системного вызова <blockquote>fcntl</blockquote> вы можете выполнить несколько разнородных операций над открытыми дескрипторами файлов, включая их дублирование, получение и установку флагов дескрипторов файлов, получение и установку флагов состояния файла и управление блокировкой файла (advisory file locking).</p>     <p>Различные операции выбираются разными значениями параметра команды <blockquote>cmd</blockquote>, как определено в файле fcntl.h. В зависимости от выбранной команды системному вызову может потребоваться третий параметр <blockquote>arg</blockquote>.</p>     <p>&#9633; <blockquote>fcntl(fildes, F_DUPFD, newfd)</blockquote> — этот вызов возвращает новый дескриптор файла с числовым значением, равным или большим целочисленного параметра <blockquote>newfd</blockquote>. Новый дескриптор — копия дескриптора <blockquote>fildes</blockquote>. В зависимости от числа открытых файлов и значения <blockquote>newfd</blockquote> этот вызов может быть практически таким же, как вызов <blockquote>dup(fildes)</blockquote>.</p>     <p>&#9633; <blockquote>fcntl(fildes, F_GETFD)</blockquote> — этот вызов возвращает флаги дескриптора файла, как определено в файле fcntl.h. К ним относится <blockquote>FD_CLOEXEC</blockquote>, определяющий, закрыт ли дескриптор файла после успешного вызова одного из системных вызовов семейства exec.</p>     <p>&#9633; <blockquote>fcntl(fildes, F_SETFD, flags)</blockquote> — этот вызов применяется для установки флагов дескриптора файла, как правило, только <blockquote>FD_CLOEXEC</blockquote>.</p>     <p>&#9633; <blockquote>fcntl(fildes, F_GETFL)</blockquote> и <blockquote>fcntl(fildes, F_SETFL, flags)</blockquote> — эти вызовы применяются, соответственно, для получения и установки флагов состояния файла и режимов доступа. Вы можете извлечь режимы доступа к файлу с помощью маски <blockquote>O_ACCMODE</blockquote>, определенной в файле fcntl.h. Остальные флаги включают передаваемые значения в третьем аргументе вызову open с использованием <blockquote>O_CREAT</blockquote>. Учтите, что вы не можете задать все флаги. В частности, нельзя задать права доступа к файлу с помощью вызова fcntl.</p>     <p>Вызов <blockquote>fcntl</blockquote> также позволяет реализовать блокировку файла. См. более подробную информацию в разделе 2 интерактивного справочного руководства или<i> главу</i> 7, в которой мы обсуждаем блокировку файлов.</p>             <a name="metkadoc47"><h1><i>mmap</i></h1></a>     <p>Система UNIX предоставляет полезное средство, позволяющее программам совместно использовать память, и, к счастью, оно включено в версию 2.0 и более поздние версии ядра Linux. Функция <blockquote>mmap</blockquote> (для отображения памяти) задает сегмент памяти, который может читаться двумя или несколькими программами и в который они могут записывать данные. Изменения, сделанные одной программой, видны всем остальным.</p>     <p>Вы можете применить то же самое средство для работы с файлами, заставив все содержимое файла на диске выглядеть как массив в памяти. Если файл состоит из записей, которые могут быть описаны структурами на языке С, вы сможете обновлять файл с помощью методов доступа к массиву структур.</p>     <p>Это становится возможным благодаря применению сегментов виртуальной памяти с набором особых прав доступа. Чтение из сегмента и запись в него заставляет операционную систему читать соответствующую часть файла на диске и писать данные в нее.</p>     <p>Функция mmap создает указатель на область памяти, ассоциированную с содержимым файла, доступ к которому осуществляется через открытый дескриптор файла.</p>     <p><blockquote><b>#include &lt;sys/mman.h&gt;</b></blockquote></p>     <p><blockquote><b>void *mmap(void *addr, size_t len, int prot, int flags, int fildes, off_t off);</b></blockquote></p>     <p>Изменить начальную позицию порции данных файла, к которым выполняется обращение через совместно используемый сегмент, можно, передавая параметр <blockquote>off</blockquote>. Открытый дескриптор файла задается в параметре <blockquote>fildes</blockquote>. Объем данных, к которым возможен доступ (т. е. размер сегмента памяти), указывается в параметре <blockquote>len</blockquote>.</p>     <p>Параметр <blockquote>addr</blockquote> можно использовать для запроса конкретного адреса памяти. Если он равен нулю, результирующий указатель формируется автоматически. Последний вариант рекомендуется, потому что в противном случае трудно добиться переносимости; диапазоны доступных адресов в разных системах отличаются.</p>     <p>Параметр <blockquote>prot</blockquote> используется для установки прав доступа к сегменту памяти. Он представляет собой результат поразрядной операции or, примененной к следующим константам:</p>     <p>&#9633; <blockquote>PROT_READ</blockquote> — сегмент может читаться;</p>     <p>&#9633; <blockquote>PROT_WRITE</blockquote> — в сегмент можно писать;</p>     <p>&#9633; <blockquote>PROT_EXEC</blockquote> — сегмент может выполняться;</p>     <p>&#9633; <blockquote>PROT_NONE</blockquote> — к сегменту нет доступа.</p>     <p>Параметр <blockquote>flags</blockquote> контролирует, как изменения, сделанные программой в сегменте, отражаются в других местах; его возможные значения приведены в табл. 3.7.</p>     <br>     <p><b><i>Таблица 3.7</i></b></p>     <table>      <tr>       <th valign="top">Константа</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>MAP_PRIVATE</blockquote></td>       <td valign="top">Сегмент частный, изменения локальные</td>      </tr>      <tr>       <td valign="top"><blockquote>MAP_SHARED</blockquote></td>       <td valign="top">Изменения сегмента переносятся в файл</td>      </tr>      <tr>       <td valign="top"><blockquote>MAP_FIXED</blockquote></td>       <td valign="top">Сегмент должен располагаться по заданному адресу <blockquote>addr</blockquote></td>      </tr>     </table>     <p>Функция <blockquote>msync</blockquote> вызывает запись изменений в части или во всем сегменте памяти обратно а отображенный файл (или считывание из файла).</p>     <p><blockquote><b>#include &lt;sys/mman.h&gt;</b></blockquote></p>     <p><blockquote><b>int msync(void *addr, size_t len, int flags);</b></blockquote></p>     <p>Корректируемая часть сегмента задается передачей начального адреса <blockquote>addr</blockquote> и размера <blockquote>len</blockquote>. Параметр <blockquote>flags</blockquote> управляет способом выполнения корректировки с помощью вариантов, приведенных в табл. 3.8.</p>     <br>     <p><b><i>Таблица 3.8</i></b></p>     <table>      <tr>       <th valign="top">Константа</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>MS_ASYNC</blockquote></td>       <td valign="top">Выполнять запись асинхронно</td>      </tr>      <tr>       <td valign="top"><blockquote>MS_SYNC</blockquote></td>       <td valign="top">Выполнять запись синхронно</td>      </tr>      <tr>       <td valign="top"><blockquote>MS_INVALIDATE</blockquote></td>       <td valign="top">Обновить другие отражения этого файла так, чтобы они содержали изменения, внесенные этим вызовом</td>      </tr>     </table>     <p>Функция <blockquote>munmap</blockquote> освобождает сегмент памяти.</p>     <p><blockquote><b>#include &lt;sys/mman.h&gt;</b></blockquote></p>     <p><blockquote><b>int munmap(void *addr, size_t len);</b></blockquote></p>     <p>В программе mmap.с из упражнения 3.5 показан файл из структур, которые будут корректироваться с помощью функции <blockquote>mmap</blockquote> и обращений в стиле массива. Ядро Linux версий, меньших 2.0, не полностью поддерживает применение функции <blockquote>mmap</blockquote>. Программа работает корректно в системе Sun Solaris и других системах.</p>     <b>Упражнение 3.5. Применение функции <blockquote>mmap</blockquote></b>     <p>1. Начните с определения структуры <blockquote>RECORD</blockquote> и создайте <blockquote>NRECORDS</blockquote> вариантов, в каждый из которых записывается собственный номер. Они будут добавлены в конец файла records.dat.</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/mman.h&gt;</blockquote></p>     <p><blockquote>#include &lt;fcntl.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <br>     <p><blockquote>typedef struct {</blockquote></p>     <p><blockquote> int integer;</blockquote></p>     <p><blockquote> char string[24];</blockquote></p>     <p><blockquote>} RECORD;</blockquote></p>     <br>     <p><blockquote>#define NRECORDS (100)</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> RECORD record, *mapped;</blockquote></p>     <p><blockquote> int i, f;</blockquote></p>     <p><blockquote> FILE *fp;</blockquote></p>     <p><blockquote> fp = fopen("records.dat", "w+");</blockquote></p>     <p><blockquote> for (i=0; i&lt;NRECORDS; i++) {</blockquote></p>     <p><blockquote>  record.integer = i;</blockquote></p>     <p><blockquote>  sprintf(record.string, "RECORD-%d", i);</blockquote></p>     <p><blockquote>  fwrite(&amp;record, sizeof(record), 1, fp);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> fclose(fp);</blockquote></p>     <p>2. Далее измените целое значение записи с 43 на 143 и запишите его в строку 43-й записи.</p>     <p><blockquote> fp = fopen("records.dat", "r+");</blockquote></p>     <p><blockquote> fseek(fp, 43*sizeof(record), SEEK_SET);</blockquote></p>     <p><blockquote> fread(&amp;record, sizeof(record), 1, fp);</blockquote></p>     <p><blockquote> record.integer =143;</blockquote></p>     <p><blockquote> sprintf(record.string, "RECORD-%d", record.integer);</blockquote></p>     <p><blockquote> fseek(fp, 43*sizeof(record), SEEK_SET);</blockquote></p>     <p><blockquote> fwrite(&amp;record, sizeof(record), 1, fp);</blockquote></p>     <p><blockquote> fclose(fp);</blockquote></p>     <p>3. Теперь отобразите записи в память и обратитесь к 43-й записи для того, чтобы изменить целое на 243 (и обновить строку записи), снова используя отображение в память.</p>     <p><blockquote> f = open("records.dat", O_RDWR);</blockquote></p>     <p><blockquote> mapped = (RECORD *)mmap(0, NRECORDS*sizeof(record),</blockquote></p>     <p><blockquote>  PROT_READ|PROT_WRITE, MAP_SHARED, f, 0);</blockquote></p>     <p><blockquote> mapped[43].integer = 243;</blockquote></p>     <p><blockquote> sprintf(mapped[43].string, "RECORD-%d", mapped[43].integer);</blockquote></p>     <p><blockquote> msync((void *)mapped, NRECORDS*sizeof(record), MS_ASYNC);</blockquote></p>     <p><blockquote> munmap((void *)mapped, NRECORDS*sizeof(record));</blockquote></p>     <p><blockquote> close(f);</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>В<i> главе 13</i> вы встретитесь с еще одним средством совместного использования памяти — разделяемой памятью System V.</p>              <a name="metkadoc48"><h1>Резюме</h1></a>    <p>В этой главе вы увидели, как ОС Linux обеспечивает прямой доступ к файлам и устройствам, как на этих низкоуровневых функциях строятся библиотечные функции, предоставляющие гибкие решения программных проблем. В результате вы смогли написать довольно мощную процедуру просмотра каталога с помощью нескольких строк программного кода.</p>    <p>Вы также узнали об обработке файлов и каталогов достаточно для того, чтобы превратить "сырое" приложение для работы с компакт-дисками, созданное в конце<i> главы 2,</i> в программу на языке С, применяющую более структурированное решение на базе файлов. Но на этом этапе вы не можете расширить функциональные возможности программы, поэтому мы отложим ее переработку до того времени, когда вы научитесь управлять экраном и клавиатурой, которые будут предметами обсуждения следующих двух глав. </p>     <br><br>
<center><div align="center"><a href="index.php.html">Оглавление</a></div></center>




<br>
<script type="text/javascript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="https://www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script><br>

<noindex>
<div align="center">
<center>

<!-- SAPE RTB DIV 600x340 -->
<div id="SRTB_507029"></div>
<!-- SAPE RTB END -->

</center>
</div>
</noindex>

</td>
<td width="240" valign="top">

<br>

<div id="menu3">
<ul>
<li><a href="../../alternativnaja_medicina/index.html"><span>Альтернативная медицина</span></a></li>
<li><a href="../../astronomija_i_kosmos/index.html"><span>Астрономия и Космос</span></a></li>
<li><a href="../../biologija/index.html"><span>Биология</span></a></li>
<li><a href="../../voennaja_istorija/index.html"><span>Военная история</span></a></li>
<li><a href="../../geologija_i_geografija/index.html"><span>Геология и география</span></a></li>
<li><a href="../../gosudarstvo_i_pravo/index.html"><span>Государство и право</span></a></li>
<li><a href="../../delovaja_literatura/index.html"><span>Деловая литература</span></a></li>
<li><a href="../../domashnie_zhivotnye/index.html"><span>Домашние животные</span></a></li>
<li><a href="../../domovodstvo/index.html"><span>Домоводство</span></a></li>
<li><a href="../../zdorove/index.html"><span>Здоровье</span></a></li>
<li><a href="../../istorija/index.html"><span>История</span></a></li>
<li><a href="../index.html"><span>Компьютеры и Интернет</span></a></li>
<li><a href="../../kulinarija/index.html"><span>Кулинария</span></a></li>
<li><a href="../../kulturologija/index.html"><span>Культурология</span></a></li>
<li><a href="../../literaturovedenie/index.html"><span>Литературоведение</span></a></li>
<li><a href="../../matematika/index.html"><span>Математика</span></a></li>
<li><a href="../../medicina/index.html"><span>Медицина</span></a></li>
<li><a href="../../nauchnaja_literatura_prochee/index.html"><span>Науч. литер. - прочее</span></a></li>
<li><a href="../../pedagogika/index.html"><span>Педагогика</span></a></li>
<li><a href="../../politika/index.html"><span>Политика</span></a></li>
<li><a href="../../psihologija/index.html"><span>Психология</span></a></li>
<li><a href="../../religiovedenie/index.html"><span>Религиоведение</span></a></li>
<li><a href="../../sad_i_ogorod/index.html"><span>Сад и огород</span></a></li>
<li><a href="../../samosovershenstvovanie/index.html"><span>Самосовершенствование</span></a></li>
<li><a href="../../sdelai_sam/index.html"><span>Сделай сам</span></a></li>
<li><a href="../../sport/index.html"><span>Спорт</span></a></li>
<li><a href="../../tehnicheskie_nauki/index.html"><span>Технические науки</span></a></li>
<li><a href="../../transport_i_aviacija/index.html"><span>Транспорт и авиация</span></a></li>
<li><a href="../../uchebniki/index.html"><span>Учебники</span></a></li>
<li><a href="../../fizika/index.html"><span>Физика</span></a></li>
<li><a href="../../filosofija/index.html"><span>Философия</span></a></li>
<li><a href="../../himija/index.html"><span>Химия</span></a></li>
<li><a href="../../hobbi_i_remesla/index.html"><span>Хобби и ремесла</span></a></li>
<li><a href="../../shpargalki/index.html"><span>Шпаргалки</span></a></li>
<li><a href="../../yezoterika/index.html"><span>Эзотерика</span></a></li>
<li><a href="../../yurisprudencija/index.html"><span>Юриспруденция</span></a></li>
<li><a href="../../jazykoznanie/index.html"><span>Языкознание</span></a></li>
</ul>
</div>

<br>
<div align="center">
<center>
<noindex>

<!-- SAPE RTB DIV 240x400 -->
<div id="SRTB_507028"></div>
<!-- SAPE RTB END -->

</noindex>
</center>
</div>

</td>
</tr>
<tr>
<td colspan="3" align="center">


<hr>
<a href="../../index.html"><span>Главная</span></a> | 
<a rel="sidebar" href="p7.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a> | 
<a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a> | 
<a href="p7.php.html#" onClick="scroll(0,0); return false" title="наверх">Наверх</a>
</td>
</tr>
<tr>
<td colspan="3" valign="top" align="left">
<br>

 



</td>
</tr>
</table>

<noindex>
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter21717787 = new Ya.Metrika({id:21717787,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="http://mc.yandex.ru/watch/21717787" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

</noindex>
</center>
</div></body>
</html>