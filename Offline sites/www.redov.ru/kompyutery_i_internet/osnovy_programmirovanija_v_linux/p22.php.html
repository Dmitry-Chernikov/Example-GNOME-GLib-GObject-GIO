<html>
<head>
<meta http-equiv="Content-Language" content="ru">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<link href="../../0img/style.css" rel="stylesheet" type="text/css" />
<link rel="SHORTCUT ICON" href="http://www.redov.ru/0img/favicon.ico" type="image/x-icon"> 
<title>Глава 18 Стандарты Linux / Основы программирования в Linux</title>
</head>
<body>
<div align="center">
<center>
<table border="0" cellpadding="0" cellspacing="0" width="1260">
<tr>
<td colspan="3" valign="top" align="left" height="100">
<table border="0" cellpadding="0" cellspacing="0" width="1260" height="100">
<tr>
<td valign="middle" align="center" width="350">
<a href="../../index.html"><img src="../../0img/logo.jpg" width="350" height="100" title="Онлайн библиотека redov.ru"/></a>
</td>
<td valign="middle" align="center" width="910">

<noindex>

<!-- SAPE RTB JS -->
<script
    async="async"
    src="http://cdn-rtb.sape.ru/rtb-b/js/393/2/106393.js"
    type="text/javascript">
</script>
<!-- SAPE RTB END -->

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507025"></div>
<!-- SAPE RTB END -->

</noindex>

</td>
</tr>
</table>
</td>
</tr>
<tr>
<td colspan="3" valign="middle" align="left">

<div id="menu">
<ul>
		<li><a href="../../index.html"><span>Главная</span></a></li>
		<li><a rel="sidebar" href="p22.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a></li>
		<li><a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a></li>
		<li><a href="p22.php.html#" onClick="scroll(0,9999999); return false"><span>Вниз</span></a></li>
</ul>
</div>


</td>
</tr>
<tr>
<td width="240" valign="top" align="center">

<br>
<noindex>
<!-- SAPE RTB DIV 160x600 -->
<div id="SRTB_733378"></div>
<!-- SAPE RTB END -->
</noindex>



</td>
<td valign="top" align="left" style="padding-left: 5; padding-right: 5" width="780">
<br>
<noindex>
<div align="center">

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507027"></div>
<!-- SAPE RTB END -->

</div>
</noindex>
<br>



<li><a href="p22.php.html#metkadoc2">     Язык программирования С     </a></li>
<li><a href="p22.php.html#metkadoc3">      Краткий урок истории      </a></li>
<li><a href="p22.php.html#metkadoc4">      Коллекция компиляторов GNU      </a></li>
<li><a href="p22.php.html#metkadoc5">      Опции gcc      </a></li>
<li><a href="p22.php.html#metkadoc6">     Интерфейсы и Linux Standards Base     </a></li>
<li><a href="p22.php.html#metkadoc7">      Стандартные библиотеки LSB      </a></li>
<li><a href="p22.php.html#metkadoc8">      Применение стандарта LSB к библиотекам      </a></li>
<li><a href="p22.php.html#metkadoc9">      Инициализация системы LSB      </a></li>
<li><a href="p22.php.html#metkadoc10">     Стандарт устройства файловой системы     </a></li>
<li><a href="p22.php.html#metkadoc11">     Что еще почитать о стандартах?     </a></li>
<li><a href="p22.php.html#metkadoc12">     Резюме     </a></li>
<a name="metkadoc1"><h1>Глава 18</p>    <p>Стандарты Linux</h1></a>       <p>ОС Linux появилась сначала только как ядро системы. К сожалению, ядро само по себе не очень полезно; программам нужна регистрация, управление файлами, компиляция новых программ и т.д. Для того чтобы сделать систему полезной, в рамках проекта GNU были добавлены разные средства. Они представляли собой клоны похожих программ, имевшихся в UNIX и UNIX-подобных системах того времени. Превращение системы Linux в подобие UNIX-системы установило первые стандарты для Linux, предоставляя программистам на языке С знакомую рабочую среду.</p>    <p>Разные разработчики ОС UNIX (а позднее Linux) вставляли собственные расширения в команды и утилиты, которые включали в состав системы, и структура используемых ими файловых систем тоже слегка отличалась. Все это затрудняло создание приложений, способных выполняться в разных системах. Более того, программист не мог даже полагаться на то, что функциональные возможности системы были реализованы одинаково, или файлы конфигурации хранились в одном и том же месте.</p>    <p>Стало ясно, что для сохранения подобия UNIX-систем нужна стандартизация, и такая работа сейчас ведется.</p>    <p>Со временем не только стандарты двигались вперед, но и ОС Linux с впечатляющей скоростью совершенствовалась сообществом, поддержанным коммерческими организациями, такими как Red Hat и Canonical, и даже разработчиками не-Linux, например, корпорацией IBM. По мере развития Linux наряду с разработкой коллекции компиляторов gcc не только следила за соответствующими стандартами, но и определяла новые стандарты, если существующие оказывались неэффективными. В действительности по мере того, как ОС Linux и связанные с нею программные средства и утилиты становились все более популярными, разработчики UNIX-систем начали вносить изменения в свои продукты, чтобы сделать их более совместимыми с ОС Linux.</p>    <p>В этой заключительной главе мы собираемся рассмотреть стандарты Linux, обращая внимание нате области, о которых вы должны знать для того, чтобы не только писать приложения, работающие в ваших системах Linux после их обновления, но и создавать программный код, который можно будет переносить в другие дистрибутивы Linux, а может быть и в UNIX-подобные системы, обеспечивая, таким образом, совместное использование ваших программ.</p>    <p>В особенности мы коснемся следующих тем:</p>    <p>&#9633; стандарт языка программирования С;</p>    <p>&#9633; стандарты UNIX, в особенности POSIX, разрабатываемые IEEE, и стандарт Single UNIX Specification, разработанный Open Group;</p>    <p>&#9633; разработка Free Standards Group, в особенности Linux Standard Base, в которой определен макет стандартной файловой системы Linux.</p>    <p>Хорошей отправной точкой для знакомства со стандартами, относящимися к ОС Linux, служит стандарт Linux Standard Base (LSB), который можно найти на Web- сайте Linux Foundation по адресу<b> http://www.linux-foundation.org/</b>.</p>    <p>Мы не собираемся подробно рассматривать содержание стандартов, многие из которых по объему сравнимы с данной книгой. Мы хотим обратить ваше внимание на ключевые стандарты, о которых следует знать, дать вам краткие исторические сведения о том, как развивались эти стандарты, и помочь решить, какие из них могут оказаться полезными при написании ваших собственных программ.</p>          <a name="metkadoc2"><h1>Язык программирования С</h1></a>         <p>Язык программирования С — de facto язык программирования ОС Linux, поэтому, для того чтобы писать программы на С для Linux, необходимо немного разобраться в его истоках, узнать, как менялся язык, и, что особенно важно понять, как проверяются программы на соответствие стандартам.</p>             <a name="metkadoc3"><h1>Краткий урок истории</h1></a>     <p>Тем, кто не слишком любит историю, не стоит беспокоиться: эта книга о программировании, а не об истории, поэтому обзор будет очень кратким.</p>     <p>Язык программирования С появился в начале 1970-х годов и был основан отчасти на более раннем языке программирования BCPL и расширениях для языка В. Деннис Ритчи (Dennis М. Ritchie) написал руководство пользователя для языка в 1974 г., и примерно в это же время С был использован как язык программирования для переработки ядра UNIX на компьютерах PDP-11. В 1978 г. Брайан Керниган (Brian W. Kernighan) и Ритчи написали классическое руководство по, языку "The С Programming Language" ("Язык программирования С").</p>     <p>Очень быстро язык приобрел большую популярность, обусловленную, несомненно, отчасти быстрым ростом популярности UNlX-систем, но также и своими возможностями и понятным синтаксисом. Синтаксис языка С продолжал развиваться согласованно, но по мере того, как он изменялся все больше и больше по сравнению с первоначальным описанием, приведенным в книге, становилось ясно, что нужен стандарт, который соответствовал бы современному употреблению и был более строгим.</p>     <p>В 1983 г. ANSI (American National Standards Institute, Американский институт стандартов) основал комитет стандартов X3J11 для разработки четкого и строгого определения языка. Попутно обе организации вносили в язык незначительные изменения, в особенности придавая ему долгожданную способность объявлять типы параметров, но в основном комитет просто вносил ясность и логическое обоснование существующего определения того, что составляло общеупотребительный вариант языка. Окончательный стандарт был опубликован в 1989 г. как ANSI Standard Programming Language С, X3.159-1989 или более кратко C89, иногда именуемый C90. (Этот последний превратился в стандарт ISO/IEC 9899:1990, Programming Languages — С. Оба стандарта формально идентичны.)</p>     <p>Как и для большинства стандартов, публикация не закончила работу комитета, который продолжал устранять некоторые неточности, обнаруженные в спецификации, и в 1993 г. начал работу над новой версией стандарта, названного C9X. Комитет также публиковал, незначительные корректировки и обновления существующего стандарта в 1994-1996 гг.</p>     <p>Новая версия стандарта была сделана в 1990 гг. и официально стала стандартом С99; она была принята ISO как стандарт ISO/IEC 9899:1999. До сих пор существует работающий комитет J11, который следит за стандартизацией языка С и его библиотек, но теперь он работает под управлением группы International Committee for Information Technology Standards (Международный комитет по промышленным стандартам в сфере информационных технологий). Дополнительную информацию о работе по стандартизации С см. на Web-сайте <b>http://j11.incits.org/</b>.</p>             <a name="metkadoc4"><h1>Коллекция компиляторов GNU</h1></a>     <p>После разработки редактора Emacs (да, мы любим Emacs) следующим важным достижением проекта GNU, как упоминалось в<i> главе 1,</i> стал полностью бесплатный компилятор С, gcc, первая официальная версия которого была выпущена в 1987 г.</p>     <p>Первоначально имя gcc расшифровывалось как GNU С Compiler (компилятор С проекта GNU), но, поскольку базовая рабочая среда компилятора теперь поддерживает много других языков программирования, таких как С++, Objective-C, FORTRAN, Java и Ada, а также библиотеки для этих языков, определение было заменено на более подходящее GNU Compiler Collection (коллекция компиляторов GNU).</p>     <p>gcc всегда был и похоже останется стандартным компилятором для Linux и С или С++, основного языка для написания программ в ОС Linux. Исходную страницу gcc можно найти по адресу <b>http://gcc.gnu.org/</b>.</p>     <p>Компилятор С GNU всегда хорошо отслеживал развитие стандарта языка С, хотя он допускает некоторые расширения языка, и, безусловно, существуют незначительные задержки, как почти у всех компиляторов, между выходом стандарта и появлением версий компиляторов, точно следующих этой спецификации. Порой происходит обратное, и gcc предвосхищает слабые изменения стандарта, что тоже может совершенно сбивать с толку. У gcc есть ряд опций командной строки и других, позволяющих задать версию стандарта языка С, которой должен соответствовать компилятор, а также ряд других опций для управления степенью придирчивости или строгости компилятора.</p>             <a name="metkadoc5"><h1>Опции gcc</h1></a>     <p>Теперь, когда вы узнали кое-что о стандарте С, давайте рассмотрим опции, которые предлагает компилятор gcc для гарантии соответствия стандарту языка С, на котором вы пишете. Есть три способа, позволяющих убедиться в том, что ваш код на С соответствует стандартам и не содержит изъянов: опции, контролирующие версию стандарта, соответствия с которой вы намерены добиваться, определения, контролирующие заголовочные файлы, и опции предупреждений, инициирующие более строгую проверку программного кода.</p>     <p>У gcc есть огромный набор опций, и здесь мы рассмотрим лишь те из них, которые считаем наиболее важными. Полный перечень опций можно найти на страницах интерактивного справочного руководства gcc. Мы также кратко обсудим некоторые опции директивы <blockquote>#define</blockquote>, которые можно применять; обычно их следует задавать в вашем исходном программном коде перед любыми строками с директивой <blockquote>#include</blockquote> или определять в командной строке gcc. Вас может удивить такое обилие опций для выбора применяемого стандарта вместо простого флага, заставляющего использовать современный стандарт. Причина заключается в том, что много более старых программ полагается на исторически сложившееся поведение компилятора и потребовалась бы значительная работа по их обновлению в соответствии с последними стандартами. Редко, если вообще когда-нибудь, вам захочется обновить компилятор для того, чтобы он начал прерывать работающий программный код. По мере изменения стандартов важно иметь возможность работать вопреки определенному стандарту, даже если это и не самая свежая версия стандарта.</p>     <p>Даже если вы пишете маленькую программу для личного применения, когда соответствие стандартам, возможно, не так уж важно, часто имеет смысл включить дополнительные предупреждения gcc, чтобы заставить компилятор искать ошибки в вашем коде еще до выполнения программы. Это всегда эффективнее, чем выполнять по шагам код в отладчике и недоумевать по поводу возможного места возникшей проблемы. У компилятора есть много опций, которые не ограничиваются простой проверкой на соответствие стандартам, таких, как способность обнаруживать код, который удовлетворяет стандарту, но, возможно, имеет сомнительную семантику. Например, в программе может быть такой порядок выполнения, который позволяет обращаться к переменной до ее инициализации.</p>     <p>Если вам нужно написать программу для коллективного использования, при выбранных степени соответствия стандарту и типах предупреждений компилятора, которые вы считаете достаточными, очень важно затратить немного больше усилий и добиться компиляции вашего кода без каких-либо предупреждений вообще. Если вы допустите наличие некоторых предупреждений и привыкните их игнорировать, в один прекрасный день может появиться более серьезное предупреждение, которое вы рискуете пропустить. Если ваш программный код всегда компилируется без предупреждающих сообщений, новое предупреждение неизбежно привлечет ваше внимание. Компиляция программного кода без предупреждений — полезная привычка, которую стоит взять на вооружение.</p>     <b>Опции компилятора для отслеживания стандартов</b>     <p>Приведенные далее опции передаются gcc в командной строке; мы перечисляем здесь только самые важные из них.</p>     <p>&#9633; <blockquote>-ansi</blockquote> — это самая важная опция, касающаяся стандартов и заставляющая компилятор действовать в соответствии со стандартом языка ISO C90. Она отключает некоторые расширения gcc, не совместимые со стандартом, отключает в программах на языке С комментарии в стиле С++ (<blockquote>//</blockquote>) и включает обработку триграфов (трехсимвольных последовательностей) ANSI. Кроме того, она содержит макрос __<blockquote>STRICT_ANSI__</blockquote>, который отключает некоторые расширения в заголовочных файлах, не совместимые со стандартом. В последующих версиях компилятора принятый стандарт может измениться.</p>     <p>&#9633; <blockquote>-std=</blockquote> — эта опция обеспечивает более тонкий контроль используемого стандарта, предоставляя параметр, точно задающий требуемый стандарт. Далее приведены основные возможные варианты:</p>     <p> • <blockquote>с89</blockquote> — поддерживать стандарт C89;</p>     <p> • <blockquote>iso9899:1999</blockquote>— поддерживать последнюю версию стандарта ISO, C90;</p>     <p> • <blockquote>gnu89</blockquote> — поддерживать стандарт C89, но разрешить некоторые расширения GNU и некоторые функциональные возможности C99. В версии 4.2 gcc этот вариант применяется по умолчанию.</p>     <b>Опции для отслеживания стандарта в директивах <i>define</i></b>     <p>Существуют константы (<blockquote>#defines</blockquote>), которые могут задаваться опциями в командной строке или виде определений в исходном тексте программы. Мы, как правило, считаем, что для них используется командная строка компилятора.</p>     <p>&#9633; <blockquote>__STRICT_ANSI__</blockquote> — заставляет применять стандарт С ISO. Определяется, когда в командной строке компилятора задана опция <blockquote>-ansi</blockquote>.</p>     <p>&#9633; <blockquote>_POSIX_C_SOURCE=2</blockquote> — активизирует функциональные возможности, определенные стандартами IEEE Std 1003.1 и 1003.2. Мы вернемся к этим стандартам чуть позже в этой главе.</p>     <p>&#9633; <blockquote>_BSD_SOURCE</blockquote> — включает функциональные возможности систем BSD. Если они конфликтуют с определениями POSIX, определения BSD обладают более высоким приоритетом.</p>     <p>&#9633; <blockquote>_GNU_SOURCE</blockquote> — допускает широкий диапазон свойств и функций, включая расширения GNU. Если эти определения конфликтуют с определениями POSIX, у последних более высокий приоритет.</p>     <b>Опции компилятора для вывода предупреждений</b>     <p>Эти опции передаются компилятору из командной строки. И снова мы перечислим лишь основные, полный список можно найти в интерактивном справочном руководстве gcc.</p>     <p>&#9633; <blockquote>-pedantic</blockquote> — эта наиболее мощная опция проверки чистоты, программного кода на языке С. Помимо включения опции проверки на соответствие стандарту С, она отключает некоторые традиционные конструкции языка С, запрещенные стандартом, и делает недопустимыми все расширения GNU по отношению к стандарту. Эту опцию следует применять, чтобы добиться максимальной переносимости вашего кода на С. Недостаток ее в том, что компилятор сильно озабочен чистотой вашего программного кода, и порой приходится поломать голову для того, чтобы разделаться с несколькими оставшимися предупреждениями.</p>     <p>&#9633; <blockquote>-Wformat</blockquote> — проверяет корректность типов аргументов функций семейства <blockquote>printf</blockquote>.</p>     <p>&#9633; <blockquote>-Wparentheses</blockquote> — проверяет наличие скобок, даже там, где они не нужны. Эта опция очень полезна для проверки того, что сложные структуры инициализированы так, как задумано.</p>     <p>&#9633; <blockquote>-Wswitch-default</blockquote> — проверяет наличие варианта <blockquote>default</blockquote> в операторах <blockquote>switch</blockquote>, что обычно считается хорошим стилем программирования.</p>     <p>&#9633; <blockquote>-Wunused</blockquote> — проверяет разнообразные случаи, например, статические функции объявленные, но не описанные, неиспользуемые параметры, отброшенные результаты.</p>     <p>&#9633; <blockquote>-Wall</blockquote> — включает большинство типов предупреждений gcc, в том числе все предыдущие опции -<blockquote>W</blockquote> (не охватывается только <blockquote>-pedantic</blockquote>). С ее помощью легко добиться чистоты программного кода.</p>     <blockquote>      <b>Примечание</b>      <p>Существует еще огромное множество дополнительных опций предупреждений, все подробности см. на Web-страницах gcc. В основном мы рекомендуем применять <blockquote>-Wall</blockquote>; это удачный компромисс между проверкой, обеспечивающей программный код высокого качества, и необходимостью вывода компилятором массы тривиальных предупреждений, которые становится трудно свести к нулю.</p>     </blockquote>              <a name="metkadoc6"><h1>Интерфейсы и Linux Standards Base</h1></a>         <p>Теперь мы собираемся подняться на уровень выше и перейти от программного кода на языке С к рассмотрению интерфейсов (системных функций), предоставляемых операционной системой. У этого уровня стандартизации есть разные составляющие: функции, предоставляемые библиотеками, и системные вызовы, реализованные операционной системой на низком уровне. И у тех, и у других есть два уровня детализации: какие интерфейсы представлены и определение того, что делает каждый интерфейс.</p>     <p>Определяющий документ в этой области для ОС Linux — Linux Standards Base (LSB, стандарты операционных систем на базе Linux), который можно найти на Web-сайтах <b>http://mvw.linuxbase.org</b> или <b>http://www.linux-foundation.org/en/LSB</b>. Уже выпущено несколько версий стандартов, и работа продолжается.</p>     <p>Список дистрибутивов, прошедших сертификацию, можно найти по адресу <b>http://www.linux-foundation.org/en/Products</b>. Сертифицированы разные версии Red Hat, SUSE и Ubuntu, но помните о том, что после выпуска дистрибутива до момента сертификации должно пройти некоторое время. На Web-сайте есть список дистрибутивов, проходящих тестирование или только нуждающихся в некоторых обновлениях для того, чтобы пройти сертификационные испытания.</p>     <p>В стандарте Linux Standards Base (что касается версии 3.1) определены три области для проверки на соответствие:</p>     <p>&#9633; ядро — основные библиотеки, утилиты и местонахождение ключевых компонентов файловой системы;</p>     <p>&#9633; С++ — библиотеки С++;</p>     <p>&#9633; рабочий стол — дополнительные файлы для установок рабочего стола, в основном разные графические библиотеки.</p>     <p>В спецификации нас интересует больше всего ядро.</p>     <p>Стандарт LSB охватывает ряд областей в собственной документации, но для определений конкретных интерфейсов также приводит ссылки на внешние стандарты. В стандарте описаны следующие области:</p>     <p>&#9633; форматы объектных файлов для двоичной совместимости;</p>     <p>&#9633; стандарты динамического связывания;</p>     <p>&#9633; стандартные библиотеки, как базовые, так и библиотеки X Window System;</p>     <p>&#9633; командная оболочка и другие программы режима командной строки;</p>     <p>&#9633; среда исполнения, включая пользователей и группы;</p>     <p>&#9633; инициализация системы и уровни запуска (run levels).</p>     <p>В этой главе мы обсудим только стандартные библиотеки, пользователей и инициализацию системы.</p>             <a name="metkadoc7"><h1>Стандартные библиотеки LSB</h1></a>     <p>Документация Linux Standard Base определяет двумя способами интерфейсы, которые должны присутствовать. Для некоторых функций, в основном реализованных библиотекой С проекта GNU или склонных быть стандартами только для Linux, определяются и интерфейс, и его поведение. Для других интерфейсов, в особенности с UNIX-подобной основой, стандарт просто констатирует, что такой интерфейс должен присутствовать и должен вести себя, как определено другим стандартом, обычно Common Application Environment (CAE, общая прикладная среда) или еще чаще Single UNIX Specification (единая спецификация UNIX), который есть на Web-сайте Open Group <b>http://www.opengroup.org</b>. Некоторые части можно найти (в настоящее время требуется регистрация) по адресу <b>http://www.unix.org/online.html</b>.</p>     <p>К сожалению, у лежащих в основе стандартов для ОС Linux и UNIX-стандартов довольно запутанное прошлое, и существует слишком широкий выбор, хотя в основном разные версии почти совместимы.</p>     <b>Краткий урок истории</b>     <p>ОС UNIX родилась в конце 1960 гг. в подразделении Bell Laboratories компании AT&amp;T, когда Кен Томпсон (Ken Thompson) и Деннис Ритчи (Dennis Ritchie) написали операционную систему, первоначально предназначенную только для личного пользования, которую назвали Unics. Каким-то образом имя изменилось на UNIX. AT&amp;T разрешила университетам брать исходный программный код для собственных разработок, и система UNIX быстро стала невероятно популярной благодаря очень четкой логической структуре и мощным идеям. Наличие исходного программного кода должно было стать существенным стимулом, т. к. позволяло программистам вносить изменения и экспериментировать.</p>     <p>Операционная система BSD была вариантом, который появился благодаря работе, проделанной в Университете Калифорнии в Беркли, и уделившей много внимания организации и поддержке сети.</p>     <p>Когда компания AT&amp;T начала превращать UNIX в коммерческую систему, что происходило главным образом в середине 1980 гг., она называла выпуски системы UNIX System, и самым популярным был UNIX System V.</p>     <p>Появилось много и других вариантов, слишком много, чтобы перечислять их здесь, все они имели небольшие отличия от базовых стандартов и некоторые дополнения, поскольку компании пытались повысить стоимость продукта, создавая собственные расширения.</p>     <p>Все по-настоящему усложнилось, когда AT&amp;T продала UNIX-бизнес компании Novell, которая в 1994 г. решила его завершить, и владение правами и торговыми марками стало чем-то неопределенным, послужившим предметом разных судебных разбирательств.</p>     <p>В 1988 г. IEEE (Institute of Electrical and Electronic Engineers, Институт инженеров по электротехнике и радиоэлектронике, <b>http://www.ieee.org</b>) выпустил первый набор стандартов: POSIX или IEEE 1003 — стандартов, которые задумывались как определяющая спецификация переносимого интерфейса компьютерных операционных систем. Несмотря на то, что это хороший и четко определенный стандарт, POSIX — также во многом лишь спецификация ядра с очень ограниченной областью применения.</p>     <p>В 1994 г. X/Open Company, не участвующая в поставках организация, выпустила более полный набор спецификаций, X/Open CAE или Common Applications Environment (общая прикладная среда), представляющий собой расширенный вариант стандартов IEEE POSIX и формально идентичный им во многих областях. Компания X/Open позже объединилась с OSF (Free Software Foundation, фонд свободного программного обеспечения) для учреждения Open Group; ее исходная Web-страница находится по адресу <b>http://www.opengroup.org/</b>. Стандарт CAE был исправлен и выпущен в 2002 г. как Single UNIX Specification, Version 3 (единая спецификация UNIX, версия 3), разработанный Open Group.</p>     <p>Именно на эту спецификацию чаще всего ссылается база стандартов Linux.</p>     <blockquote>      <b>Примечание</b>      <p>Следует отметить, что "Linux" — это торговая марка, принадлежащая Линусу Торвальдсу (Linus Torvalds). См. <b>http://www.linuxmark.org/</b>.</p>     </blockquote>             <a name="metkadoc8"><h1>Применение стандарта LSB к библиотекам</h1></a>     <p>Довольно об истории создания стандартов. Что означает для людей, пишущих программы на языке С (или С++), требование их переносимости?</p>     <p>Во-первых, вы должны убедиться в том, что используемая вами библиотечная функция приведена в стандарте LSB. Если ее там нет, возможно, вы делаете что-то, что нелегко будет перенести в другую систему, и вам следует поискать стандартный способ реализации той задачи, которую вы пытаетесь решить. Быть может, стоит попробовать команду Linux apropos, которая ищет страницы интерактивного справочного руководства для соответствующих ссылок.</p>     <p>Во-вторых, что труднее, следует убедиться в том, что поведение используемой вами функции включено в стандарт, и вы не полагаетесь на поведение, не описанное в стандарте. Возможно, для этого вам придется обратиться к стандарту Single UNIX Specification, если применение функции не определено в стандарте LSB. Очень хороший способ проверки неопределенного или потенциально ошибочного поведения — обращение к интерактивному руководству Linux. На многих его страницах есть раздел "BUGS" ("Ошибки"), представляющий собой неоценимый источник информации о том, где в ОС Linux конкретный вызов не в полной мере реализует стандарты или где существуют дефекты и нелепости в поведении.</p>     <b>Пользователи и группы LSB</b>     <p>Этот раздел стандарта точен, краток и понятен. Далее перечислены некоторые требования стандарта.</p>     <p>&#9633; Спецификация требует для получения подробных сведений о пользователе никогда не читать напрямую такие файлы, как /etc/passwd, а всегда применять вызовы стандартной библиотеки, например <blockquote>getpwent</blockquote>, или стандартные утилиты, например <blockquote>passwd</blockquote>.</p>     <p>&#9633; Стандарт требует наличия пользователя с именем root в группе root, который является администратором системы с полным набором привилегий или прав доступа. Мы также находим в стандарте ряд необязательных имен пользователей и групп, которые никогда не следует применять в стандартных приложениях; они предназначены для использования дистрибутивами.</p>     <p>&#9633; В стандарте также указано, что ID, меньшие 100, — системные учетные записи, диапазон 100-499 занимают системные администраторы и постустановочные сценарии, и, наконец, ID с номерами 500 и большими предназначены для учетных записей обычных пользователей.</p>     <p>Как правило, большинство программистов Linux должно знать о требованиях стандартов, касающихся пользователей.</p>             <a name="metkadoc9"><h1>Инициализация системы LSB</h1></a>     <p>Область инициализации или запуска системы всегда, по крайней мере для нас, была источником беспокойства из-за трудноуловимых различий дистрибутивов.</p>     <p>Система Linux унаследовала от UNIX-подобных операционных систем идею уровней запуска или выполнения, определяющих сервисы, постоянно выполняющиеся в системе. В табл. 18.1 приведены стандартные определения для ОС Linux.</p>     <br>     <p><i><b>Таблица 18.1</b></i></p>     <table>      <tr>       <th valign="top">Уровень запуска</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top">0</td>       <td valign="top">Halt. Применяется как логическое состояние, к которому следует перейти при остановке системы</td>      </tr>      <tr>       <td valign="top">1</td>       <td valign="top">Однопользовательский режим. Каталоги, отличающиеся от / (корневой), могут не монтироваться, и сетевой поддержки не будет. Обычно применяется для обслуживания системы</td>      </tr>      <tr>       <td valign="top">2</td>       <td valign="top">Многопользовательский режим, но без сетевой поддержки</td>      </tr>      <tr>       <td valign="top">3</td>       <td valign="top">Обычный многопользовательский режим с сетевой поддержкой, использующий экран регистрации в текстовом режиме</td>      </tr>      <tr>       <td valign="top">4</td>       <td valign="top">Зарезервирован</td>      </tr>      <tr>       <td valign="top">5</td>       <td valign="top">Обычный многопользовательский режим с сетевой поддержкой, использующий экран регистрации в графическом режиме</td>      </tr>      <tr>       <td valign="top">6</td>       <td valign="top">Псевдоуровень, применяемый для перезагрузки</td>      </tr>     </table>     <p>Стандарт LSB приводит эти уровни, но не требует их обязательного использования, хотя они и очень распространены.</p>     <p>Сопровождает уровни запуска набор сценариев инициализации, применяемых для запуска, останова и повторного запуска сервисов. В прошлом они хранились в разных местах в каталоге /etc, часто в /etc/init.d или в /etc/rc.d/init.d. Подобное разнообразие часто было причиной путаницы, поскольку пользователи, менявшие дистрибутивы, не могли найти сценарии инициализации в привычных местах, и установка программ завершалась аварийно при попытке выполнить сценарий инициализации из неверного каталога.</p>     <p>Стандарт LSB 3.1 определяет каталог /etc/init.d, как место хранения сценариев инициализации, но при этом разрешает этому каталогу быть ссылкой на другое место в системе.</p>     <p>У каждого сценария в каталоге /etc/init.d есть имя, связанное с предоставляемым им сервисом. Поскольку все сервисы ОС Linux должны совместно использовать одно пространство имен, важно, чтобы эти имена были уникальны. Например, жизнь будет несладкой, если сервисы MySQL и PostgreSQL решат назвать свои сценарии "database". Для устранения такого конфликта существует еще один набор стандартов. Это стандарт Assigned Names And Numbers Authority (LANANА, орган назначения имен и номеров в Linux), который можно найти на Web-сайте <b>http://www.lanana.org/</b>. К счастью, вам понадобится знать очень немногое об этом стандарте, за исключением того, что в нем хранится список зарегистрированных имен сценариев и пакетов, облегчающий жизнь пользователям систем Linux.</p>     <br>     <p>Сценарий инициализации должен принимать параметр, управляющий его действиями. В стандарте определены параметры, перечисленные в табл. 18.2.</p>     <br>     <p><i><b>Таблица 18.2</b></i></p>     <table>      <tr>       <th valign="top">Параметр</th>       <th valign="top">Значение</th>      </tr>      <tr>       <td valign="top"><blockquote>start</blockquote></td>       <td valign="top">Запускает (или перезапускает) сервис</td>      </tr>      <tr>       <td valign="top"><blockquote>stop</blockquote></td>       <td valign="top">Останавливает сервис</td>      </tr>      <tr>       <td valign="top"><blockquote>restart</blockquote></td>       <td valign="top">Перезапускает сервис; обычно реализован как простой останов сервиса, за которым следует запуск этого сервиса</td>      </tr>      <tr>       <td valign="top"><blockquote>reload</blockquote></td>       <td valign="top">Переустанавливает сервис, повторно загружая параметры без реальной остановки сервиса. Этот вариант поддерживают не все сервисы, поэтому данный параметр может быть недоступен в некоторых сценариях, а если доступен, то не имеет эффекта</td>      </tr>      <tr>       <td valign="top"><blockquote>force-reload</blockquote></td>       <td valign="top">Пытается вызвать переустановку, если сервис ее поддерживает, если нет — выполняет перезапуск сервиса</td>      </tr>      <tr>       <td valign="top"><blockquote>status</blockquote></td>       <td valign="top">Выводит текстовое сообщение о состоянии сервиса и возвращает код состояния, который может применяться для определения состояния сервиса</td>      </tr>     </table>     <p>Все команды возвращают 0 в случае успешного завершения или код ошибки, обозначающий причину аварийного исхода. В случае параметра <blockquote>status</blockquote> возвращается 0, если сервис выполняется; все остальные коды означают, что сервис не запущен по какой-то причине.</p>              <a name="metkadoc10"><h1>Стандарт устройства файловой системы</h1></a>    <p>Последний стандарт, который мы собираемся, рассмотреть в этой главе, — Filesystem Hierarchy Standard (FHS, стандарт иерархии файловой системы). Его можно найти по адресу <b>http://www.pathname.com/fhs/</b>.</p>    <p>Назначение этого стандарта — определение типовых мест хранения в файловой системе Linux для того, чтобы как разработчики, так и пользователи могли делать обоснованные предположения относительно местонахождения тех или иных файлов. Многолетние пользователи UNIX-подобных операционных систем долгое время жаловались на трудноуловимые различия в схемах расположения файловых систем, и стандарт FHS предлагает дистрибутивам Linux способ избежать повторения этого прерывистого пути.</p>    <p>Схема размещения файлов в системе Linux на первый взгляд может показаться полупроизвольной структурой файлов и каталогов, основанной на исторически сложившихся представлениях. Отчасти это правда, но с годами схема размещения небезосновательно эволюционировала в иерархию, которую мы видим сегодня. Основная ее идея — разделение файлов и каталогов на три следующие группы:</p>    <p>&#9633; файлы и каталоги, уникальные для конкретной работающей системы Linux, такие как сценарии запуска и файлы конфигурации;</p>    <p>&#9633; файлы и каталоги, предназначенные только для чтения и, возможно, совместно используемые несколькими работающими системами Linux, например исполняемые файлы приложений;</p>    <p>&#9633; каталоги, предназначенные для чтения/записи, но, возможно, совместно используемые работающими системами Linux или другими операционными системами, например исходные каталоги пользователей.</p>    <p>В этой книге нас не слишком интересует совместное использование файлов разными версиями Linux, хотя, в случае сети из машин с ОС Linux, это отличный способ убедиться в том, что существует только одна копия каталогов ключевых программ, и совместно использовать ее на разных машинах в сети. Это особенно полезно для бездисковых рабочих станций.</p>    <p>В стандарте FHS определена структура верхнего уровня, имеющая ряд обязательных подкаталогов и несколько необязательных каталогов; основные из них приведены в табл. 18.3.</p>    <br>    <p><i><b>Таблица 18.3</b></i></p>    <table>     <tr>      <th valign="top">Каталог</th>      <th valign="top">Обязательный?</th>      <th valign="top">Назначение</th>     </tr>     <tr>      <td valign="top">/bin</td>      <td valign="top">Да</td>      <td valign="top">Важные системные двоичные файлы</td>     </tr>     <tr>      <td valign="top">/boot</td>      <td valign="top">Да</td>      <td valign="top">Файлы, необходимые для загрузки системы</td>     </tr>     <tr>      <td valign="top">/dev</td>      <td valign="top">Да</td>      <td valign="top">Устройства</td>     </tr>     <tr>      <td valign="top">/etc</td>      <td valign="top">Да</td>      <td valign="top">Системные файлы конфигурации</td>     </tr>     <tr>      <td valign="top">/home</td>      <td valign="top">Нет</td>      <td valign="top">Каталоги для файлов пользователей</td>     </tr>     <tr>      <td valign="top">/lib</td>      <td valign="top">Да</td>      <td valign="top">Стандартные библиотеки</td>     </tr>     <tr>      <td valign="top">/media</td>      <td valign="top">Да</td>      <td valign="top">Место для съемных монтируемых носителей с отдельными подкаталогами для каждого типа носителей, поддерживаемого системой</td>     </tr>     <tr>      <td valign="top">/mnt</td>      <td valign="top">Да</td>      <td valign="top">Удобная точка для временно монтируемых устройств, таких как CD-ROM и накопители флэш-памяти</td>     </tr>     <tr>      <td valign="top">/opt</td>      <td valign="top">Да</td>      <td valign="top">Дополнительное прикладное программное обеспечение</td>     </tr>     <tr>      <td valign="top">/root</td>      <td valign="top">Нет</td>      <td valign="top">Файлы пользователя root</td>     </tr>     <tr>      <td valign="top">/sbin</td>      <td valign="top">Да</td>      <td valign="top">Важные системные двоичные файлы, которые необходимы в процессе запуска системы</td>     </tr>     <tr>      <td valign="top">/srv</td>      <td valign="top">Да</td>      <td valign="top">Предназначенные только для чтения данные для сервисов, предоставляемых данной системой</td>     </tr>     <tr>      <td valign="top">/tmp</td>      <td valign="top">Да</td>      <td valign="top">Временные файлы</td>     </tr>     <tr>      <td valign="top">/usr</td>      <td valign="top">Да</td>      <td valign="top">Вспомогательная иерархия. Традиционно файлы пользователей также хранятся здесь, но в наши дни это считается дурным стилем и обычным пользователем не следует предоставлять право записи в этот каталог</td>     </tr>     <tr>      <td valign="top">/var</td>      <td valign="top">Да</td>      <td valign="top">Переменные данные, например файлы регистрации</td>     </tr>    </table>    <p>Кроме того, могут существовать и другие каталоги, начинающиеся с lib, хотя это и не распространено. Как правило, вы также будете встречать каталог /lost+found (для восстановления файловой системы с помощью программы fsck) и каталог /proc, представляющий собой псевдофайловую систему, обеспечивающую отображение работающей системы. Текущая версия стандарта FHS усиленно поддерживает файловую систему /proc, но ее присутствие не обязательно. Подробности, касающиеся системы /proc, в основном выходят за рамки тем, обсуждаемых в этой книге, хотя мы и привели ее краткий обзор в<i> главе 3.</i></p>    <p>Далее познакомимся вкратце с назначением каждого из стандартных подкаталогов корневого каталога /.</p>    <p>&#9633; /bin — содержит двоичные файлы, которые могут использовать как пользователь root, так и обычные пользователи и которые важны для функционирования в однопользовательском режиме, когда некоторые другие структуры каталогов могут не монтироваться. Например, обычно здесь можно найти команды ядра <blockquote>cat</blockquote> и <blockquote>ls</blockquote>, как и команду <blockquote>sh</blockquote>.</p>    <p>&#9633; /boot — применяется для файлов, требуемых во время загрузки системы Linux. Часто этот каталог очень мал, менее 10 Мбайт, и часто это отдельный раздел. Это очень удобно в системах на базе PC, в которых есть ограничения BIOS для активного раздела, который должен находиться в первых 2 или 4 Гбайт диска. Имея этот каталог в виде отдельного раздела, вы будете обладать большей гибкостью при размещении остальных разделов диска.</p>    <p>&#9633; /dev — содержит специальные файлы устройств, отображаемые на аппаратные устройства. Например, /dev/had будет отображаться на первый диск IDE.</p>    <p>&#9633; /etc — содержит файлы конфигурации. По традиции здесь можно найти и некоторые двоичные файлы, но это уже не соответствует действительности для большинства современных систем Linux. Самый известный файл в каталоге /etc — это, вероятно, файл passwd, содержащий информацию о пользователях. Другие полезные файлы — fstab с перечнем вариантов монтирования; hosts со списком отображений IP-адресов в имена компьютеров, и каталог httpd, содержащий конфигурацию для сервера Apache.</p>    <p>&#9633; /home — каталог для файлов пользователей. Обычно у каждого пользователя в этом каталоге есть один каталог с именем, совпадающим с регистрационным именем пользователя, и он будет регистрационным каталогом по умолчанию. Например, после регистрации пользователь rick почти наверняка обнаружит себя в каталоге /home/rick.</p>    <p>&#9633; /lib — содержит важные совместно используемые библиотеки и модули ядра, особенно те, которые потребуются во время загрузки системы в однопользовательском режиме.</p>    <p>&#9633; /media — задуман как каталог верхнего уровня для хранения каталогов-точек монтирования для съемных носителей. Цель — иметь возможность удалять ненужные каталоги верхнего уровня, такие как /cdrom и /floppy.</p>    <p>&#9633; /mnt — просто удобное место для монтирования на время дополнительных файловых систем. По сложившейся традиции некоторые дистрибутивы добавляли в  каталог /mnt подкаталоги для разных устройств, таких как /cdrom и /floppy, но в настоящее время предпочтительнее размещать их в каталоге /media, вернув /mnt его первоначальное назначение — единое место размещения верхнего уровня для временного монтирования (single top-level temporary mount location).</p>    <p>&#9633; /opt — каталог для поставщиков программного обеспечения, используемый для вставки программных приложений, добавляемых к базовому дистрибутиву. Дистрибутивы не должны пользоваться им для хранения программного обеспечения, которое поставляется как часть стандартного дистрибутива, его следует оставлять для использования сторонними поставщиками. Обычно поставщики будут создавать подкаталоги со своими именами и в них последующие каталоги, такие как /bin и /lib, для файлов, относящихся к их приложению.</p>    <blockquote>     <b>Примечание</b>     <p>По принятому соглашению многие пакеты Open Source Linux используют каталог /usr/local для инсталляции.</p>    </blockquote>    <p>&#9633; /root — это каталог для файлов, используемых пользователем root. Он не входит в ветвь каталога /home в дереве каталогов, поскольку может не монтироваться в однопользовательском режиме.</p>    <p>&#9633; /sbin — применяется для команд, обычно используемых только системным администратором и требующихся во время загрузки системы в однопользовательском режиме. Здесь обитают команды <blockquote>fsck</blockquote>, <blockquote>halt</blockquote> и <blockquote>swapon</blockquote>.</p>    <p>&#9633; /srv — предназначен для размещения данных местного назначения в режиме "только для чтения", но в настоящее время он широко не используется.</p>    <p>&#9633; /tmp — применяется для временных файлов. Обычно, но не всегда, очищается при загрузке системы.</p>    <p>&#9633; /usr — довольно сложная вспомогательная файловая система, как правило, содержащая все команды системного типа и библиотеки, не требуемые при загрузке системы или в однопользовательском режиме. В каталоге много подкаталогов, таких как /bin, /lib, /X11R6 и /local.</p>    <blockquote>     <b>Примечание</b>     <p>Когда только появились системы UNIX и Linux, каталог /usr также имел подкаталоги для регистраций, буферизации электронной почты и т.п. Теперь все эти подкаталоги удалены из каталога usr и помещены в каталог var. Преимущество такого подхода в том, что теперь /usr может быть монтируемой файловой системой, ее могут совместно использовать другие системы в сети, и он стал менее чувствителен к повреждениям системы, которые останавливают ее неуправляемым образом, например из-за отказа электропитания.</p>    </blockquote>    <p>&#9633; /var — содержит часто меняющиеся данные, такие как файлы буферов печати, файлы регистраций приложений и каталоги буферизации электронной почты.</p>          <a name="metkadoc11"><h1>Что еще почитать о стандартах?</h1></a>    <p>Конечно, существует гораздо больше вещей, которые нужно знать, если вы хотите написать и применять полностью переносимое приложение Linux.</p>    <p>Вы хотите локализовать ваше приложение, так чтобы оно работало на разных языках и с разными региональными установками? Даже если вы ограничены английским языком, остается выбор валюты, разделителей в числах, форматов дат и множество других требующих внимания параметров. Как вы догадываетесь, есть специалисты, работающие над такими стандартами; увидеть их работу можно на Web-сайте <b>http://www.openi18n.org/.</b></p>    <p>С другой стороны, нужно учитывать, какие параметры, версии библиотек и т.д. установлены в применяемой системе. К счастью, эта проблема становится менее острой во многом благодаря работе по стандартизации, о которой мы рассказали в этой главе, хотя и все еще может оказаться серьезной проблемой. Есть пара средств в проекте GNU, которые оказывают существенную помощь в решении данной проблемы: <blockquote>autoconf</blockquote> и <blockquote>automake</blockquote>. Хотя вы, возможно, не применяли их явно, почти наверняка вы видели пользу от их применения, когда устанавливали программное обеспечение из исходного программного кода и набирали <blockquote>./configure; make</blockquote>.</p>    <p>Польза от применения этих средств выходит за рамки обсуждаемых в данной книге тем, но вы можете найти дополнительную информацию о них на Web-страницах проекта GNU <b>http://www.gnu.org/software/autoconf/</b> и <b>http://www.gnu.org/software/automake</b>.</p>          <a name="metkadoc12"><h1>Резюме</h1></a>    <p>В этой заключительной главе мы кратко рассмотрели некоторые из множества стандартов, помогающих сделать более легким программирование на платформе Linux и обеспечивающих соответствие разных дистрибутивов Linux некоторым базовым стандартам. Соответствие стандартам облегчает жизнь всем нам, программистам и пользователям, и мы настоятельно рекомендуем вам применять стандарты и поощрять их использование другими людьми.</p>     <br><br>
<center><div align="center"><a href="index.php.html">Оглавление</a></div></center>




<br>
<script type="text/javascript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="https://www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script><br>

<noindex>
<div align="center">
<center>

<!-- SAPE RTB DIV 600x340 -->
<div id="SRTB_507029"></div>
<!-- SAPE RTB END -->

</center>
</div>
</noindex>

</td>
<td width="240" valign="top">

<br>

<div id="menu3">
<ul>
<li><a href="../../alternativnaja_medicina/index.html"><span>Альтернативная медицина</span></a></li>
<li><a href="../../astronomija_i_kosmos/index.html"><span>Астрономия и Космос</span></a></li>
<li><a href="../../biologija/index.html"><span>Биология</span></a></li>
<li><a href="../../voennaja_istorija/index.html"><span>Военная история</span></a></li>
<li><a href="../../geologija_i_geografija/index.html"><span>Геология и география</span></a></li>
<li><a href="../../gosudarstvo_i_pravo/index.html"><span>Государство и право</span></a></li>
<li><a href="../../delovaja_literatura/index.html"><span>Деловая литература</span></a></li>
<li><a href="../../domashnie_zhivotnye/index.html"><span>Домашние животные</span></a></li>
<li><a href="../../domovodstvo/index.html"><span>Домоводство</span></a></li>
<li><a href="../../zdorove/index.html"><span>Здоровье</span></a></li>
<li><a href="../../istorija/index.html"><span>История</span></a></li>
<li><a href="../index.html"><span>Компьютеры и Интернет</span></a></li>
<li><a href="../../kulinarija/index.html"><span>Кулинария</span></a></li>
<li><a href="../../kulturologija/index.html"><span>Культурология</span></a></li>
<li><a href="../../literaturovedenie/index.html"><span>Литературоведение</span></a></li>
<li><a href="../../matematika/index.html"><span>Математика</span></a></li>
<li><a href="../../medicina/index.html"><span>Медицина</span></a></li>
<li><a href="../../nauchnaja_literatura_prochee/index.html"><span>Науч. литер. - прочее</span></a></li>
<li><a href="../../pedagogika/index.html"><span>Педагогика</span></a></li>
<li><a href="../../politika/index.html"><span>Политика</span></a></li>
<li><a href="../../psihologija/index.html"><span>Психология</span></a></li>
<li><a href="../../religiovedenie/index.html"><span>Религиоведение</span></a></li>
<li><a href="../../sad_i_ogorod/index.html"><span>Сад и огород</span></a></li>
<li><a href="../../samosovershenstvovanie/index.html"><span>Самосовершенствование</span></a></li>
<li><a href="../../sdelai_sam/index.html"><span>Сделай сам</span></a></li>
<li><a href="../../sport/index.html"><span>Спорт</span></a></li>
<li><a href="../../tehnicheskie_nauki/index.html"><span>Технические науки</span></a></li>
<li><a href="../../transport_i_aviacija/index.html"><span>Транспорт и авиация</span></a></li>
<li><a href="../../uchebniki/index.html"><span>Учебники</span></a></li>
<li><a href="../../fizika/index.html"><span>Физика</span></a></li>
<li><a href="../../filosofija/index.html"><span>Философия</span></a></li>
<li><a href="../../himija/index.html"><span>Химия</span></a></li>
<li><a href="../../hobbi_i_remesla/index.html"><span>Хобби и ремесла</span></a></li>
<li><a href="../../shpargalki/index.html"><span>Шпаргалки</span></a></li>
<li><a href="../../yezoterika/index.html"><span>Эзотерика</span></a></li>
<li><a href="../../yurisprudencija/index.html"><span>Юриспруденция</span></a></li>
<li><a href="../../jazykoznanie/index.html"><span>Языкознание</span></a></li>
</ul>
</div>

<br>
<div align="center">
<center>
<noindex>

<!-- SAPE RTB DIV 240x400 -->
<div id="SRTB_507028"></div>
<!-- SAPE RTB END -->

</noindex>
</center>
</div>

</td>
</tr>
<tr>
<td colspan="3" align="center">


<hr>
<a href="../../index.html"><span>Главная</span></a> | 
<a rel="sidebar" href="p22.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a> | 
<a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a> | 
<a href="p22.php.html#" onClick="scroll(0,0); return false" title="наверх">Наверх</a>
</td>
</tr>
<tr>
<td colspan="3" valign="top" align="left">
<br>

 



</td>
</tr>
</table>

<noindex>
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter21717787 = new Ya.Metrika({id:21717787,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="http://mc.yandex.ru/watch/21717787" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

</noindex>
</center>
</div></body>
</html>