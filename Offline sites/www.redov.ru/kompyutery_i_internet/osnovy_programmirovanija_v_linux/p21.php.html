<html>
<head>
<meta http-equiv="Content-Language" content="ru">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<link href="../../0img/style.css" rel="stylesheet" type="text/css" />
<link rel="SHORTCUT ICON" href="http://www.redov.ru/0img/favicon.ico" type="image/x-icon"> 
<title>Глава 17 Программирование в KDE с помощью Qt / Основы программирования в Linux</title>
</head>
<body>
<div align="center">
<center>
<table border="0" cellpadding="0" cellspacing="0" width="1260">
<tr>
<td colspan="3" valign="top" align="left" height="100">
<table border="0" cellpadding="0" cellspacing="0" width="1260" height="100">
<tr>
<td valign="middle" align="center" width="350">
<a href="../../index.html"><img src="../../0img/logo.jpg" width="350" height="100" title="Онлайн библиотека redov.ru"/></a>
</td>
<td valign="middle" align="center" width="910">

<noindex>

<!-- SAPE RTB JS -->
<script
    async="async"
    src="http://cdn-rtb.sape.ru/rtb-b/js/393/2/106393.js"
    type="text/javascript">
</script>
<!-- SAPE RTB END -->

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507025"></div>
<!-- SAPE RTB END -->

</noindex>

</td>
</tr>
</table>
</td>
</tr>
<tr>
<td colspan="3" valign="middle" align="left">

<div id="menu">
<ul>
		<li><a href="../../index.html"><span>Главная</span></a></li>
		<li><a rel="sidebar" href="p21.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a></li>
		<li><a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a></li>
		<li><a href="p21.php.html#" onClick="scroll(0,9999999); return false"><span>Вниз</span></a></li>
</ul>
</div>


</td>
</tr>
<tr>
<td width="240" valign="top" align="center">

<br>
<noindex>
<!-- SAPE RTB DIV 160x600 -->
<div id="SRTB_733378"></div>
<!-- SAPE RTB END -->
</noindex>



</td>
<td valign="top" align="left" style="padding-left: 5; padding-right: 5" width="780">
<br>
<noindex>
<div align="center">

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507027"></div>
<!-- SAPE RTB END -->

</div>
</noindex>
<br>



<li><a href="p21.php.html#metkadoc2">     Введение в KDE и Qt     </a></li>
<li><a href="p21.php.html#metkadoc3">     Установка Qt     </a></li>
<li><a href="p21.php.html#metkadoc4">     Сигналы и слоты     </a></li>
<li><a href="p21.php.html#metkadoc5">     Виджеты Qt     </a></li>
<li><a href="p21.php.html#metkadoc6">      <i>QLineEdit</i>      </a></li>
<li><a href="p21.php.html#metkadoc7">      Кнопки Qt      </a></li>
<li><a href="p21.php.html#metkadoc8">      <i>QComboBox</i>      </a></li>
<li><a href="p21.php.html#metkadoc9">      <i>QListView</i>      </a></li>
<li><a href="p21.php.html#metkadoc10">     Диалоговые окна     </a></li>
<li><a href="p21.php.html#metkadoc11">      <i>QDialog</i>      </a></li>
<li><a href="p21.php.html#metkadoc12">      <i>QMessageBox</i>      </a></li>
<li><a href="p21.php.html#metkadoc13">      <i>QInputDialog</i>      </a></li>
<li><a href="p21.php.html#metkadoc14">      Применение <i>qmake</i> для упрощения написания make-файлов      </a></li>
<li><a href="p21.php.html#metkadoc15">     Создание меню и панелей инструментов с помощью KDE     </a></li>
<li><a href="p21.php.html#metkadoc16">     Приложение для работы с базой данных компакт-дисков с использованием KDE/Qt     </a></li>
<li><a href="p21.php.html#metkadoc17">      <i>MainWindow</i>      </a></li>
<li><a href="p21.php.html#metkadoc18">      <i>AddCdDialog</i>      </a></li>
<li><a href="p21.php.html#metkadoc19">      <i>LogonDialog</i>      </a></li>
<li><a href="p21.php.html#metkadoc20">      main.cpp      </a></li>
<li><a href="p21.php.html#metkadoc21">     Резюме      </a></li>
<a name="metkadoc1"><h1>Глава 17</p>    <p>Программирование в KDE с помощью Qt</h1></a>       <p>В<i> главе 16</i> вы познакомились с библиотеками GUI графической среды GNOME/GTK+, предназначенными для создания пользовательского графического интерфейса под управлением системы X. Эти библиотеки — лишь половина истории, другой крупный игрок на поле GUI в системе Linux — графическая среда KDE/Qt, и в этой главе мы рассмотрим ее библиотеки и увидим, как они развиваются в условиях конкуренции.</p>    <p>Комплект инструментальных средств Qt написан на языке С++, стандартный язык для написания приложений Qt/KDE, поэтому в данной главе вам придется отойти от обычного языка С и испачкать свои руки С++. Возможно, вы воспользуетесь этой возможностью и освежите свои знания языка С++, вспомнив прежде всего принципы наследования и инкапсуляции, метод переопределения и виртуальные функции.</p>    <p>В этой главе мы обсудим следующие темы:</p>    <p>&#9633; знакомство с комплектом инструментов Qt;</p>    <p>&#9633; установка Qt;</p>    <p>&#9633; практическое применение;</p>    <p>&#9633; механизм "сигнал/слот";</p>    <p>&#9633; виджеты Qt;</p>    <p>&#9633; диалоговые окна;</p>    <p>&#9633; создание меню и панелей инструментов с помощью KDE;</p>    <p>&#9633; разработка средствами KDE/Qt вашего приложения для работы с базой данных компакт-дисков.</p>          <a name="metkadoc2"><h1>Введение в KDE и Qt</h1></a>    <p>KDE (Desktop Environment, K-среда рабочего стола) — графическая среда рабочего стола с открытым программным кодом, основанная на библиотеке графического пользовательского интерфейса Qt. В состав KDE входит множество приложений и утилит, включая полный офисный пакет, Web-обозреватель и даже полнофункциональную IDE (интегрированная среда разработки) для программирования приложений KDE/Qt (KDevelop обсуждалась в<i> главе 9</i>). Профессиональное признание функциональных возможностей развитых приложений KDE пришло, когда компания Apple выбрала Web-обозреватель KDE в качестве ядра основного Web-обозревателя для системы Mac OS X, названного Safari и известного как очень быстрый обозреватель.</p>    <p>Главная страница проекта KDE находится по адресу <b>http://www.kde.org</b>, на ней вы найдете подробные сведения, файлы загрузки среды KDE и ее приложения, документацию, сможете присоединиться к списку адресатов файлов рассылок и получить другую информацию для разработчиков.</p>    <blockquote>     <b>Примечание</b>     <p>Во время написания книги последней версией KDE была версия 3.5.7, и поскольку эта версия включена в современные дистрибутивы Linux, мы считаем, что у вас установлена версия KDE 3.5 или более свежая. Продолжается работа над крупным обновлением — KDE 4.0. Вы можете также загрузить из Интернета предварительные версии KDE 4.0. Точно так же самая свежая версия Qt — 4.3, но в большинстве дистрибутивов Linux установлена версия Qt 3, например версия 3.3, как стандартная версия Qt. В этой главе обсуждается Qt 3.3, потому что она встречается чаще других.</p>    </blockquote>    <p>С точки зрения программиста, KDE предлагает десятки виджетов KDE, обычно унаследованных от их аналогов Qt, но улучшенных и облегчающих использование. Виджеты KDE обеспечивают более тесную связь с рабочим столом KDE, чем сам по себе комплект инструментов Qt; у вас появляется, например, возможность управления сеансами<b>.</b></p>    <p>Qt — тщательно продуманный межплатформный комплект инструментов GUI, написанный на языке С++. Это детище норвежской компании Trolltech, разрабатывающей, продающей и осуществляющей техническую поддержку Qt и сопутствующего программного обеспечения для промышленного рынка. Trolltech во всеуслышание рекламирует межплатформные возможности комплекта Qt, которые бесспорно впечатляющи, Qt поддерживается в ОС Linux и модификациях UNIX, Windows, Mac OS X и даже на встроенных платформах, явно отдающих предпочтение комплекту Qt по сравнению с его конкурентами.</p>    <blockquote>     <b>Примечание</b>     <p>Специализированная версия Qt выполняется на сотовых телефонах. Еще одна версия работает на PDA (Personal Digital Assistant, электронный секретарь) Sharp Zaurus и аналогичных платформах. Qt Jambi представляет собой версию комплекта инструментов для языка Java.</p>    </blockquote>    <p>В настоящее время компания Trolltech продает коммерческие версии Qt случайным пользователям и любителям по завышенным ценам. К счастью, Trolltech понимает важность бесплатной версии для сообщества, распространяющего свободное программное обеспечение, и предлагает свободно распространяемую версию Qt Open Source Edition для. ОС Linux, Windows и Mac OS X. В ответ Trolltech получает большую базу пользовательских установок, обширное сообщество программистов и высокое реноме своего продукта.</p>    <p>Qt Open Source Edition распространяется на условиях лицензии GPL, т.е. вы можете программировать, используя библиотеки-Qt, и распространять бесплатно собственное программное обеспечение, отвечающее требованиям лицензии GPL. Насколько мы можем судить, у свободно распространяемой версии есть два основных отличия от коммерческих версий: отсутствие технической поддержки и запрет на применение программного обеспечения Qt в коммерческих приложениях. Вся необходимая вам документация по API есть на Web-сайте Trolltech по адресу <b>http://www.trolltech.com</b>.</p>          <a name="metkadoc3"><h1>Установка Qt</h1></a>    <p>Если у вас нет особых причин для компиляции из исходного программного кода, самый простой путь — найти для вашего дистрибутива двоичный пакет или пакет RPM. Дистрибутив Fedora Linux 7 поставляется с пакетом qt-3.3.8-4.i386.rpm, который можно установить с помощью следующей команды.</p>    <p><blockquote>$ <b>rpm -Uvh qt-3.3.3-4.i386.rpm</b></blockquote></p>    <p>Комплект Qt и библиотеки программирования KDE можно также установить с помощью приложения <b>Package Manager</b> (Диспетчер пакетов) — рис. 17.1.</p>    <img src="image066.jpg"/>    <p><b>Рис. 17.1</b> </p>    <br>    <p>Если вы хотите загрузить из Интернета исходный программный код и сформировать Qt самостоятельно, самый свежий программный код можно получить с FTP-сайта Trolltech по адресу <b>ftp://ftp.trolltech.com/qt/source/.</b> Пакет исходного программного кода приходит с подробнейшими инструкциями, касающимися компиляции и установки Qt и хранящимися в файле INSTALL, упакованном программой tar.</p>    <p><blockquote>$ <b>сd /usr/local</b></blockquote></p>    <p><blockquote>$ <b>tar -xvzf qt-x11-free-3.3.8.tar.gz</b></blockquote></p>    <p><blockquote>$ <b>./configure</b></blockquote></p>    <p><blockquote>$ <b>make</b></blockquote></p>    <p>Также следует добавить в файл /etc/ld.so.conf следующую строку:</p>    <p><blockquote>/usr/lib/qt-3.3/lib</blockquote></p>    <p>Вставить ее можно в любое место файла.</p>    <blockquote>     <b>Примечание</b>     <p>В системах Linux Fedora и Red Hat эту строку нужно сохранить в файле /etc/ld.so.conf.d/qt-i386.conf. Если вы устанавливали Qt, как показано на рис. 17.1, этот этап уже будет пройден.</p>    </blockquote>    <p>Если комплект Qt установлен корректно, переменная окружения <blockquote>QTDIR</blockquote> будет содержать каталог установки. Проверить это можно следующим образом:</p>    <p><blockquote>$ <b>echo $QTDIR</b></blockquote></p>    <p><blockquote>/usr/lib/qt-3.3</blockquote></p>    <p>Убедитесь также в том, что каталог lib добавлен в файл /etc/ld.so.conf. Затем выполните как суперпользователь следующую команду:</p>    <p><blockquote># <b>ldconfig</b></blockquote></p>    <p>Испытайте простейшую программу с применением Qt и убедитесь в том, что ваша установка функционирует должным образом (упражнение 17.1).</p>    <b>Упражнение 17.1. Окно <blockquote>QMain</blockquote></b>    <p>Введите (или скопируйте и вставьте программный код из загруженного файла) приведенную далее программу и назовите ее qt1.cpp:</p>    <p><blockquote>#include &lt;qapplication.h&gt;</blockquote></p>    <p><blockquote>#include &lt;qmainwindow.h&gt;</blockquote></p>    <br>    <p><blockquote>int main(int argc, char **argv) {</blockquote></p>    <p><blockquote> QApplication app(argc, argv);</blockquote></p>    <p><blockquote> QMainWindow* window = new QMainWindow();</blockquote></p>    <p><blockquote> app.setMainWidget(window);</blockquote></p>    <p><blockquote> window-&gt;show();</blockquote></p>    <p><blockquote> return app.exec();</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>При компиляции вам необходимо указать Qt-каталоги include и lib:</p>    <p><blockquote>$ <b>g++ -о qt1 qt1.cpp -I$QTDIR/include -L$QTDIR/lib -lqui</b></blockquote></p>    <blockquote>     <b>Примечание</b>     <p>На некоторых платформах в конце строки указывается библиотека <blockquote>-lqt</blockquote>. В версии Qt 3.3, тем не менее, используйте <blockquote>-lqui</blockquote>.</p>    </blockquote>    <p>Выполнив приложение, вы должны получить окно Qt (рис. 17.2).</p>    <p><blockquote>$ <b>./qtl</b></blockquote></p>    <img src="image067.jpg"/>    <p><b>Рис. 17.2</b> </p>    <br>    <p><b>Как это работает</b></p>    <p>В отличие от GTK+ здесь нет вмещающего в себя все заголовочного файла qt.h, поэтому вы должны явно включать заголовочные файлы всех используемых объектов.</p>    <p>Первый объект, с которым вы встречаетесь, — <blockquote>QApplication</blockquote>. Это главный объект Qt, который вы должны сформировать, передав ему в самом начале аргументы командной строки. У каждого приложения Qt должен быть один и только один объект типа <blockquote>QApplication</blockquote>, который вы должны создать перед тем, как делать что-то еще. <blockquote>QApplication</blockquote> имеет дело с внутренними встроенными операциями Qt, такими как обработка событий, размещение строк и управление внешним представлением.</p>    <p>Вы будете применять два метода <blockquote>QApplication</blockquote>: <blockquote>setMainWidget</blockquote>, который создает главный виджет вашего приложения, и exec, который запускает выполнение цикла отслеживания событий. Метод exec не возвращает управление до тех пор, пока либо не будет вызван метод <blockquote>QApplication::quit()</blockquote>, либо не будет закрыт главный виджет.</p>    <p><blockquote>QMainWindow</blockquote> — базовый виджет окна в Qt, который поддерживает меню, панель инструментов и строку состояния. Он будет играть важную роль в этой главе, по мере того, как вы научитесь расширять его возможности и вставлять в него виджеты, формирующие интерфейс.</p>    <p>Далее мы обсудим механизм программирования, управляемого событиями, и вы вставите в приложение виджет <blockquote>PushButton</blockquote>.</p>          <a name="metkadoc4"><h1>Сигналы и слоты</h1></a>    <p>Как вы видели в<i> главе 16</i>, сигналы и их обработка — главные механизмы, используемые приложениями GUI для реагирования на ввод пользователя, и ключевые функции библиотек GUI. Механизм обработки сигналов комплекта Qt состоит из сигналов и слотов или приемников, называемых сигналами и функциями обратного вызова в комплекте инструментов GTK+ или событиями и обработчиками событий в языке программирования Java.</p>    <blockquote>     <b>Примечание</b>     <p>Имейте в виду, что сигналы Qt отличаются от сигналов UNIX, обсуждавшихся в<i> главе 11.</i></p>    </blockquote>    <p>Вот как устроено программирование, управляемое событиями: графический интерфейс пользователя состоит из меню, панелей инструментов, кнопок, полей ввода и множества других элементов GUI, называемых виджетами. Когда пользователь взаимодействует с виджетом, например, активизирует пункт меню или вводит какой-то текст в поле ввода, виджет порождает именованный сигнал, такой как <blockquote>clicked</blockquote>, <blockquote>text_changed</blockquote> или <blockquote>key_pressed</blockquote>. Как правило, вам захочется сделать что-то в ответ на действие пользователя, например, сохранить документ или выйти из приложения, и вы выполняете это, связав сигнал с функцией обратного вызова или слотом на языке Qt.</p>    <p>Применение сигналов и слотов довольно специфично — Qt определяет два новых соответствующим образом описанных псевдоключевых слова, <blockquote>signals</blockquote> и <blockquote>slots</blockquote> для обозначения в вашем программном коде классов сигналов и слотов. Это замечательно с точки зрения читаемости и сопровождения программного кода, но вы вынуждены пропускать свой код через отдельный этап препроцессорной обработки для поиска и замены этих псевдоключевых слов дополнительным кодом на языке С++.</p>    <blockquote>     <b>Примечание</b>     <p>Таким образом, программный код с использованием Qt — не настоящий программный код на С++. Порой это становится проблемой для некоторых разработчиков. См. документацию Qt на Web-сайте <b>http://doc.trolltech.com/</b>, чтобы понять причину применения этих новых псевдоключевых слов в С++. Более того, применение сигналов и слотов не так уж отличается от Microsoft Foundation Classes (MFC, библиотека базовых классов Microsoft) в ОС Windows, в которой также используется модифицированное определение языка С++.</p>    </blockquote>    <p>На способы применения сигналов и слотов в Qt есть несколько ограничений, но они не слишком существенные:</p>    <p>&#9633; сигналы и слоты должны быть функциями-методами класса-потомка <blockquote>QObject</blockquote>;</p>    <p>&#9633; при использовании множественного наследования <blockquote>QObject</blockquote> должен быть первым в списке класса;</p>    <p>&#9633; оператор <blockquote>Q_OBJECT</blockquote> должен появляться первым в объявлении класса;</p>    <p>&#9633; сигналы нельзя применять в шаблонах;</p>    <p>&#9633; указатели на функцию не могут использоваться как аргументы в сигналах и слотах;</p>    <p>&#9633; сигналы и слоты не могут переопределяться или обновляться до статуса <blockquote>public</blockquote> (общедоступный).</p>    <p>Поскольку вы должны писать ваши сигналы и слоты как потомков объекта <blockquote>QObject</blockquote>, логично создавать ваш интерфейс, расширяя и настраивая виджет, начиная с <blockquote>QWidget</blockquote>, базового виджета Qt, потомка виджета <blockquote>QObject</blockquote>. В комплекте Qt вы почти всегда будете создавать интерфейсы, расширяя такие виджеты, как <blockquote>QMainWindow</blockquote>.</p>    <p>Типичное определение класса в файле MyWindow.h для вашего GUI будет напоминать приведенное далее:</p>    <p><blockquote>class MyWindow : public QMainWindow {</blockquote></p>    <p><blockquote> Q_OBJECT</blockquote></p>    <p><blockquote>public:</blockquote></p>    <p><blockquote> MyWindow();</blockquote></p>    <p><blockquote> virtual ~MyWindow();</blockquote></p>    <p><blockquote>signals:</blockquote></p>    <p><blockquote> void aSignal();</blockquote></p>    <p><blockquote>private slots:</blockquote></p>    <p><blockquote> void doSomething();</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Ваш класс — наследник объекта <blockquote>QMainWindow</blockquote>, который определяет функциональные возможности главного окна в приложении. Аналогичным образом при создании диалогового окна вы определите подкласс <blockquote>QDialog</blockquote>. Первым указан оператор <blockquote>Q_OBJECT</blockquote>, действующий как метка для препроцессора, за которым следуют обычные объявления конструктора и деструктора. Далее даны определения сигнала и слота.</p>    <p>У вас есть один сигнал и один слот, оба без параметров. Для порождения сигнала <blockquote>aSignal()</blockquote> вам нужно всего лишь в любом месте программы вызвать функцию <blockquote>emit</blockquote>:</p>    <p><blockquote>emit aSignal();</blockquote></p>    <p>Это означает, что все остальное обрабатывается Qt. Вам даже не потребуется реализация <blockquote>aSignal()</blockquote>.</p>    <p>Для применения слотов их нужно связать с сигналом. Делается это соответствующим образом с помощью названного статического метода <blockquote>connect</blockquote> класса <blockquote>QObject</blockquote>:</p>    <p><blockquote><b>bool QObject::connect(const QObject * sender, const char* signal,</b></blockquote></p>    <p><blockquote><b> const QObject * receiver, const char * member);</b></blockquote></p>    <p>Просто передайте объект, владеющий сигналом (отправитель), функцию сигнала, объект, владеющий слотом (приемником), и в завершение укажите имя слота.</p>    <p>В примере MyWindow, если бы вы захотели связать сигнал <blockquote>clicked</blockquote> виджета <blockquote>QPushButton</blockquote> с вашим слотом <blockquote>doSomething</blockquote>, вы бы написали:</p>    <p><blockquote>connect(button, SIGNAL(clicked()), this, SLOT(doSomething()));</blockquote></p>    <p>Учтите, что необходимо применять макросы <blockquote>SIGNAL</blockquote> и <blockquote>SLOT</blockquote> для выделения функций сигналов и слотов. Как и в комплекте GTK+, вы можете связать ряд слотов с заданным сигналом и также связать слот с любым количеством сигналов с помощью множественных вызовов функции connect. Если она завершается аварийно, то возвращает <blockquote>FALSE</blockquote>.</p>    <p>Остается реализовать ваш слот в виде обычной функции-метода:</p>    <p><blockquote>void MyWindow::doSomething() {</blockquote></p>    <p><blockquote> // Код слота</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Выполните упражнение 17.2.</p>    <b>Упражнение 17.2. Сигналы и слоты</b>    <p>Теперь, зная основы использования сигналов и слотов, применим их в примере. Усовершенствуйте <blockquote>QMainWindow</blockquote>, вставьте в него кнопку и свяжите сигнал кнопки <blockquote>clicked</blockquote> со слотом.</p>    <p>1. Введите следующее объявление класса и назовите файл ButtonWindow.h:</p>    <p><blockquote>#include &lt;qmainwindow.h&gt;</blockquote></p>    <br>    <p><blockquote>class ButtonWindow : public QMainWindow {</blockquote></p>    <p><blockquote> Q_OBJECT</blockquote></p>    <p><blockquote>public:</blockquote></p>    <p><blockquote> ButtonWindow(QWidget *parent = 0, const char *name = 0);</blockquote></p>    <p><blockquote> virtual ~ButtonWindow();</blockquote></p>    <p><blockquote>private slots:</blockquote></p>    <p><blockquote> void Clicked();</blockquote></p>    <p><blockquote>};</blockquote></p>    <p>2. Далее следует реализация класса в файле ButtonWindow.cpp:</p>    <p><blockquote>#include "ButtonWindow.moc"</blockquote></p>    <p><blockquote>#include &lt;qpushbutton.h&gt;</blockquote></p>    <p><blockquote>#include &lt;qapplication.h&gt;</blockquote></p>    <p><blockquote>#include &lt;iostream&gt;</blockquote></p>    <p>3. В конструкторе вы задаете заголовок окна, создаете кнопку и связываете сигнал нажатия кнопки с вашим слотом. <blockquote>setCaption</blockquote> — метод объектов типа <blockquote>QMainWindow</blockquote>, который, что неудивительно, задает заголовок окна:</p>    <p><blockquote>ButtonWindow::ButtonWindow(QWidget *parent, const char* name) : QMainWindow(parent, name) {</blockquote></p>    <p><blockquote> this-&gt;setCaption("This is the window Title");</blockquote></p>    <p><blockquote> QPushButton *button = new QPushButton("Click Me!", this, "Button1");</blockquote></p>    <p><blockquote> button-&gt;setGeometry(50, 30, 70, 20);</blockquote></p>    <p><blockquote> connect(button, SIGNAL(clicked()), this, SLOT(Clicked()));</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>4. Qt автоматически удаляет виджеты, поэтому ваш деструктор пуст:</p>    <p><blockquote>ButtonWindow::~ButtonWindow() {}</blockquote></p>    <p>5. Затем реализация слота:</p>    <p><blockquote>void ButtonWindow::Clicked(void) {</blockquote></p>    <p><blockquote> std::cout &lt;&lt; "clicked!\n";</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>6. И наконец, в функции <blockquote>main</blockquote> вы просто создаете экземпляр типа <blockquote>ButtonWindow</blockquote>, делаете его главным окном вашего приложения и отображаете окно на экране:</p>    <p><blockquote>int main(int argc, char **argv) {</blockquote></p>    <p><blockquote> QApplication app(argc, argv);</blockquote></p>    <p><blockquote> ButtonWindow *window = new ButtonWindow();</blockquote></p>    <p><blockquote> app.setMainWidget(window);</blockquote></p>    <p><blockquote> window-&gt;show();</blockquote></p>    <p><blockquote> return app.exec();</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>7. Прежде чем вы сможете откомпилировать данный пример, необходимо запустить препроцессор для заголовочного файла. Программа этого препроцессора называется Meta Object Compiler (moc, компилятор метаобъекта) и должна быть включена в пакет комплекта Qt. Выполните <blockquote>moc</blockquote> для файла ButtonWindow.h, сохранив результат в файле ButtonWindow.moc:</p>    <p><blockquote>$ <b>moc ButtonWindow.h -о ButtonWindow.moc</b></blockquote></p>    <p>Теперь можно компилировать как обычно, скомпоновав с результатом команды <blockquote>moc</blockquote>.</p>    <p><blockquote>$ <b>g++ -о button ButtonWindow.срр -I$QTDIR/include -L$QTDIR/lib -lqui</b></blockquote></p>    <p>Выполнив программу, вы получите пример, показанный на рис. 17.3.</p>    <img src="image068.jpg"/>    <p><b>Рис. 17.3</b> </p>    <br>    <p><b>Как это работает</b></p>    <p>В этом примере мы ввели новый виджет и некоторые новые функции, поэтому давайте их рассмотрим. <blockquote>QPushButton</blockquote> — виджет простой кнопки, хранящий метку и растровую графику и способный активизироваться при щелчке пользователя кнопкой мыши или при нажатии клавиш.</p>    <p>Конструктор объекта <blockquote>QPushButton</blockquote> очень прост.</p>    <p><blockquote><b>QPushButton::QPushButton(const QString &amp;text, QWidget *parent,</b></blockquote></p>    <p><blockquote><b> const char* name=0);</b></blockquote></p>    <p>Первый аргумент — текст метки кнопки, далее родительский виджет и последний аргумент — имя кнопки, обычно применяемое Qt для внутренних операций.</p>    <p>Параметр родительского виджета, общий для всех объектов, — <blockquote>QWidget</blockquote>, он управляет отображением и уничтожением и разными другими свойствами. Передача <blockquote>NULL </blockquote>в качестве родительского объекта означает виджет верхнего уровня, при этом создается содержащее его пустое окно. В примере вы передаете текущий объект <blockquote>ButtonWindow</blockquote> с помощью ключевого слова <blockquote>this</blockquote>, что приводит к вставке кнопки в основную область окна <blockquote>ButtonWindow</blockquote>.</p>    <p>Аргумент <blockquote>name</blockquote> задает имя виджета для внутреннего использования Qt. Если комплект Qt обнаружит ошибку, имя виджета будет выведено в сообщении об ошибке, поэтому неплохо выбирать подходящие имена виджетов, поскольку при отладке это сбережет массу времени.</p>    <p>Вы могли заметить, что объект <blockquote>QPushButton</blockquote> очень примитивно вставляется в окно <blockquote>ButtonWindow</blockquote>, с помощью параметра parent конструктора <blockquote>QPushButton</blockquote>, без указания положения кнопки, ее размера, рамки или чего-либо еще. Если вы хотите управлять внешним видом кнопки, что очень важно для создания привлекательного интерфейса, следует применять виджеты компоновки комплекта Qt. Давайте их сейчас рассмотрим,</p>    <p>В Qt есть целый ряд способов размещения и компоновки виджетов. Вы уже видели использование абсолютных координат с помощью вызова <blockquote>setGeometry</blockquote>, но они редко применяются, поскольку виджеты не масштабируются и не меняют размеры при изменении величины окна.</p>    <p>Предпочтительный метод компоновки виджетов — применение классов <blockquote>QLayout</blockquote> или виджетов-контейнеров, которые изменяют свои размеры соответствующим образом после задания им подсказок, касающихся отступов и расстояний между виджетами.</p>    <p>Ключевое различие между классами <blockquote>QLayout</blockquote> и упаковочными контейнерами заключается в том, что объекты класса <blockquote>QLayout</blockquote> <i>не</i> являются виджетами.</p>    <p>Классы компоновки — потомки объектов, типа <blockquote>QObject</blockquote>, а не <blockquote>QWidget</blockquote>, поэтому их применение ограничено. Например, вы не можете создать объект <blockquote>QVBoxLayout</blockquote> — основной виджет объекта <blockquote>QMainWindow</blockquote>.</p>    <p>Виджеты упаковочных контейнеров (такие, как <blockquote>QHBox</blockquote> и <blockquote>QVBox</blockquote>) напротив — потомки объекта типа <blockquote>QWidget</blockquote> следовательно, вы можете применять их как обычные виджеты. Возможно, вас удивляет, что в Qt есть и классы <blockquote>QLayout</blockquote>, и виджеты <blockquote>QBox</blockquote> с дублирующимися функциональными возможностями. На самом деле виджеты <blockquote>QBox</blockquote> существуют только для удобства и по существу служат оболочкой классов <blockquote>QLayout</blockquote> в типе <blockquote>QWidget</blockquote>. Объекты <blockquote>QLayout</blockquote> обладают возможностью автоматического изменения размеров, в то время как размеры виджетов нужно изменять вручную с помощью вызова метода <blockquote>QWidget::resizeEvent()</blockquote>.</p>    <p>Подклассы <blockquote>QLayout</blockquote>: <blockquote>QVBoxLayout</blockquote> и <blockquote>QHBoxLayout</blockquote>, — самый распространенный способ создания интерфейса, и именно их вы будете чаще всего встречать в программном коде с применением Qt.</p>    <p><blockquote>QVBoxLayout</blockquote> и <blockquote>QHBoxLayout</blockquote> — невидимые объекты-контейнеры, хранящие другие виджеты и схемы размещения с вертикальной и горизонтальной ориентациями соответственно. Вы сможете создавать сколь угодно сложные компоновки виджетов, поскольку допускается использование вложенных компоновок, например, за счет вставки как элемента горизонтальной схемы размещения внутрь вертикального упаковочного контейнера.</p>    <p>Есть три конструктора <blockquote>QVBoxLayout</blockquote>, заслуживающих внимания (у объектов <blockquote>QHBoxLayout</blockquote> идентичный API).</p>    <p><blockquote><b>QVBoxLayout::QVBoxLayout(QWidget *parent, int margin, int spacing,</b></blockquote></p>    <p><blockquote><b> const char *name)</b></blockquote></p>    <p><blockquote><b>QVBoxLayout::QVBoxLayout(QLayout *parentLayout, int spacing,</b></blockquote></p>    <p><blockquote><b> const char * name)</b></blockquote></p>    <p><blockquote><b>QVBoxLayout::QVBoxLayout(int spacing, const char *name)</b></blockquote></p>    <p>Родителем объекта <blockquote>QLayout</blockquote> может быть либо виджет, либо другой объект типа <blockquote>QLayout</blockquote>. Если не задавать родительский объект, вы сможете только вставить позже данную схему размещения в другой объект <blockquote>QLayout</blockquote> с помощью метода <blockquote>addLayout</blockquote>.</p>    <p>Параметры margin и spacing задают пустое пространство в пикселах вокруг схемы размещения <blockquote>QLayout</blockquote> и между отдельными виджетами в ней.</p>    <p>После создания вашей схемы размещения <blockquote>QLayout</blockquote> вы можете вставлять дочерние виджеты или схемы с помощью следующей пары методов:</p>    <p><blockquote><b>QBoxLayout::addWidget(QWidget *widget, int stretch = 0, int alignment = 0);</b></blockquote></p>    <p><blockquote><b>QBoxLayout::addLayout(QLayout *layout, int stretch = 0);</b></blockquote></p>    <p>Выполните упражнение 17.3.</p>    <b>Упражнение 17.3. Применение классов <blockquote>QBoxLayout</blockquote></b>    <p>В этом примере вы увидите в действии классы <blockquote>QBoxLayout</blockquote> при размещении виджетов <blockquote>QLabel</blockquote> в окне <blockquote>QMainWindow</blockquote>.</p>    <p>1. Сначала введите заголовочный файл LayoutWindow.h:</p>    <p><blockquote>#include &lt;qmainwindow.h&gt;</blockquote></p>    <br>    <p><blockquote>class LayoutWindow : public QMainWindow {</blockquote></p>    <p><blockquote> QOBJECT</blockquote></p>    <p><blockquote>public:</blockquote></p>    <p><blockquote> LayoutWindow(QWidget *parent = 0, const char *name = 0);</blockquote></p>    <p><blockquote>virtual ~LayoutWindow();</blockquote></p>    <p><blockquote>};</blockquote></p>    <p>2. Теперь введите реализацию в файл LayoutWindow.cpp:</p>    <p><blockquote>#include &lt;qapplication.h&gt;</blockquote></p>    <p><blockquote>#include &lt;qlabel.h&gt;</blockquote></p>    <p><blockquote>#include &lt;qlayout.h&gt;</blockquote></p>    <br>    <p><blockquote>#include "LayoutWindow.moc"</blockquote></p>    <p><blockquote>LayoutWindow::LayoutWindow(QWidget* parent, const char *name) :</blockquote></p>    <p><blockquote> QMainWindow(parent, name) {</blockquote></p>    <p><blockquote> this-&gt;setCaption("Layouts");</blockquote></p>    <p>3. Необходимо создать фиктивный <blockquote>QWidget</blockquote> для хранения объекта <blockquote>QHBoxLayout</blockquote>, поскольку его нельзя напрямую вставить в объект <blockquote>QMainWindow</blockquote>:</p>    <p><blockquote> QWidget *widget = new QWidget(this);</blockquote></p>    <p><blockquote> setCentralWidget(widget); </blockquote></p>    <p><blockquote> QHBoxLayout *horizontal = new QHBoxLayout(widget, 5, 10, "horizontal");</blockquote></p>    <p><blockquote> QVBoxLayout *vertical = new QVBoxLayout();</blockquote></p>    <p><blockquote> QLabel* label1 = new QLabel("Top", widget, "textLabel1");</blockquote></p>    <p><blockquote> QLabel* label2 = new QLabel("Bottom", widget, "textLabel2");</blockquote></p>    <p><blockquote> QLabel* label3 = new QLabel("Right", widget, "textLabel3");</blockquote></p>    <p><blockquote> vertical-&gt;addwidget(label1);</blockquote></p>    <p><blockquote> vertical-&gt;addwidget(label2);</blockquote></p>    <p><blockquote> horizontal-&gt;addLayout(vertical);</blockquote></p>    <p><blockquote> horizontal-&gt;addWidget(label3);</blockquote></p>    <p><blockquote> resize(150, 100);</blockquote></p>    <p><blockquote>}</blockquote></p>    <br>    <p><blockquote>LayoutWindow::~LayoutWindow() { }</blockquote></p>    <br>    <p><blockquote>int main(int argc, char **argv) {</blockquote></p>    <p><blockquote> QApplication app(argc, argv);</blockquote></p>    <p><blockquote> LayoutWindow *window = new LayoutWindow();</blockquote></p>    <p><blockquote> app.setMainWidget(window);</blockquote></p>    <p><blockquote> window-&gt;show();</blockquote></p>    <p><blockquote> return app.exec();</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Как и прежде, перед компиляцией нужно выполнить <blockquote>moc</blockquote> для заголовочного файла:</p>    <p><blockquote>$ <b>moc LayoutWindow.h -о LayoutWindow.moc</b></blockquote></p>    <p><blockquote>$ <b>g++ -о layout LayoutWindow.cpp -I$QTDIR/include -L$QTDIR/lib -lqui</b></blockquote></p>    <p>Выполнив эту программу, вы получите схему размещения ваших меток QLabel (рис. 17.4). Попробуйте изменить величину окна и посмотрите, как расширяются и сжимаются метки, заполняя все доступное пространство.</p>    <img src="image069.jpg"/>    <p><b>Рис. 17.4</b></p>    <br>    <p><b>Как это работает</b></p>    <p>Программа LayoutWindow.cpp создает два виджета упаковочных контейнеров, горизонтальный и вертикальный контейнер для размещения виджетов. Вертикальный контейнер получает две метки, описанные, соответственно, как <blockquote>Top</blockquote> и <blockquote>Bottom</blockquote>. Горизонтальный контейнер также содержит два виджета, метку, обозначенную <blockquote>Right</blockquote>, и вертикальный контейнер. Вы можете помещать компоновочные виджеты внутрь других компоновочных виджетов, как показано в данном примере.</p>    <p>Попробуйте изменить исходный текст программы в файле LayoutWindow.срр, чтобы поэкспериментировать и лучше понять, как работают компоновочные виджеты.</p>    <p>Мы рассмотрели основы применения Qt — сигналы и слоты, команду moc и средства компоновки. Теперь пора более внимательно изучить виджеты.</p>          <a name="metkadoc5"><h1>Виджеты Qt</h1></a>         <p>Для каждого случая в Qt есть виджеты, и их подробное рассмотрение займет всю оставшуюся часть книги. В этом разделе мы познакомимся с виджетами Qt общего применения, включая виджеты для ввода данных, кнопки, обычные и раскрывающиеся списки.</p>             <a name="metkadoc6"><h1><i>QLineEdit</i></h1></a>     <p><blockquote>QLineEdit</blockquote> — виджет для ввода однострочного текста. Применяйте его для ввода коротких фрагментов текста, таких как имя пользователя. В виджете <blockquote>QLineEdit</blockquote> можно ограничить длину вводимого текста с помощью маски ввода, предлагающей заполнить шаблон, или для дополнительного контроля можно применить функцию проверки допустимости, например, чтобы убедиться в том, что пользователь вводит корректные дату, номер телефона или подобные величины. У виджета <blockquote>QLineEdit</blockquote> есть функции редактирования, позволяющие выбирать части текста, вырезать и вставлять, отменять и повторять изменения, как командами пользователя, так и средствами API.</p>     <p>Далее перечислены конструкторы и наиболее полезные методы.</p>     <p><blockquote><b>#include &lt;qlineedit.h&gt;</b></blockquote></p>     <p><blockquote><b>QLineEdit::QLineEdit(QWidget *parent, const char* name = 0);</b></blockquote></p>     <p><blockquote><b>QLineEdit::QLineEdit(const QString&amp; contents, QWidget *parent,</b></blockquote></p>     <p><blockquote><b> const char *name = 0);</b></blockquote></p>     <p><blockquote><b>QLineEdit::QLineEdit(const QString&amp; contents, const QString&amp; inputMask,</b></blockquote></p>     <p><blockquote><b> QWidget *parent, const char* name = 0);</b></blockquote></p>     <p><blockquote><b>void setInputMask(const QString&amp; inputMask);</b></blockquote></p>     <p><blockquote><b>void insert(const QString&amp; newText);</b></blockquote></p>     <p><blockquote><b>bool isModified(void);</b></blockquote></p>     <p><blockquote><b>void setMaxLength(int length);</b></blockquote></p>     <p><blockquote><b>void setReadOnly(bool read);</b></blockquote></p>     <p><blockquote><b>void setText(const QString &amp;text);</b></blockquote></p>     <p><blockquote><b>QString text(void);</b></blockquote></p>     <p><blockquote><b>void setEchoMode(EchoMode mode);</b></blockquote></p>     <p>В конструкторах вы задаете как обычно родительский виджет и имя виджета с помощью параметров <blockquote>parent</blockquote> и <blockquote>name</blockquote>.</p>     <p>Интересно свойство <blockquote>EchoMode</blockquote>, определяющее способ отображения текста в виджете. Оно может принимать одно из трех значений:</p>     <p>&#9633; <blockquote>QLineEdit::Normal</blockquote> — отображать вводимые символы (по умолчанию);</p>     <p>&#9633; <blockquote>QLineEdit::Password</blockquote> — отображать звездочки на месте символов;</p>     <p>&#9633; <blockquote>QLineEdit::NoEcho</blockquote> — ничего не отображать. Задается режим отображения с помощью метода <blockquote>setEchoMode</blockquote>:</p>     <p><blockquote>lineEdit-&gt;setEchoMode(QLineEdit::Password);</blockquote></p>     <p>Усовершенствование, внесенное в версию Qt 3.2, — свойство <blockquote>inputMask</blockquote>, ограничивающее ввод в соответствии с правилом маски.</p>     <p><blockquote>inputMask</blockquote> — это строка, сформированная из символов, каждый из которых соответствует правилу, принимающему диапазон определенных символов. Если вы знакомы с регулярными выражениями, <blockquote>inputMask</blockquote> использует во многом тот же самый принцип.</p>     <p>Есть два сорта символов, формирующих <blockquote>inputMask</blockquote>: первые указывают на необходимость присутствия определенного символа, вторые при наличии символа добиваются его соответствия заданному правилу. В табл. 17.1 приведены примеры таких символов и их значения.</p>     <br>     <p><i><b>Таблица 17.1</b></i></p>     <table>      <tr>       <th valign="top">Обязательный символ</th>       <th valign="top">Символы, которые разрешены, но не обязательны</th>       <th valign="top">Значение</th>      </tr>      <tr>       <td valign="top">A</td>       <td valign="top">a</td>       <td valign="top">Символы ASCII А–Z, а–z</td>      </tr>      <tr>       <td valign="top">N</td>       <td valign="top">n</td>       <td valign="top">Символы ASCII A–Z, a–z, 0–9</td>      </tr>      <tr>       <td valign="top">X</td>       <td valign="top">x</td>       <td valign="top">Любой символ</td>      </tr>      <tr>       <td valign="top">9</td>       <td valign="top">0</td>       <td valign="top">Цифры 0–9</td>      </tr>      <tr>       <td valign="top">D</td>       <td valign="top">d</td>       <td valign="top">Цифры 1–9</td>      </tr>     </table>     <p>Наша <blockquote>inputMask</blockquote> — это строка, сформированная комбинацией этих символов и необязательно завершающаяся точкой с запятой. Существуют дополнительные специальные символы, у которых также есть значения (табл. 17.2).</p>     <br>     <p><i><b>Таблица 17.2</b></i></p>     <table>      <tr>       <th valign="top">Символ</th>       <th valign="top">Значение</th>      </tr>      <tr>       <td valign="top"><blockquote>#</blockquote></td>       <td valign="top">Разрешен, но не обязателен знак <blockquote>+/-</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>&gt;</blockquote></td>       <td valign="top">Преобразует все последующие введенные символы в символы верхнего регистра.</td>      </tr>      <tr>       <td valign="top"><blockquote>&lt;</blockquote></td>       <td valign="top">Преобразует все последующие введенные символы в символы нижнего регистра</td>      </tr>      <tr>       <td valign="top"><blockquote>!</blockquote></td>       <td valign="top">Останавливает преобразование регистра</td>      </tr>      <tr>       <td valign="top"><blockquote>\</blockquote></td>       <td valign="top">Символ управляющей последовательности для применения специальных символов в качестве разделителей</td>      </tr>     </table>     <p>Все остальные символы в <blockquote>inputMask</blockquote> действуют как разделители в поле ввода <blockquote>QLineEdit</blockquote>.</p>     <p>В табл. 17.3 приведены примеры масок ввода и соответствующий им текст для ввода.</p>     <br>     <p><i><b>Таблица 17.3</b></i></p>     <table>      <tr>       <th valign="top">Пример</th>       <th valign="top">Допустимый ввод</th>      </tr>      <tr>       <td valign="top"><blockquote>"AAAAAA-999D"</blockquote></td>       <td valign="top">Допустимо Athens-2004, но не Sydney-2000 или Atlanta-1996</td>      </tr>      <tr>       <td valign="top"><blockquote>"ААААnn-99-99;"</blockquote></td>       <td valign="top">Допустимо March-03-12, но не Мау-03-12 или September-03-12</td>      </tr>      <tr>       <td valign="top"><blockquote>"000.000.000.000"</blockquote></td>       <td valign="top">Допустим IP-адрес, например, 192.168.0.1</td>      </tr>     </table>     <p>Выполните упражнение 17.4.</p>     <b>Упражнение 17.4. Виджет <blockquote>QLineEdit</blockquote></b>     <p>Посмотрим, как действует виджет <blockquote>QLineEdit</blockquote>.</p>     <p>1. Сначала — заголовочный файл LineEdit.h:</p>     <p><blockquote>#include &lt;qmainwindow.h&gt;</blockquote></p>     <p><blockquote>#include &lt;qlineedit.h&gt;</blockquote></p>     <p><blockquote>#include &lt;qstring.h&gt;</blockquote></p>     <br>     <p><blockquote>class LineEdit : public QMainWindow {</blockquote></p>     <p><blockquote> Q_OBJECT</blockquote></p>     <p><blockquote>public:</blockquote></p>     <p><blockquote> LineEdit(QWidget *parent = 0, const char *name = 0);</blockquote></p>     <p><blockquote> QLineEdit *password_entry;</blockquote></p>     <p><blockquote>private slots:</blockquote></p>     <p><blockquote> void Clicked();</blockquote></p>     <p><blockquote>};</blockquote></p>     <p>2. LineEdit.cpp — уже знакомый файл реализации класса:</p>     <p><blockquote>#include "LineEdit.moc"</blockquote></p>     <p><blockquote>#include &lt;qpushbutton.h&gt;</blockquote></p>     <p><blockquote>#include &lt;qapplication.h&gt;</blockquote></p>     <p><blockquote>#include &lt;qlabel.h&gt;</blockquote></p>     <p><blockquote>#include &lt;qlayout.h&gt;</blockquote></p>     <p><blockquote>#include &lt;iostream&gt;</blockquote></p>     <br>     <p><blockquote>LineEdit::LineEdit(QWidget *parent, const char *name) :</blockquote></p>     <p><blockquote> QMainWindow(parent, name) {</blockquote></p>     <p><blockquote> QWidget *widget = new QWidget(this);</blockquote></p>     <p><blockquote> setCentralWidget(widget);</blockquote></p>     <p>3. Для компоновки виджетов примените <blockquote>QGridLayout</blockquote>. Задайте число строк и столбцов, величины отступов и расстояния между виджетами:</p>     <p><blockquote> QGridLayout *grid = new QGridLayout(widget, 3, 2, 10, 10, "grid");</blockquote></p>     <p><blockquote> QLineEdit *username_entry = new QLineEdit(widget, "username_entry");</blockquote></p>     <p><blockquote> password_entry = new QLineEdit(widget, "password_entry");</blockquote></p>     <p><blockquote> password_entry-&gt;setEchoMode(QLineEdit::Password);</blockquote></p>     <p><blockquote> grid-&gt;addWidget(new QLabel("Username", widget, "userlabel"), 0, 0, 0);</blockquote></p>     <p><blockquote> grid-&gt;addwidget(new QLabel("Password", widget, "passwordlabel"), 1, 0, 0);</blockquote></p>     <p><blockquote> grid-&gt;addWidget(username_entry, 0, 1, 0);</blockquote></p>     <p><blockquote> grid-&gt;addWidget(password_entry, 1, 1, 0);</blockquote></p>     <p><blockquote> QPushButton *button = new QPushButton("Ok", widget, "button");</blockquote></p>     <p><blockquote> grid-&gt;addWidget(button, 2, 1, Qt::AlignRight);</blockquote></p>     <p><blockquote> resize(350, 200);</blockquote></p>     <p><blockquote> connect(button, SIGNAL(clicked()), this, SLOT(Clicked()));</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote>void LineEdit::Clicked(void) {</blockquote></p>     <p><blockquote> std::cout &lt;&lt; password_entry-&gt;text() &lt;&lt; "\n";</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote>int main(int argc, char **argv) {</blockquote></p>     <p><blockquote> QApplication app(argc, argv);</blockquote></p>     <p><blockquote> LineEdit *window = new LineEdit();</blockquote></p>     <p><blockquote> app.setMainWidget(window);</blockquote></p>     <p><blockquote> window-&gt;show();</blockquote></p>     <p><blockquote> return app.exec();</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Выполнив эту программу, вы должны получить результат, показанный на рис. 17.5.</p>     <img src="image070.jpg"/>     <p><b>Рис. 17.5</b></p>     <br>     <p>Как это работает</p>     <p>Вы создали два виджета <blockquote>QLineEdit</blockquote>, один подготовили для ввода пароля, задав <blockquote>EchoMode</blockquote>, и заставили его выводить содержимое при щелчке мышью кнопки <blockquote>PushButton</blockquote>. Обратите внимание на виджет <blockquote>QGridLayout</blockquote>, который очень полезен для размещения виджетов в табличной сетке. Когда виджет вставляется в сетку таблицы, вы передаете номер строки и столбца, нумерация начинается с 0, нулевые номера строки и столбца у верхней левой ячейки.</p>             <a name="metkadoc7"><h1>Кнопки Qt</h1></a>     <p>Кнопки виджетов вездесущи и мало отличаются внешним видом, способом применения и API в разных комплектах инструментов. Неудивительно, что Qt предлагает стандартные кнопки <blockquote>PushButton</blockquote>, флажки <blockquote>CheckBox</blockquote> и радиокнопки (или зависимые переключатели) <blockquote>RadioButton</blockquote>.</p>     <b><i>QButton:</i> базовый класс кнопок</b>     <p>Все виджеты кнопок в комплекте Qt — потомки абстрактного класса <blockquote>QButton</blockquote>. У этого класса есть методы для опроса и переключения включенного/выключенного состояния кнопки и задания текста кнопки или ее графического представления.</p>     <p>Вам никогда не придется обрабатывать виджет типа <blockquote>QButton</blockquote> (не путайте с виджетом <blockquote>QPushButton</blockquote>!), поэтому нет смысла приводить конструкторы. Далее перечислено несколько полезных функций-методов этого класса:</p>     <p><blockquote><b>#include &lt;qbutton.h&gt;</b></blockquote></p>     <p><blockquote><b>virtual void QButton::setText(const QString&amp;);</b></blockquote></p>     <p><blockquote><b>virtual void QButton::setPixmap(const QPixmap&amp;);</b></blockquote></p>     <p><blockquote><b>bool QButton::isToggleButton() const;</b></blockquote></p>     <p><blockquote><b>virtual void QButton::setDown(bool);</b></blockquote></p>     <p><blockquote><b>bool QButton::isDown() const;</b></blockquote></p>     <p><blockquote><b>bool QButton::isOn() const;</b></blockquote></p>     <p><blockquote><b>enum QButton::ToggleState { Off, NoChange, On }</b></blockquote></p>     <p><blockquote><b>ToggleState QButton::state() const;</b></blockquote></p>     <p>У функций <blockquote>isDown</blockquote> и <blockquote>isOn</blockquote> одно назначение. Обе они возвращают <blockquote>TRUE</blockquote>, если кнопка была нажата или активизирована.</p>     <p>Часто вам нужно отключить или сделать серым вариант, если он недоступен в данный момент. Сделать недоступным любой виджет, включая QButton, можно с помощью вызова метода <blockquote>QWidget::setEnable(FALSE)</blockquote>.</p>     <p>У <blockquote>QButton</blockquote> есть три подкласса, заслуживающие внимания:</p>     <p>&#9633; <blockquote>QPushButton</blockquote> — виджет простой кнопки, выполняющий некоторое действие при щелчке кнопкой мыши;</p>     <p>&#9633; <blockquote>QCheckBox</blockquote> — виджет кнопки, способный изменять состояние с включенного на выключенное для обозначения некоторого выбора;</p>     <p>&#9633; <blockquote>QRadioButton</blockquote> — виджет кнопки, обычно применяемый в группе таких же кнопок, только одна из которых может быть активна в любой момент времени.</p>     <b><i>QPushButton</i></b>     <p><blockquote>QPushButton</blockquote> — стандартная кнопка общего вида, содержащая текст, такой как "OK" или "Cancel" и/или пиксельную пиктограмму. Как все кнопки класса <blockquote>QButton</blockquote>, она порождает при активизации сигнал <blockquote>clicked</blockquote> и обычно используется для связи со слотом и выполнения некоторого действия.</p>     <p>Вы уже применяли кнопку <blockquote>QPushButton</blockquote> в примерах, и есть лишь еще одна интересная деталь, касающаяся этого простейшего из виджетов Qt. Кнопку <blockquote>QPushButton</blockquote> можно превратить из кнопки, не помнящей своего состояния, в кнопку-выключатель (т.е. способную быть включенной и выключенной), вызвав метод <blockquote>setToggleButton</blockquote>. (Если помните, у комплекта GTK+ из предыдущей главы есть для этих целей разные виджеты.)</p>     <p>Далее для полноты описания приведены конструкторы и полезные методы.</p>     <p><blockquote><b>#include &lt;qpushbutton.h&gt;</b></blockquote></p>     <p><blockquote><b>QPushButton(QWidget *parent, const char *name = 0);</b></blockquote></p>     <p><blockquote><b>QPushButton(const QString&amp; text, QWidget *parent, const char *name = 0);</b></blockquote></p>     <p><blockquote><b>QPushButton(const QIconSet&amp; icon, const QString&amp; text,</b></blockquote></p>     <p><blockquote><b> QWidget *parent, const char * name = 0);</b></blockquote></p>     <p><blockquote><b>void QPushButton::setToggleButton(bool);</b></blockquote></p>     <b><i>QCheckBox</i></b>     <p><blockquote>QCheckBox</blockquote> — это кнопка, у которой есть состояние, ее можно включить и выключить (или установить и сбросить). Внешний вид <blockquote>QCheckBox</blockquote> зависит от стиля отображения окон текущей системы (Motif, Windows и т.д.), но обычно она отображается как флажок с сопроводительным текстом справа.</p>     <p>Вы можете также перевести кнопку <blockquote>QCheckBox</blockquote> в третье промежуточное состояние, которое означает "без изменения". Оно бывает полезно в редких случаях, когда вы не можете прочесть состояние выбора, который предоставляет кнопка <blockquote>QCheckBox</blockquote> (и, следовательно, самостоятельно установить или сбросить флажок), но хотите дать пользователю возможность оставить выбор неизменным наряду с установкой и сбросом.</p>     <p><blockquote><b>#include &lt;qcheckbox.h&gt;</b></blockquote></p>     <p><blockquote><b>QCheckBox(QWidget *parent, const char *name = 0);</b></blockquote></p>     <p><blockquote><b>QCheckBox(const QString&amp; text, QWidget *parent, const char *name = 0);</b></blockquote></p>     <p><blockquote><b>bool QCheckBox::isChecked();</b></blockquote></p>     <p><blockquote><b>void QCheckBox::setTristate(bool y = TRUE);</b></blockquote></p>     <p><blockquote><b>bool QCheckBox::isTristate();</b></blockquote></p>     <b><i>QRadioButton</i></b>     <p>Радиокнопки — кнопки-переключатели, применяемые для отображения исключающего выбора, когда можно выбрать только один вариант из группы представленных (вспомните снова старые автомобильные радиоприемники, в которых можно было нажать только одну кнопку блока). Сами по себе кнопки <blockquote>QRadioButton</blockquote> не многим отличаются от кнопок <blockquote>QCheckBox</blockquote>, поскольку группировка и исключительный выбор обрабатываются классом <blockquote>QButtonGroup</blockquote>, главное же их отличие заключается в том, что они отображаются как круглые кнопки, а не как флажки.</p>     <p><blockquote>QButtonGroup</blockquote> — виджет, облегчающий обработку групп кнопок за счет предоставления удобных методов.</p>     <p><blockquote><b>#include &lt;qbuttongroup.h&gt;</b></blockquote></p>     <p><blockquote><b>QButtonGroup(QWidget *parent = 0, const char* name = 0);</b></blockquote></p>     <p><blockquote><b>QButtonGroup(const QString&amp; title, QWidget* parent = 0,</b></blockquote></p>     <p><blockquote><b> const char * name = 0);</b></blockquote></p>     <p><blockquote><b>int insert (QButton *button, int id = -1);</b></blockquote></p>     <p><blockquote><b>void remove(QButton *button);</b></blockquote></p>     <p><blockquote><b>int id(QButton *button) const;</b></blockquote></p>     <p><blockquote><b>int count() const;</b></blockquote></p>     <p><blockquote><b>int selectedId() const;</b></blockquote></p>     <p>Применять виджет <blockquote>QButtonGroup</blockquote> проще простого: он даже предлагает необязательную рамку вокруг кнопок, если используется конструктор <blockquote>title</blockquote>.</p>     <p>Добавить кнопку в <blockquote>QButtonGroup</blockquote> можно с помощью метода <blockquote>insert</blockquote> или заданием <blockquote>QButtonGroup</blockquote> в качестве родительского виджета кнопки. Для уникального обозначения каждой кнопки в группе можно задать <blockquote>id</blockquote> в методе <blockquote>insert</blockquote>. Это особенно полезно при определении выбранной кнопки, т.к. функция <blockquote>selectedId</blockquote> возвращает <blockquote>id</blockquote> выбранной кнопки.</p>     <p>Все кнопки <blockquote>QRadioButton</blockquote>, добавляемые в группу, автоматически становятся кнопками с исключающим выбором.</p>     <p>Далее приведены прототипы конструкторов <blockquote>QRadioButton</blockquote> и одного уникального метода, который не вызовет большого удивления:</p>     <p><blockquote><b>#include &lt;qradiobutton.h&gt;</b></blockquote></p>     <p><blockquote><b>QRadioButton(QWidget* parent, const char* name = 0);</b></blockquote></p>     <p><blockquote><b>QRadioButton(const QString&amp; text, QWidget *parent, const char *name = 0);</b></blockquote></p>     <p><blockquote><b>bool QRadioButton::isChecked();</b></blockquote></p>     <p>Выполните упражнение 17.5.</p>     <b>Упражнение 17.5. Виджет <blockquote>QButton</blockquote></b>     <p>Теперь применим полученные знания в примере с кнопками Qt. Приведенная далее программа создает кнопки разных типов (радиокнопки, флажки и простые кнопки), чтобы показать, как использовать эти виджеты в ваших приложениях.</p>     <p>1. Введите файл Buttons.h:</p>     <p><blockquote>#include &lt;qmainwindow.h&gt;</blockquote></p>     <p><blockquote>#include &lt;qcheckbox.h&gt;</blockquote></p>     <p><blockquote>#include &lt;qbutton.h&gt;</blockquote></p>     <p><blockquote>#include &lt;qradiobutton.h&gt;</blockquote></p>     <p><blockquote>class Buttons : public CMainWindow {</blockquote></p>     <p><blockquote> Q_OBJECT</blockquote></p>     <p><blockquote>public:</blockquote></p>     <p><blockquote> Buttons(QWidget *parent = 0, const char *name = 0);</blockquote></p>     <p>2. Вы запросите состояние ваших кнопок позже, в функции слота, поэтому объявите указатели кнопок и вспомогательную функцию <blockquote>PrintActive</blockquote> с атрибутом private в объявлении класса:</p>     <p><blockquote>private:</blockquote></p>     <p><blockquote> void PrintActive(QButton *button);</blockquote></p>     <p><blockquote> QCheckBox *checkbox;</blockquote></p>     <p><blockquote> QRadioButton *radiobutton1, *radiobutton2;</blockquote></p>     <p><blockquote>private slots:</blockquote></p>     <p><blockquote> void Clicked();</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>3. Далее следует файл Buttons.срр:</p>     <p><blockquote>#include "Buttons.moc"</blockquote></p>     <p><blockquote>#include &lt;qbuttongroup.h&gt;</blockquote></p>     <p><blockquote>#include &lt;qpushbutton.h&gt;</blockquote></p>     <p><blockquote>#include &lt;qapplication.h&gt;</blockquote></p>     <p><blockquote>#include &lt;qlabel.h&gt;</blockquote></p>     <p><blockquote>#include &lt;qlayout.h&gt;</blockquote></p>     <p><blockquote>#include &lt;iostream&gt;</blockquote></p>     <br>     <p><blockquote>Buttons::Buttons(QWidget *parent, const char *name) :</blockquote></p>     <p><blockquote> QMainWindow(parent, name) {</blockquote></p>     <p><blockquote> QWidget* widget = new QWidget(this);</blockquote></p>     <p><blockquote> setCentralWidget(widget);</blockquote></p>     <p><blockquote> QVBoxLayout *vbox = new QVBoxLayout(widget, 5, 10, "vbox");</blockquote></p>     <p><blockquote> checkbox = new QCheckBox("CheckButton", widget, "check");</blockquote></p>     <p><blockquote> vbox-&gt;addWidget(checkbox);</blockquote></p>     <p>4. Затем вы создаете <blockquote>QButtonGroup</blockquote> для двух ваших радиокнопок (переключателей).</p>     <p><blockquote> QButtonGroup *buttongroup = new QButtonGroup(0);</blockquote></p>     <p><blockquote> radiobutton1 = new QRadioButton("RadioButton1", widget, "radio1");</blockquote></p>     <p><blockquote> buttongroup-&gt;insert(radiobutton1);</blockquote></p>     <p><blockquote> vbox-&gt;addWidget(radiobutton1);</blockquote></p>     <p><blockquote> radiobutton2 = new QRadioButton("RadioButton2", widget, "radio2");</blockquote></p>     <p><blockquote> buttongroup-&gt;insert(radiobutton2);</blockquote></p>     <p><blockquote> vbox-&gt;addWidget(radiobutton2);</blockquote></p>     <p><blockquote> QPushButton* button = new QPushButton("Ok", widget, "button");</blockquote></p>     <p><blockquote> vbox-&gt;addWidget(button);</blockquote></p>     <p><blockquote> resize(350, 200);</blockquote></p>     <p><blockquote> connect(button, SIGNAL(clicked()), this, SLOT(Clicked()));</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>5. Затем приведен удобный метод для вывода состояния заданной кнопки <blockquote>QButton</blockquote>:</p>     <p><blockquote>void Buttons::PrintActive(QButton *button) {</blockquote></p>     <p><blockquote> if (button-&gt;isOn())</blockquote></p>     <p><blockquote>  std::cout &lt;&lt; button-&gt;name() &lt;&lt; " is checked\n";</blockquote></p>     <p><blockquote> else</blockquote></p>     <p><blockquote>  std::cout" &lt;&lt; button-&gt;name() &lt;&lt; " is not checked\n";</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote>void Buttons::Clicked(void) {</blockquote></p>     <p><blockquote> PrintActive(checkbox);</blockquote></p>     <p><blockquote> PrintActive(radiobutton1);</blockquote></p>     <p><blockquote> PrintActive(radiobutton2);</blockquote></p>     <p><blockquote> std::cout &lt;&lt; "\n";</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote>int main(int argc, char **argv) {</blockquote></p>     <p><blockquote> QApplication app(argc, argv);</blockquote></p>     <p><blockquote> Buttons *window = new Buttons();</blockquote></p>     <p><blockquote> app.setMainWidget(window);</blockquote></p>     <p><blockquote> window-&gt;show();</blockquote></p>     <p><blockquote> return app.exec();</blockquote></p>     <p><blockquote>}</blockquote></p>     <p><b>Как это работает</b></p>     <p>Этот простой пример показывает, как опрашивать виджеты кнопок Qt разных типов. После создания все они по большей части действуют одинаково. Например, функция <blockquote>PrintActive</blockquote> демонстрирует, как получить состояние кнопки (включена или выключена). Обратите внимание на то, как она действует в случае запоминающих состояние кнопок разных типов, таких как флажки и переключатели (радиокнопки). В основном отличаются только вызовы для создания виджета кнопки. Радиокнопки, наиболее сложные (т.к. только одна в группе может быть включена), при создании требуют больше всего работы. В случае радиокнопок вы должны создать <blockquote>QButtonGroup</blockquote> для того, чтобы гарантировать активность только одной радиокнопки в группе в любой момент времени.</p>             <a name="metkadoc8"><h1><i>QComboBox</i></h1></a>     <p>Переключатели (радиокнопки) — отличный способ, позволяющий пользователю выбрать из небольшого числа вариантов, скажем шести или меньше. Если вариантов больше шести, ситуация начинает выходить из-под контроля и становится еще более напряженной, когда количество вариантов растет, что приводит к ощутимому увеличению размера окна. В этом случае прекрасным решением может быть использование поля ввода с раскрывающимся меню, также называемое раскрывающимся списком (combo box). Варианты выводятся, когда вы щелкаете кнопкой мыши и открываете меню и количество вариантов при этом ограничено только удобством поиска в списке.</p>     <p>В виджете <blockquote>QComboBox</blockquote> сочетаются функциональные возможности виджетов <blockquote>QLineEdit</blockquote> и <blockquote>QPushButton</blockquote> и раскрывающихся меню, позволяя выбрать один вариант из неограниченного набора вариантов.</p>     <p><blockquote>QComboBox</blockquote> может быть открытым, как для чтения и записи, так и только для чтения. Если он позволяет читать и записывать, пользователь может ввести новый вариант в дополнение к предлагаемым; в противном случае пользователь ограничен выбором варианта из раскрывающегося списка.</p>     <p>При создании виджета <blockquote>QComboBox</blockquote> можно указать, открыт ли он для чтения и записи или только для чтения, задавая логическое значение в конструкторе:</p>     <p><blockquote>QComboBox *combo = new QComboBox(TRUE, parent, "widgetname");</blockquote></p>     <p>Передача значения <blockquote>TRUE</blockquote> переводит <blockquote>QComboBox</blockquote> в режим "чтение/запись". Остальные параметры — обычный указатель на родительский виджет и имя создаваемого виджета.</p>     <p>Как все виджеты Qt, <blockquote>QComboBox</blockquote> обладает гибкостью и предлагает широкий набор функциональных возможностей.</p>     <p>Вы можете добавлять варианты по одному или набором, как тип <blockquote>QString</blockquote> или в стандартном формате <blockquote>char*</blockquote>.</p>     <p>Для вставки одного варианта вызовите функцию <blockquote>insertItem</blockquote>:</p>     <p><blockquote>combo-&gt;insertItem(QString("An Item"), 1);</blockquote></p>     <p>Приведенная функция принимает объект типа <blockquote>QString</blockquote> и номер позиции в списке. В данном случае 1 вставляет вариант в список первым.</p>     <p>Для добавления в конец списка задайте любое отрицательное целое число.</p>     <p>Гораздо чаще вы будете вставлять несколько элементов списка одновременно, для этого можно применить класс <blockquote>QStrList</blockquote> или, как показано далее, массив <blockquote>char*</blockquote>:</p>     <p><blockquote>char* weather[] = {"Thunder", "Lightning", "Rain", 0};</blockquote></p>     <p><blockquote>combo-&gt;insertStrList(weather, 3);</blockquote></p>     <p>И снова вы можете задать номер позиции вставляемых в список элементов.</p>     <p>Если в виджете <blockquote>QComboBox</blockquote> задан режим "чтение/запись", вводимые пользователем варианты могут автоматически вставляться в список. Это очень полезное, экономящее время свойство, избавляющее пользователя от повторного набора варианта, если он хочет уже введенный вариант использовать несколько раз.</p>     <p>Метод <blockquote>InsertionPolicy</blockquote> управляет позицией вводимого в список элемента. Вы можете выбрать одно из значений, приведенных в табл. 17.4.</p>     <br>     <p><i><b>Таблица 17.4</b></i></p>     <table>      <tr>       <th valign="top">Значение</th>       <th valign="top">Действие</th>      </tr>      <tr>       <td valign="top"><blockquote>QComboBox::AtTop</blockquote></td>       <td valign="top">Вставляет вводимый в список элемент первым</td>      </tr>      <tr>       <td valign="top"><blockquote>QComboBox::AtBottom</blockquote></td>       <td valign="top">Вставляет вводимый в список элемент последним</td>      </tr>      <tr>       <td valign="top"><blockquote>QComboBox::AtCurrent</blockquote></td>       <td valign="top">Заменяет предварительно выбранный вариант в списке</td>      </tr>      <tr>       <td valign="top"><blockquote>QComboBox::BeforeCurrent</blockquote></td>       <td valign="top">Вставляет вводимый элемент перед предварительно выбранным вариантом из списка</td>      </tr>      <tr>       <td valign="top"><blockquote>QComboBox::AfterCurrent</blockquote></td>       <td valign="top">Вставляет вводимый элемент после предварительно выбранного варианта из списка</td>      </tr>      <tr>       <td valign="top"><blockquote>QComboBox::NoInsertion</blockquote></td>       <td valign="top">Новый элемент не вставляется в список вариантов</td>      </tr>     </table>     <p>Для задания политики вызовите метод <blockquote>InsertionPolicy</blockquote> виджета <blockquote>QComboBox</blockquote>:</p>     <p><blockquote>combo-&gt;setInsertionPolicy(QComboBox::AtTop);</blockquote></p>     <p>Давайте бросим взгляд на конструкторы и методы выбора варианта виджета <blockquote>QComboBox</blockquote>:</p>     <p><blockquote><b>#include &lt;qcombobox.h&gt;</b></blockquote></p>     <p><blockquote><b>QComboBox(QWidget *parent = 0, const char *name = 0);</b></blockquote></p>     <p><blockquote><b>QComboBox(bool readwrite, QWidget *parent = 0, const char *name = 0);</b></blockquote></p>     <p><blockquote><b>int count();</b></blockquote></p>     <p><blockquote><b>void insertStringList(const QStringList&amp; list, int index = -1);</b></blockquote></p>     <p><blockquote><b>void insertStrList(const QStrList&amp; list, int index = -1);</b></blockquote></p>     <p><blockquote><b>void insertStrList(const QStrList *list, int index = -1);</b></blockquote></p>     <p><blockquote><b>void insertStrList (const char **strings, int numStrings = -1, int index = -1);</b></blockquote></p>     <p><blockquote><b>void insertItem(const QString &amp;t, int index = -1);</b></blockquote></p>     <p><blockquote><b>void removeItem(int index);</b></blockquote></p>     <p><blockquote><b>virtual void setCurrentItem(int index);</b></blockquote></p>     <p><blockquote><b>QString currentText();</b></blockquote></p>     <p><blockquote><b>virtual void setCurrentText(const QString &amp;);</b></blockquote></p>     <p><blockquote><b>void setEditable(bool);</b></blockquote></p>     <p>Функция <blockquote>count</blockquote> возвращает количество вариантов в списке. <blockquote>QStringList</blockquote> и <blockquote>QStrList</blockquote> — классы коллекций, которые можно применять для вставки вариантов. Удалить варианты можно с помощью метода removeItem, извлечь и задать текущий вариант можно, с помощью методов <blockquote>currentText</blockquote> и <blockquote>setCurrentText</blockquote>, а перейти в редактируемый режим — с помощью метода <blockquote>setEditable</blockquote>.</p>     <p><blockquote>QComboBox</blockquote> порождает сигнал <blockquote>textChanged(QString&amp;)</blockquote> при каждом новом выборе варианта, передавая вновь выбранный элемент как аргумент.</p>     <p>Выполните упражнение 17.6.</p>     <b>Упражнение 17.6. Виджет <blockquote>QComboBox</blockquote></b>     <p>В этом примере вы сделаете попытку применить виджет <blockquote>QComboBox</blockquote> и посмотрите, как ведут себя сигналы и слоты с параметрами. Вы создадите класс <blockquote>ComboBox</blockquote>, потомка <blockquote>QMainWindow</blockquote>. В нем будут два виджета <blockquote>QComboBox</blockquote>: один для чтения/записи, другой только для чтения. Вы установите связь с сигналом <blockquote>textChanged</blockquote> для того, чтобы получать текущее значение при каждом его изменении.</p>     <p>1. Введите следующий программный код и назовите файл ComboBox.h:</p>     <p><blockquote>#include &lt;qmainwindow.h&gt;</blockquote></p>     <p><blockquote>#include &lt;qcombobox.h&gt;</blockquote></p>     <br>     <p><blockquote>class ComboBox : public QMainWindow {</blockquote></p>     <p><blockquote> Q_OBJECT</blockquote></p>     <p><blockquote>public:</blockquote></p>     <p><blockquote> ComboBox(QWidget* parent = 0, const char *name = 0);</blockquote></p>     <p><blockquote>private slots:</blockquote></p>     <p><blockquote> void Changed(const QString&amp; s);</blockquote></p>     <p><blockquote>};</blockquote></p>     <p>2. Интерфейс состоит из двух виджетов <blockquote>QComboBox</blockquote>: один редактируемый, а другой предназначен только для чтения. Вы заполните оба списка одними и теми же вариантами:</p>     <p><blockquote>#include "ComboBox.moс"</blockquote></p>     <p><blockquote>#include &lt;qlayout.h&gt;</blockquote></p>     <p><blockquote>#include &lt;iostream&gt;</blockquote></p>     <br>     <p><blockquote>ComboBox::ComboBox(QWidget *parent, const char *name) :</blockquote></p>     <p><blockquote> QMainWindow(parent, name) {</blockquote></p>     <p><blockquote> QWidget *widget = new QWidget(this);</blockquote></p>     <p><blockquote> setCentralWidget(widget);</blockquote></p>     <p><blockquote> QVBoxLayout *vbox = new QVBoxLayout(widget, 5, 10, "vbox");</blockquote></p>     <p><blockquote> QComboBox *editablecombo = new QComboBox(TRUE, widget, "editable");</blockquote></p>     <p><blockquote> vbox-&gt;addWidget(editablecombo);</blockquote></p>     <p><blockquote> QComboBox *readonlycombo = new QComboBox(FALSE, widget, "readonly");</blockquote></p>     <p><blockquote> vbox-&gt;addWidget(readonlycombo);</blockquote></p>     <p><blockquote> static const char* items[] = {"Macbeth", "Twelfth Night", "Othello", 0};</blockquote></p>     <p><blockquote> editablecombo-&gt;insertStrList(items);</blockquote></p>     <p><blockquote> readonlycombo-&gt;insertStrList(items);</blockquote></p>     <p><blockquote> connect(editablecombo, SIGNAL(textchanged(const QString&amp;),</blockquote></p>     <p><blockquote>  this, SLOT(Changed(const QString&amp;)));</blockquote></p>     <p><blockquote> resize(350, 200);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>3. Далее приведена функция слота. Обратите внимание на параметр <blockquote>s</blockquote> типа <blockquote>QString</blockquote>, передаваемый сигналом:</p>     <p><blockquote>void ComboBox::Changed(const QString&amp; s) {</blockquote></p>     <p><blockquote> std::cout &lt;&lt; s &lt;&lt; "\n";</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote>int main(int argc, char **argv) {</blockquote></p>     <p><blockquote> QApplication app(argc, argv);</blockquote></p>     <p><blockquote> ComboBox* window = new ComboBox();</blockquote></p>     <p><blockquote> app.setMainWidget(window);</blockquote></p>     <p><blockquote> window-&gt;show();</blockquote></p>     <p><blockquote> return app.exec();</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Вы сможете видеть вновь выбранные из редактируемого <blockquote>QComboBox</blockquote> варианты в командной строке на рис. 17.6.</p>     <img src="image071.jpg"/>     <p><b>Рис. 17.6</b></p>     <br>     <p><b>Как это работает</b></p>     <p>Создаются виджеты раскрывающегося списка во многом так же, как и другие виджеты. Главная новая деталь — вызов функции <blockquote>insertStrList</blockquote> для сохранения списка вариантов в виджете.</p>     <p>Как и в других содержащих текст виджетах, можно задать функцию, которая будет вызываться каждый раз при изменении значения или в общем случае текста раскрывающегося списка.</p>             <a name="metkadoc9"><h1><i>QListView</i></h1></a>     <p>Списки и деревья в комплекте Qt формируются виджетом <blockquote>QListView</blockquote>. Этот виджет представляет как простые списки, так и иерархические данные, разделенные на строки и столбцы. Он очень подходит для вывода структур каталогов или чего-то подобного, потому что дочерние элементы можно раскрыть и свернуть, щелкнув кнопкой мыши знак "плюс" или "минус", так же как в файловом обозревателе.</p>     <p>В отличие от виджета GTK+ <blockquote>ListView</blockquote> виджет <blockquote>QListView</blockquote> обрабатывает и данные, и их представление, что сделано для облегчения использования, если не для исключительной гибкости.</p>     <p>В виджете <blockquote>QListView</blockquote> можно выбрать строки или отдельные ячейки и затем вырезать и вставить данные, отсортировать их по столбцу и вы получите виджеты <blockquote>QCheckBox</blockquote>, отображенные в ячейках. В этот виджет встроено множество функциональных возможностей — как программисту вам достаточно лишь вставить данные и задать некоторые правила форматирования.</p>     <p>Создается виджет <blockquote>QListView</blockquote> обычным образом, заданием родительского виджета и собственного имени виджета:</p>     <p><blockquote>QListView *view = new QListView(parent, "name");</blockquote></p>     <p>Для задания заголовков столбцов используйте соответствующим образом названный метод <blockquote>addColumn</blockquote>:</p>     <p><blockquote>view-&gt;addColumn("Left Column", width1); // фиксированной ширины</blockquote></p>     <p><blockquote>view-&gt;addColumn("Right Column"); // с автоматически задаваемым размером</blockquote></p>     <p>Ширина столбца задается в пикселах или, если пропущена, приравнивается к величине самого длинного элемента в столбце. В дальнейшем при вставке и удалении элементов ширина столбца автоматически меняется.</p>     <p>Данные вставляются в <blockquote>QListView</blockquote> с помощью объекта <blockquote>QListViewItem</blockquote>, представляющего строку данных. Вы должны лишь передать в конструктор объект <blockquote>QListView</blockquote> и элементы строки, и она добавится в конец представления:</p>     <p><blockquote>QListViewItem *toplevel = new QListViewItem(view, "Left Data", "Right Data");</blockquote></p>     <p>Первый параметр — либо объект <blockquote>QListView</blockquote>, как в данном случае, либо еще один объект типа <blockquote>QListViewItem</blockquote>. Если передается <blockquote>QListViewItem</blockquote>, строка создается как дочерняя по отношению к этому объекту <blockquote>QListViewItem</blockquote>. Таким образом, структура дерева формируется передачей объекта <blockquote>QListView</blockquote> для узлов верхнего уровня и затем последующих объектов типа <blockquote>QListViewItem</blockquote> для дочерних или подчиненных узлов.</p>     <p>Остальные параметры — данные каждого столбца, по умолчанию равные <blockquote>NULL</blockquote>, если не заданы.</p>     <p>Добавление дочернего узла — это просто вариант передачи в функцию указателя верхнего уровня. Если вы не добавляете последующие дочерние узлы в объект <blockquote>QListViewItem</blockquote>, нет необходимости сохранять возвращаемый указатель:</p>     <p><blockquote>new QListViewItem(toplevel, "Left Data", "Right Data");</blockquote></p>     <p><blockquote>// Дочерний по отношению к верхнему уровню</blockquote></p>     <p>В API <blockquote>QListViewItem</blockquote> можно найти методы обхода узлов дерева на случай корректировки конкретных строк:</p>     <p><blockquote><b>#include &lt;qlistview.h&gt;</b></blockquote></p>     <p><blockquote><b>virtual void insertItem(QListviewitem* newChild);</b></blockquote></p>     <p><blockquote><b>virtual void setText(int column, const QString&amp; text);</b></blockquote></p>     <p><blockquote><b>virtual QString text(int column) const;</b></blockquote></p>     <p><blockquote><b>QListViewItem* firstChild() const;</b></blockquote></p>     <p><blockquote><b>QListViewItem* nextSibling() const;</b></blockquote></p>     <p><blockquote><b>QListViewItem* parent() const;</b></blockquote></p>     <p><blockquote><b>QListViewItem* itemAbove();</b></blockquote></p>     <p><blockquote><b>QListViewItem *itemBelow();</b></blockquote></p>     <p>Получить первую строку в дереве можно, вызвав метод <blockquote>firstChild</blockquote> для самого объекта <blockquote>QListView</blockquote>. Затем можно многократно вызывать <blockquote>firstChild</blockquote> <b>и </b><blockquote>nextSibling</blockquote> для возврата фрагментов или целого дерева.</p>     <p>Приведенный далее фрагмент программного кода выводит первый столбец всех узлов верхнего уровня:</p>     <p><blockquote>QListViewItem *child = view-&gt;firstChild();</blockquote></p>     <p><blockquote>while(child) {</blockquote></p>     <p><blockquote> cout &lt;&lt; myChild-&gt;text(1) &lt;&lt; "\n";</blockquote></p>     <p><blockquote> myChild = myChild-&gt;nextSibling();</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Все подробности, касающиеся <blockquote>QListView</blockquote>, <blockquote>QListViewItem</blockquote> и <blockquote>QCheckListView</blockquote>, см. в документации API комплекта Qt.</p>     <p>Выполните упражнение 17.7.</p>     <b>Упражнение 17.7 Виджет <blockquote>QListView</blockquote></b>     <p>В этом упражнении вы соберете все вместе и напишете короткий пример использования виджета QListView.</p>     <p>Давайте для краткости пропустим заголовочный файл и рассмотрим реализацию класса, файл ListView.cpp.</p>     <p><blockquote>#include "Listview.moc"</blockquote></p>     <br>     <p><blockquote>ListView::ListView(QWidget *parent, const char *name) :</blockquote></p>     <p><blockquote> QMainWindow(parent, name) {</blockquote></p>     <p><blockquote> listview = new QListView(this, "listview1");</blockquote></p>     <p><blockquote> listview-&gt;addColumn("Artist");</blockquote></p>     <p><blockquote> listview-&gt;addColumn("Title");</blockquote></p>     <p><blockquote> listview-&gt;addColumn("Catalogue");</blockquote></p>     <p><blockquote> listview-&gt;setRootIsDecorated(TRUE);</blockquote></p>     <p><blockquote> QListViewItem* toplevel = new QListViewItem(listview, "Avril Lavigne",</blockquote></p>     <p><blockquote>  "Let Go", "AVCD01");</blockquote></p>     <p><blockquote> new QListViewItem(toplevel, "Complicated");</blockquote></p>     <p><blockquote> new QListViewItem(toplevel, "Sk8er Boi");</blockquote></p>     <p><blockquote> setCentralWidget(listview);</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote>int main(int argc, char **argv) {</blockquote></p>     <p><blockquote> QApplication app(argc, argv);</blockquote></p>     <p><blockquote> ListView *window = new ListView();</blockquote></p>     <p><blockquote> app.setMainWidget(window);</blockquote></p>     <p><blockquote> window-&gt;show();</blockquote></p>     <p><blockquote> return app.exec();</blockquote></p>     <p><blockquote>}</blockquote></p>     <p><b>Как это работает</b></p>     <p>Виджет <blockquote>QListView</blockquote> кажется сложным, потому что он действует и как список элементов, и как дерево элементов. В вашем программном коде необходимо создать экземпляры <blockquote>QListViewItem</blockquote> для каждого элемента, включаемого вами в список. У каждого экземпляра типа <blockquote>QListViewItem</blockquote> есть родитель. Эти элементы с самим виджетом в качестве родителя отображаются как элементы верхнего уровня. Элементы с другим элементом типа <blockquote>QListViewItem</blockquote> в качестве родителя выводятся на экран как дочерние элементы. В этом примере показаны экземпляры <blockquote>QListViewItem</blockquote> со всего одним уровнем глубины, но можно создавать и деревья элементов с гораздо большей глубиной.</p>     <p>После компиляции и выполнения примера ListView вы увидите виджет <blockquote>QListView</blockquote> в действии, как показано на рис. 17.7.</p>     <p>Обратите внимание на то, как дочерние строки почтительно отступают от своих "родителей". Знаки "плюс" и "минус", указывающие на наличие скрытых или сворачивающихся строк, не представлены по умолчанию; в этом примере они задаются с помощью <blockquote>setRootIsDecorated</blockquote>.</p>     <img src="image072.jpg"/>     <p><b>Рис. 17.7</b></p>     <br>              <a name="metkadoc10"><h1>Диалоговые окна</h1></a>         <p>До сих пор вы создавали подклассы <blockquote>QMainWindow</blockquote> для построения своих интерфейсов. Объекты <blockquote>QMainWindow</blockquote> предназначены для создания главного окна в вашем приложении, но для кратковременных диалоговых окон следует рассмотреть виджет <blockquote>QDialog</blockquote>.</p>     <p>Диалоговые окна хороши для ввода пользователем определенной информации, предназначенной для конкретной задачи, или передачи пользователю коротких сообщений, таких как предупреждение или сообщение об ошибке. Для таких задач лучше применять подкласс <blockquote>QDialog</blockquote>, поскольку вы получаете удобные методы формирования диалогового окна и специализированные сигналы и слоты для обработки ответов пользователя.</p>     <p>Наряду с обычными модальными и немодальными (или безмодальными на языке Qt) диалоговыми окнами комплект Qt также предлагает полумодальное диалоговое окно. В следующем перечне приведены отличия модальных и немодальных диалоговых окон, в него также включены полумодальные окна.</p>     <p><i>&#9633; Модальное диалоговое окно</i> блокирует ввод во все другие окна, чтобы заставить пользователя дать ответ в диалоговом окне. Модальные диалоговые окна полезны для захвата немедленного ответа пользователя и отображения важных сообщений об ошибках.</p>     <p><i>&#9633; Немодальное диалоговое окно</i> — неблокирующее окно, которое действует обычно наряду с другими окнами приложения. Немодальные диалоговые окна удобны для окон поиска или ввода, в которых вы сможете, например, копировать и вставлять значения в главное окно и из него.</p>     <p><i>&#9633; Полумодальное диалоговое окно</i> — это модальное окно, не имеющее своего цикла событий. Это позволяет возвращать управление приложению, но сохранять блокировку ввода для других окон. Полумодальные окна бывают полезны в редких случаях, когда у вас есть индикатор выполнения процесса важной, требующей значительного времени операции, и вы хотите дать пользователю возможность отменить ее при необходимости. Поскольку у такого окна нет собственного цикла событий, для его обновления вы должны периодически вызывать метод <blockquote>QApplication::processEvents</blockquote>.</p>             <a name="metkadoc11"><h1><i>QDialog</i></h1></a>     <p><blockquote>QDialog</blockquote> — базовый класс диалоговых окон в Qt, предоставляющий методы <blockquote>exec</blockquote> и <blockquote>show</blockquote> для обработки модальных и немодальных диалоговых окон, у него есть встроенный класс <blockquote>QLayout</blockquote>, который можно использовать, и несколько сигналов и слотов, полезных для формирования откликов на нажатие кнопки.</p>     <p>Обычно вы будете создавать для своих диалоговых окон класс-потомок <blockquote>QDialog</blockquote> и вставлять в него виджеты для создания интерфейса диалогового окна:</p>     <p><blockquote>#include &lt;qdialog.h&gt;</blockquote></p>     <br>     <p><blockquote>MyDialog::MyDialog(QWidget *parent, const char *name) : QDialog(parent, name) {</blockquote></p>     <p><blockquote> QHBoxLayout *hbox = new QHBoxLayout(this);</blockquote></p>     <p><blockquote> hbox-&gt;addWidget(new Qlabel("Enter your name"));</blockquote></p>     <p><blockquote> hbox-&gt;addWidget(new QLineEdit());</blockquote></p>     <p><blockquote> hbox-&gt;addWidget(ok_pushbutton);</blockquote></p>     <p><blockquote> hbox-&gt;addWidget(cancel_pushbutton);</blockquote></p>     <p><blockquote> connect(ok_pushbutton, SIGNAL(clicked()), this, SLOT(accept()));</blockquote></p>     <p><blockquote> connect(cancel_pushbutton, SIGNAL(clicked()), this, SLOT(reject()));</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>В отличие от виджета типа <blockquote>QMainWindow</blockquote> вы можете задать объект <blockquote>MyDialog</blockquote> как родительский для своего объекта <blockquote>QLayout</blockquote> без создания пустого <blockquote>QWidget</blockquote> в качестве родительского.</p>     <blockquote>      <b>Примечание</b>      <p>Имейте в виду, что в этом примере пропущен программный код для создания виджетов <blockquote>ok_pushbutton</blockquote> и <blockquote>cancel_pushbutton</blockquote>.</p>     </blockquote>     <p>У объекта <blockquote>QDialog</blockquote> есть два слота — <blockquote>accept</blockquote> и <blockquote>reject</blockquote>, которые применяются для обозначения результата, полученного в диалоговом окне. Этот результат возвращается методом exec. Как правило, вы будете связывать кнопки <b>OK</b> и <b>Cancel</b> со слотами, как в <blockquote>MyDialog</blockquote>.</p>     <b>Модальные диалоговые окна</b>     <p>Для применения диалогового окна как модального вы вызываете метод <blockquote>exec</blockquote>, который открывает диалоговое окно и возвращает <blockquote>QDialog::Accepted</blockquote> или <blockquote>QDialog::Rejected</blockquote> в зависимости от того, какой слот был активизирован:</p>     <p><blockquote>MyDialog* dialog = new MyDialog(this, "mydialog");</blockquote></p>     <p><blockquote>if (dialog-&gt;exec() == QDialog::Accepted) {</blockquote></p>     <p><blockquote> // Пользователь щелкнул мышью кнопку OK</blockquote></p>     <p><blockquote> doSomething();</blockquote></p>     <p><blockquote>} else {</blockquote></p>     <p><blockquote> // Пользователь щелкнул мышью кнопку Cancel или</blockquote></p>     <p><blockquote> // диалоговое окно уничтожено</blockquote></p>     <p><blockquote> doSomethingElse();</blockquote></p>     <p><blockquote>}</blockquote></p>     <p><blockquote>delete dialog;</blockquote></p>     <p>Когда метод <blockquote>exec</blockquote> возвращает управление приложению, диалоговое окно автоматически скрывается, но вы все равно удаляете объект из памяти.</p>     <p>Учтите, что когда вызывается <blockquote>exec</blockquote>, вся обработка прекращается, поэтому, если в вашем приложении есть важный с точки зрения затраченного времени программный код, больше подойдут немодальное или полумодальное диалоговые окна.</p>     <b>Немодальные диалоговые окна</b>     <p>Немодальные диалоговые окна слегка отличаются от обычных основных окон прежде всего тем, что располагаются поверх своего родительского окна, совместно используют их элемент на панели задач и автоматически скрываются, когда вызван слот <blockquote>accept</blockquote> или <blockquote>reject</blockquote>.</p>     <p>Для отображения немодального диалогового окна вызывайте метод <blockquote>show</blockquote>, как вы сделали бы для окна <blockquote>QMainWindow</blockquote>:</p>     <p><blockquote>MyDialog *dialog = new MyDialog(this, "mydialog");</blockquote></p>     <p><blockquote>dialog-&gt;show();</blockquote></p>     <p>Функция <blockquote>show</blockquote> выводит диалоговое окно на экран и немедленно возвращается в приложение для продолжения цикла выполнения. Для обработки нажатой кнопки вы должны написать слоты и установить с ними связь:</p>     <p><blockquote>MyDialog::MyDialog(QWidget *parent, const char *name) :</blockquote></p>     <p><blockquote> QDialog(parent, name) {</blockquote></p>     <p><blockquote> ...</blockquote></p>     <p><blockquote> connect(ok_pushbutton, SIGNAL(clicked()), this, SLOT(OkClicked()));</blockquote></p>     <p><blockquote> connect(cancel_pushbutton, SIGNAL(clicked()), this, SLOT(CancelClicked()));</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote>MyDialog::OkClicked() {</blockquote></p>     <p><blockquote> // Выполните что-либо</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote>MyDialog::CancelClicked() {</blockquote></p>     <p><blockquote> // Выполните что-либо другое</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Как и в случае модального окна, диалоговое окно автоматически скрывается при нажатии кнопки.</p>     <b>Полумодальное диалоговое окно</b>     <p>Для создания полумодального диалогового окна вы должны задать флаг модального режима в конструкторе <blockquote>QDialog</blockquote> и применить метод <blockquote>show</blockquote>:</p>     <p><b><blockquote><b>QDialog(QWidget *parent=0, const char *name=0, bool modal=FALSE, WFlags f=0);</b></blockquote></b></p>     <p>Вы не задаете в модальном диалоговом окне флаг модального режима равным <blockquote>TRUE</blockquote>, потому что вызов <blockquote>exec</blockquote> заставляет диалоговое окно перейти в модальный режим независимо от значения этого флага.</p>     <p>Конструктор вашего диалогового окна будет выглядеть примерно следующим образом:</p>     <p><blockquote>MySMDialog::MySMDialog(QWidget *parent, const char *name): </blockquote></p>     <p><blockquote> QDialog(parent, name, TRUE) {</blockquote></p>     <p><blockquote> ...</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>После того как вы определили ваше диалоговое окно, вызовите функцию <blockquote>show</blockquote> как обычно и затем продолжите свою обработку, периодически вызывая <blockquote>QApplication::processEvents</blockquote> для обновления вашего диалогового окна:</p>     <p><blockquote>MySMDialog *dialog = MySMDialog(this, "semimodal");</blockquote></p>     <p><blockquote>dialog-&gt;show();</blockquote></p>     <p><blockquote>while (processing) {</blockquote></p>     <p><blockquote> doSomeProcessing();</blockquote></p>     <p><blockquote> app-&gt;processEvents();</blockquote></p>     <p><blockquote> if (dialog-&gt;wasCancelled()) break;</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Перед продолжением выполнения проверьте, не уничтожено ли диалоговое окно. Имейте в виду, что функция <blockquote>wasCancelled</blockquote> не является частью класса <blockquote>QDialog</blockquote> — вы должны написать ее самостоятельно.</p>     <p>Комплект Qt предоставляет готовые подклассы класса <blockquote>QDialog</blockquote>, предназначенные для конкретных задач, таких как выбор файлов, ввод текста, индикация процесса выполнения и вывод окна сообщения. Применение этих виджетов в любых приложениях убережет вас от множества неприятностей и проблем.</p>             <a name="metkadoc12"><h1><i>QMessageBox</i></h1></a>     <p><blockquote>QMessageBox</blockquote> — модальное диалоговое окно, отображающее простое сообщение с пиктограммой и кнопками. Пиктограмма зависит от серьезности сообщения, которое может содержать обычные сведения или предупреждения и другую важную информацию.</p>     <p>У класса <blockquote>QMessageBox</blockquote> есть статические методы создания и отображения окон всех трех перечисленных типов:</p>     <p><blockquote><b>#include &lt;qmessagebox.h&gt;</b></blockquote></p>     <p><blockquote><b>int information(QWidget *parent, const QString&amp; caption,</b></blockquote></p>     <p><blockquote><b> const QString&amp;text, int button0, int button1=0, int button2=0);</b></blockquote></p>     <p><blockquote><b>int warning(QWidget *parent, const QString&amp; caption,</b></blockquote></p>     <p><blockquote><b> const QString&amp; text, int button0, int button1, int button2=0);</b></blockquote></p>     <p><blockquote><b>int critical(QWidget *parent, const QString&amp; caption,</b></blockquote></p>     <p><blockquote><b> const QString&amp; text, int button0, int button1, int button2=0);</b></blockquote></p>     <p>Можно выбрать кнопки из списка готовых кнопок <blockquote>QMessageBox</blockquote>, соответствующих значениям, возвращаемым статическими методами:</p>     <p>&#9633; <blockquote>QMessageBox::Ok</blockquote>;</p>     <p>&#9633; <blockquote>QMessageBox::Cancel</blockquote>;</p>     <p>&#9633; <blockquote>QMessageBox::Yes</blockquote>;</p>     <p>&#9633; <blockquote>QMessageBox::No</blockquote>;</p>     <p>&#9633; <blockquote>QMessageBox::Abort</blockquote>;</p>     <p>&#9633; <blockquote>QMessageBox::Retry</blockquote>;</p>     <p>&#9633; <blockquote>QMessageBox::Ignore</blockquote>.</p>     <p>Типичный пример использования окна <blockquote>QMessageBox</blockquote> будет похож на приведенный далее фрагмент программного кода:</p>     <p><blockquote>int result = QMessageBox::information(this,</blockquote></p>     <p><blockquote> "Engine Room Query",</blockquote></p>     <p><blockquote> "Do you wish to engage the HyperDrive?",</blockquote></p>     <p><blockquote> QMessageBox::Yes | QMessageBox::Default,</blockquote></p>     <p><blockquote> QMessageBox::No | QMessageBox::Escape);</blockquote></p>     <p><blockquote>switch (result) {</blockquote></p>     <p><blockquote>case QMessageBox::Yes:</blockquote></p>     <p><blockquote> hyperdrive-&gt;engage();</blockquote></p>     <p><blockquote> break;</blockquote></p>     <p><blockquote>case QMessageBox::No:</blockquote></p>     <p><blockquote> // сделайте что-нибудь еще</blockquote></p>     <p><blockquote> break;</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Вы соединили операцией <blockquote>OR</blockquote> (<blockquote>|</blockquote>) коды кнопок с вариантами <blockquote>Default</blockquote> и <blockquote>Escape</blockquote>, чтобы задать стандартные действия, при нажатии клавиш &lt;Enter&gt; (или &lt;Return&gt;) и &lt;Esc&gt;. Результирующее диалоговое окно показано на рис. 17.8.</p>     <img src="image073.jpg"/>     <p><b>Рис. 17.8</b> </p>             <a name="metkadoc13"><h1><i>QInputDialog</i></h1></a>     <p>Окно <blockquote>QInputDialog</blockquote> полезно для ввода пользователем отдельных значений, будь то текст, вариант раскрывающегося списка, целочисленное или действительное значение. У класса <blockquote>QInputDialog</blockquote> есть статические методы, например <blockquote>QMessageBox</blockquote>, создающие некоторые проблемы, поскольку у них слишком много параметров, к счастью, у большинства из них есть значения по умолчанию:</p>     <p><blockquote><b>#include &lt;qinputdialog.h&gt;</b></blockquote></p>     <p><blockquote><b>QString getText(const QString&amp; caption, const QString&amp; label,</b></blockquote></p>     <p><blockquote><b> QLineEdit::EchoMode mode=QLineEdit::Normal,</b></blockquote></p>     <p><blockquote><b> const QString&amp; text=QString::null,</b></blockquote></p>     <p><blockquote><b> bool* ok = 0, QWidget* parent = 0, const char * name = 0);</b></blockquote></p>     <p><blockquote><b>QString getItem(const QString&amp; caption, const QString&amp; label,</b></blockquote></p>     <p><blockquote><b> const QStringList&amp; list, int current=0, bool editable=TRUE,</b></blockquote></p>     <p><blockquote><b> bool* ok=0, QWidget* parent = 0, const char* name=0)</b></blockquote></p>     <p><blockquote><b>int getInteger(const QString&amp; caption, const QString&amp; label,</b></blockquote></p>     <p><blockquote><b> int num=0, int from = -2147483647, int to = 2147483647,</b></blockquote></p>     <p><blockquote><b> int step = 1, bool* ok = 0, QWidget* parent = 0, const char* name = 0);</b></blockquote></p>     <p><blockquote><b>double getDouble(const QString&amp; caption, const QString&amp; label,</b></blockquote></p>     <p><blockquote><b> double num = 0, double from = -2147483647, double to = 2147483647,</b></blockquote></p>     <p><blockquote><b> int decimals = 1, bool* ok = 0, QWidget* parent = 0, const char* name = 0);</b></blockquote></p>     <p>Для ввода строки текста напишите следующий фрагмент кода:</p>     <p><blockquote>bool result;</blockquote></p>     <p><blockquote>QString text = QInputDialog::getText("Question", "What is your Quest?:",</blockquote></p>     <p><blockquote> QLineEdit::Normal, QString::null, &amp;result, this, "input");</blockquote></p>     <p><blockquote>if (result) {</blockquote></p>     <p><blockquote> doSomething(text);</blockquote></p>     <p><blockquote>} else {</blockquote></p>     <p><blockquote> // Пользователь нажал Cancel</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Как видно из рис. 17.9, окно <blockquote>QInputDialog</blockquote> создано с помощью виджета QLi<blockquote>n</blockquote>eEdit и кнопок <b>OK</b> и <b>Cancel</b>.</p>     <img src="image074.jpg"/>     <p><b>Рис. 17.9</b> </p>     <br>     <p>Диалоговое окно, созданное методом <blockquote>QInputDialog::getText</blockquote>, применяет виджет <blockquote>QLineEdit</blockquote>. Параметр режима редактирования, передаваемый в функцию <blockquote>getText</blockquote>, управляет способом отображения набираемого текста точно так же, как аналогичный параметр режима виджета <blockquote>QLineEdit</blockquote>. Вы можете также задать текст, выводимый по умолчанию, или оставить поле пустым, как показано на рис. 17.9. У всех окон <blockquote>QInputDialog</blockquote> есть кнопки <b>OK</b> и <b>Cancel</b>, и в метод передается указатель типа <blockquote>bool</blockquote> для обозначения нажатой кнопки — результат равен <blockquote>TRUE</blockquote>, если пользователь щелкает мышью кнопку <b>OK</b>.</p>     <p>Метод <blockquote>getItem</blockquote> с помощью раскрывающегося списка <blockquote>QComboBox</blockquote> предлагает пользователю список вариантов:</p>     <p><blockquote>bool result;</blockquote></p>     <p><blockquote>QStringList options;</blockquote></p>     <p><blockquote>options &lt;&lt; "London" &lt;&lt; "New York" &lt;&lt; "Paris";</blockquote></p>     <p><blockquote>QString city = QInputDialog::getItem("Holiday", "Please select a</blockquote></p>     <p><blockquote> destination:", options, 1, TRUE, &amp;result, this, "combo");</blockquote></p>     <p><blockquote>if (result) selectDestination(city);</blockquote></p>     <p>Созданное диалоговое окно показано на рис. 17.10.</p>     <img src="image075.jpg"/>     <p><b>Рис. 17.10</b> </p>     <br>     <p>Функции <blockquote>getInteger</blockquote> и <blockquote>getDouble</blockquote> действуют во многом аналогично, поэтому мы не будем на них останавливаться.</p>             <a name="metkadoc14"><h1>Применение <i>qmake</i> для упрощения написания make-файлов</h1></a>     <p>Компиляция приложения с библиотеками KDE и Qt становится утомительным занятием, поскольку ваш make-файл получается очень сложным из-за необходимости использовать <blockquote>moc</blockquote> и иметь библиотеки здесь, там и везде. К счастью, Qt поставляется с утилитой <blockquote>qmake</blockquote> для создания ваших make-файлов.</p>     <blockquote>      <b>Примечание</b>      <p>Если вы уже пользовались комплектом Qt, вам, возможно, знакома утилита <blockquote>tmake</blockquote> — более раннее (и теперь устаревшее) воплощение <blockquote>qmake</blockquote>, поставлявшееся с предыдущими версиями Qt.</p>     </blockquote>     <p>Утилита <blockquote>qmake</blockquote> принимает в качестве входного файл .pro. Этот файл содержит самые существенные сведения, необходимые для компиляции, такие как исходные тексты, заголовочные файлы, результирующий двоичный файл и местонахождения библиотек KDE/Qt.</p>     <p>Типичный pro-файл среды KDE выглядит следующим образом:</p>     <p><blockquote>TARGET = app</blockquote></p>     <p><blockquote>MOC_DIR = moc</blockquote></p>     <p><blockquote>OBJECTS_DIR = obj</blockquote></p>     <p><blockquote>INCLUDEPATH = /usr/include/kde</blockquote></p>     <p><blockquote>QMAKE_LIBDIR_X11 += /usr/lib</blockquote></p>     <p><blockquote>QMAKE_LIBS_X11 += -lkdeui -lkdecore</blockquote></p>     <p><blockquote>SOURCES = main.cpp window.cpp</blockquote></p>     <p><blockquote>HEADERS = window.h</blockquote></p>     <p>Вы задаете результирующий двоичный файл, временные каталоги moc и объектных файлов, путь к библиотеке KDE и исходные тексты, и заголовочные файлы, из которых формируется приложение. Учтите, что местонахождение файлов библиотек и заголовочных файлов KDE зависит от вашего дистрибутива. Пользователи SUSE должны приравнять <blockquote>INCLUDEPATH</blockquote> путь /opt/kde3/include и <blockquote>QMAKE_LIBS_X11</blockquote> путь /opt/kde3/lib.</p>     <p><blockquote>$ <b>qmake file.pro -о Makefile</b></blockquote></p>     <p>Затем вы можете выполнить команду <blockquote>make</blockquote> как обычно, что не вызовет затруднений. Для упрощения процедуры построения приложения следует использовать <blockquote>qmake</blockquote> с программами любой сложности, применяющими KDE/Qt.</p>              <a name="metkadoc15"><h1>Создание меню и панелей инструментов с помощью KDE</h1></a>    <p>Для того чтобы продемонстрировать мощь виджетов KDE, мы оставили меню и панели инструментов напоследок, поскольку они — уж очень наглядные примеры того, как библиотеки KDE экономят время и усилия по сравнению с применением только Qt или любых других комплектов с элементами графического пользовательского интерфейса.</p>    <p>Обычно в библиотеках GUI элементы меню и панелей инструментов — отличающиеся элементы, каждый со своим собственным виджетом. Вы должны создавать отдельные объекты для каждого элемента и отслеживать изменения, например, делая недоступными определенные варианты, каждый отдельно.</p>    <p>У программистов KDE появилось лучшее решение. Вместо такого обособленного подхода в KDE определен виджет <blockquote>KAction</blockquote> для представления действия, которое может выполнить приложение. Это действие может открыть новый документ, сохранить файл или вывести окно справки.</p>    <p><blockquote>KAction</blockquote> присваивается текст, клавиатурный акселератор, пиктограмма и слот, который вызывается при активизации действия:</p>    <p><blockquote>KAction *new_file = new KAction("New", "filenew",</blockquote></p>    <p><blockquote> KstdAccel::shortcut(KstdAccel::New), this,</blockquote></p>    <p><blockquote> SLOT(newFile()), this, "newaction");</blockquote></p>    <p>Затем <blockquote>KAction</blockquote> может быть вставлено в меню и панель инструментов без дополнительного описания:</p>    <p><blockquote>new_file-&gt;plug(a_menu);</blockquote></p>    <p><blockquote>new_file-&gt;plug(a_toolbar);</blockquote></p>    <p>Таким образом, вы создали пункт меню <b>New</b> и кнопку панели инструментов, которые вызывают <blockquote>newFile</blockquote> при щелчке кнопкой мыши.</p>    <p>Теперь если вам нужно отменить <blockquote>KAction</blockquote> — скажем, вы не хотите, чтобы пользователь мог создать новый файл, — вызов централизован:</p>    <p><blockquote>new_file-&gt;setEnabled(FALSE);</blockquote></p>    <p>Это все, что касается меню и панелей инструментов в среде KDE — на самом деле очень легко и просто. Далее приведен конструктор виджета <blockquote>KAction</blockquote>:</p>    <p><blockquote><b>#include &lt;kde/kaction.h&gt;</b></blockquote></p>    <p><blockquote><b>KAction(const QString&amp; text, const KShortcut&amp; cut,</b></blockquote></p>    <p><blockquote><b> const QObject* receiver, const char* slot,</b></blockquote></p>    <p><blockquote><b> QObject *parent, const char* name = 0);</b></blockquote></p>    <p>KDE предоставляет стандартные объекты <blockquote>KAction</blockquote> для унификации текста, клавиатурных акселераторов и пиктограмм в разных приложениях KDE:</p>    <p><blockquote><b>#include &lt;kde/kaction.h&gt;</b></blockquote></p>    <p><blockquote><b>KAction* openNew(const QObject* recvr, const char *slot,</b></blockquote></p>    <p><blockquote><b> KActionCollection* parent, const char* name = 0)ж</b></blockquote></p>    <p><blockquote><b>KAction* save ...</b></blockquote></p>    <p><blockquote><b>KAction* saveAs ...</b></blockquote></p>    <p><blockquote><b>KAction* revert ...</b></blockquote></p>    <p><blockquote><b>KAction* close ...</b></blockquote></p>    <p><blockquote><b>KAction* print ...</b></blockquote></p>    <p>И т.д.</p>    <p>Любое стандартное действие принимает одни и те же параметры; слот-приемник и функцию, <blockquote>KActionCollection</blockquote> и имя <blockquote>KAction</blockquote>. Объект <blockquote>KActionCollection</blockquote> управляет в окне объектами <blockquote>KAction</blockquote>, и вы можете получить текущий объект с помощью метода <blockquote>actionCollection</blockquote> окна <blockquote>KMainWindow</blockquote>:</p>    <p><blockquote>KAction *saveas = KStdAction::saveAs(this, SLOT(saveAs()) ,</blockquote></p>    <p><blockquote> actionCollection(), "saveas");</blockquote></p>    <p>Выполните упражнение 17.8.</p>    <b>Упражнение 17.8. Приложение в KDE с меню и панелями инструментов</b>    <p>В приведенном далее примере вы опробуете объекты <blockquote>KAction</blockquote> в приложении среды KDE.</p>    <p>1. Начните с заголовочного файла KDEMenu.h. <blockquote>KDEMenu</blockquote> — это подкласс <blockquote>KMainWindow</blockquote>, являющегося подклассом класса <blockquote>QMainWindow</blockquote>. <blockquote>KMainWindow</blockquote> управляет сеансом в среде KDE и обладает встроенными панелью инструментов и строкой состояния.</p>    <p><blockquote>#include &lt;kde/kmainwindow.h&gt;</blockquote></p>    <br>    <p><blockquote>class KDEMenu : public KMainWindow {</blockquote></p>    <p><blockquote> Q_OBJECT</blockquote></p>    <p><blockquote>public:</blockquote></p>    <p><blockquote> KDEMenu(const char * name = 0);</blockquote></p>    <p><blockquote>private slots:</blockquote></p>    <p><blockquote> void newFile();</blockquote></p>    <p><blockquote> void aboutApp();</blockquote></p>    <p><blockquote>};</blockquote></p>    <p>2. Файл KDEMenu.cpp начните с директив <blockquote>#include</blockquote> для виджетов, которые будете применять:</p>    <p><blockquote>#include "KDEMenu.h"</blockquote></p>    <p><blockquote>#include &lt;kde/kapp.h&gt;</blockquote></p>    <p><blockquote>#include &lt;kde/kaction.h&gt;</blockquote></p>    <p><blockquote>#include &lt;kde/kstdaccel.h&gt;</blockquote></p>    <p><blockquote>#include &lt;kde/kmenubar.h&gt;</blockquote></p>    <p><blockquote>#include &lt;kde/kaboutdialog.h&gt;</blockquote></p>    <p>3. В конструкторах, создающих три виджета <blockquote>KAction</blockquote>, <blockquote>new_file</blockquote> определяется вручную, a <blockquote>quit_action</blockquote> и <blockquote>help_action</blockquote> используют стандартные определения <blockquote>KAction</blockquote>:</p>    <p><blockquote>KDEMenu::KDEMenu(const char *name = 0) : KMainWindow (0L, name) {</blockquote></p>    <p><blockquote> KAction *new_file = new KAction("New", "filenew",</blockquote></p>    <p><blockquote>  KstdAccel::shortcut(KstdAccel::New), this, SLOT(newFile()),</blockquote></p>    <p><blockquote>  this, "newaction");</blockquote></p>    <p><blockquote> KAction *quit_action = KStdAction::quit(KApplication::kApplication(),</blockquote></p>    <p><blockquote>  SLOT(quit()), actionCollection());</blockquote></p>    <p><blockquote> KAction *help_action = KStdAction::aboutApp(this, SLOT(aboutApp()),</blockquote></p>    <p><blockquote>  actionCollection());</blockquote></p>    <p>4. Создайте два меню верхнего уровня и включите их в строку меню <blockquote>KApplication</blockquote>:</p>    <p><blockquote>QPopupMenu *file_menu = new QPopupMenu;</blockquote></p>    <p><blockquote>QPopupMenu *help_menu = new QPopupMenu;</blockquote></p>    <p><blockquote>menuBar()-&gt;insertItem("&amp;File", file_menu);</blockquote></p>    <p><blockquote>menuBar()-&gt;insertItem("&amp;Help", help_menu);</blockquote></p>    <p>5. Теперь вставьте действия в меню и панель инструментов, добавив разделительную линию между <blockquote>new_file</blockquote> и <blockquote>quit_action</blockquote>:</p>    <p><blockquote> new_file-&gt;plug(file_menu);</blockquote></p>    <p><blockquote> file_menu-&gt;insertSeparator();</blockquote></p>    <p><blockquote> quit_action-&gt;plug(file_menu);</blockquote></p>    <p><blockquote> help_action-&gt;plug(help_menu);</blockquote></p>    <p><blockquote> new_file-&gt;plug(toolBar());</blockquote></p>    <p><blockquote> quit_action-&gt;plug(toolBar());</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>6. В заключение несколько определений слотов: <blockquote>aboutApp</blockquote> создает диалоговое окно <blockquote>KAbout</blockquote> для отображения сведений о программе. Учтите, что слот <blockquote>quit</blockquote> определен как часть <blockquote>KApplication</blockquote>:</p>    <p><blockquote>void KDEMenu::newFile() {</blockquote></p>    <p><blockquote> // Создание нового файла</blockquote></p>    <p><blockquote>}</blockquote></p>    <br>    <p><blockquote>void KDEMenu::aboutApp() {</blockquote></p>    <p><blockquote> KAboutDialog *about = new KAboutDialog(this, "dialog");</blockquote></p>    <p><blockquote>  about-&gt;setAuthor(QString("A. N. Author"),</blockquote></p>    <p><blockquote>  QString("an@email.net"), QString("http://url.com"),</blockquote></p>    <p><blockquote>  QString("work"));</blockquote></p>    <p><blockquote> about-&gt;setVersion("1.0");</blockquote></p>    <p><blockquote> about-&gt;show();</blockquote></p>    <p><blockquote>}</blockquote></p>    <br>    <p><blockquote>int main(int argc, char **argv) {</blockquote></p>    <p><blockquote> KApplication app(argc, argv, "cdapp");</blockquote></p>    <p><blockquote> KDEMenu* window = new KDEMenu("kdemenu");</blockquote></p>    <p><blockquote> app.setMainWidget(window);</blockquote></p>    <p><blockquote> window-&gt;show();</blockquote></p>    <p><blockquote> return app.exec();</blockquote></p>    <p><blockquote>}</blockquote> </p>    <p>7. Далее вам нужен файл menu.pro для утилиты <blockquote>qmake</blockquote>:</p>    <p><blockquote>TARGET = kdemenu</blockquote></p>    <p><blockquote>MOC_DIR = moc</blockquote></p>    <p><blockquote>OBJECTS_DIR = obj</blockquote></p>    <p><blockquote>INCLUDEPATH = /usr/include/kde</blockquote></p>    <p><blockquote>QMAKE_LIBDIR_X11 += -L$KDEDIR/lib</blockquote></p>    <p><blockquote>QMAKE_LIBS_X11 += -lkdeui -lkdecore</blockquote></p>    <p><blockquote>SOURCES = KDEMenu.cpp</blockquote></p>    <p><blockquote>HEADERS = KDEMenu.h</blockquote></p>    <p>8. Теперь запустите <blockquote>qmake</blockquote> для создания make-файла, откомпилируйте и выполните программу:</p>    <p><blockquote>$ <b>qmake menu.pro -о Makefile</b></blockquote></p>    <p><blockquote>$ <b>make</b></blockquote></p>    <p><blockquote>$ <b>./kdemenu</b></blockquote></p>    <p><b>Как это работает</b></p>    <p>Несмотря на то, что этот пример получился чуть длиннее других, программный код довольно краток, если учесть всю выполняемую им работу по созданию строки меню и самих меню. Лучшее качество виджетов <blockquote>KAction</blockquote> — возможность использования каждого из них в разных частях программы, таких как панель инструментов и меню в строке меню, все упомянутые возможности показаны в данном примере.</p>    <p>Построение приложений KDE требует больше работы, чем создание большинства программ, по крайней мере, на первый взгляд. В действительности файл menu.pro и команда <blockquote>qmake</blockquote> скрывают большой набор параметров, которые в противном случае вам пришлось бы вставлять вручную в ваш make-файл.</p>    <p>На рис. 17.11 и 17.12 показано, как появляются в окне меню и кнопки панели инструментов.</p>    <img src="image076.jpg"/>    <p><b>Рис. 17.11</b> </p>    <br>    <br>    <img src="image077.jpg"/>    <p><b>Рис. 17.12</b> </p>    <br>    <p>И вот оно! Мы закончили наш тур по Qt и KDE, рассмотрев базовые элементы, всех приложений GUI, окна, схемы размещения, кнопки, диалоговые окна и меню. Существует бесчисленное множество виджетов Qt и KDE, о которых мы не упоминали, начиная с <blockquote>QColorDialog</blockquote> — диалогового окна для выбора цвета — и заканчивая <blockquote>KHTML</blockquote> — виджетом Web-обозревателя — все они подробно описаны на Web-сайтах компании Trolltech и графической среды KDE. </p>          <a name="metkadoc16"><h1>Приложение для работы с базой данных компакт-дисков с использованием KDE/Qt</h1></a>         <p>Теперь, когда вы можете использовать силу и мощь KDE/Qt, пришло время снова обратить внимание на приложение для работы с компакт-дисками, чтобы привести его в чувство.</p>     <p>Напоминаем, чего вы хотите добиться от вашего приложения для работы с базой данных компакт-дисков:</p>     <p>&#9633; регистрация в базе данных из графического пользовательского интерфейса;</p>     <p>&#9633; поиск компакт-диска в базе данных;</p>     <p>&#9633; вывод информации о компакт-диске и его дорожках;</p>     <p>&#9633; добавление компакт-диска в базу данных;</p>     <p>&#9633; отображение окна <b>About</b> (О программе).</p>             <a name="metkadoc17"><h1><i>MainWindow</i></h1></a>     <p><b>Начнем обсуждение с программного кода для главного окна приложения, которое содержит виджет поля поиска и список для отображения результатов поиска.</b></p>     <p>1. Начните с ввода программного кода в файл MainWindow.h (или загрузите его с Web-сайта книги). Поскольку окно содержит виджет <blockquote>QLineEdit</blockquote> для поиска компакт-дисков и виджет <blockquote>QListView</blockquote> для вывода результатов поиска, вы должны вставить в программный код заголовочные файлы qlistview.h и qlineedit.h:</p>     <p><blockquote>#include &lt;kde/kmainwindow.h&gt;</blockquote></p>     <p><blockquote>#include &lt;qlistview.h&gt;</blockquote></p>     <p><blockquote>#include &lt;qlineedit.h&gt;</blockquote></p>     <br>     <p><blockquote>class MainWindow : public KMainWindow {</blockquote></p>     <p><blockquote> Q_OBJECT</blockquote></p>     <p><blockquote>public:</blockquote></p>     <p><blockquote> MainWindow(const char *name);</blockquote></p>     <p><blockquote>public slots:</blockquote></p>     <p><blockquote> void doSearch();</blockquote></p>     <p><blockquote> void Added();</blockquote></p>     <p><blockquote>private:</blockquote></p>     <p><blockquote> QListView *list;</blockquote></p>     <p><blockquote> QLineEdit *search_entry;</blockquote></p>     <p><blockquote>};</blockquote></p>     <p>2. MainWindow.срр — самая сложная часть программы. В конструкторе вы создаете интерфейс главного окна и связываете необходимые сигналы с вашими слотами. Как обычно, начните программу с файлов в директивах <blockquote>#include</blockquote>:</p>     <p><blockquote>#include "MainWindow.h"</blockquote></p>     <p><blockquote>#include "AddCdDialog.h"</blockquote></p>     <p><blockquote>#include "app_mysql.h"</blockquote></p>     <p><blockquote>#include &lt;qvbox.h&gt;</blockquote></p>     <p><blockquote>#include &lt;qlineedit.h&gt;</blockquote></p>     <p><blockquote>#include &lt;qpushbutton.h&gt;</blockquote></p>     <p><blockquote>#include &lt;qlabel.h&gt;</blockquote></p>     <p><blockquote>#include &lt;qlistview.h&gt;</blockquote></p>     <p><blockquote>#include &lt;kde/kapp.h&gt;</blockquote></p>     <p><blockquote>#include &lt;kde/kmenubar.h&gt;</blockquote></p>     <p><blockquote>#include &lt;kde/klocale.h&gt;</blockquote></p>     <p><blockquote>#include &lt;kde/kpopupmenu.h&gt;</blockquote></p>     <p><blockquote>#include &lt;kde/kstatusbar.h&gt;</blockquote></p>     <p><blockquote>#include &lt;kde/kaction.h&gt;</blockquote></p>     <p><blockquote>#include &lt;kde/kstdaccel.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <br>     <p><blockquote>MainWindow::MainWindow(const char * name) : KMainWindow(0L, name) {</blockquote></p>     <p><blockquote> setCaption("CD Database");</blockquote></p>     <p>3. Теперь создайте элементы меню и панели инструментов с помощью виджета <blockquote>KAction</blockquote>.</p>     <p><blockquote>KAction *addcd_action = new KAction("&amp;Add CD", "filenew",</blockquote></p>     <p><blockquote> KStdAccel::shortcut(KStdAccel::New), this, SLOT(AddCd()), this);</blockquote></p>     <p><blockquote> KAction *quit_action = KStdAction::quit(KApplication::kApplication(),</blockquote></p>     <p><blockquote>  SLOT(quit()), actionCollection());</blockquote></p>     <p><blockquote> QPopupMenu* filemenu = new QPopupMenu;</blockquote></p>     <p><blockquote> QString about = ("CD App\n\n"</blockquote></p>     <p><blockquote>  "(C) 2007 Wrox Press\n" "email@email.com\n");</blockquote></p>     <p><blockquote> QPopupMenu* helpmenu = helpMenu(about);</blockquote></p>     <p><blockquote> menuBar()-&gt;insertItem("&amp;File", filemenu);</blockquote></p>     <p><blockquote> menuBar()-&gt;insertltem(i18n("&amp;Help"), helpmenu);</blockquote></p>     <p><blockquote> addcd_action-&gt;plug(filemenu);</blockquote></p>     <p><blockquote> filemenu-&gt;insertSeparator();</blockquote></p>     <p><blockquote> quit_action-&gt;plug(filemenu);</blockquote></p>     <p><blockquote> addcd_action-&gt;plug(toolBar());</blockquote></p>     <p><blockquote> quit_action-&gt;plug(toolBar());</blockquote></p>     <p>4. Для разнообразия примените виджеты <blockquote>QBoxLayout</blockquote> вместо обычных классов <blockquote>QLayout</blockquote>:</p>     <p><blockquote> QVBox *vbox = new QVBox(this);</blockquote></p>     <p><blockquote> QHBox *hbox = new QHBox(vbox);</blockquote></p>     <p><blockquote> QLabel* label = new QLabel(hbox);</blockquote></p>     <p><blockquote> label-&gt;setText("Search Text: ");</blockquote></p>     <p><blockquote> search_entry = new QLineEdit(hbox);</blockquote></p>     <p><blockquote> QPushButton *button = new QPushButton("Search", hbox);</blockquote></p>     <p>5. Далее следует виджет <blockquote>QListView</blockquote>, занимающий основную часть рабочей области окна. После этого для поиска компакт-диска в базе данных вы связываете необходимые сигналы с вашим слотом <blockquote>doSearch</blockquote>. Строка состояния <blockquote>KMainWindow</blockquote> становится видимой за счет вставки пустого сообщения:</p>     <p><blockquote> list = new QListView(vbox, "name", 0L);</blockquote></p>     <p><blockquote> list-&gt;setRootIsDecorated(TRUE);</blockquote></p>     <p><blockquote> list-&gt;addColumn("Title");</blockquote></p>     <p><blockquote> list-&gt;addColumn("Artist");</blockquote></p>     <p><blockquote> list-&gt;addColumn("Catalogue");</blockquote></p>     <p><blockquote> connect(button, SIGNAL(clicked()), this, SLOT(doSearch()));</blockquote></p>     <p><blockquote> connect(search_entry, SIGNAL(returnPressed()), this, SLOT(doSearch()));</blockquote></p>     <p><blockquote> statusBar()-&gt;message("");</blockquote></p>     <p><blockquote> setCentralWidget(vbox);</blockquote></p>     <p><blockquote> resize(300, 400);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>6. Слот <blockquote>doSearch</blockquote> — рабочее завершение приложения. В нем считывается строка поиска и выбираются все соответствующие ей компакт-диски и их дорожки. Логика слота такая же, как в функции <blockquote>doSearch</blockquote> GNOME/GTK+ в<i> главе 16.</i></p>     <p><blockquote>void MainWindow::doSearch() {</blockquote></p>     <p><blockquote> cd_search_st *cd_res = new cd_search_st;</blockquote></p>     <p><blockquote> current_cd_st *cd = new current_cd_st;</blockquote></p>     <p><blockquote> struct current_tracks_st ct;</blockquote></p>     <p><blockquote> int res1, i, j, res2, res3;</blockquote></p>     <p><blockquote> char track_title[110];</blockquote></p>     <p><blockquote> char search_text[100];</blockquote></p>     <p><blockquote> char statusBar_text[200];</blockquote></p>     <p><blockquote> QListViewItem *cd_item;</blockquote></p>     <p><blockquote> strcpy(search_text, search_entry-&gt;text());</blockquote></p>     <p>7. Извлеките <blockquote>id</blockquote> соответствующих компакт-дисков и обновите строку состояния, чтобы отобразить результаты поиска:</p>     <p><blockquote> res1 = find_cds(search_text, cd_res);</blockquote></p>     <p><blockquote> sprintf(statusBar_text,</blockquote></p>     <p><blockquote>  " Displaying %d result(s) for search string ' %s'",</blockquote></p>     <p><blockquote>  res1, search_text);</blockquote></p>     <p><blockquote> statusBar()-&gt;message(statusBar_text);</blockquote></p>     <p><blockquote> i = 0;</blockquote></p>     <p><blockquote> list-&gt;clear();</blockquote></p>     <p>8. Для каждого <blockquote>id</blockquote> извлеките сведения о компакт-диске в виджет <blockquote>QListView</blockquote> и информацию обо всех дорожках данного CD:</p>     <p><blockquote> while (i &lt; res1) {</blockquote></p>     <p><blockquote>  res2 = get_cd(cd_res-&gt;cd_id[i], cd);</blockquote></p>     <p><blockquote>  cd_item = new QListViewItem(list, cd-&gt;title, cd-&gt;artist_name,</blockquote></p>     <p><blockquote>   cd-&gt;catalogue);</blockquote></p>     <p><blockquote>  res3 = get_cd_tracks(cd_res-&gt;cd_id[i++], &amp;ct);</blockquote></p>     <p><blockquote>  j = 0;</blockquote></p>     <p><blockquote>  /* Заполните дерево дорожками текущего компакт-диска */</blockquote></p>     <p><blockquote>  while (j &lt; res3) {</blockquote></p>     <p><blockquote>   sprintf(track_title, " Track %d. ", j+1);</blockquote></p>     <p><blockquote>   strcat(track_title, ct.track[j++]);</blockquote></p>     <p><blockquote>   new QListViewItem(cd_item, track_title);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote>}</blockquote></p>     <img src="image078.jpg"/>     <p><b>Рис. 17.13</b></p>     <br>     <p>9. Слот <blockquote>AddCd</blockquote> вызывается, когда активизирован пункт меню или кнопка панели инструментов <blockquote>addcd_action</blockquote>:</p>     <p><blockquote>void MainWindow::AddCd()</blockquote></p>     <p><blockquote> AddCdDialog* dialog = new AddCdDialog(this);</blockquote></p>     <p><blockquote> dialog-&gt;show();</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Результат показан на рис. 17.13.</p>             <a name="metkadoc18"><h1><i>AddCdDialog</i></h1></a>     <p>Для вставки сведений о компакт-диске в базу данных вам нужно включить в программу диалоговое окно с полями, необходимыми для ввода информации.</p>     <p>1. Введите следующий программный код в файл AddCdDialog.h. Имейте в виду, что класс <blockquote>AddCdDialog</blockquote> — потомок <blockquote>KDialogBase</blockquote>, виджета диалогового окна в среде KDE.</p>     <p><blockquote>#include &lt;kde/kdialogbase.h&gt;</blockquote></p>     <p><blockquote>#include &lt;qlineedit.h&gt;</blockquote></p>     <br>     <p><blockquote>class AddCdDialog : public KDialogBase {</blockquote></p>     <p><blockquote> Q_OBJECT</blockquote></p>     <p><blockquote>public:</blockquote></p>     <p><blockquote> AddCdDialog(QWidget* parent);</blockquote></p>     <p><blockquote>private:</blockquote></p>     <p><blockquote> QLineEdit* artist_entry, *title_entry, *catalogue_entry;</blockquote></p>     <p><blockquote>public slots:</blockquote></p>     <p><blockquote> void okClicked();</blockquote></p>     <p><blockquote>};</blockquote></p>     <p>2. Далее следует файл AddCdDialog.cpp, в котором в слоте <blockquote>okClicked</blockquote> вызывается функция <blockquote>add_cd</blockquote> из интерфейса MySQL:</p>     <p><blockquote>#include "AddCdDialog.h"</blockquote></p>     <p><blockquote>#include "app_mysql.h"</blockquote></p>     <p><blockquote>#include &lt;qlayout.h&gt;</blockquote></p>     <p><blockquote>#include &lt;qlabel.h&gt;</blockquote></p>     <p><blockquote>AddCdDialog::AddCdDialog(QWidget* parent)</blockquote></p>     <p><blockquote> : KDialogBase(parent, "AddCD", false, "Add CD",</blockquote></p>     <p><blockquote> KDialogBase::Ok | KDialogBase::Cancel, KDialogBase::Ok, true) {</blockquote></p>     <p><blockquote> QWidget *widget = new QWidget(this);</blockquote></p>     <p><blockquote> setMainWidget(widget);</blockquote></p>     <p><blockquote> QGridLayout *grid = new QGridLayout(widget, 3, 2, 10, 5, "grid");</blockquote></p>     <p><blockquote> grid-&gt;addWidget(new QLabel("Artist", widget, "artistlabel"), 0, 0, 0);</blockquote></p>     <p><blockquote> grid-&gt;addWidget(new QLabel("Title", widget, "titlelabel"), 1, 0, 0);</blockquote></p>     <p><blockquote> grid-&gt;addwidget(new QLabel("Catalogue", widget, "cataloguelabel"), 2, 0, 0);</blockquote></p>     <p><blockquote> artist_entry = new QLineEdit(widget, "artist_entry");</blockquote></p>     <p><blockquote> title_entry = new QLineEdit(widget, "titleentry");</blockquote></p>     <p><blockquote> catalogue_entry = new QLineEdit(widget, "catalogue_entry");</blockquote></p>     <p><blockquote> grid-&gt;addWidget(artist_entry, 0, 1, 0);</blockquote></p>     <p><blockquote> grid-&gt;addWidget(title_entry, 1, 1, 0);</blockquote></p>     <p><blockquote> grid-&gt;addWidget(catalogue_entry, 2, 1, 0);</blockquote></p>     <p><blockquote> connect(this, SIGNAL(okClicked()), this, SLOT(okClicked()));</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote>void AddCdDialog::okClicked() {</blockquote></p>     <p><blockquote> char artist[200];</blockquote></p>     <p><blockquote> char title[200];</blockquote></p>     <p><blockquote> char catalogue[200];</blockquote></p>     <p><blockquote> int cd_id = 0;</blockquote></p>     <p><blockquote> strcpy(artist, artist_entry-&gt;text());</blockquote></p>     <p><blockquote> strcpy(title, title_entry-&gt;text());</blockquote></p>     <p><blockquote> strcpy(catalogue, catalogue_entry-&gt;text());</blockquote></p>     <p><blockquote> add_cd(artist, title, catalogue, &amp;cd_id);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>На рис. 17.14 показано работающее диалоговое окно <blockquote>AddCdDialog</blockquote>.</p>     <img src="image079.jpg"/>     <p><b>Рис. 17.14</b> </p>             <a name="metkadoc19"><h1><i>LogonDialog</i></h1></a>     <p>Вы, конечно же, не сможете запрашивать базу данных без предварительной регистрации, поэтому вам необходимо простое диалоговое окно для ввода имени пользователя и пароля. Назовите этот класс <blockquote>LogonDialog</blockquote>. (Да, еще один пример остроумного и образного имени!)</p>     <p>1. Начнем с заголовочного файла. Введите приведенный далее программный код и назовите файл LogonDialog.h. Обратите внимание на то, что для разнообразия этот класс описан в данном случае как потомок класса <blockquote>QDialog</blockquote>, а не <blockquote>KDialogBase</blockquote>.</p>     <p><blockquote>#include &lt;qdialog.h&gt;</blockquote></p>     <p><blockquote>#include &lt;qlineedit.h&gt;</blockquote></p>     <br>     <p><blockquote>class LogonDialog : public QDialog {</blockquote></p>     <p><blockquote> Q_OBJECT</blockquote></p>     <p><blockquote>public:</blockquote></p>     <p><blockquote> LogonDialog(QWidget* parent = 0, const char *name = 0);</blockquote></p>     <p><blockquote> QString getUsername();</blockquote></p>     <p><blockquote>QString getPassword();</blockquote></p>     <p><blockquote>private:</blockquote></p>     <p><blockquote> QLineEdit *username_entry, *password_entry;</blockquote></p>     <p><blockquote>};</blockquote></p>     <p>2. У вас есть более удобные методы для имени пользователя и пароля, чем инкапсуляция в файле LogonDialog.cpp вызова <blockquote>database_start</blockquote>. Далее приведен файл LogonDialog.cpp:</p>     <p><blockquote>#include "LogonDialog.h"</blockquote></p>     <p><blockquote>#include "appmysql.h"</blockquote></p>     <p><blockquote>#include &lt;qpushbutton.h&gt;</blockquote></p>     <p><blockquote>#include &lt;qlayout.h&gt;</blockquote></p>     <p><blockquote>#include &lt;qlabel.h&gt;</blockquote></p>     <br>     <p><blockquote>LogonDialog::LogonDialog(QWidget *parent, const char *name):</blockquote></p>     <p><blockquote> QDialog(parent, name) {</blockquote></p>     <p><blockquote> QGridLayout *grid = new QGridLayout(this, 3, 2, 10, 5, "grid");</blockquote></p>     <p><blockquote> grid-&gt;addWidget(new QLabel("Username", this, "usernamelabel"), 0, 0, 0);</blockquote></p>     <p><blockquote> grid-&gt;addWidget(new QLabel("Password", this, "passwordlabel"), 1, 0, 0);</blockquote></p>     <p><blockquote> username_entry = new QLineEdit(this, "username entry");</blockquote></p>     <p><blockquote> password_entry = new QLineEdit(this, "password_entry");</blockquote></p>     <p><blockquote> password_entry-&gt;setEchoMode(QLineEdit::Password);</blockquote></p>     <p><blockquote> grid-&gt;addWidget(username_entry, 0, 1, 0);</blockquote></p>     <p><blockquote> grid-&gt;addWidget(passwordentry, 1, 1, 0);</blockquote></p>     <p><blockquote> QPushButton* button = new QPushButton("Ok", this, "button");</blockquote></p>     <p><blockquote> grid-&gt;addWidget(button, 2, 1, Qt::AlignRight);</blockquote></p>     <p><blockquote> connect (button, SIGNAL(clicked()), this, SLOT(accept()));</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote>QString LogonDialog::getUsername() {</blockquote></p>     <p><blockquote> if (username_entry == NULL) return NULL;</blockquote></p>     <p><blockquote> return username_entry-&gt;text();</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote>QString LogonDialog::getPassword() {</blockquote></p>     <p><blockquote> if (password_entry == NULL) return NULL;</blockquote></p>     <p><blockquote> return password_entry-&gt;text();</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>На рис. 17.15 показано, как будет выглядеть диалоговое окно.</p>     <img src="image080.jpg"/>     <p><b>Рис. 17.15</b> </p>             <a name="metkadoc20"><h1>main.cpp</h1></a>     <p>Единственный оставшийся программный код — функция <blockquote>main</blockquote>, которую вы помещаете в отдельный файл main.cpp.</p>     <p>1. В файле main.cpp вы открываете окно <blockquote>LogonDialog</blockquote> и получаете успешную регистрацию из функции <blockquote>database_start</blockquote>. Если регистрация оказалась неудачной, вы выводите окно <blockquote>QMessageBox</blockquote> или при попытке закрыть <blockquote>LogonDialog</blockquote> просите у пользователя подтверждения его выхода.</p>     <p><blockquote>#include "MainWindow.h"</blockquote></p>     <p><blockquote>#include "app_mysql.h"</blockquote></p>     <p><blockquote>#include "LogonDialog.h"</blockquote></p>     <p><blockquote>#include &lt;kde/kapp.h&gt;</blockquote></p>     <p><blockquote>#include &lt;qmessagebox.h&gt;</blockquote></p>     <br>     <p><blockquote>int main(int argc, char **argv) {</blockquote></p>     <p><blockquote> char username[100];</blockquote></p>     <p><blockquote> char password[100];</blockquote></p>     <p><blockquote> KApplication a(argc, argv, "cdapp");</blockquote></p>     <p><blockquote> LogonDialog *dialog = new LogonDialog();</blockquote></p>     <p><blockquote> while (1) {</blockquote></p>     <p><blockquote>  if (dialog-&gt;exec() == QDialog::Accepted) {</blockquote></p>     <p><blockquote>   strcpy(username, dialog-&gt;getUsername());</blockquote></p>     <p><blockquote>   strcpy(password, dialog-&gt;getPassword());</blockquote></p>     <p><blockquote>   if (database_start(username, password)) break;</blockquote></p>     <p><blockquote>   QMessageBox::information(0, "Title",</blockquote></p>     <p><blockquote>    "Could not Logon: Check username and/or password",</blockquote></p>     <p><blockquote>    QMessageBox::Ok);</blockquote></p>     <p><blockquote>   continue;</blockquote></p>     <p><blockquote>  } else {</blockquote></p>     <p><blockquote>   if (QMessageBox:information(0, "Title",</blockquote></p>     <p><blockquote>    "Are you sure you want to quit?", QMessageBox::Yes,</blockquote></p>     <p><blockquote>    QMessageBox::No) == QMessageBox::Yes) {</blockquote></p>     <p><blockquote>    return 0;</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> delete dialog;</blockquote></p>     <p><blockquote> MainWindow *window = new MainWindow("Cd App");</blockquote></p>     <p><blockquote> window-&gt;resize(600, 400);</blockquote></p>     <p><blockquote> a.setMainWidget(window);</blockquote></p>     <p><blockquote> window-&gt;show();</blockquote></p>     <p><blockquote> return a.exec();</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>2. Осталось только написать pro-файл для утилиты <blockquote>qmake</blockquote>. Назовите его cdapp.pro:</p>     <p><blockquote>TARGET = app</blockquote></p>     <p><blockquote>MOC_DIR = moc</blockquote></p>     <p><blockquote>OBJECTS_DIR = obj</blockquote></p>     <p><blockquote>INCLUDEPATH = /usr/include/kde /usr/include/mysql</blockquote></p>     <p><blockquote>QMAKE_LIBDIR_X11 += -/usr/lib</blockquote></p>     <p><blockquote>QMAKE_LIBDIR_X11 += /usr/lib/mysql</blockquote></p>     <p><blockquote>QMAKE_LIBS_X11 += -lkdeui -lkdecore -lmysqlclient</blockquote></p>     <p><blockquote>SOURCES = MainWindow.cpp main.cpp app_mysql.cpp AddCdDialog.cpp LogonDialog.cpp</blockquote></p>     <p><blockquote>HEADERS = MainWindow.h app_mysql.h AddCdDialog.h LogonDialog.h</blockquote></p>     <blockquote>      <b>Примечание</b>      <p>Обратите внимание на то, что приведенный программный код позволяет вам немного схитрить, просто переименовав файл app_mysql.c в файл app_mysql.cpp; таким образом, вы сможете использовать его как обычный исходный файл на языке С++. Это устраняет небольшое усложнение, необходимость редактирования связей или компоновки объектного файла на языке С и объектного файла на языке С++,</p>     </blockquote>     <p><blockquote>$ <b>qmake cdapp.pro -о Makefile</b></blockquote></p>     <p><blockquote>$ <b>make</b></blockquote></p>     <p><blockquote>$ <b>./арр</b></blockquote></p>     <p>Если все нормально, вы должны получить работающую базу данных компакт-дисков!</p>     <p>Для того чтобы глубже понять KDE/Qt, можно попробовать реализовать другие функции в интерфейсе MySQL, такие как добавление дорожек в компакт-диски или удаление компакт-дисков. Вам понадобятся диалоговые окна, новые элементы меню и панели инструментов, придется также запрограммировать внутреннюю логику. Сделайте такую попытку!</p>              <a name="metkadoc21"><h1>Резюме </h1></a>    <p>В этой главе вы научились применять библиотеку графического пользовательского интерфейса Qt и рассмотрели виджеты графической среды KDE в действии. Вы узнали, что Qt — это библиотека на языке С++, применяющая механизм "сигнал/слот" для реализации программирования, управляемого событиями. Вы познакомились с основными виджетами Qt и написали несколько программ-примеров для демонстрации их практического применения. В заключение средствами KDE/Qt реализован графический пользовательский интерфейс вашего приложения для работы с компакт-дисками. </p>     <br><br>
<center><div align="center"><a href="index.php.html">Оглавление</a></div></center>




<br>
<script type="text/javascript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="https://www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script><br>

<noindex>
<div align="center">
<center>

<!-- SAPE RTB DIV 600x340 -->
<div id="SRTB_507029"></div>
<!-- SAPE RTB END -->

</center>
</div>
</noindex>

</td>
<td width="240" valign="top">

<br>

<div id="menu3">
<ul>
<li><a href="../../alternativnaja_medicina/index.html"><span>Альтернативная медицина</span></a></li>
<li><a href="../../astronomija_i_kosmos/index.html"><span>Астрономия и Космос</span></a></li>
<li><a href="../../biologija/index.html"><span>Биология</span></a></li>
<li><a href="../../voennaja_istorija/index.html"><span>Военная история</span></a></li>
<li><a href="../../geologija_i_geografija/index.html"><span>Геология и география</span></a></li>
<li><a href="../../gosudarstvo_i_pravo/index.html"><span>Государство и право</span></a></li>
<li><a href="../../delovaja_literatura/index.html"><span>Деловая литература</span></a></li>
<li><a href="../../domashnie_zhivotnye/index.html"><span>Домашние животные</span></a></li>
<li><a href="../../domovodstvo/index.html"><span>Домоводство</span></a></li>
<li><a href="../../zdorove/index.html"><span>Здоровье</span></a></li>
<li><a href="../../istorija/index.html"><span>История</span></a></li>
<li><a href="../index.html"><span>Компьютеры и Интернет</span></a></li>
<li><a href="../../kulinarija/index.html"><span>Кулинария</span></a></li>
<li><a href="../../kulturologija/index.html"><span>Культурология</span></a></li>
<li><a href="../../literaturovedenie/index.html"><span>Литературоведение</span></a></li>
<li><a href="../../matematika/index.html"><span>Математика</span></a></li>
<li><a href="../../medicina/index.html"><span>Медицина</span></a></li>
<li><a href="../../nauchnaja_literatura_prochee/index.html"><span>Науч. литер. - прочее</span></a></li>
<li><a href="../../pedagogika/index.html"><span>Педагогика</span></a></li>
<li><a href="../../politika/index.html"><span>Политика</span></a></li>
<li><a href="../../psihologija/index.html"><span>Психология</span></a></li>
<li><a href="../../religiovedenie/index.html"><span>Религиоведение</span></a></li>
<li><a href="../../sad_i_ogorod/index.html"><span>Сад и огород</span></a></li>
<li><a href="../../samosovershenstvovanie/index.html"><span>Самосовершенствование</span></a></li>
<li><a href="../../sdelai_sam/index.html"><span>Сделай сам</span></a></li>
<li><a href="../../sport/index.html"><span>Спорт</span></a></li>
<li><a href="../../tehnicheskie_nauki/index.html"><span>Технические науки</span></a></li>
<li><a href="../../transport_i_aviacija/index.html"><span>Транспорт и авиация</span></a></li>
<li><a href="../../uchebniki/index.html"><span>Учебники</span></a></li>
<li><a href="../../fizika/index.html"><span>Физика</span></a></li>
<li><a href="../../filosofija/index.html"><span>Философия</span></a></li>
<li><a href="../../himija/index.html"><span>Химия</span></a></li>
<li><a href="../../hobbi_i_remesla/index.html"><span>Хобби и ремесла</span></a></li>
<li><a href="../../shpargalki/index.html"><span>Шпаргалки</span></a></li>
<li><a href="../../yezoterika/index.html"><span>Эзотерика</span></a></li>
<li><a href="../../yurisprudencija/index.html"><span>Юриспруденция</span></a></li>
<li><a href="../../jazykoznanie/index.html"><span>Языкознание</span></a></li>
</ul>
</div>

<br>
<div align="center">
<center>
<noindex>

<!-- SAPE RTB DIV 240x400 -->
<div id="SRTB_507028"></div>
<!-- SAPE RTB END -->

</noindex>
</center>
</div>

</td>
</tr>
<tr>
<td colspan="3" align="center">


<hr>
<a href="../../index.html"><span>Главная</span></a> | 
<a rel="sidebar" href="p21.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a> | 
<a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a> | 
<a href="p21.php.html#" onClick="scroll(0,0); return false" title="наверх">Наверх</a>
</td>
</tr>
<tr>
<td colspan="3" valign="top" align="left">
<br>

 



</td>
</tr>
</table>

<noindex>
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter21717787 = new Ya.Metrika({id:21717787,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="http://mc.yandex.ru/watch/21717787" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

</noindex>
</center>
</div></body>
</html>