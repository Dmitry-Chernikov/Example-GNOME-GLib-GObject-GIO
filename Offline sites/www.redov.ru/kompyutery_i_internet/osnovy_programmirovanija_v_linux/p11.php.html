<html>
<head>
<meta http-equiv="Content-Language" content="ru">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<link href="../../0img/style.css" rel="stylesheet" type="text/css" />
<link rel="SHORTCUT ICON" href="http://www.redov.ru/0img/favicon.ico" type="image/x-icon"> 
<title>Глава 7 Управление данными / Основы программирования в Linux</title>
</head>
<body>
<div align="center">
<center>
<table border="0" cellpadding="0" cellspacing="0" width="1260">
<tr>
<td colspan="3" valign="top" align="left" height="100">
<table border="0" cellpadding="0" cellspacing="0" width="1260" height="100">
<tr>
<td valign="middle" align="center" width="350">
<a href="../../index.html"><img src="../../0img/logo.jpg" width="350" height="100" title="Онлайн библиотека redov.ru"/></a>
</td>
<td valign="middle" align="center" width="910">

<noindex>

<!-- SAPE RTB JS -->
<script
    async="async"
    src="http://cdn-rtb.sape.ru/rtb-b/js/393/2/106393.js"
    type="text/javascript">
</script>
<!-- SAPE RTB END -->

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507025"></div>
<!-- SAPE RTB END -->

</noindex>

</td>
</tr>
</table>
</td>
</tr>
<tr>
<td colspan="3" valign="middle" align="left">

<div id="menu">
<ul>
		<li><a href="../../index.html"><span>Главная</span></a></li>
		<li><a rel="sidebar" href="p11.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a></li>
		<li><a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a></li>
		<li><a href="p11.php.html#" onClick="scroll(0,9999999); return false"><span>Вниз</span></a></li>
</ul>
</div>


</td>
</tr>
<tr>
<td width="240" valign="top" align="center">

<br>
<noindex>
<!-- SAPE RTB DIV 160x600 -->
<div id="SRTB_733378"></div>
<!-- SAPE RTB END -->
</noindex>



</td>
<td valign="top" align="left" style="padding-left: 5; padding-right: 5" width="780">
<br>
<noindex>
<div align="center">

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507027"></div>
<!-- SAPE RTB END -->

</div>
</noindex>
<br>



<li><a href="p11.php.html#metkadoc2">     Управляемая память     </a></li>
<li><a href="p11.php.html#metkadoc3">      Простое выделение памяти      </a></li>
<li><a href="p11.php.html#metkadoc4">      Выделение огромных объемов памяти      </a></li>
<li><a href="p11.php.html#metkadoc5">      Неправильное обращение к памяти      </a></li>
<li><a href="p11.php.html#metkadoc6">      Указатель <i>null</i>      </a></li>
<li><a href="p11.php.html#metkadoc7">      Освобождение памяти      </a></li>
<li><a href="p11.php.html#metkadoc8">      Другие функции распределения памяти      </a></li>
<li><a href="p11.php.html#metkadoc9">     Блокировка файлов     </a></li>
<li><a href="p11.php.html#metkadoc10">      Создание файлов с блокировкой      </a></li>
<li><a href="p11.php.html#metkadoc11">      Блокировка участков файла      </a></li>
<li><a href="p11.php.html#metkadoc12">      Применение вызовов <i>read</i> и <i>write </i>при наличии блокировки      </a></li>
<li><a href="p11.php.html#metkadoc13">      Конкурирующие блокировки      </a></li>
<li><a href="p11.php.html#metkadoc14">      Другие команды блокировок      </a></li>
<li><a href="p11.php.html#metkadoc15">      Взаимоблокировки      </a></li>
<li><a href="p11.php.html#metkadoc16">     Базы данных     </a></li>
<li><a href="p11.php.html#metkadoc17">      База данных dbm      </a></li>
<li><a href="p11.php.html#metkadoc18">      Подпрограммы<i> dbm</i>      </a></li>
<li><a href="p11.php.html#metkadoc19">      Функции доступа dbm      </a></li>
<li><a href="p11.php.html#metkadoc20">      Дополнительные функции dbm      </a></li>
<li><a href="p11.php.html#metkadoc21">     Приложение для работы с коллекцией компакт-дисков     </a></li>
<li><a href="p11.php.html#metkadoc22">      Обновление проектного решения      </a></li>
<li><a href="p11.php.html#metkadoc23">      Приложение управления базой данных компакт-дисков, использующее dbm      </a></li>
<li><a href="p11.php.html#metkadoc24">     Резюме     </a></li>
<a name="metkadoc1"><h1>Глава 7</p>    <p>Управление данными</h1></a>       <p>В предыдущих главах мы касались темы ограниченности ресурсов. В этой главе мы собираемся рассмотреть сначала способы управления распределением ресурсов, затем методы обработки файлов, к которым обращается много пользователей примерно в одно и то же время, и наконец, одно средство, предоставляемое в системах Linux и позволяющее преодолеть ограничения простых файлов как среды хранения данных.</p>    <p>Мы можем представить все эти темы как три способа управления данными:</p>    <p><i>&#9633; управление динамической памятью</i>: что делать и что Linux не разрешит делать;</p>    <p>&#9633; <i>блокировка файлов</i>: совместная блокировка, блокируемые области совместно используемых файлов и обход взаимоблокировок;</p>    <p>&#9633; <i>база данных dbm</i>: базовая, основанная не на запросах SQL библиотека базы данных, присутствующая в большинстве систем Linux.</p>          <a name="metkadoc2"><h1>Управляемая память</h1></a>         <p>Во всех компьютерных системах память — дефицитный ресурс. Не важно, сколько памяти доступно, ее всегда не хватает. Кажется, совсем недавно считалось, что 256 Мбайт RAM вполне достаточно, а сейчас распространено мнение о том, что 2 Гбайт RAM — это обоснованное минимальное требование даже для настольных систем, а серверам полезно было бы иметь значительно больше.</p>     <p>У всех UNIX-подобных операционных систем, начиная с самых первых версий, был ясный подход к управлению памятью, который унаследовала ОС Linux, воплощающая стандарт X/Open. Приложениям в ОС Linux, за исключением нескольких специализированных встроенных приложений, никогда не разрешается напрямую обращаться к физической памяти. Приложению может казаться, что у него есть такая возможность, но самом деле это тщательно управляемая иллюзия. </p>     <p>Система Linux снабжает приложения четким представлением огромной прямо адресуемой области оперативной памяти. Кроме того, она обеспечивает защиту приложений друг от друга и позволяет им явно обращаться к объему памяти, большему, чем имеющаяся физическая память в машине, хорошо настроенной и имеющей достаточную область свопинга или подкачки.</p>             <a name="metkadoc3"><h1>Простое выделение памяти</h1></a>     <p>Вы можете выделить память с помощью вызова <blockquote>malloc</blockquote> из стандартной библиотеки С:</p>     <p><blockquote><b>#include &lt;stdlib.h&gt;</b></blockquote></p>     <p><blockquote><b>void *malloc(size_t size);</b></blockquote></p>     <blockquote>      <b>Примечание</b>      <p>Имейте в виду, что ОС Linux (следующая требованиям стандарта X/Open) отличается от некоторых реализаций UNIX тем, что не требует включения специального заголовочного файла malloc.h. Кроме того, параметр <blockquote>size</blockquote>, задающий количество выделяемых байтов, — это не простой тип <blockquote>int</blockquote>, хотя обычно он задается типом беззнаковое целое (unsigned integer).</p>     </blockquote>     <p>В большинстве систем Linux вы можете выделять большой объем памяти. Давайте начнем с очень простой программы из упражнения 7.1, которая, тем не менее, выигрывает соревнование со старыми программами ОС MS-DOS, поскольку они не могут обращаться к памяти за пределами базовой карты памяти ПК объемом 640 Кбайт.</p>     <b>Упражнение 7.1. Простое распределение памяти</b>     <p>Наберите следующую программу memory1.с:</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#define A_MEGABYTE (1024 * 1024)</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> char *some_memory;</blockquote></p>     <p><blockquote> int megabyte = A_MEGABYTE;</blockquote></p>     <p><blockquote> int exit_code = EXIT_FAILURE;</blockquote></p>     <p><blockquote> some_memory = (char*)malloc(megabyte);</blockquote></p>     <p><blockquote> if (some_memory ! = NULL) {</blockquote></p>     <p><blockquote>  sprintf(some_memory, "Hello World\n");</blockquote></p>     <p><blockquote>  printf("%s", some_memory);</blockquote></p>     <p><blockquote>  exit_code = EXIT_SUCCESS;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> exit(exit_code);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Когда вы выполните эту программу, то получите следующий вывод:</p>     <p><blockquote>$ <b>./memory1</b></blockquote></p>     <p><blockquote>Hello World</blockquote></p>     <p><b>Как это работает</b></p>     <p>Данная программа запрашивает с помощью библиотечного вызова <blockquote>malloc</blockquote> указатель на один мегабайт памяти. Вы проверяете, успешно ли завершился вызов <blockquote>malloc</blockquote>, и используете часть памяти, чтобы продемонстрировать ее наличие. Когда вы выполните программу, то увидите вывод фразы "Hello World", показывающий, что <blockquote>malloc</blockquote> действительно вернул мегабайт используемой памяти. Мы не проверяем наличие мегабайта целиком; мы приняли на веру программный код <blockquote>malloc</blockquote>!</p>     <p>Поскольку функция <blockquote>malloc</blockquote> возвращает указатель типа <blockquote>void*</blockquote>, вы преобразуете результат в нужный вам указатель типа <blockquote>char*</blockquote>. Эта функция возвращает память, выровненную так, что она может быть преобразована в указатель любого типа.</p>     <p>Простое основание — современные системы Linux применяют 32-разрядные целые и 32-разрядные указатели, что позволяет задавать до 4 Гбайт. Эта способность задавать адреса с помощью 32-разрядного указателя без необходимости применения регистров сегментов или других приемов, называется<i> простой 32-разрядной моделью памяти.</i> Эта модель также используется и в 32-разрядных версиях ОС Windows ХР и Vista. Тем не менее, никогда не следует рассчитывать на 32-разрядные целые, поскольку все возрастающее количество 64-разрядных версий Linux находится в употреблении.</p>             <a name="metkadoc4"><h1>Выделение огромных объемов памяти</h1></a>     <p>Теперь, когда вы увидели, что ОС Linux преодолевает ограничения модели памяти ОС MS-DOS, давайте усложним ей задачу. Приведенная в упражнении 7.2 программа запрашивает выделение объема памяти, большего, чем физически есть в машине, поэтому можно предположить, что функция malloc начнет давать сбои при приближении к максимальному объему физической памяти, поскольку ядру и всем остальным выполняющимся процессам также нужна память.</p>     <b>Упражнение 7.2. Запрос на всю физическую память</b>     <p>С помощью программы memory2.с мы собираемся запросить больше памяти, чем физически есть в машине. Вам нужно откорректировать определение <blockquote>PHY_MEM_MEGS</blockquote> в соответствии с физическими ресурсами вашего компьютера.</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#define A_MEGABYTE (1024 * 1024)</blockquote></p>     <p><blockquote>#define PHY_MEM_MEGS 1024 /* Откорректируйте это число</blockquote></p>     <p><blockquote>                             должным образом */</blockquote></p>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> char *some_memory;</blockquote></p>     <p><blockquote> size_t size_to_allocate = A_MEGABYTE;</blockquote></p>     <p><blockquote> int megs_obtained = 0;</blockquote></p>     <p><blockquote> while (megs_obtained &lt; (PHY_MEM_MEGS * 2)) {</blockquote></p>     <p><blockquote>  some_memory = (char *)malloc(size_to_allocate);</blockquote></p>     <p><blockquote>  if (some_memory != NULL) {</blockquote></p>     <p><blockquote>   megs_obtained++;</blockquote></p>     <p><blockquote>   sprintf(somememory, "Hello World");</blockquote></p>     <p><blockquote>   printf("%s — now allocated %d Megabytes\n", some_memory, megs_obtained);</blockquote></p>     <p><blockquote>  } else {</blockquote></p>     <p><blockquote>   exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Далее приведен немного сокращенный вывод:</p>     <p><blockquote>$ <b>./memory3</b></blockquote></p>     <p><blockquote>Hello World — now allocated 1 Megabytes</blockquote></p>     <p><blockquote>Hello World — now allocated 2 Megabytes</blockquote></p>     <p><blockquote>...</blockquote></p>     <p><blockquote>Hello World — now allocated 2047 Megabytes</blockquote></p>     <p><blockquote>Hello World — now allocated 2048 Megabytes</blockquote></p>     <p><b>Как это работает</b></p>     <p>Программа очень похожа на предыдущий пример. Это просто циклы, запрашивающие все больше и больше памяти до тех пор, пока не будет выделено памяти вдвое больше, чем заданный вами с помощью корректировки определения <blockquote>PHY_MEM_MEGS</blockquote> объем памяти, имеющейся у вашего компьютера. Удивительно, что эта программа вообще работает, потому что мы, как оказалось, создали программу, которая использует каждый байт физической памяти на машине одного из авторов. Обратите внимание на то, что в нашем вызове <blockquote>malloc</blockquote> применяется тип <blockquote>size_t</blockquote>.</p>     <p>Другая интересная особенность заключается в том, что, по крайней мере, на данной машине программа выполняется в мгновение ока. Таким образом, мы не только вне сомнения использовали всю память, но и сделали это на самом деле очень быстро.</p>     <p>Продолжим исследование и посмотрим, сколько памяти мы сможем выделить на этой машине с помощью программы memory3.c (упражнение 7.3). Поскольку уже понятно, что система Linux способна очень умно обходиться с запросами памяти, мы каждый раз будем выделять память по 1 Кбайт и записывать данные в каждый полученный нами блок.</p>     <b>Упражнение 7.3. Доступная память</b>     <p>Далее приведена программа memory3.c. По своей истинной природе она крайне недружественная по отношению к пользователю и может очень серьезно повлиять на многопользовательскую машину. Если вас беспокоит подобный риск, лучше совсем не запускать ее; если вы окажитесь от выполнения этой программы, усвоению материала это не повредит.</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#define ONE_K (1024)</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> char *some_memory;</blockquote></p>     <p><blockquote> int size_to_allocate = ONE_K;</blockquote></p>     <p><blockquote> int megs_obtained = 0;</blockquote></p>     <p><blockquote> int ks_obtained = 0;</blockquote></p>     <p><blockquote> while (1) {</blockquote></p>     <p><blockquote>  for (ks_obtained = 0; ks_obtained &lt; 1024; ks_obtained++) {</blockquote></p>     <p><blockquote>   some_memory = (char *)malloc(size_to_allocate);</blockquote></p>     <p><blockquote>   if (some_memory == NULL) exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote>   sprintf(some_memory, "Hello World");</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  megs_obtained++;</blockquote></p>     <p><blockquote>  printf("Now allocated %d Megabytes\n", megs_obtained);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>На этот раз вывод, также сокращенный, выглядит следующим образом:</p>     <p><blockquote>$ <b>./memory3</b></blockquote></p>     <p><blockquote>Now allocated 1 Megabytes</blockquote></p>     <p><blockquote>...</blockquote></p>     <p><blockquote>Now allocated 1535 Megabytes</blockquote></p>     <p><blockquote>Now allocated 1536 Megabytes</blockquote></p>     <p><blockquote>Out of Memory: Killed process 2365</blockquote></p>     <p><blockquote>Killed</blockquote></p>     <p>После этого программа завершается. Она выполняется несколько секунд и существенно замедляется при приближении к размеру, равному объему физической памяти на компьютере, а также активно использует жесткий диск. Тем не менее программа выделяла и получала доступ к области памяти, большей по размеру объема физической памяти, которая была установлена на машине одного из авторов во время написания этой главы. В конце концов, система защищает себя от этой довольно агрессивной программы и уничтожает ее. В некоторых системах она может тихо закончить выполнение, когда функция <blockquote>malloc</blockquote> завершается аварийно.</p>     <p><b>Как это работает</b></p>     <p>Память, выделяемая приложению, управляется ядром системы Linux. Каждый раз, когда программа запрашивает память, пытается записывать в память или считывать из памяти, которая была выделена, ядро Linux решает, как обрабатывать этот запрос.</p>     <p>Сначала ядро может использовать свободную физическую память для удовлетворения запроса приложения на выделение памяти, но когда физическая память исчерпана, ядро начинает использовать так называемую<i> область свопинга</i> или<i> подкачки.</i> В ОС Linux это отдельная область диска, выделяемая во время инсталляции системы. Если вы знакомы с ОС Windows, функционирование области свопинга в Linux немного напоминает файл подкачки в Windows. Но в отличие от ОС Windows при написании программного кода не нужно беспокоиться ни о локальной, ни о глобальной динамической памяти (heap), ни о выгружаемых сегментах памяти — ядро Linux все организует для вас.</p>     <p>Ядро перемещает данные и программный код между физической памятью и областью свопинга так, что при каждом чтении из памяти или записи в нее данные кажутся находящимися в физической памяти, где бы они не находились на самом деле перед вашей попыткой обратиться к ним.</p>     <p>Говоря более профессиональным языком, система Linux реализует систему виртуальной памяти с подкачкой страниц по требованию. Вся память, видимая программами пользователя, — виртуальная, т. е. реально не существующая в физическом адресном пространстве, используемом программой. Система Linux делит всю память на страницы, обычно размером 4096 байтов. Когда программа пытается обратиться к памяти, выполняется преобразование виртуальной памяти в физическую, конкретный способ реализации которого и затрачиваемое на преобразование время зависят от конкретного оборудования, применяемого вами. Когда выполняется обращение к области памяти, физически нерезидентной, возникает ошибка страницы памяти и управление передается ядру.</p>     <p>Ядро Linux проверяет адрес, к которому обратилась программа, и, если это допустимый для нее адрес, определяет, какую страницу физической памяти сделать доступной. Затем оно либо выделяет память для страницы, если она еще не записывалась ни разу, либо, если страница хранится на диске в области свопинга, считывает страницу памяти, содержащую данные, в физическую память (возможно выгружая на диск имеющуюся в памяти страницу). Затем после преобразования адресов виртуальной памяти в соответствующие физические адреса ядро разрешает пользовательской программе продолжить выполнение. Приложениям в ОС Linux не нужно заботиться об этих действиях, поскольку их реализация полностью скрыта в ядре.</p>     <p>В итоге, когда приложение исчерпает и физическую память, и область свопинга или когда она превысит максимальный размер стека, ядро откажется выполнить запрос на дальнейшее выделение памяти, может завершить программу и выгрузить ее.</p>     <blockquote>      <b>Примечание</b>      <p>Это поведение, сопровождающееся уничтожением процесса, отличается от поведения более старых версий Linux и множества других вариантов UNIX, в которых просто аварийно завершалась функция <blockquote>malloc</blockquote>. Называется оно уничтожением из-за нехватки памяти (out of memory (OOM) killer), и хотя может показаться чересчур радикальным, на самом деле служит разумным компромиссом между возможностью быстрого и эффективного выделения памяти процессам и необходимостью собственной защиты ядра от полного исчерпания ресурсов, что является серьезной проблемой.</p>     </blockquote>     <p>Но что это означает для прикладного программиста? В основном благую весть. Система Linux очень умело управляет памятью и позволяет приложениям использовать большие области памяти и даже очень большие единые блоки памяти. Но вы должны помнить о том, что выделение двух блоков памяти в результате не приведет к формированию одного непрерывно адресуемого блока памяти. Вы получите то, что просили: два отдельных блока памяти.</p>     <p>Означает ли этот, по-видимому, неограниченный источник памяти с последующим прерыванием и уничтожением процесса, что в проверке результата, возвращаемого функцией <blockquote>malloc</blockquote>, нет смысла? Конечно же нет. Одна из самых распространенных проблем в программах на языке С, использующих динамическую память, — запись за пределами выделенного блока. Когда это происходит, программа может не завершиться немедленно, но вы, вероятно, перезапишите некоторые внутренние данные, используемые подпрограммами библиотеки malloc.</p>     <p>Обычный результат — аварийное завершение последующих вызовов <blockquote>malloc</blockquote> не из- за нехватки памяти, а из-за повреждения структур памяти. Такие проблемы бывает трудно отследить, и чем быстрее в программах обнаружится ошибка, тем больше шансов найти причину. В<i> главе 10,</i> посвященной отладке и оптимизации, мы обсудим некоторые средства, которые могут помочь вам выявить проблемы, связанные с памятью.</p>             <a name="metkadoc5"><h1>Неправильное обращение к памяти</h1></a>     <p>Предположим, что вы хотите сделать что-то "плохое" с памятью. В упражнении 7.4 в программе memory4.c вы выделяете некоторую область памяти, а затем пытаетесь записать данные за пределами выделенной области.</p>     <b>Упражнение 7.4. Неправильное обращение к вашей памяти</b>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#define ONE_K (1024)</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> char *some_memory;</blockquote></p>     <p><blockquote> char *scan_ptr;</blockquote></p>     <p><blockquote> some_memory = (char *)malloc(ONE_K);</blockquote></p>     <p><blockquote> if (some_memory == NULL) exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> scan_ptr = some_memory;</blockquote></p>     <p><blockquote> while (1) {</blockquote></p>     <p><blockquote>  *scan_ptr = '\0';</blockquote></p>     <p><blockquote>  scan_ptr++;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Вывод прост:</p>     <p><blockquote>$ <b>./memory4</b></blockquote></p>     <p><blockquote>Segmentation fault</blockquote></p>     <p><b>Как это работает</b></p>     <p>Система управления памятью в ОС Linux защищает остальную систему от подобного некорректного использования памяти. Для того чтобы быть уверенной в том, что одна плохо ведущая себя программа (как эта) не сможет повредить любые другие программы, система Linux прекратила ее выполнение.</p>     <p>Каждая выполняющаяся в системе Linux программа видит собственную карту распределения памяти, которая отличается от карты распределения памяти любой другой программы. Только операционная система знает, как организована физическая память и не только управляет ею в интересах пользовательских программ, но также защищает их друг от друга.</p>             <a name="metkadoc6"><h1>Указатель <i>null</i></h1></a>     <p>Современные системы Linux, в отличие от ОС MS-DOS, но подобно новейшим вариантам ОС Windows, надежно защищены от записи или чтения по адресу, на который ссылается пустой указатель (<blockquote>null</blockquote>), хотя реальное поведение системы зависит от конкретной реализации.</p>     <p>Выполните упражнение 7.5.</p>     <b>Упражнение 7.5. Обращение по указателю <blockquote>null</blockquote></b>     <p>Давайте выясним, что произойдет, когда мы попытаемся обратиться к памяти по пустому или null-указателю в программе memory5a.c.</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> char *some_memory = (char*)0;</blockquote></p>     <p><blockquote> printf("A read from null %s\n", some_memory);</blockquote></p>     <p><blockquote> sprintf(some_memory, "A write to null\n");</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Будет получен следующий вывод:</p>     <p><blockquote>$ <b>./memory5a</b></blockquote></p>     <p><blockquote>A read from null (null)</blockquote></p>     <p><blockquote>Segmentation fault</blockquote></p>     <p><b>Как это работает</b></p>     <p>Первая функция <blockquote>printf</blockquote> пытается вывести строку, полученную от указателя <blockquote>null</blockquote>; далее <blockquote>sprintf</blockquote> пытается записать по указателю <blockquote>null</blockquote>. В данном случае Linux (под видом библиотеки GNU С) простила чтение и просто предоставила "магическую" строку, содержащую символы <blockquote>(null)\0</blockquote>. Система не столь терпима в случае записи и просто завершила программу. Такое поведение порой полезно при выявлении программных ошибок.</p>     <p>Если вы повторите попытку, но не будете использовать библиотеку GNU С, вы обнаружите, что безадресное чтение не разрешено. Далее приведена программа memory5b.c:</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> char z = *(const char *)0;</blockquote></p>     <p><blockquote> printf("I read from location zero\n");</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Вы получите следующий результат:</p>     <p><blockquote>$ <b>./memory5b</b></blockquote></p>     <p><blockquote>Segmentation fault</blockquote></p>     <p>В этот раз вы пытаетесь прочесть непосредственно из нулевого адреса. Между вами и ядром теперь нет GNU-библиотеки libc, и программа прекращает выполнение. Имейте в виду, что некоторые системы UNIX разрешают читать из нулевого адреса, ОС Linux этого не допускает.</p>             <a name="metkadoc7"><h1>Освобождение памяти</h1></a>     <p>До сих пор мы выделяли память и затем надеялись на то, что по завершении программы использованная нами память не будет потеряна, К счастью, система управления памятью в ОС Linux вполне способна с высокой степенью надежности гарантировать возврат памяти в систему по завершении программы. Но большинство программ просто не хотят распределять память, используют ее очень короткий промежуток времени и затем завершаются. Гораздо более распространено динамическое использование памяти по мере необходимости.</p>     <p>Программы, применяющие память на динамической основе, должны всегда возвращать неиспользованную память диспетчеру распределения памяти <blockquote>malloc</blockquote> с помощью вызова <blockquote>free</blockquote>. Это позволяет выделить блоки, нуждающиеся в повторном объединении, и дает возможность библиотеке <blockquote>malloc</blockquote> следить за памятью, вместо того, чтобы заставлять приложение управлять ею. Если выполняющаяся программа (процесс) использует, а затем освобождает память, эта освободившаяся память остается выделенной процессу. За кадром система Linux управляет блоками памяти, которые программист использует как набор физических "страниц" в памяти, размером 4 Кбайт каждая. Но если страница памяти в данный момент не используется, диспетчер управления памятью ОС Linux сможет переместить ее из оперативной памяти в область свопинга (это называется обменом страниц), где она слабо влияет на потребление ресурсов. Если программа пытается обратиться к данным на странице, которая была перенесена в область свопинга, Linux на очень короткое время приостанавливает программу, возвращает страницу обратно из области свопинга в физическую память и затем разрешает программе продолжить выполнение так, будто данные все время находились в оперативной памяти.</p>     <p><blockquote><b>#include &lt;stdlib.h&gt;</b></blockquote></p>     <p><blockquote><b>void free(void *ptr_to_memory);</b></blockquote></p>     <p>Вызов <blockquote>free</blockquote> следует выполнять только с указателем на память, выделенную с помощью вызова <blockquote>malloc</blockquote>, <blockquote>calloc</blockquote> или <blockquote>realloc</blockquote>. Очень скоро вы встретитесь с функциями <blockquote>calloc</blockquote> и <blockquote>realloc</blockquote>. А сейчас выполните упражнение 7.6.</p>     <b>Упражнение 7.6. Освобождение памяти</b>     <p>Эта программа называется memory6.c.</p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#define ONE_K (1024)</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> char *some_memory;</blockquote></p>     <p><blockquote> int exit code = EXIT_FAILURE;</blockquote></p>     <p><blockquote> some_memory = (char*)malloc(ONE_K);</blockquote></p>     <p><blockquote> if (some_memory != NULL) {</blockquote></p>     <p><blockquote>  free(some_memory);</blockquote></p>     <p><blockquote>  printf("Memory allocated and freed again\n");</blockquote></p>     <p><blockquote>  exit_code = EXIT_SUCCESS;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> exit(exit_code);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Вывод программы следующий:</p>     <p><blockquote>$ <b>./memory6</b></blockquote></p>     <p><blockquote>Memory allocated and freed again</blockquote></p>     <p><b>Как это работает</b></p>     <p>Эта программа просто показывает, как вызвать функцию <blockquote>free</blockquote> с указателем, направленным на предварительно выделенную область памяти.</p>     <blockquote>      <b>Примечание</b>      <p>Помните о том, что после вызова <blockquote>free</blockquote> для освобождения блока памяти этот блок больше не принадлежит процессу. Он больше не управляется библиотекой <blockquote>malloc</blockquote>. Никогда не пытайтесь читать из области памяти или писать в область памяти, для которой была вызвана функция <blockquote>free</blockquote>.</p>     </blockquote>             <a name="metkadoc8"><h1>Другие функции распределения памяти</h1></a>     <p>Две другие функции распределения или выделения памяти <blockquote>calloc</blockquote> и <blockquote>realloc</blockquote> применяются не так часто, как <blockquote>malloc</blockquote> и <blockquote>free</blockquote>.</p>     <p>Далее приведены их прототипы:</p>     <p><blockquote><b>#include &lt;stdlib.h&gt;</b></blockquote></p>     <p><blockquote><b>void *calloc(size_t number_of_elements, size_t element_size);</b></blockquote></p>     <p><blockquote><b>void *realloc(void *existing_memozy, size_t new_size);</b></blockquote></p>     <p>Несмотря на то, что функция <blockquote>calloc</blockquote> выделяет память, которую можно освободить с помощью функции <blockquote>free</blockquote>, ее параметры несколько отличаются от параметров функции <blockquote>malloc</blockquote>: она выделяет память для массива структур и требует задания количества элементов и размера каждого элемента массива как параметров. Выделенная память заполняется нулями; и если функция <blockquote>calloc</blockquote> завершается успешно, возвращается указатель на первый элемент. Как и в случае функции <blockquote>malloc</blockquote>, последовательные вызовы не гарантируют возврата непрерывной области памяти, поэтому вы не можете увеличить длину массива, созданного функцией <blockquote>calloc</blockquote>, просто повторным вызовом этой функции и рассчитывать на то, что второй вызов вернет память, добавленную в конец блока памяти, полученного после первого вызова функции.</p>     <p>Функция <blockquote>realloc</blockquote> изменяет размер предварительно выделенного блока памяти. Она получает в качестве параметра указатель на область памяти, предварительно выделенную функциями <blockquote>malloc</blockquote>, <blockquote>calloc</blockquote> или <blockquote>realloc</blockquote>, и уменьшает или увеличивает эту область в соответствии с запросом. Функция бывает вынуждена для достижения результата в перемещении данных, поэтому важно быть уверенным в том, что к памяти, выделенной после вызова <blockquote>realloc</blockquote>, вы всегда обращаетесь с помощью нового указателя и никогда не используете указатель, установленный ранее до вызова функции <blockquote>realloc</blockquote>.</p>     <p>Другая проблема, за которой нужно следить, заключается в том, что функция <blockquote>realloc</blockquote> возвращает пустой указатель при невозможности изменить размер блока памяти. Это означает, что в приложениях следует избегать кода, подобного приведенному далее:</p>     <p><blockquote>my_ptr = malloc(BLOCK_SIZE);</blockquote></p>     <p><blockquote>...</blockquote></p>     <p><blockquote>my_ptr = realloc(my_ptr, BLOCK_SIZE * 10);</blockquote></p>     <p>Если <blockquote>realloc</blockquote> завершится аварийно, она вернет пустой указатель; переменная <blockquote>my_ptr</blockquote> будет указывать в никуда и к первоначальной области памяти, выделенной функцией <blockquote>malloc</blockquote>, больше нельзя будет обратиться с помощью указателя <blockquote>my_ptr</blockquote>. Следовательно, было бы полезно сначала запросить новый блок памяти с помощью <blockquote>malloc</blockquote>, а затем скопировать данные из старого блока памяти в новый блок с помощью функции <blockquote>memcpy</blockquote> и освободить старый блок памяти вызовом <blockquote>free</blockquote>. При возникновении ошибки это позволит приложению сохранить доступ к данным, хранящимся в первоначальном блоке памяти, возможно, на время организации корректного завершения программы.</p>              <a name="metkadoc9"><h1>Блокировка файлов</h1></a>         <p>Блокировка файлов — очень важная составляющая многопользовательских многозадачных операционных систем. Программы часто нуждаются в совместно используемых данных, обычно хранящихся в файлах, и очень важно, что у этих программ есть способ управления файлом. Файл может быть при этом безопасно обновлен или программа может пресечь свои попытки чтения файла, находящегося в переходном состоянии во время записи в него данных другой программой.</p>     <p>У системы Linux есть несколько средств, которые можно применять для блокировки файлов. Простейший способ — блокировка файла на элементарном уровне, когда ничего не может произойти при установленной блокировке. Он предоставляет программе метод создания файлов, обеспечивающий уникальность файла и невозможность одновременного создания этого файла другой программой.</p>     <p>Второй способ более сложный, он позволяет программам блокировать части файла для получения исключительного права доступа к ним. Есть два метода реализации этого варианта блокировки. Мы рассмотрим подробно только один из них, поскольку второй очень похож и отличается от первого немного иным интерфейсом.</p>             <a name="metkadoc10"><h1>Создание файлов с блокировкой</h1></a>     <p>Многие приложения нуждаются в возможности создания ресурса в виде файла с блокировкой. Другие программы после этого могут проверить файл, чтобы узнать, есть ли у них право доступах ресурсу.</p>     <p>Как правило, эти заблокированные файлы находятся в специальном месте и имеют имена, связанные с управляемыми ими ресурсами. Например, когда используется модем, система Linux создает файл с блокировкой, часто применяя каталог в каталоге /var/spool.</p>     <p>Помните о том, что блокировки файлов действуют только как индикаторы; программы должны сотрудничать для их применения. Такие блокировки называют <i>рекомендательными</i> (advisory lock), в отличие от<i> обязательных</i> блокировок (mandatory lock), при которых система инициирует блокирование.</p>     <p>Для создания файла с блокировкой (упражнение 7.7) можно использовать системный вызов <blockquote>open</blockquote>, определенный в файле fcntl.h (уже встречавшемся в предыдущих главах) и содержащий набор флагов <blockquote>O_CREAT</blockquote> и <blockquote>O_EXCL</blockquote>. Этот способ позволяет проверить, не существует ли уже такой файл, и затем создать его за одну элементарную неделимую операцию.</p>     <b>Упражнение 7.7. Создание файла с блокировкой</b>     <p>В программе lock1.c вы сможете увидеть файл с блокировкой в действии.</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;fcntl.h&gt;</blockquote></p>     <p><blockquote>#include &lt;errno.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int file_desc;</blockquote></p>     <p><blockquote> int save_errno;</blockquote></p>     <p><blockquote> file_desc = open("/tmp/LCK.test", O_RDWR | O_CREAT | O_EXCL, 0444);</blockquote></p>     <p><blockquote> if (file_desc == -1) {</blockquote></p>     <p><blockquote>  save errno = errno;</blockquote></p>     <p><blockquote>  printf("Open failed with error %d\n", save_errno);</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  printf("Open succeeded\n");</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote> </p>     <p>Выполнив программу первый раз, вы получите следующий вывод:</p>     <p><blockquote>$ <b>./lock1</b></blockquote></p>     <p><blockquote>Open succeeded</blockquote></p>     <p>Но при повторной попытке вы получите результат, приведенный далее:</p>     <p><blockquote>$ <b>./lock1</b></blockquote></p>     <p><blockquote>Open failed with error 17</blockquote></p>     <p><b>Как это работает</b></p>     <p>Для создания файла с именем /tmp/LCK.test программа выполняет вызов, использующий флаги <blockquote>O_CREAT</blockquote> и <blockquote>O_EXCL</blockquote>. Во время первого выполнения программы файл не существует, поэтому вызов <blockquote>open</blockquote> завершается успешно. Последующие запуски программы завершаются аварийно, потому что файл уже существует. Для успешного выполнения этой программы в дальнейшем вы должны вручную удалить файл с блокировкой.</p>     <p>В системах Linux, ошибка 17 соответствует константе <blockquote>EEXIST</blockquote>, указывающей на то, что файл уже существует. Номера ошибок определены в файле errno.h или, скорее, в файлах, включаемых этим файлом. В данном случае определение в действительности, находящееся в /usr/include/asm-generic/errno-base.h, гласит</p>     <p><blockquote>#define EEXIST 17 /* File exists */</blockquote></p>     <p>Это ошибка, соответствующая аварийному завершению вызова <blockquote>open(O_CREAT | O_EXCL)</blockquote>.</p>     <p>Если программе на короткий период во время выполнения, часто называемый<i> критической секцией,</i> нужно право исключительного доступа к ресурсу, ей следует перед входом в критическую секцию, создать файл с блокировкой с помощью системного вызова open и применить системный вызов <blockquote>unlink</blockquote> для удаления этого файла впоследствии, когда она завершит выполнение критической секции.</p>     <p>Вы можете увидеть сотрудничество программ, применяющих этот механизм блокировки, написав программу-пример и запустив одновременно две ее копии (упражнение 7.8). В программе будет использован вызов функции <blockquote>getpid</blockquote>, с которой вы встречались в<i> главе 4,</i> она возвращает идентификатор процесса, уникальный номер для каждой выполняющейся в данный момент программы.</p>     <b>Упражнение 7.8. Совместная блокировка файлов</b>     <p>1. Далее приведен исходный код тестовой программы lock2.с.</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt; </blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;fcntl.h&gt;</blockquote></p>     <p><blockquote>#include &lt;errno.h&gt;</blockquote></p>     <p><blockquote>const char *lock_file = "/tmp/LCK.test2"; </blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int file_desc;</blockquote></p>     <p><blockquote> int tries = 10;</blockquote></p>     <p><blockquote> while (--tries) {</blockquote></p>     <p><blockquote>  file_desc = open(lock_file, O_RDWR | O_CREAT | O_EXCL, 0444);</blockquote></p>     <p><blockquote>  if (file_desc == -1) {</blockquote></p>     <p><blockquote>   printf("%d - Lock already present\n", getpid());</blockquote></p>     <p><blockquote>   sleep(3);</blockquote></p>     <p><blockquote>  } else {</blockquote></p>     <p>2. Далее следует критическая секция:</p>     <p><blockquote>   printf("%d — I have exclusive access\n", getpid());</blockquote></p>     <p><blockquote>   sleep(1);</blockquote></p>     <p><blockquote>   (void)close(file_desc);</blockquote></p>     <p><blockquote>   (void)unlink(lockfile);</blockquote></p>     <p>3. В этом месте она заканчивается:</p>     <p><blockquote>   sleep(2);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Для выполнения программы вам сначала нужно выполнить следующую команду, чтобы убедиться в том, что файла не существует:</p>     <p><blockquote>$ <b>rm -f /tmp/LCK.test2</b></blockquote></p>     <p>Затем с помощью приведенной далее команды запустите две копии программы:</p>     <p><blockquote>$ <b>./lock2 &amp; ./lock2</b></blockquote></p>     <p>Она запускает одну копию программы в фоновом режиме, а вторую — как основную программу. Далее приведен вывод:</p>     <p><blockquote>1284 — I have exclusive access</blockquote></p>     <p><blockquote>1283 — Lock already present</blockquote></p>     <p><blockquote>1283 — I have exclusive access</blockquote></p>     <p><blockquote>1284 — Lock already present</blockquote></p>     <p><blockquote>1284 — I have exclusive access</blockquote></p>     <p><blockquote>1283 — Lock already present</blockquote></p>     <p><blockquote>1283 — I have exclusive access</blockquote></p>     <p><blockquote>1284 — Lock already present</blockquote></p>     <p><blockquote>1284 — I have exclusive access</blockquote></p>     <p><blockquote>1283 — Lock already present</blockquote></p>     <p><blockquote>1283 — I have exclusive access</blockquote></p>     <p><blockquote>1284 — Lock already present</blockquote></p>     <p><blockquote>1284 — I have exclusive access</blockquote></p>     <p><blockquote>1283 — Lock already present</blockquote></p>     <p><blockquote>1283 — I have exclusive access</blockquote></p>     <p><blockquote>1284 — Lock already present</blockquote></p>     <p><blockquote>1284 — I have exclusive access</blockquote></p>     <p><blockquote>1283 — Lock already present</blockquote></p>     <p><blockquote>1283 — I have exclusive access</blockquote></p>     <p><blockquote>1284 — Lock already present</blockquote></p>     <p>В приведенном примере показано, как взаимодействуют две выполняющиеся копии одной и той же программы. Если вы попробуете выполнить данный пример, то почти наверняка увидите другие идентификаторы процессов в выводе, но поведение программ будет тем же самым.</p>     <p><b>Как это работает</b></p>     <p>Для демонстрации вы 10 раз выполняете в программе цикл с помощью оператора <blockquote>while</blockquote>. Затем программа пытается получить доступ к дефицитному ресурсу, создав уникальный файл с блокировкой /tmp/LCK.test2. Если эта попытка терпит неудачу из-за того, что файл уже существует, программа ждет короткий промежуток времени и затем снова пытается создать файл. Если ей это удается, она получает доступ к ресурсу и в части программы, помеченной как "критическая секция", выполняет любую обработку, требующую исключительных прав доступа.</p>     <p>Поскольку это всего лишь пример, вы ждете очень короткий промежуток времени. Когда программа завершает использование ресурса, она снимает блокировку, удаляя файл с блокировкой. Далее она может выполнить другую обработку (в данном случае это просто функция <blockquote>sleep</blockquote>) прежде, чем попытаться возобновить блокировку. Файлы с блокировкой действуют как двоичный семафор, давая программе ответ "да" или "нет" на вопрос: "Могу ли я использовать ресурс?". В<i> главе 14</i> вы узнаете больше о семафорах.</p>     <b>Примечание</b>     <p>Важно уяснить, что это совместное мероприятие, и вы должны корректно писать программы для его работы. Программа, потерпевшая неудачу в создании файла с блокировкой, не может просто удалить файл и попробовать снова, Возможно, в дальнейшем она сумеет создать файл с блокировкой, но у другой программы, уже создавшей такой файл, нет способа узнать о том, что она лишилась исключительного доступа к ресурсу.</p>             <a name="metkadoc11"><h1>Блокировка участков файла</h1></a>     <p>Создание файлов с блокировкой подходит для управления исключительным доступом к ресурсам, таким как последовательные порты или редко используемые файлы, но этот способ не годится для доступа к большим совместно используемым файлам. Предположим, что у вас есть большой файл, написанный одной программой и одновременно обновляемый многими программами. Такая ситуация может возникнуть, если программа записывает какие-то данные, получаемые непрерывно или в течение длительного периода, и обрабатывает их с помощью нескольких разных программ. Обрабатывающие программы не могут ждать, пока программа, записывающая данные, завершится — она работает постоянно, поэтому программам нужен какой-то способ кооперации для обеспечения одновременного доступа к одному и тому же файлу.</p>     <p>Урегулировать эту ситуацию можно, блокируя участки файла. При этом конкретная часть файла блокируется, но другие программы могут иметь доступ к другим участкам файла. Это называется<i> блокировкой сегментов</i> или<i> участков файла.</i> У системы Linux есть (как минимум) два способа сделать это: с помощью системного вызова <blockquote>fcntl</blockquote> или системного вызова <blockquote>lockf</blockquote>. Мы рассмотрим интерфейс <blockquote>fcntl</blockquote>, поскольку он наиболее часто применяется. Интерфейс <blockquote>lockf</blockquote> в основном аналогичен, и в ОС Linux он используется как альтернативный интерфейсу <blockquote>fcntl</blockquote>. Однако блокирующие механизмы <blockquote>fcntl</blockquote> и <blockquote>lockf</blockquote> не работают вместе: у них разные низкоуровневые реализации. Поэтому никогда не следует смешивать вызовы этих двух типов; выберите один или другой.</p>     <p>Вы встречали вызов fcntl в<i> главе 3.</i> У него следующее определение:</p>     <p><blockquote><b>#include &lt;fcntl.h&gt;</b></blockquote></p>     <p><blockquote><b>int fcntl(int fildes, int command, ...);</b></blockquote></p>     <p>Системный вызов <blockquote>fcntl</blockquote> оперирует открытыми дескрипторами файлов и, в зависимости от параметра <blockquote>command</blockquote>, может выполнять разные задачи. Для блокировки файлов интересны три приведенные далее возможные значения параметра command:</p>     <p>&#9633; <blockquote>F_GETLK</blockquote>;</p>     <p>&#9633; <blockquote>F_SETLK</blockquote>;</p>     <p>&#9633; <blockquote>F_SETLKW</blockquote>.</p>     <p>Когда вы используете эти варианты, третий аргумент в вызове должен быть указателем на структуру <blockquote>struct flock</blockquote>, поэтому на самом деле прототип вызова выглядит следующим образом:</p>     <p><b><blockquote><b>int fcntl(int fildes, int command, struct flock *flock_structure);</b></blockquote></b></p>     <p>Структура <blockquote>flock</blockquote> (он англ. <i>file lock</i>) зависит от конкретной реализации, но, как минимум, она будет содержать следующие элементы:</p>     <p>&#9633; <blockquote>short l_type</blockquote>;</p>     <p>&#9633; <blockquote>short l_whence</blockquote>;</p>     <p>&#9633; <blockquote>off_t l_start</blockquote>;</p>     <p>&#9633; <blockquote>off_t l_len</blockquote>;</p>     <p>&#9633; <blockquote>pid_t l_pid</blockquote>.</p>     <p>Элемент <blockquote>l_type</blockquote> принимает одно из нескольких значений (табл. 7.1), определенных в файле fcntl.h.</p>     <br>     <p><b><i>Таблица 7.1.</i></b></p>     <table>      <tr>       <th valign="top">Значение</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>F_RDLCK</blockquote></td>       <td valign="top">Разделяемая или совместная блокировка (блокировка на чтение). У разных процессов может быть разделяемая блокировка одних и тех же (или перекрывающихся) участков файла. Если у какого-либо процесса есть разделяемая блокировка, ни один процесс не сможет установить исключительную блокировку этого участка. Для получения совместной блокировки файл должен быть открыт с правом на чтение или на чтение/запись</td>      </tr>      <tr>       <td valign="top"><blockquote>F_UNLCK</blockquote></td>       <td valign="top">Разблокировать. Применяется для снятия блокировок</td>      </tr>      <tr>       <td valign="top"><blockquote>F_WRLCK</blockquote></td>       <td valign="top">Исключительная блокировка (или блокировка на запись). Только один процесс может установить исключительную блокировку на любой конкретный участок файла. После того как процесс установил такую блокировку, никакой другой процесс не сможет установить блокировку любого типа на этот участок файла. Для установки исключительной блокировки файл должен быть открыт с правом на запись или на чтение/запись</td>      </tr>     </table>     <p>Элементы <blockquote>l_whence</blockquote>, <blockquote>l_start</blockquote> и <blockquote>l_len</blockquote> определяют участок файла, непрерывную область в байтах. Элемент <blockquote>l_whence</blockquote> должен задаваться одним из следующих значений: <blockquote>SEEK_SET</blockquote>, <blockquote>SEEK_CUR</blockquote>, <blockquote>SEEK_END</blockquote> (из файла unistd.h). Они соответствуют началу, текущей позиции или концу файла соответственно. Элемент <blockquote>l_whence</blockquote> задает смещение для первого байта участка файла, определенного элементом <blockquote>l_start</blockquote>. Обычно оно задается константой <blockquote>SEEK_SET</blockquote>, поэтому <blockquote>l_start</blockquote> отсчитывается от начала файла. Параметр <blockquote>l_len</blockquote> содержит количество байтов в участке файла.</p>     <p>Параметр <blockquote>l_pid</blockquote> применяется для указания процесса, установившего блокировку; см. следующее далее описание значения <blockquote>F_GETLK</blockquote> параметра <blockquote>command</blockquote>.</p>     <p>Для каждого байта в файле может быть установлена блокировка только одного типа в каждый конкретный момент времени и может быть либо разделяемой блокировкой, либо исключительной или блокировка может отсутствовать. Для системного вызова <blockquote>fcntl</blockquote> существует совсем немного комбинаций значений команд и вариантов, поэтому рассмотрим их все по очереди.</p>     <b>Значение<i> F_GETLK </i>параметра<i> command</i></b>     <p>Первое значение параметра command — <blockquote>F_GETLK</blockquote>. Эта команда получает информацию о файле, который открыт <blockquote>fildes</blockquote> (первый параметр в вызове). Она не пытается блокировать файл. В процессе вызова передаются сведения о типе блокировки, которую хотелось бы установить, и вызов <blockquote>fcntl</blockquote> с командой <blockquote>F_GETLK</blockquote> возвращает любую информацию, которая могла бы помешать установке блокировки.</p>     <p>Значения, используемые в структуре <blockquote>flock</blockquote>, приведены в табл. 7.2.</p>     <br>     <p><b><i>Таблица 7.2</i></b></p>     <table>      <tr>       <th valign="top">Значение</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>l_type</blockquote></td>       <td valign="top">Или <blockquote>F_RDLCK</blockquote> для разделяемой (только чтение) блокировки, или <blockquote>F_WRLCK</blockquote> для исключительной (на запись) блокировки</td>      </tr>      <tr>       <td valign="top"><blockquote>l_whence</blockquote></td>       <td valign="top">Одно из значений: <blockquote>SEEK_SET</blockquote>, <blockquote>SEEK_CUR</blockquote> или <blockquote>SEEK_END LCK</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>l_start</blockquote></td>       <td valign="top">Начальный байт интересующего вас участка файла</td>      </tr>      <tr>       <td valign="top"><blockquote>l_len</blockquote></td>       <td valign="top">Количество байтов в интересующем вас участке файла</td>      </tr>      <tr>       <td valign="top"><blockquote>l_pid</blockquote></td>       <td valign="top">Идентификатор процесса, удерживающего блокировку</td>      </tr>     </table>     <p>Процесс может применять вызов с командой <blockquote>F_GETLK</blockquote> для определения текущего состояния блокировки участка файла. Он должен настроить структуру <blockquote>flock</blockquote>, указав тип требуемой блокировки и определив интересующую его область файла. Вызов <blockquote>fcntl</blockquote> возвращает в случае успешного завершения значение, отличное от -1. Если у файла уже есть блокировки, препятствующие установке требуемой блокировки, структура <blockquote>flock</blockquote> обновляется соответствующими данными. Если блокировке ничто не мешает, структура <blockquote>flock</blockquote> не изменяется. Если вызов с командой <blockquote>F_GETLK</blockquote> не может получить информацию, он возвращает -1 для обозначения аварийного завершения.</p>     <p>Если вызов с командой <blockquote>F_GETLK</blockquote> завершился успешно (т. е. вернул значение, отличное от -1), вызвавшее его приложение должно проверить, изменено ли содержимое структуры <blockquote>flock</blockquote>. Поскольку значение <blockquote>l_pid</blockquote> содержит идентификатор блокирующего процесса (если таковой найден), это поле очень удобно для того, чтобы проверить, изменялась ли структура <blockquote>flock</blockquote>.</p>     <b>Значение<i> F_SETLK</i> параметра<i> command</i></b>     <p>Эта команда пытается заблокировать или разблокировать участок файла, заданного <blockquote>fildes</blockquote>. В табл. 7.3 приведены значения полей структуры <blockquote>flock</blockquote> (отличающиеся от значений, применяемых командой <blockquote>F_GETLK</blockquote>).</p>     <br>     <p><b><i>Таблица 7.3</i></b></p>     <table>      <tr>       <th valign="top">Значение</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>l_type</blockquote></td>       <td valign="top">Одно из следующих: • <blockquote>F_RDLCK</blockquote> — для разделяемой или допускающей только чтение блокировки; • <blockquote>F_WRLCK</blockquote> — для исключительной или блокировки записи; • <blockquote>F_UNLCK</blockquote> — для разблокирования участка</td>      </tr>      <tr>       <td valign="top"><blockquote>l_pid</blockquote></td>       <td valign="top">Не используется</td>      </tr>     </table>     <p>Как и в случае <blockquote>F_GETLK</blockquote>, блокируемый участок определяется значениями элементов <blockquote>l_start</blockquote>, <blockquote>l_whence</blockquote> и <blockquote>l_len</blockquote> структуры <blockquote>flock</blockquote>. Если блокировка установлена, вызов <blockquote>fcntl</blockquote> вернет значение, отличное от -1, при аварийном завершении возвращается -1. Вызов завершается немедленно.</p>     <b>Значение <i>F_SETLKW</i> параметра <i>command</i></b>     <p>Команда <blockquote>F_SETLKW</blockquote> аналогична команде <blockquote>F_SETLK</blockquote> за исключением того, что при невозможности установки блокировки вызов будет ждать до тех пор, пока такая возможность не представится. После перехода в состояние ожидания вызов завершится только, когда блокировка будет установлена или появится сигнал. Сигналы мы обсудим в<i> главе 11.</i></p>     <p>Все блокировки файла, установленные программой, автоматически очищаются, когда закрывается соответствующий дескриптор файла. То же самое происходит, когда программа завершается.</p>             <a name="metkadoc12"><h1>Применение вызовов <i>read</i> и <i>write </i>при наличии блокировки</h1></a>     <p>Когда вы применяете блокировку участков файла, очень важно использовать для доступа к данным низкоуровневые вызовы <blockquote>read</blockquote> и <blockquote>write</blockquote> вместо высокоуровневых функций <blockquote>fread</blockquote>и <blockquote>fwrite</blockquote>. Это необходимо, поскольку функции <blockquote>fread</blockquote> и <blockquote>fwrite</blockquote> выполняют внутри библиотеки буферизацию читаемых или записываемых данных, так что при выполнений вызова <blockquote>fread</blockquote> для считывания 100 байтов из файла может быть (и на самом деле почти наверняка будет), считано более 100 байтов, и дополнительные данные помещаются во внутрибиблиотечный буфер. Если программа применит функцию <blockquote>fread</blockquote> для считывания следующих 100 байтов, она на самом деле считает данные из буфера и не разрешит низкоуровневому вызову <blockquote>read</blockquote> извлечь больше данных из файла.</p>     <p>Для того чтобы понять, в чем тут проблема, рассмотрим две программы, которые хотят обновить один и тот же файл. Предположим, что файл содержит 200 байтов данных, все нули. Первая программа начинает работу и устанавливает блокировку на запись для первых 100 байтов файла. Затем она применяет функцию <blockquote>fread</blockquote> для считывания этих 100 байтов. Однако, как было показано в одной из предшествующих глав, <blockquote>fread</blockquote> будет каждый раз считывать больше, до <blockquote>BUFSIZ</blockquote> байтов, поэтому она на самом деле считает в память целиком весь файл, но программе вернет только первые 100 байтов.</p>     <p>Затем стартует вторая программа. Она устанавливает блокировку <blockquote>write</blockquote> на вторые 100 байтов файла. Это действие завершится успешно, поскольку первая программа заблокировала только первые 100 байтов. Вторая программа записывает двойки в байты с 100-го по 199-й, закрывает файл, снимает блокировку и завершается. В это время первая программа блокирует вторые 100 байтов файла и вызывает функцию <blockquote>fread</blockquote> для их считывания. Поскольку эти данные были уже занесены библиотекой в буфер, программа увидит 100 байтов нулей, а не 100 двоек, которые на самом деле хранятся в файле на жестком диске. Подобной проблемы не возникает, если вы применяете вызовы <blockquote>read</blockquote> и <blockquote>write</blockquote>.</p>     <p>Приведенное описание блокировки файла может показаться сложноватым, но ее труднее описать, чем применить. Поэтому выполните упражнение 7.9.</p>     <b>Упражнение 7.9. Блокировка файла с помощью вызова <blockquote>fcntl</blockquote></b>     <p>Давайте рассмотрим пример работы блокировки файла в программе lock3.с. Для опробования блокировки вам понадобятся две программы: одна для установки блокировки и другая для ее тестирования. Первая программа выполняет блокировку.</p>     <p>1. Начните с файлов <blockquote>include</blockquote> и объявлений переменных:</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;fcntl.h&gt;</blockquote></p>     <br>     <p><blockquote>const char *test_file = "/tmp/test_lock";</blockquote></p>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int file desc;</blockquote></p>     <p><blockquote> int byte_count;</blockquote></p>     <p><blockquote> char *byte_to_write = "A";</blockquote></p>     <p><blockquote> struct flock region_1;</blockquote></p>     <p><blockquote> struct flock region_2;</blockquote></p>     <p><blockquote> int res;</blockquote></p>     <p>2. Откройте файловый дескриптор:</p>     <p><blockquote> file_desc = open(test_file, O_RDWR | O_CREAT, 0666);</blockquote></p>     <p><blockquote> if (!file_desc) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Unable to open %s for read/write\n", test_file);</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p>3. Поместите данные в файл:</p>     <p><blockquote> for (byte_count = 0; byte_count &lt; 100; byte_count++) {</blockquote></p>     <p><blockquote>  (void)write(file_desc, byte_to_write, 1);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p>4. Задайте разделяемую блокировку для участка region 1 с 10-го байта по 30-й:</p>     <p><blockquote> region_1.l_type = F_RDLCK;</blockquote></p>     <p><blockquote> region_1.l_whence = SEEK_SET;</blockquote></p>     <p><blockquote> region_1.l_start = 10;</blockquote></p>     <p><blockquote> region_1.l_len = 20;</blockquote></p>     <p>5. Задайте исключительную блокировку для участка region_2 с 40-го байта по 50-й:</p>     <p><blockquote> region_2.l_type = F_WRLCK;</blockquote></p>     <p><blockquote> region_2.l_whence = SEEK_SET;</blockquote></p>     <p><blockquote> region_2.l_start = 40;</blockquote></p>     <p><blockquote> region_2.l_len = 10;</blockquote></p>     <p>6. Теперь заблокируйте файл:</p>     <p><blockquote> printf("Process %d locking file\n", getpid());</blockquote></p>     <p><blockquote> res = fcntl(file_desc, F_SETLK, &amp;region_1);</blockquote></p>     <p><blockquote> if (res == -1) fprintf(stderr, "Failed to lock region 1\n");</blockquote></p>     <p><blockquote> res = fcntl(file_desc, F_SETLK, &amp;region_2);</blockquote></p>     <p><blockquote> if (res = fprintf(stderr, "Failed to lock region 2\n");</blockquote></p>     <p>7. Подождите какое-то время:</p>     <p><blockquote> sleep(60);</blockquote></p>     <p><blockquote> printf ("Process %d closing file\n", getpid());</blockquote></p>     <p><blockquote> close(file_desc);</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p><b>Как это работает</b></p>     <p>Сначала программа создает файл, открывает его для чтения и записи и затем заполняет файл данными. Далее задаются два участка: первый с 10-го по 30-й байт для разделяемой блокировки и второй с 40-го по 50-й байт для исключительной блокировки. Затем программа выполняет вызов <blockquote>fcntl</blockquote> для установки блокировок на два участка файла и ждет в течение минуты, прежде чем закрыть файл и завершить работу.</p>     <p>На рис. 7.1 показан этот сценарий с блокировками в тот момент, когда программа переходит к ожиданию.</p>     <img src="image022.jpg"/>     <p><b>Рис. 7.1</b></p>     <br>     <p>Сама по себе эта программа не очень полезна. Вам нужна вторая программа lock4.c для тестирования блокировок (упражнение 7.10).</p>     <b>Упражнение 7.10. Тестирование блокировок файла</b>     <p>В этом примере вы напишете программу, проверяющую блокировки разных типов, установленные для различных участков файла.</p>     <p>1. Как обычно, начнем с заголовочных файлов и объявлений:</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;fcntl.h&gt;</blockquote></p>     <br>     <p><blockquote>const char *test_file = "/tmp/test_lock";</blockquote></p>     <p><blockquote>#define SIZE_TO_TRY 5</blockquote></p>     <p><blockquote>void show_lock_info(struct flock *to_show);</blockquote></p>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int file_desc;</blockquote></p>     <p><blockquote> int res;</blockquote></p>     <p><blockquote> struct flock region_to_test;</blockquote></p>     <p><blockquote> int start_byte;</blockquote></p>     <p>2. Откройте дескриптор файла:</p>     <p><blockquote> file_desc = open(test_file, O_RDWR | O_CREAT, 0666);</blockquote></p>     <p><blockquote> if (!file_desc) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Unable to open %s for read/write", test_file);</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> for (start_byte = 0; start_byte &lt; 99; start_byte += SIZE_TO_TRY) {</blockquote></p>     <p>3. Задайте участок файла, который хотите проверить:</p>     <p><blockquote>  region_to_test.l_type = F_WRLCK;</blockquote></p>     <p><blockquote>  region_to_test.l_whence = SEEK_SET;</blockquote></p>     <p><blockquote>  region_to_test.lstart = start_byte;</blockquote></p>     <p><blockquote>  region_to_test.l_len = SIZE_TO_TRY;</blockquote></p>     <p><blockquote>  region_to_test.l_pid = -1;</blockquote></p>     <p><blockquote>  printf("Testing F_WRLCK on region from %d to %d\n", start_byte, start_byte + SIZE_TO_TRY);</blockquote></p>     <p>4. Теперь проверьте блокировку файла:</p>     <p><blockquote>  res = fcntl(file_desc, F_GETLK, &amp;region_to_test);</blockquote></p>     <p><blockquote>  if (res == -1) {</blockquote></p>     <p><blockquote>   fprintf(stderr, "F_GETLK failed\n");</blockquote></p>     <p><blockquote>   exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  if (region_to_test.l_pid != -1) {</blockquote></p>     <p><blockquote>   printf("Lock would fail. F_GETLK returned:\n");</blockquote></p>     <p><blockquote>   showlockinfo(&amp;region_to_test);</blockquote></p>     <p><blockquote>  } else {</blockquote></p>     <p><blockquote>   printf("F_WRLCK - Lock would succeed\n");</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p>5. Далее повторите тест с разделяемой блокировкой (на чтение). Снова задайте участок файла, который хотите проверить:</p>     <p><blockquote>  region_to_test.l_type = F_RDLCK;</blockquote></p>     <p><blockquote>  region_to_test.l_whence = SEEK_SET;</blockquote></p>     <p><blockquote>  region_to_test.l_start = start_byte;</blockquote></p>     <p><blockquote>  region_to_test.l_len = SIZE_TO_TRY;</blockquote></p>     <p><blockquote>  region_to_test.l_pid = -1;</blockquote></p>     <p><blockquote>  printf("Testing F_RDLCK on region from %d to %d\n", start_byte, start_byte + SIZE_TO_TRY);</blockquote></p>     <p>6. Еще раз проверьте блокировку файла:</p>     <p><blockquote>  res = fcntl(file_desc, F_GETLK, &amp;region_to_test);</blockquote></p>     <p><blockquote>  if (res == -1) {</blockquote></p>     <p><blockquote>   fprintf(stderr, "F_GETLK failed\n");</blockquote></p>     <p><blockquote>   exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  if (region_to_test.l_pid != -1) {</blockquote></p>     <p><blockquote>   printf("Lock would fail. F_GETLK returned:\n");</blockquote></p>     <p><blockquote>   show_lock_info(&amp;region_to_test);</blockquote></p>     <p><blockquote>  } else {</blockquote></p>     <p><blockquote>   printf("F_RDLCK — Lock would succeed\n");</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> close(file_desc);</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p><blockquote>void show_lock_info(struct flock *to_show) {</blockquote></p>     <p><blockquote> printf("\tl_type %d, ", to_show-&gt;l_type);</blockquote></p>     <p><blockquote> printf("l_whence %d, ", to_show-&gt;l_whence);</blockquote></p>     <p><blockquote> printf("l_start %d, (int)to_show-&gt;l_start);</blockquote></p>     <p><blockquote> printf("l_len %d, ", (int)to_show-&gt;l_len);</blockquote></p>     <p><blockquote> printf("l_pid %d\n", to_show-&gt;l_pid);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Для проверки блокировки сначала запустите программу lock3, затем выполните программу lock4, чтобы протестировать заблокированный файл. Сделайте это, запустив программу lock3 в фоновом режиме с помощью следующей команды:</p>     <p><blockquote>$ <b>./lock3 &amp;</b></blockquote></p>     <p><blockquote>$ process 1534 locking file</blockquote></p>     <p>На экране появится приглашение для ввода команд, поскольку lock3 выполняется в фоновом режиме. Далее сразу же запустите программу lock4 с помощью следующей команды:</p>     <p><blockquote>$ <b>./lock4</b></blockquote></p>     <p>Вы получите вывод, приведенный далее с некоторыми пропусками для краткости:</p>     <p><blockquote>Testing F_WRLCK on region from 0 to 5</blockquote></p>     <p><blockquote>F_WRLCK — Lock would succeed</blockquote></p>     <p><blockquote>Testing F_RDLCK on region from 0 to 5</blockquote></p>     <p><blockquote>F_RDLCK - Lock would succeed</blockquote></p>     <p><blockquote>...</blockquote></p>     <p><blockquote>Testing F_WRLCK on region from 10 to 15</blockquote></p>     <p><blockquote>Lock would fail. F_GETLK returned:</blockquote></p>     <p><blockquote>l_type 0, l_whence 0, l_start 10, l_len 20, l_pid 1534</blockquote></p>     <p><blockquote>Testing F_RDLCK on region from 10 to 15</blockquote></p>     <p><blockquote>F_RDLCK — Lock would succeed</blockquote></p>     <p><blockquote>Testing F_WRLCK on region from 15 to 20</blockquote></p>     <p><blockquote>Lock would fail. F_GETLK returned:</blockquote></p>     <p><blockquote>l_type 0, l_whence 0, l_start 10, l_len 20, l_pid 1534</blockquote></p>     <p><blockquote>Testing F_RDLCK on region from 15 to 20</blockquote></p>     <p><blockquote>F_RDLCK — Lock would succeed</blockquote></p>     <p><blockquote>...</blockquote></p>     <p><blockquote>Testing F_WRLCK on region from 25 to 30</blockquote></p>     <p><blockquote>Lock would fail. F_GETLK returned:</blockquote></p>     <p><blockquote>l_type 0, l_whence 0, l_start 10, l_len 20, l_pid 1534</blockquote></p>     <p><blockquote>Testing F_RDLCK on region from 25 to 30</blockquote></p>     <p><blockquote>F_RDLCK — Lock would succeed</blockquote></p>     <p><blockquote>...</blockquote></p>     <p><blockquote>Testing F_WRLCK on region from 40 to 45</blockquote></p>     <p><blockquote>Lock would fail. F_GETLK returned:</blockquote></p>     <p><blockquote>l_type 1, l_whence 0, l_start 40, l_len 10, l_pid 1534</blockquote></p>     <p><blockquote>Testing F_RDLCK on region from 40 to 45</blockquote></p>     <p><blockquote>Lock would fail. F_GETLK returned:</blockquote></p>     <p><blockquote>l_type 1, l_whence 0, l_start 40, l_len 10, l_pid 1534</blockquote></p>     <p><blockquote>...</blockquote></p>     <p><blockquote>Testing F_RDLCK on region from 95 to 100</blockquote></p>     <p><blockquote>F_RDLCK - Lock would succeed</blockquote></p>     <p><b>Как это работает</b></p>     <p>Для каждой группы из пяти байтов в файле программа lock4 задает структуру участка файла для тестирования блокировок, которую она потом применяет для определения того, может ли этот участок быть заблокирован для чтения или записи. Возвращаемая информация показывает байты, относящиеся к участку файла, смещение от нулевого байта, которое могло бы вызвать аварийное завершение запроса на блокировку. Поскольку поле <blockquote>l_pid</blockquote> возвращаемой структуры содержит идентификатор программы, владеющей в данный момент заблокированным файлом, программа задает ему значение -1 (некорректное значение) и затем проверяет, изменилось ли оно после завершения вызова <blockquote>fcntl</blockquote>. Если участок в данный момент не заблокирован, поле <blockquote>l_pid</blockquote> не изменится.</p>     <p>Для того чтобы понять вывод, следует заглянуть в заголовочный файл fcntl.h (обычно /usr/include/fcntl.h) и увидеть, что поле <blockquote>l_type</blockquote>, равное 1, вытекает из определения <blockquote>F_WRLCK</blockquote> как 1, а равное 0 из определения <blockquote>F_RDLCK</blockquote> как 0. Таким образом, поле <blockquote>l_type</blockquote>, равное 1, говорит о том, что блокировка не будет установлена, поскольку существует блокировка на запись, а поле <blockquote>l_type</blockquote>, равное 0, свидетельствует о существовании блокировки на чтение. Для тех участков файла, которые не заблокировала программа lock3, могут быть установлены и разделяемая, и исключительная блокировки.</p>     <p>Для байтов с 10-го по 30-й возможна установка разделяемой блокировки, поскольку блокировка, установленная программой lock3, не исключительная, а разделяемая. Для участка с 40-го по 50-й байт нельзя установить оба типа блокировки, поскольку lock3 задала исключительную (<blockquote>F_WRLCK</blockquote>) блокировку для этого участка.</p>     <p>После завершения программы lock4 необходимо немного подождать, чтобы программа lock3 завершила вызов <blockquote>sleep</blockquote> и закончила выполнение.</p>             <a name="metkadoc13"><h1>Конкурирующие блокировки</h1></a>     <p>Теперь, когда вы увидели, как проверять существующие блокировки файла, давайте посмотрим, что произойдет, когда две программы состязаются за получение блокировки для одного и того же участка файла. Вы воспользуетесь снова программой lock3 для блокировки файла и новой программой lock5 для попытки установить новую блокировку файла. В завершение вы добавите в программу lock5 несколько вызовов для снятия блокировки (упражнение 7.11).</p>     <b>Упражнение 7.11. Конкурирующие блокировки</b>     <p>Далее приведена программа lock5.с, которая пытается заблокировать уже заблокированные участки файла вместо того, чтобы проверить состояние блокировки других частей файла.</p>     <p>После директив #include и объявлений откройте дескриптор файла.</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;fcntl.h&gt;</blockquote></p>     <br>     <p><blockquote>const char *test_file = "/tmp/test_lock";</blockquote></p>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int file_desc;</blockquote></p>     <p><blockquote> struct flock region_to_lock;</blockquote></p>     <p><blockquote> int res;</blockquote></p>     <p><blockquote> file_desc = open(test_file, O_RDWR | O_CREAT, 0666);</blockquote></p>     <p><blockquote> if (!file_desc) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Unable to open %s for read/write\n", test_file);</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p>В оставшейся части программы задаются разные участки файла, и делается попытка установить для них блокировки разных типов:</p>     <p><blockquote> region_to_lock.l_type = F_RDLCK;</blockquote></p>     <p><blockquote> region_to_lock.l_whence = SEEK_SET;</blockquote></p>     <p><blockquote> region_to_lock.l_start = 10;</blockquote></p>     <p><blockquote> region_to_lock.l_len = 5;</blockquote></p>     <p><blockquote> printf("Process %d, trying F_RDLCK, region %d to %d\n", getpid(), (int)region_to_lock.l_start,</blockquote></p>     <p><blockquote>  (int)(region_to_lock.l_start + region_to_lock.l_len));</blockquote></p>     <p><blockquote> res = fcntl(file_desc, F_SETLK, &amp;region_to_lock);</blockquote></p>     <p><blockquote> if (res == -1) {</blockquote></p>     <p><blockquote>  printf("Process %d - failed to lock region\n", getpid());</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  printf("Process %d — obtained lock region\n", getpid());</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> region_to_lock.l_type = F_UNLCK;</blockquote></p>     <p><blockquote> region_to_lock.l_whence = SEEK_SET;</blockquote></p>     <p><blockquote> region_to_lock.l_start = 10;</blockquote></p>     <p><blockquote> region_to_lock.l_len = 5;</blockquote></p>     <p><blockquote> printf("Process %d, trying F_UNLCK, region %d to %d\n", getpid(), (int)region_to_lock.l_start,</blockquote></p>     <p><blockquote>  (int)(region_to_lock.l_start + region_to_lock.l_len));</blockquote></p>     <p><blockquote> res = fcntl(file_desc, F_SETLK, &amp;region_to_lock);</blockquote></p>     <p><blockquote> if (res == -1) {</blockquote></p>     <p><blockquote>  printf("Process %d — failed to unlock region\n", getpid());</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  printf("Process %d — unlocked region\n", getpid());</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> region_to_lock.l_type = F_UNLCK;</blockquote></p>     <p><blockquote> region_to_lock.l_whence = SEEK_SET;</blockquote></p>     <p><blockquote> region_to_lock.l_start = 0;</blockquote></p>     <p><blockquote> region_to_lock.l_len = 50;</blockquote></p>     <p><blockquote> printf("Process %d, trying F_UNLCK, region %d to %d\n", getpid()", (int)region_to_lock.l_start,</blockquote></p>     <p><blockquote>  (int)(region_to_lock.l_start + region_to_lock.l_len));</blockquote></p>     <p><blockquote> res = fcntl(file_desc, F_SETLK, &amp;region_to_lock);</blockquote></p>     <p><blockquote> if (res == -1) {</blockquote></p>     <p><blockquote>  printf("Process %d — failed to unlock region\n", getpid());</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  printf("Process %d — unlocked region\n", getpid());</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> region_to_lock.l_type = F_WRLCK;</blockquote></p>     <p><blockquote> region_to_lock.l_whence = SEEK_SET;</blockquote></p>     <p><blockquote> region_to_lock.lstart = 16;</blockquote></p>     <p><blockquote> region_to_lock.l_len = 5;</blockquote></p>     <p><blockquote> printf("Process %d, trying F_WRLCK, region %d to %d\n", getpid(), (int)region_to_lock.l_start,</blockquote></p>     <p><blockquote>  (int)(region_to_lock.l_start + region_to_lock.l_len));</blockquote></p>     <p><blockquote> res = fcntl(file_desc, F_SETLK, &amp;region_to_lock);</blockquote></p>     <p><blockquote> if (res == -1) {</blockquote></p>     <p><blockquote>  printf("Process %d — failed to lock region\n", getpid());</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  printf("Process %d — obtained lock on region\n", getpid());</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> region_to_lock.l_type = F_RDLCK;</blockquote></p>     <p><blockquote> region_to_lock.l_whence = SEEK_SET;</blockquote></p>     <p><blockquote> region_to_lock.l_start = 40;</blockquote></p>     <p><blockquote> region_to_lock.l_len = 10;</blockquote></p>     <p><blockquote> printf("Process %d, trying F_RDLCK, region %d to %d\n", getpid(), (int)region_to_lock.l_start,</blockquote></p>     <p><blockquote>  (int)(region_to_lock.l_start + region_to_lock.l_len));</blockquote></p>     <p><blockquote> res = fcntl(filedesc, F_SETLK, &amp;region_to_lock);</blockquote></p>     <p><blockquote> if (res == -1) {</blockquote></p>     <p><blockquote>  printf("Process %d — failed to lock region\n", getpid());</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  printf("Process %d — obtained lock on region\n", getpid());</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> region_to_lock.l_type = F_WRLCK;</blockquote></p>     <p><blockquote> region_to_lock.l_whence = SEEK_SET;</blockquote></p>     <p><blockquote> region_to_lock.l_start = 16;</blockquote></p>     <p><blockquote> region_to_lock. l_len = 5;</blockquote></p>     <p><blockquote> printf("Process %d, trying F_WRLCK with wait, region %d to %d\n", getpid(), (int)region_to_lock.l_start,</blockquote></p>     <p><blockquote>  (int)(region_to_lock.l_start + region_to_lock.l_len));</blockquote></p>     <p><blockquote> res = fcntl(file_desc, F_SETLKW, &amp;region_to_lock);</blockquote></p>     <p><blockquote> if (res == -1) {</blockquote></p>     <p><blockquote>  printf("Process %d — failed to lock region\n", getpid());</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  printf("Process %d — obtained lock, on region\n", getpid());</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote>printf ("Process %d ending\n", getpid());</blockquote></p>     <p><blockquote> close(file_desc);</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Если вы сначала запустите программу lock3 в фоновом режиме, далее сразу запускайте новую программу:</p>     <p><blockquote>$ .<b>/lock3 &amp;</b></blockquote></p>     <p><blockquote>$ process 227 locking file</blockquote></p>     <p><blockquote>$ <b>./lock5</b></blockquote></p>     <p>Вы получите следующий вывод:</p>     <p><blockquote>Process 227 locking file</blockquote></p>     <p><blockquote>Process 228, trying F_RDLCK, region 10 to 15</blockquote></p>     <p><blockquote>Process 228 — obtained lock on region</blockquote></p>     <p><blockquote>Process 228, trying F_UNLCK, region 10 to 15</blockquote></p>     <p><blockquote>Process 228 — unlocked region</blockquote></p>     <p><blockquote>Process 228, trying F_UNLCK, region 0 to 50</blockquote></p>     <p><blockquote>Process 228 — unlocked region</blockquote></p>     <p><blockquote>Process 228, trying F_WRLCK, region 16 to 21</blockquote></p>     <p><blockquote>Process 228 — failed to lock on region</blockquote></p>     <p><blockquote>Process 228, trying F_RDLCK, region 4 0 to 50</blockquote></p>     <p><blockquote>Process 228 - failed to lock on region</blockquote></p>     <p><blockquote>Process 228, trying F_WRLCK with wait, region 16 to 21</blockquote></p>     <p><blockquote>Process 227 closing file</blockquote></p>     <p><blockquote>Process 228 — obtained lock on region</blockquote></p>     <p><blockquote>Process 228 ending</blockquote></p>     <p><b>Как это работает</b></p>     <p>Сначала программа пытается заблокировать участок с 10-го по 15-й байты с помощью разделяемой блокировки. Эта область уже заблокирована блокировкой того же типа, но одновременные разделяемые блокировки допустимы, и установка блокировки завершается успешно.</p>     <p>Затем программа снимает свою разделяемую блокировку с участка файла, и эта операция тоже завершается успешно. Далее она пытается разблокировать первые 50 байтов файла, даже если у них нет никакой блокировки. Это действие тоже завершается успешно, потому что, несмотря на то, что программа не установила блокировок на этот участок, конечный результат запроса на снятие блокировки заключается в констатации того, что для первых 50 байтов данная программа не поддерживает никаких блокировок.</p>     <p>Далее программа пытается заблокировать участок с 16-то по 21-й байты исключительной блокировкой. Эта область уже заблокирована разделяемой блокировкой, поэтому новая попытка блокировки завершается аварийно, т.к. не может быть создана исключительная блокировка. </p>     <p>После этого программа пробует установить разделяемую блокировку на участок с 40-го по 50-й байты. Эта область уже заблокирована исключительной блокировкой, поэтому данная операция снова завершается аварийно.</p>     <p>В заключение программа опять пытается получить исключительную блокировку для участка с 16-го по 21-й байты, но в этот раз она применяет команду <blockquote>F_SETLKW</blockquote>, позволяющую ждать до тех пор, пока блокировка не будет установлена. В выводе наступает долгая пауза, длящаяся, пока программа lock3, заблокировавшая этот участок, завершает вызов <blockquote>sleep</blockquote> и закрывает файл, тем самым снимая все установленные блокировки. Программа lock5 возобновляет выполнение, успешно блокирует участок файла и затем тоже завершается.</p>             <a name="metkadoc14"><h1>Другие команды блокировок</h1></a>     <p>Есть второй метод блокировки файлов — функция <blockquote>lockf</blockquote>. Она тоже действует, используя дескрипторы файлов.</p>     <p>У функции следующий прототип:</p>     <p><blockquote><b>#include &lt;unistd.h&gt;</b></blockquote></p>     <p><blockquote><b>int lockf(int fildes, int function, off_t size_to_lock);</b></blockquote></p>     <p>Параметр <blockquote>function</blockquote> может принимать следующие значения:</p>     <p>&#9633; <blockquote>F_ULOCK</blockquote> — разблокировать;</p>     <p>&#9633; <blockquote>F_LOCK</blockquote> — заблокировать монопольно;</p>     <p>&#9633; <blockquote>F_TLOCK</blockquote> — проверить и заблокировать монопольно;</p>     <p>&#9633; <blockquote>F_TEST</blockquote> — проверить наличие блокировок других процессов.</p>     <p>Параметр <blockquote>size_to_lock</blockquote> содержит количество обрабатываемых байтов, отсчитываемых в файле от текущей величины смещения. У функции <blockquote>lockf</blockquote> более простой интерфейс, чем у вызова <blockquote>fcntl</blockquote> в основном потому, что у нее меньше функциональных возможностей и гибкости. Для применения функции вы должны найти начало участка, который хотите заблокировать, затем вызвать функцию, указав количество блокируемых байтов.</p>     <p>Как и в случае вызова <blockquote>fcntl</blockquote>, все блокировки только рекомендательные; они на самом деле не могут помешать чтению из файла или записи в файл. За проверку имеющихся блокировок отвечают программы. Эффект от смешивания блокировок с помощью <blockquote>fcntl</blockquote> и блокировок с помощью <blockquote>lockf</blockquote> непредсказуем, поэтому вам следует решить, какой способ выбрать, и строго его придерживаться.</p>             <a name="metkadoc15"><h1>Взаимоблокировки</h1></a>     <p>Обсуждение блокировок не было бы законченным без упоминания об опасности взаимоблокировок или тупиков. Предположим, что две программы хотят обновить один и тот же файл. Им обеим нужно обновить байт 1 и байт 2 одновременно. Программа А выбирает первым обновление байта 2, затем байта 1. Программа В пытается обновить сначала байт 1, затем байт 2.</p>     <p>Обе программы стартуют одновременно. Программа А блокирует байт 2, а программа В — байт 1. Программа А пытается установить блокировку для байта 1. Поскольку он уже заблокирован программой В, программа А ждет. Программа В пытается заблокировать байт 2. Поскольку он уже заблокирован программой А, программа В тоже ждет.</p>     <p>Ситуация, в которой ни одна программа не может выполняться, называется<i> взаимоблокировкой</i> или<i> тупиковой ситуацией.</i> Эта проблема очень распространена в работающих с базами данных приложениях, в которых многие пользователи часто пытаются получить доступ к одним и тем же данным. Многие коммерческие реляционные базы данных обнаруживают взаимоблокировки и устраняют их автоматически; ядро Linux этого не делает. Для устранения возникшего непорядка требуется внешнее вмешательство, возможно, принудительно завершающее выполнение одной из программ.</p>     <p>Программистам стоит опасаться подобных ситуаций. Если у вас есть несколько программ ждущих установки блокировок, нужно быть очень внимательным и рассмотреть возможность возникновения тупиковой ситуации. В данном примере этого легко избежать: обе программы просто должны блокировать нужные им байты в одном и том же порядке или использовать область большего размера для блокировки.</p>     <blockquote>      <b>Примечание</b>      <p>В этой книге из-за ограниченности объема у нас нет возможности рассматривать трудности действующих одновременно программ. Если вы хотите почитать побольше об этом, попробуйте найти книгу: Ben-Ari М. Principles of Concurrent and Distributed Programming. — Prentice Hall, 1990 (Бен-Ари M. Принципы параллельного и распределенного программирования).</p>     </blockquote>              <a name="metkadoc16"><h1>Базы данных</h1></a>         <p>Вы научились использованию файлов для хранения данных, зачем применять для этого базы данных? Очень просто, в некоторых обстоятельствах средства баз данных предоставляют лучший способ решения проблем. Применение базы данных лучше, чем хранение файлов, по двум причинам:</p>     <p>&#9633; вы можете хранить записи данных переменного размера, что довольно трудно реализовать с помощью простых неструктурированных файлов;</p>     <p>&#9633; базы данных эффективнее хранят и извлекают данные, применяя индекс. Это большое преимущество, потому что этот индекс должен быть не просто номером записи, который легко было бы реализовать в обычном файле, а произвольной строкой.</p>             <a name="metkadoc17"><h1>База данных dbm</h1></a>     <p>Все версии Linux и большая часть вариантов систем UNIX поставляются с базовым, но очень эффективным набором подпрограмм для хранения данных, называемым базой данных dbm. База данных dbm отлично подходит для хранения индексированных данных, которые относительно статичны. Некоторые консерваторы в области баз данных могут возразить, что dbm — вовсе не база данных, а просто система хранения индексных файлов. Стандарт X/Open, тем не менее, называет dbm базой данных, поэтому в книге мы будем продолжать называть ее так же.</p>     <b>Введение в базу данных dbm</b>     <p>Несмотря на взлет свободно распространяемых реляционных баз данных, таких как MySQL и PostgreSQL, база данных dbm продолжает играть важную роль в системе Linux. Дистрибутивы, использующие RPM, например, Red Hat и SUSE, применяют dbm как внутреннее хранилище для данных устанавливаемых пакетов. Реализация LDAP с открытым кодом, Open LDAP (Lightweight Directory Access Protocol, облегченный протокол доступа к каталогу), также может применять dbm как механизм хранения. Преимущества dbm по сравнению с более сложными базами данных, такими как MySQL, в ее "легковесности" и возможности более простого встраивания в распределенный двоичный код (distributed binary), поскольку не требуется установка отдельного сервера базы данных. Во время написания книги программы Sendmail и Apache использовали dbm.</p>     <p>База данных dbm позволяет хранить структуры данных переменного размера с помощью индекса и затем извлекать структуру либо используя индекс, либо просто последовательно просматривая базу данных. Базу данных dbm лучше всего применять для данных, к которым часто обращаются, но которые редко обновляются, поскольку она довольно медленно создает элементы, но быстро извлекает их.</p>     <p>В данный момент мы сталкиваемся с небольшой проблемой: в течение многих лет было сформировано несколько версий базы данных dbm с разными API и средствами. Существует исходный набор dbm, "новый" набор dbm, называемый ndbm, и реализация проекта GNU gdbm. Реализация GNU может эмулировать интерфейсы более старой версии dbm и версии ndbm, но ее собственный интерфейс существенно отличается от других реализаций. Различные дистрибутивы Linux поставляются с библиотеками разных версий dbm, но самый популярный вариант — поставка с библиотекой gdbm и установка ее с возможностью эмуляции интерфейсов двух других типов.</p>     <p>В книге мы собираемся сосредоточиться на интерфейсе ndbm, поскольку он стандартизован X/OPEN и его применять легче, чем непосредственно интерфейс реализации gdbm.</p>     <b>Получение dbm</b>     <p>Самые широко распространенные дистрибутивы Linux приходят с уже установленной версией gdbm, хотя в некоторых из них вам придется применить соответствующий диспетчер пакетов (package manager) для установки нужных библиотек разработки. Например, в дистрибутиве Ubuntu вам может понадобиться диспетчер пакетов Synaptic для установки пакета libgdbm-dev, если он не установлен по умолчанию.</p>     <p>Если вы хотите просмотреть исходный код или используете дистрибутив, в который не включен встроенный пакет разработки, реализацию GNU можно найти по адресу <b>www.gnu.org/software/gdbm/gdbm.html.</b></p>     <b>Устранение неполадок и повторная установка dbm</b>     <p>Эта глава написана в расчете на то, что у вас установлена реализация GNU gdbm, укомплектованная библиотеками совместимости с ndbm. Это обычный вариант для дистрибутивов Linux, однако, как упоминалось ранее, возможно, вам придется явно устанавливать пакет библиотеки разработки для того, чтобы компилировать файлы с использованием подпрограмм ndbm.</p>     <p>К сожалению, требуемые библиотеки директив <blockquote>include</blockquote> и компоновки слегка различаются в разных дистрибутивах, поэтому, несмотря на их установку, вам, возможно, придется поэкспериментировать немного, чтобы выяснить, как компилировать исходные файлы с использованием ndbm. Наиболее частый вариант — база данных gdbm установлена и поддерживает по умолчанию режим совместимости с версией ndbm. Дистрибутивы, например Red Hat, как правило, делают это. В этом случае вам нужно выполнить следующие шаги:</p>     <p>1. Включите в ваш файл на языке С файл ndbm.h.</p>     <p>2. Включите каталог заголовочного файла /usr/include/gdbm с помощью опции <blockquote>-I/usr/include/gdbm</blockquote>.</p>     <p>3. Скомпонуйте программу с библиотекой gdbm, используя опцию <blockquote>-lgdbm</blockquote>.</p>     <p>Если программа не работает, обычная альтернатива, принятая в новейших версиях дистрибутивов Ubuntu и SUSE, — устанавливается база данных gdbm, но при необходимости явно запрашивается совместимость с базой данных ndbm, и вы должны компоновать программу сначала с библиотекой совместимости, а затем с основной библиотекой. В этом случае надо выполнить следующие шаги:</p>     <p>1. Вместо файла ndbm.h включите в ваш файл на С файл gdbm-ndbrh.h.</p>     <p>2. Включите каталог заголовочного файла /usr/include/gdbm с помощью опции <blockquote>-I/usr/include/gdbm</blockquote>.</p>     <p>3. Скомпонуйте программу с дополнительной библиотекой совместимости gdbm, используя опцию <blockquote>-lgdbm_compat -lgdbm</blockquote>.</p>     <p>Загружаемый Makefile и С-файлы dbm установлены с первым вариантом, принятым по умолчанию, но содержат комментарии о том, как их отредактировать, чтобы можно было легко выбрать второй вариант. В оставшейся части главы мы полагаем, что в вашей системе совместимость с ndbm — характеристика, принятая по умолчанию.</p>             <a name="metkadoc18"><h1>Подпрограммы<i> dbm</i></h1></a>     <p>Как и библиотека curses, обсуждавшаяся нами в<i> главе 6,</i> средство dbm состоит из заголовочного файла и библиотеки, которая должна компоноваться с программой во время компиляции последней. Библиотека называется просто dbm, но поскольку мы обычно применяем в системе Linux реализацию GNU, необходимо компоновать с этой реализацией, используя в строке компиляции опцию <blockquote>-lgdbm</blockquote>. Заголовочный файл — ndbm.h.</p>     <p>Прежде чем мы попытаемся описать каждую функцию, важно понять чего старается достичь база данных dbm. Когда вы поймете это, гораздо легче будет уяснить, как применять функции dbm.</p>     <p>Основной элемент базы данных dbm — блок данных, предназначенных для хранения, связанный с блоком данных, действующих как ключ для извлечения данных. У всех баз данных dbm должны быть уникальные ключи для каждого хранящегося блока данных. Значение ключа используется как индекс хранящихся данных. Нет ограничений на ключи или данные и не определено никаких ошибок при использовании данных или ключей слишком большого размера. Стандарт допускает реализацию, ограничивающую размер ключа/данных величиной 1023 байта, но, как правило, ограничений не существует, поскольку реализации оказались более гибкими, чем требования, предъявляемые к ним.</p>     <p>Для манипулирования этими блоками как данными в заголовочном файле ndbm.h определен новый тип данных, названный <blockquote>datum</blockquote>. Конкретное содержимое этого типа зависит от реализации, но он должен, как минимум, включать следующие элементы:</p>     <p><blockquote><b>void *dptr;</b></blockquote></p>     <p><blockquote><b>size_t dsize</b></blockquote></p>     <p>Здесь <blockquote>datum</blockquote> — тип, который будет определяться оператором typedef. В файле ndbm.h также дано определение dbm, представляющее собой структуру, применяемую для доступа к базе данных, и во многом похожее на определение <blockquote>FILE</blockquote>, используемое для доступа к файлам. Внутреннее содержимое <blockquote>dbm typedef</blockquote> зависит от реализации и никогда не должно использоваться.</p>     <p>Для ссылки на блок данных при использовании библиотеки dbm вы должны объявить <blockquote>datum</blockquote>, задать указатель <blockquote>dptr</blockquote> для указания на начало данных, а также задать параметр <blockquote>dsize</blockquote>, содержащий размер данных. На хранящиеся данные и индекс, применяемый для доступа к ним, всегда нужно ссылаться с помощью типа <blockquote>datum</blockquote>.</p>     <b>О типе <blockquote>DBM</blockquote> лучше всего думать как об аналоге типа <blockquote>FILE</blockquote>. Когда вы открываете базу данных dbm, обычно создаются два физических файла: один с расширением pag, а другой с расширением dir. Возвращается один указатель dbm, который применяется для обращения к обоим файлам как к паре. Файлы никогда не следует непосредственно читать и в них не нужно писать; они предназначены для доступа через стандартные операции dbm.</b>     <blockquote>      <b>Примечание</b>      <p>В некоторых реализациях эти два файла объединены, и создается один новый файл.</p>     </blockquote>     <p>Если вы знакомы с базами данных SQL, то заметите, что в случае базы данных dbm не существует структур таблиц или столбцов. Эти структуры не нужны, т.к. dbm не задает фиксированного размера элементов сохраняемых данных и не требует описания внутренней структуры для них. Библиотека dbm работает с блоками неструктурированных двоичных данных.</p>             <a name="metkadoc19"><h1>Функции доступа dbm</h1></a>     <p>Теперь, когда мы рассказали об основах работы библиотеки dbm, можем поподробнее рассмотреть функции. Далее приведены прототипы основных функций dbm.</p>     <p><blockquote><b>#include &lt;ndbm.h&gt;</b></blockquote></p>     <p><blockquote><b>DBM *dbm_open(const char* filename, int file_open_flags,</b></blockquote></p>     <p><blockquote><b> mode_t file_mode);</b></blockquote></p>     <p><blockquote><b>int dbm_store(DBM *database_descriptor, datum key, datum content,</b></blockquote></p>     <p><blockquote><b> int store_mode);</b></blockquote></p>     <p><blockquote><b>datum dbm_fetch(DBM* database descriptor, datum key);</b></blockquote></p>     <p><blockquote><b>void dbm_close(DBM *database descriptor);</b></blockquote></p>     <b><i>dbm_open</i></b>     <p>Эта функция применяется для открытия имеющихся баз данных и для создания новых баз данных. Аргумент <blockquote>filename</blockquote> — имя файла базы данных без расширения dir или pag.</p>     <p>Остальные параметры такие же, как второй и третий параметры функции <blockquote>open</blockquote>, с которой вы встречались в<i> главе 3.</i> Вы можете использовать те же директивы <blockquote>#define</blockquote>. Второй аргумент управляет возможностью чтения базы данных, записью в нее или обеими операциями. Если создается новая база данных, флаги должны быть двоичными <blockquote>O_READ</blockquote> с <blockquote>O_CREAT</blockquote>, чтобы разрешить создание файлов. Третий аргумент задает начальные права доступа к файлам, которые будут созданы.</p>     <p>Функция <blockquote>dbm_open</blockquote> возвращает указатель на тип <blockquote>DBM</blockquote>. Он применяется во всех последующих обращениях к базе данных. В случае аварийного завершения возвращается <blockquote>(DBM*)0</blockquote>.</p>     <b><i>dbm_store</i></b>     <p>Эту функцию применяют для ввода данных в базу данных. Как упоминалось ранее, все данные должны сохраняться с уникальным индексом. Для определения данных, которые вы хотите сохранить, и индекса, используемого для ссылки на них, следует задать два типа datum: один для ссылки на индекс, а другой — на реальные данные. Последний параметр <blockquote>store_mode</blockquote> управляет действиями, совершаемыми при попытке сохранить какие-либо данные с применением ключа, который уже существует. Если установлено значение параметра <blockquote>dbm_insert</blockquote>, сохранение завершается аварийно и функция <blockquote>dbm_store</blockquote> возвращает 1. Если установлено значение параметра <blockquote>dbm_replace</blockquote>, новые данные заменяют существующие и <blockquote>dbm_store</blockquote> возвращает 0. При возникновении других ошибок функция <blockquote>dbm_store</blockquote> возвращает отрицательные числа.</p>     <b><i>dbm_fetch</i></b>     <p>Подпрограмма <blockquote>dbm_fetch</blockquote> применяется для извлечения данных из базы данных. Она принимает в качестве параметра указатель dbm, возвращенный предшествующим вызовом функции <blockquote>dbm_open</blockquote> и тип <blockquote>datum</blockquote>, который должен быть задан как указатель на ключ. Тип <blockquote>datum</blockquote> возвращается, если данные, относящиеся к используемому ключу, найдены в базе данных, возвращаемая структура <blockquote>datum</blockquote> будет иметь значения <blockquote>dptr</blockquote> и <blockquote>dsize</blockquote>, ссылающиеся на возвращенные данные. Если ключ не найден, <blockquote>dptr</blockquote> будет равен <blockquote>null</blockquote>.</p>     <blockquote>      <b>Примечание</b>      <p>Важно помнить, что функция <blockquote>dbm_fetch</blockquote> возвращает только параметр типа <blockquote>datum</blockquote>, содержащий указатель на данные. Реальные данные могут находиться в локальной области памяти внутри библиотеки dbm и должны быть скопированы в переменные программы перед дальнейшими вызовами функций dbm.</p>     </blockquote>     <b><i>dbm_close</i></b>     <p>Эта подпрограмма закрывает базу данных, открытую функцией <blockquote>dbm_open</blockquote>, и должна получить указатель <blockquote>DBM</blockquote>, возвращенный предшествующим вызовом <blockquote>dbm_open</blockquote>.</p>     <p>А теперь выполните упражнение 7.12.</p>     <b>Упражнение 7.12. Простая база данных dbm</b>     <p>Познакомившись с основными функциями базы данных dbm, теперь вы знаете, как написать вашу первую программу для работы с dbm (dbm1.c). В этой программе применяется структура, названная <blockquote>test_data</blockquote>.</p>     <p>1. Первыми представлены файлы <blockquote>#include</blockquote>, директивы <blockquote>#define</blockquote>, функция <blockquote>main</blockquote> и объявление структуры <blockquote>test_data</blockquote>:</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;fcntl.h&gt;</blockquote></p>     <p><blockquote>#include &lt;ndbm.h&gt;</blockquote></p>     <p><blockquote>/* В некоторых системах вам нужно заменить вышестоящую строку строкой #include &lt;gdbm-ndbm.h&gt;*/</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <p><blockquote>#define TEST_DB_FILE "/tmp/dbm1_test"</blockquote></p>     <p><blockquote>#define ITEMS_USED 3</blockquote></p>     <br>     <p><blockquote>struct test_data {</blockquote></p>     <p><blockquote> char misc_chars[15];</blockquote></p>     <p><blockquote> int any_integer;</blockquote></p>     <p><blockquote> char more_chars[21];</blockquote></p>     <p><blockquote>};</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p>2. В функции <blockquote>main</blockquote> задайте элементы структур <blockquote>items_to_store</blockquote> и <blockquote>items_received</blockquote>, строку <blockquote>key</blockquote> и типы <blockquote>datum</blockquote>:</p>     <p><blockquote> struct test_data items_to_store[ITEMS_USED];</blockquote></p>     <p><blockquote> struct test_data item_retrieved;</blockquote></p>     <p><blockquote> char key_to_use[20];</blockquote></p>     <p><blockquote> int i, result;</blockquote></p>     <p><blockquote> datum key_datum;</blockquote></p>     <p><blockquote> datum data_datum;</blockquote></p>     <p><blockquote> DBM *dbm_ptr;</blockquote></p>     <p>3. Объявив указатель на структуру типа <blockquote>DBM</blockquote>, откройте вашу тестовую базу данных для чтения и записи, создав ее при необходимости:</p>     <p><blockquote> dbm_ptr = dbm_open(TEST_DB_FILE, O_RDWR | O_CREAT, 0666);</blockquote></p>     <p><blockquote> if (!dbm_ptr) {</blockquote></p>     <p><blockquote>  fprintf (stderr, "Failed to open database\n");</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p>4. Теперь добавьте данные в структуру <blockquote>items_to_store</blockquote>:</p>     <p><blockquote> memset(items_to_store, '\0', sizeof(items_to_store));</blockquote></p>     <p><blockquote> strcpy(items_to_store[0].misc_chars, "First! ");</blockquote></p>     <p><blockquote> items_to_store[0].any_integer = 47;</blockquote></p>     <p><blockquote> strcpy(items_to_store[0].more_chars, "foo");</blockquote></p>     <p><blockquote> strcpy(items_to_store[1].misc_chars, "bar");</blockquote></p>     <p><blockquote> items_to_store[1].any_integer = 13;</blockquote></p>     <p><blockquote> strcpy(items_to_store[1].more_chars, "unlucky? ");</blockquote></p>     <p><blockquote> strcpy(items_to_store[2].misc_chars, "Third");</blockquote></p>     <p><blockquote> items_to_store[2].any_integer = 3;</blockquote></p>     <p><blockquote> strcpy(items_to_store[2].more_chars, "baz");</blockquote></p>     <p>5. Для каждого элемента необходимо сформировать ключ для будущих ссылок в виде первой буквы каждой строки и целого числа. Этот ключ затем будет обозначен <blockquote>key_datum</blockquote>, когда <blockquote>data_datum</blockquote> сошлется на элемент <blockquote>items_to_store</blockquote>. Далее вы сохраняете данные в базе данных:</p>     <p><blockquote> for (i = 0; i &lt; ITEMS_USED; i++) {</blockquote></p>     <p><blockquote>  sprintf(key_to_use, "%c%c%d",</blockquote></p>     <p><blockquote>   items_to_store[i].misc_chars[0], items_to_store[i].more_chars[0], items_to_store[i].any_integer);</blockquote></p>     <p><blockquote>  key_datum.dptr = (void*)key_to_use;</blockquote></p>     <p><blockquote>  key_datum.dsize = strlen(key to_use);</blockquote></p>     <p><blockquote>  data_datum.dptr = (void*)&amp;items_to_store[i];</blockquote></p>     <p><blockquote>  data_datum.dsize = sizeof(struct.test_data);</blockquote></p>     <p><blockquote>  result = dbm_store(dbm_ptr, key_datum, data_datum, DBM_REPLACE);</blockquote></p>     <p><blockquote>  if (result != 0) {</blockquote></p>     <p><blockquote>   fprintf(stderr, "dbm_store failed on key %s\n", key_to_use);</blockquote></p>     <p><blockquote>   exit(2);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p>6. Далее посмотрите, сможете ли вы извлечь эти новые данные, и в заключение следует закрыть базу данных:</p>     <p><blockquote> sprintf(key_to_use, "bu%d", 13);</blockquote></p>     <p><blockquote> key_datum.dptr = key_to_use;</blockquote></p>     <p><blockquote> key_datum.dsize = strlen(key_to_use);</blockquote></p>     <p><blockquote> data_datum = dbm_fetch(dbm_ptr, key_datum);</blockquote></p>     <p><blockquote> if (data_datum.dptr) {</blockquote></p>     <p><blockquote>  printf("Data retrieved\n");</blockquote></p>     <p><blockquote>  memcpy(&amp;item_retrieved, data_datum.dptr, data_datum.dsize);</blockquote></p>     <p><blockquote>  printf("Retrieved item — %s %d %s\n", item_retrieved.misc_chars,</blockquote></p>     <p><blockquote>   item_retrieved.any_integer, item_retrieved.more_chars);</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  printf("No data found for key %s\n", key_to_use);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> dbm_close(dbm_ptr);</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Когда вы откомпилируете и выполните программу, вывод будет следующим:</p>     <p><blockquote>$ <b>gcc -о dbm1 -I/usr/include/gdtm dbm1.с -lgdbm</b></blockquote></p>     <p><blockquote>$ <b>./dbm1</b></blockquote></p>     <p><blockquote>Data retrieved</blockquote></p>     <p><blockquote>Retrieved item — bar 13 unlucky?</blockquote></p>     <p>Вы получите приведенный вывод, если база данных gdbm установлена в режиме совместимости. Если компиляция не прошла, возможно, вам придется изменить директиву <blockquote>include</blockquote>, как показано в файле, для использования заголовочного файла gdbm-ndbm.h вместо файла ndbm.h и задать в строке компиляции библиотеку совместимости перед основной библиотекой, как показано в следующей строке:</p>     <p><blockquote>$ <b>gcc -о dbm1 -I/usr/include/gdbm dbm1.с -lgdbm_compat -lgdbm</b></blockquote></p>     <p><b>Как это работает</b></p>     <p>Сначала вы открываете базу данных, при необходимости создавая ее. Затем вы заполняете три элемента структуры <blockquote>items_to_store</blockquote>, чтобы использовать их как тестовые данные. Для каждого из трех элементов вы создаете индексный ключ. Чтобы он оставался простым, используйте первые символы каждой из двух строк плюс сохраненное целое.</p>     <p>Далее вы задаете две структуры типа <blockquote>datum</blockquote>, одну для ключа и другую для сохраняемых данных. Сохранив три элемента в базе данных, вы конструируете новый ключ и настраиваете структуру типа <blockquote>datum</blockquote> так, чтобы она указывала на него. Затем вы применяете данный ключ для извлечения данных из базы данных. Убедитесь в успехе, проверив, что <blockquote>dptr</blockquote> в возвращенном <blockquote>datum</blockquote> не равен <blockquote>null</blockquote>. Получив подтверждение, вы можете копировать извлеченные данные (которые могут храниться внутри библиотеки dbm) в вашу собственную структуру, применяя возвращенный размер <blockquote>dbm_fetch</blockquote> (если этого не сделать, при наличии данных переменного размера вы можете скопировать несуществующие данные). В заключение извлеченные данные выводятся на экран, чтобы продемонстрировать корректность их извлечения.</p>             <a name="metkadoc20"><h1>Дополнительные функции dbm</h1></a>     <p>После знакомства с основными функциями библиотеки dbm приведем несколько оставшихся функций, применяемых при работе с базой данных dbm:</p>     <p><blockquote><b>int dbm_delete(DBM *database_descriptor, datum key);</b></blockquote></p>     <p><blockquote><b>int dbm_error(DBM *database_descriptor);</b></blockquote></p>     <p><blockquote><b>int dbm_clearerr(DBM *database_dascriptor);</b></blockquote></p>     <p><blockquote><b>datum dbm_firstkey(DBM *database_descriptor);</b></blockquote></p>     <p><blockquote><b>datum dbm_nextkey(DBM *database_descriptor);</b></blockquote></p>     <b><i>dbm_delete</i></b>     <p>Функция <blockquote>dbm_delete</blockquote> применяется для удаления элементов из базы данных. Она принимает ключ типа <blockquote>datum</blockquote> точно так же, как функция <blockquote>dbm_fetch</blockquote>, но вместо извлечения данных она удаляет их. В случае успешного завершения функция возвращает 0.</p>     <b><i>dbm_error</i></b>     <p>Функция <blockquote>dbm_error</blockquote> просто проверяет базу данных на наличие ошибок, возвращая 0 при их отсутствии.</p>     <b><i>dbm_clearerr</i></b>     <p>Функция dbm_clearerr очищает любой флаг ошибочной ситуации, который может быть установлен в базе данных.</p>     <b><i>dbm_firstkey</i> и <i>dbm_nextkey</i></b>     <p>Эти подпрограммы обычно используются вместе для просмотра ключей всех элементов базы данных. Далее приведена структура требуемого для просмотра цикла:</p>     <p><blockquote>DBM *db_ptr;</blockquote></p>     <p><blockquote>datum key;</blockquote></p>     <p><blockquote>for (key = dbm_firstkey(db_ptr); key.dptr; key = dbm_nextkey(db_ptr));</blockquote></p>     <p>Выполните упражнение 7.13.</p>     <b>Упражнение 7.13. Извлечение и удаление</b>     <p>В этом примере вы улучшите файл dbm1.с с помощью описанных новых функций и создадите новый файл dbm2.c.</p>     <p>1. Сделайте копию dbm1.с и откройте его для редактирования. Отредактируйте строку <blockquote>#define TEST_DB_FILE</blockquote>.</p>     <p><blockquote><i>#unclude &lt;unistd.h&gt;</i></blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;fcntl.h&gt;</blockquote></p>     <p><blockquote>#include &lt;ndbm.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <br>     <p><blockquote><i>#define TEST_DB_FILE "/tmp/dbm2_test"</i></blockquote></p>     <p><blockquote>#define ITEMS_USED 3</blockquote></p>     <p>2. Теперь вам нужно внести изменения только в секцию извлечения:</p>     <p><blockquote> /* теперь попытайтесь удалить некоторые данные */</blockquote></p>     <p><blockquote> sprintf(key_to_use, "bu%d", 13);</blockquote></p>     <p><blockquote> key_datum.dptr = key_to_use;</blockquote></p>     <p><blockquote> key_datum.dsize = strlen(key_to_use);</blockquote></p>     <p><blockquote><i> if (dbm_delete(dbm_ptr, key_datum) == 0) {</i></blockquote></p>     <p><blockquote><i>  printf("Data with key %s deleted\n", key_to_use);</i></blockquote></p>     <p><blockquote><i> } else {</i></blockquote></p>     <p><blockquote><i>  printf("Nothing deleted for key %s\n", key_to_use);</i></blockquote></p>     <p><blockquote><i> }</i></blockquote></p>     <p><blockquote><i> for (key_datum = dbm_firstkey(dbm_ptr);</i></blockquote></p>     <p><blockquote><i>  key_datum.dptr;</i></blockquote></p>     <p><blockquote><i>  key_datum = dbm_nextkey(dbm_ptr)) {</i></blockquote></p>     <p><blockquote>  data_datum = dbm_fetch(dbm_ptr, key_datum);</blockquote></p>     <p><blockquote>  if (data_datum.dptr) {</blockquote></p>     <p><blockquote>   printf("Data retrieved\n");</blockquote></p>     <p><blockquote>   memcpy(&amp;item_retrieved, data_datum.dptr, data_datum.dsize);</blockquote></p>     <p><blockquote>   printf("Retrieved item - %s %d %s\n",</blockquote></p>     <p><blockquote>    item_retrieved.misc_chars, item_retrieved.any_integer,</blockquote></p>     <p><blockquote>    item_retrieved.more_chars);</blockquote></p>     <p><blockquote>  } else {</blockquote></p>     <p><blockquote>   printf("No data found for key %s\n", key_to_use);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote><i>}</i></blockquote></p>     <p>Далее приведен вывод:</p>     <p><blockquote>$ <b>./dbm2</b></blockquote></p>     <p><blockquote>Data with key bu13 deleted</blockquote></p>     <p><blockquote>Data retrieved</blockquote></p>     <p><blockquote>Retrieved item — Third 3 baz</blockquote></p>     <p><blockquote>Data retrieved</blockquote></p>     <p><blockquote>Retrieved item - First! 47 foo</blockquote></p>     <p><b>Как это работает</b></p>     <p>Первая часть программы, идентичная предыдущему примеру, просто сохраняет данные в базе данных. Затем вы формируете ключ, соответствующий второму элементу, и удаляете этот элемент из базы данных.</p>     <p>Далее программа применяет функции <blockquote>dbm_firstkey</blockquote> и <blockquote>dbm_nextkey</blockquote> для обращения к каждому значению ключа по очереди и для извлечения соответствующих ключу данных. Обратите внимание на то, что данные извлекаются не по порядку. Перебор ключей по очереди не определяет никакого порядка извлечения данных, это просто способ просмотра всех элементов в базе данных;</p>              <a name="metkadoc21"><h1>Приложение для работы с коллекцией компакт-дисков</h1></a>         <p>Теперь, когда вы узнали об окружении и управлении данными, самое время обновить приложение. Кажется, что база данных dbm хорошо подходит для хранения информации о компакт-дисках, поэтому воспользуйтесь ею как основой новой реализации.</p>             <a name="metkadoc22"><h1>Обновление проектного решения</h1></a>     <p>Поскольку обновление предполагает значительную корректировку, сейчас самое время взглянуть на проектные решения, чтобы выяснить, не нуждаются ли они в пересмотре. Использование файлов с запятыми в качестве разделителей полей для хранения информации, хотя и обеспечивает легкую реализацию средствами командной оболочки, оказывается связанным со многими ограничениями. Во множестве заголовков компакт-дисков и дорожек встречаются запятые. Вы можете полностью отказаться от этого метода разделения, применив dbm, таким образом, у нас появился один компонент проектного решения, который придется менять.</p>     <p>Разделение информации на заголовки и дорожки с применением отдельного файла для хранения каждого вида данных кажется хорошим решением, поэтому вы можете сохранить эту логическую структуру.</p>     <p>В обеих предыдущих реализациях части приложения, относящиеся к доступу к данным, до некоторой степени смешаны с частями пользовательского интерфейса, нельзя сказать, что незначительно, потому что все приложение реализовано как единый файл. В данной реализации вы примените заголовочный файл для описания данных и подпрограммы для доступа к ним и разделите пользовательский интерфейс и манипулирование данными на два отдельных файла.</p>     <p>Несмотря на то, что вы могли бы сохранить реализацию пользовательского интерфейса средствами библиотеки curses, вы вернетесь к построчной системе. Такой подход позволит сохранить часть приложения, связанную с пользовательским интерфейсом, маленькой и простой и сосредоточиться на других аспектах реализации.</p>     <p>С базой данных dbm вы не сможете применять язык SQL, но опишите новую базу данных с помощью более формальных терминов, используя терминологию языка SQL. Не волнуйтесь, если вы не знакомы с этим языком, мы поясним все определения, а в<i> главе 8</i> вы узнаете о нем больше. В программном коде таблица может быть описана следующим образом:</p>     <p><blockquote>CREATE TABLE cdc_entry (</blockquote></p>     <p><blockquote> catalog CHAR(30) PRIMARY KEY REFERENCES cdt_entry(catalog),</blockquote></p>     <p><blockquote> title CHAR(70),</blockquote></p>     <p><blockquote> type CHAR(30),</blockquote></p>     <p><blockquote> artist CHAR(70)</blockquote></p>     <p><blockquote>);</blockquote></p>     <p><blockquote>CREATE TABLE cdt_entry (</blockquote></p>     <p><blockquote> catalog CHAR(30) REFERENCES cdc_entry(catalog),</blockquote></p>     <p><blockquote> track_no INTEGER,</blockquote></p>     <p><blockquote> track_txt CHAR(70),</blockquote></p>     <p><blockquote> PRIMARY KEY(catalog, track_no)</blockquote></p>     <p><blockquote>);</blockquote></p>     <p>Это очень краткое описание сообщает имена и размеры полей. В таблице <blockquote>cdc_entry</blockquote> у каждого элемента есть уникальный столбец каталога <blockquote>catalog</blockquote>. В таблице <blockquote>cdt_entry</blockquote> номер дорожки не может быть нулевым и комбинация столбцов <blockquote>catalog</blockquote> и <blockquote>track_no</blockquote> уникальна. Вы увидите их определение в виде структур <blockquote>typedef struct</blockquote> в следующем разделе программного кода.</p>             <a name="metkadoc23"><h1>Приложение управления базой данных компакт-дисков, использующее dbm</h1></a>     <p>Сейчас заново вы создадите приложение, использующее базу данных dbm для хранения нужной вам информации, в виде файлов cd_data.h, app_ui.c и cd_access.c (упражнения 7.14–7.16).</p>     <p>Вы также перепишите пользовательский интерфейс в виде программы с вводом команд. Позже в этой книге интерфейс базы данных и части пользовательского интерфейса будут пересмотрены, когда будет рассматриваться реализация вашего приложения с помощью различных клиент-серверных механизмов и затем как приложения, к которому можно обращаться по сети, используя Web-обозреватель. Преобразование интерфейса в более простой строковый интерфейс позволит сосредоточиться не на нем, а на более важных частях приложения.</p>     <blockquote>      <b>Примечание</b>      <p>В последующих главах вы не раз встретитесь с заголовочным файлом базы данных cd_data.h и функциями из файла cd_access.c. Помните о том, что некоторые дистрибутивы Linux требуют немного отличающихся формирующих опций, например, применения в вашем файле на языке С заголовочного файла gdbm-ndbm.h вместо файла ndbm.h и опций <blockquote>-lgdbm_compat -lgdbm</blockquote> вместо просто опции <blockquote>-lgdbm</blockquote>. Если в вашем дистрибутиве Linux дело обстоит именно так, вы должны внести соответствующие изменения в файлы access.с и Makefile.</p>     </blockquote>     <b>Упражнение 7.14. Файл cd_data.h</b>     <p>Начните с заголовочного файла для определения структуры ваших данных и подпрограмм, которые будут использоваться для доступа к данным.</p>     <p>1. Далее приведено определение структуры данных для базы данных компакт-дисков. В него включено определение структур и размеров двух таблиц, формирующих базу данных. Начните с задания размеров некоторых полей, которые вы будете применять, и двух структур: одной для элемента каталога, а другой для элемента дорожки.</p>     <p><blockquote>/* Таблица catalog */</blockquote></p>     <p><blockquote>#define CAT_CAT_LEN 30</blockquote></p>     <p><blockquote>#define CAT_TITLE_LEN 70</blockquote></p>     <p><blockquote>#define CAT_TYPE_LEN 30</blockquote></p>     <p><blockquote>#define CAT_ARTIST_LEN 70</blockquote></p>     <p><blockquote>typedef struct {</blockquote></p>     <p><blockquote> char catalog[CAT_CAT_LEN + 1];</blockquote></p>     <p><blockquote> char title[CAT_TITLE_LEN + 1];</blockquote></p>     <p><blockquote> char type [CAT_TYPE_LEN + 1];</blockquote></p>     <p><blockquote> char artist[CAT_ARTIST_LEN + 1];</blockquote></p>     <p><blockquote>} cdc_entry;</blockquote></p>     <br>     <p><blockquote>/* Таблица дорожек, по одному элементу на дорожку */</blockquote></p>     <p><blockquote>#define TRACK_CAT_LEN CAT_CAT_LEN</blockquote></p>     <p><blockquote>#define TRACK_TTEXT_LEN 70</blockquote></p>     <p><blockquote>typedef struct {</blockquote></p>     <p><blockquote> char catalog[TRACK_CAT_LEN + 1];</blockquote></p>     <p><blockquote> int track_no;</blockquote></p>     <p><blockquote> char track_txt[TRACK_TTEXT_LEN + 1];</blockquote></p>     <p><blockquote>} cdt_entry;</blockquote></p>     <p>2. Теперь, имея структуры данных, можно определить нужные вам подпрограммы доступа. Функции с префиксом <blockquote>cdc_</blockquote> в имени предназначены для элементов каталога, с префиксом <blockquote>cdt_</blockquote> — для элементов-дорожек.</p>     <blockquote>      <b>Примечание</b>      <p>Учтите, что некоторые функции возвращают структуры данных. Вы можете указать на аварийное завершение таких функций, сделав содержимое структур пустым.</p>     </blockquote>     <p><blockquote>/* Функции инициализации и завершения */</blockquote></p>     <p><blockquote>int database_initialize(const int new_database);</blockquote></p>     <p><blockquote>void database_close(void);</blockquote></p>     <p><blockquote>/* Две функции для простого извлечения данных */</blockquote></p>     <p><blockquote>cdc_entry get_cdc_entry(const char *cd_catalog_ptr);</blockquote></p>     <p><blockquote>cdt_entry get_cdt_entry(const char *cd_catalog_ptr, const int track_no);</blockquote></p>     <p><blockquote>/* Две функции для добавления данных */</blockquote></p>     <p><blockquote>int add_cdc_entry(const cdc_entry entry_to_add);</blockquote></p>     <p><blockquote>int add_cdt_entry(const cdt_entry entry_to_add);</blockquote></p>     <p><blockquote>/* Две функции для удаления данных */</blockquote></p>     <p><blockquote>int del_cdc_entry(const char *cd_catalog_ptr);</blockquote></p>     <p><blockquote>int del_cdt_entry(const char *cd_catalog_ptr, const int track_no);</blockquote></p>     <p><blockquote>/* Одна функция поиска */</blockquote></p>     <p><blockquote>cdc_entry search_cdc_entry(const char *cd_catalog_ptr,</blockquote></p>     <p><blockquote> int *first_call_ptr);</blockquote></p>     <b>Упражнение 7.15. Файл app_ui.c</b>     <p>Теперь перейдем к пользовательскому интерфейсу. Вам предлагается простая программа, с помощью которой вы сможете обращаться к функциям вашей базы данных. Интерфейс реализуется в отдельном файле.</p>     <p>1. Как обычно, начните с некоторых заголовочных файлов:</p>     <p><blockquote>#define _XOPEN_SOURCE</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <p><blockquote>#include "cd_data.h"</blockquote></p>     <br>     <p><blockquote>#define TMP_STRING_LEN 125 /* это число должно быть больше</blockquote></p>     <p><blockquote>                              самой длинной строки в структуре базы данных */</blockquote></p>     <p>2. Опишите пункты вашего меню с помощью <blockquote>typedef</blockquote>. Этот вариант лучше применения констант, заданных в директивах <blockquote>#define</blockquote>, т.к. позволяет компилятору проверить типы переменных, задающих пункт меню.</p>     <p><blockquote>typedef enum {</blockquote></p>     <p><blockquote> mo_invalid,</blockquote></p>     <p><blockquote> mo_add_cat,</blockquote></p>     <p><blockquote> mo_add_tracks,</blockquote></p>     <p><blockquote> mo_del_cat,</blockquote></p>     <p><blockquote> mo_find_cat,</blockquote></p>     <p><blockquote> mo_list_cat_tracks,</blockquote></p>     <p><blockquote> mo_del_tracks,</blockquote></p>     <p><blockquote> mo_count_entries,</blockquote></p>     <p><blockquote> mo_exit</blockquote></p>     <p><blockquote>} menu_options;</blockquote></p>     <p>3. Теперь введите прототипы локальных функций. Помните о том, что прототипы функций, обеспечивающих реальный доступ к базе данных, включены в файл cd_data.h.</p>     <p><blockquote>static int command_mode(int argc, char *argv[]);</blockquote></p>     <p><blockquote>static void announce(void);</blockquote></p>     <p><blockquote>static menu_options show_menu(const cdc_entry *current_cdc);</blockquote></p>     <p><blockquote>static int get_confirm(const char *question);</blockquote></p>     <p><blockquote>static int enter_new_cat_entry(cdc_entry *entry_to_update);</blockquote></p>     <p><blockquote>static void enter_new_track_entries(const cdc_entry* entry_to_add_to);</blockquote></p>     <p><blockquote>static void del_cat_entry(const cdc_entry *entry_to_delete);</blockquote></p>     <p><blockquote>static void del_track_entries(const cdc_entry *entry_to_delete);</blockquote></p>     <p><blockquote>static cdc_entry find_cat(void);</blockquote></p>     <p><blockquote>static void list_tracks(const cdc_entry *entry_to_use);</blockquote></p>     <p><blockquote>static void count_all_entries(void);</blockquote></p>     <p><blockquote>static void display_cdc(const cdc_entry *cdc_to_show);</blockquote></p>     <p><blockquote>static void display_cdt(const cdt_entry *cdt_to_show);</blockquote></p>     <p><blockquote>static void strip_return(char *string_to_strip);</blockquote></p>     <p>4. И наконец, вы добрались до функции <blockquote>main</blockquote>. Она начинается с проверки того, что текущий элемент <blockquote>current_cdc_entry</blockquote>, который применяется для сохранения дорожки выбранного в данный момент элемента каталога компакт-дисков, инициализирован. Также проводится грамматический разбор командной строки, выдается оповещение о том, какая программа выполняется, и инициализируется база данных.</p>     <p><blockquote>void main(int argc, char *argv[]) {</blockquote></p>     <p><blockquote> menu_options current_option;</blockquote></p>     <p><blockquote> cdc_entry current_cdc_entry;</blockquote></p>     <p><blockquote> int command_result;</blockquote></p>     <p><blockquote> memset(&amp;current_cdc_entry, '\0', sizeof(current_cdc_entry));</blockquote></p>     <p><blockquote>if (argc &gt;1) {</blockquote></p>     <p><blockquote>  command_result = command_mode(argc, argv);</blockquote></p>     <p><blockquote>  exit(command_result);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> announce();</blockquote></p>     <p><blockquote> if (!database_initialize(0)) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Sorry, unable to initialize database\n");</blockquote></p>     <p><blockquote>  fprintf(stderr, "To create a new database use %s -i\n", argv[0]);</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p>5. Теперь вы готовы обрабатывать ввод пользователя. Вы остаетесь в цикле, запрашивая пункт меню и обрабатывая его до тех пор, пока пользователь не выберет выход. Обратите вниманий на то, что вы передаете структуру <blockquote>current_cdc_entry</blockquote> в функцию <blockquote>show_menu</blockquote>, чтобы разрешить изменять варианты пунктов меню, когда выбран текущий элемент каталога:</p>     <p><blockquote> while (current_option != mo_exit) {</blockquote></p>     <p><blockquote>  current_option = show_menu(&amp;current_cdc_entry); </blockquote></p>     <p><blockquote>  switch(current_option) {</blockquote></p>     <p><blockquote>  case mo_add_cat:</blockquote></p>     <p><blockquote>   if (enter_new_cat_entry(&amp;current_cdc_entry)) {</blockquote></p>     <p><blockquote>    if (!add_cdc_entry(current_cdc_entry)) {</blockquote></p>     <p><blockquote>     fprintf(stderr, "Failed to add new entry\n");</blockquote></p>     <p><blockquote>     memset(&amp;current_cdc_entry, '\0',</blockquote></p>     <p><blockquote>      sizeof(current_cdc_entry)); </blockquote></p>     <p><blockquote>    }</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  case mo_add_tracks:</blockquote></p>     <p><blockquote>   enter_new_track_entries(&amp;current_cdc_entry);</blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  case mo_del_cat:</blockquote></p>     <p><blockquote>   del_cat_entry(&amp;current_cdc_entry);</blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  case mo_find_cat:</blockquote></p>     <p><blockquote>   current_cdc_entry = find_cat();</blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  case mo_list_cat_tracks:</blockquote></p>     <p><blockquote>   list_tracks(&amp;current_cdc_entry);</blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  case mo_del_tracks:</blockquote></p>     <p><blockquote>   del_track_entries(&amp;current_cdc_entry);</blockquote></p>     <p><blockquote>   break; </blockquote></p>     <p><blockquote>  case mo_count_entries:</blockquote></p>     <p><blockquote>   count_all_entries();</blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  case mo_exit: </blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  case mo_invalid: </blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  default:</blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  } /* switch */</blockquote></p>     <p><blockquote> } /* while */ </blockquote></p>     <p>6. Когда цикл в функции <blockquote>main</blockquote> завершится, закройте базу данных и вернитесь в окружение. Функция <blockquote>announce</blockquote> выводит приглашающее предложение:</p>     <p><blockquote> database_close();</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>} /* main */</blockquote></p>     <br>     <p><blockquote>static void announce(void) {</blockquote></p>     <p><blockquote> printf("\n\nWelcome to the demonstration CD catalog database \</blockquote></p>     <p><blockquote>  program\n");</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>7. Здесь вы реализуете функцию <blockquote>show_menu</blockquote>. Эта функция проверяет, выбран ли текущий элемент каталога, используя первый символ имени в каталоге. Если элемент каталога выбран, становятся доступными дополнительные пункты меню:</p>     <p><blockquote>static menu_options show_menu(const cdc_entry *cdc_selected) {</blockquote></p>     <p><blockquote> char tmp_str[TMP_STRING_LEN + 1];</blockquote></p>     <p><blockquote> menu_options option_chosen = mo_invalid;</blockquote></p>     <p><blockquote> while (option_chosen == mo_invalid) {</blockquote></p>     <p><blockquote>  if (cdc_selected-&gt;catalog[0]) {</blockquote></p>     <p><blockquote>   printf("\n\nCurrent entry: ");</blockquote></p>     <p><blockquote>   printf("%s, %s, %a, %s\n",</blockquote></p>     <p><blockquote>    cdc_selected-&gt;catalog, cdc_selected-&gt;title,</blockquote></p>     <p><blockquote>    cdc_selected-&gt;type, cdc_selected-&gt;artist);</blockquote></p>     <p><blockquote>   printf("\n");</blockquote></p>     <p><blockquote>   printf("1 - add new CD\n");</blockquote></p>     <p><blockquote>   printf("2 — search for a CD\n");</blockquote></p>     <p><blockquote>   printf("3 — count the CDs and tracks in the database\n");</blockquote></p>     <p><blockquote>   printf("4 — re-enter tracks for current CD\n");</blockquote></p>     <p><blockquote>   printf("5 - delete this CD, and all its tracks\n");</blockquote></p>     <p><blockquote>   printf("6 - list tracks for this CD\n");</blockquote></p>     <p><blockquote>   printf("q — quit\n");</blockquote></p>     <p><blockquote>   printf("\nOption: ");</blockquote></p>     <p><blockquote>   fgets(tmp_str, TMP_STRING_LEN, stdin);</blockquote></p>     <p><blockquote>   switch(tmp_str[0]) {</blockquote></p>     <p><blockquote>   case '1':</blockquote></p>     <p><blockquote>    option_chosen = mo_add_cat;</blockquote></p>     <p><blockquote>    break;</blockquote></p>     <p><blockquote>   case '2':</blockquote></p>     <p><blockquote>    option_chosen = mo_find_cat;</blockquote></p>     <p><blockquote>    break;</blockquote></p>     <p><blockquote>   case '3':</blockquote></p>     <p><blockquote>    option_chosen = mo_count_entries;</blockquote></p>     <p><blockquote>    break;</blockquote></p>     <p><blockquote>   case '4':</blockquote></p>     <p><blockquote>    option_chosen = mo_add_tracks;</blockquote></p>     <p><blockquote>    break;</blockquote></p>     <p><blockquote>   case '5':</blockquote></p>     <p><blockquote>    option_chosen = mo_del_cat;</blockquote></p>     <p><blockquote>    break;</blockquote></p>     <p><blockquote>   case '6':</blockquote></p>     <p><blockquote>    option_chosen = mo_list_cat_tracks;</blockquote></p>     <p><blockquote>    break;</blockquote></p>     <p><blockquote>   case 'q':</blockquote></p>     <p><blockquote>    option_chosen = mo_exit;</blockquote></p>     <p><blockquote>    break;</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>  } else {</blockquote></p>     <p><blockquote>   printf("\n\n");</blockquote></p>     <p><blockquote>   printf("1 - add new CD\n");</blockquote></p>     <p><blockquote>   printf("2 - search for a CD\n");</blockquote></p>     <p><blockquote>   printf("3 — count the CDs and tracks in the database\n");</blockquote></p>     <p><blockquote>   printf("q — quit\n");</blockquote></p>     <p><blockquote>   printf("\nOption: ");</blockquote></p>     <p><blockquote>   fgets(tmp_str, TMP_STRING_LEN, stdin);</blockquote></p>     <p><blockquote>   switch(tmp_str[0]) {</blockquote></p>     <p><blockquote>   case '1':</blockquote></p>     <p><blockquote>    option_chosen = mo_add_cat;</blockquote></p>     <p><blockquote>    break;</blockquote></p>     <p><blockquote>   case '2':</blockquote></p>     <p><blockquote>    option_chosen = mo_find_cat;</blockquote></p>     <p><blockquote>    break;</blockquote></p>     <p><blockquote>   case '3':</blockquote></p>     <p><blockquote>    option_chosen = mo_count_entries;</blockquote></p>     <p><blockquote>    break;</blockquote></p>     <p><blockquote>   case 'q':</blockquote></p>     <p><blockquote>    option_chosen = mo_exit;</blockquote></p>     <p><blockquote>    break;</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> } /* while */</blockquote></p>     <p><blockquote> return(option_chosen);</blockquote></p>     <p><blockquote>}</blockquote></p>     <blockquote>      <b>Примечание</b>      <p>Учтите, что для выбора пунктов меню теперь используются номера, а не начальные буквы, применявшиеся в двух предыдущих примерах.</p>     </blockquote>     <p>8. В программе есть несколько участков, в которых хотелось бы спросить пользователя о том, уверен ли он в своем запросе. Вместо того чтобы вставлять в эти места программный код, задающий вопрос, поместим его в отдельную функцию <blockquote>get_confirm</blockquote>:</p>     <p><blockquote>static int get_confirm(const char *question) {</blockquote></p>     <p><blockquote> char tmp_str[TMP_STRING_LEN + 1];</blockquote></p>     <p><blockquote> printf("%s", question);</blockquote></p>     <p><blockquote> fgets(tmp_str, TMP_STRING_LEN, stdin);</blockquote></p>     <p><blockquote> if (tmp_str[0] == 'Y' || tmp_str[0] = 'y') {</blockquote></p>     <p><blockquote>  return(1);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>9. Функция <blockquote>enter_new_cat_entry</blockquote> позволяет вводить новый элемент каталога. Вам не нужно сохранять перевод строки, который возвращает функция <blockquote>fgets</blockquote>, поэтому отбросьте его:</p>     <p><blockquote>static int enter_new_cat_entry(cdc_entry *entry_to_update) {</blockquote></p>     <p><blockquote> cdc_entry new_entry;</blockquote></p>     <p><blockquote> char tmp_str[TMP_STRING_LEN + 1];</blockquote></p>     <p><blockquote> memset(&amp;new_entry, '\0', sizeof(new_entry));</blockquote></p>     <p><blockquote> printf("Enter catalog entry: ");</blockquote></p>     <p><blockquote> (void)fgets(tmp_str, TMP_STRING_LEN, stdin);</blockquote></p>     <p><blockquote> strip_return(tmp_str);</blockquote></p>     <p><blockquote> strncpy(new_entry.catalog, tmp_str, CAT_CAT_LEN - 1);</blockquote></p>     <p><blockquote> printf("Enter title: ");</blockquote></p>     <p><blockquote> (void)fgets(tmp_str, TMP_STRING_LEN, stdin);</blockquote></p>     <p><blockquote> strip_return(tmp_str);</blockquote></p>     <p><blockquote> strncpy(new_entry.title, tmp_str, CAT_TITLE_LEN - 1);</blockquote></p>     <p><blockquote> printf("Enter type: ");</blockquote></p>     <p><blockquote> (void)fgets(tmp_str, TMP_STRING_LEN, stdin);</blockquote></p>     <p><blockquote> strip_return(tmp_str);</blockquote></p>     <p><blockquote> strncpy(new_entry.type, tmp_str, CAT_TYPE_LEN - 1);</blockquote></p>     <p><blockquote> printf("Enter artist: ");</blockquote></p>     <p><blockquote> (void)fgets(tmp_str, TMP_STRING_LEN, stdin);</blockquote></p>     <p><blockquote> strip_return(tmp_str);</blockquote></p>     <p><blockquote> strncpy(new_entry.artist, tmp_str, CAT_ARTIST_LEN - 1);</blockquote></p>     <p><blockquote> printf("\nNew catalog entry entry is :-\n");</blockquote></p>     <p><blockquote> display_cdc(&amp;new_entry);</blockquote></p>     <p><blockquote> if (get_confirm("Add this entry ? ")) {</blockquote></p>     <p><blockquote>  memcpy(entry_to_update, &amp;new_entry, sizeof(new_entry));</blockquote></p>     <p><blockquote>  return(1);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <blockquote>      <b>Примечание</b>      <p>Обратите внимание на то, что вы не применяете функцию <blockquote>gets</blockquote>, поскольку нет способа проверить переполнение буфера. Всегда избегайте применения функции <blockquote>gets</blockquote>! </p>     </blockquote>     <p>10. Теперь вы переходите к функции <blockquote>enter_new_track_entries</blockquote> для ввода информации о дорожке. Эта функция немного сложнее функции ввода элемента каталога, поскольку вы разрешаете существующему элементу-дорожке оставаться неизменным:</p>     <p><blockquote>static void enter_new_track_entries(const cdc_entry *entry_to_add_to) {</blockquote></p>     <p><blockquote> cdt_entry new_track, existing_track;</blockquote></p>     <p><blockquote> char tmp_str[TMP_STRING_LEN + 1];</blockquote></p>     <p><blockquote> int track_no = 1;</blockquote></p>     <p><blockquote> if (entry_to_add_to-&gt;catalog[0] == '\0') return;</blockquote></p>     <p><blockquote> printf("\nUpdating tracks for %s\n", entry_to_add_to-&gt;catalog);</blockquote></p>     <p><blockquote> printf("Press return to leave existing description unchanged, \n");</blockquote></p>     <p><blockquote> printf(" a single d to delete this and remaining tracks, \n");</blockquote></p>     <p><blockquote> printf(" or new track description\n");</blockquote></p>     <p><blockquote> while(1) {</blockquote></p>     <p>11. Сначала вы должны проверить, существует ли уже дорожка с текущим номером дорожки. В зависимости от результатов проверки меняется строка приглашения:</p>     <p><blockquote>  memset(&amp;new_track, '\0', sizeof(new_track));</blockquote></p>     <p><blockquote>  existing_track = get_cdt_entry(entry_to_add_to-&gt;catalog,</blockquote></p>     <p><blockquote>   track_no);</blockquote></p>     <p><blockquote>  if (existing_track.catalog[0]) {</blockquote></p>     <p><blockquote>   printf("\tTrack %d: %s\n", track_no,</blockquote></p>     <p><blockquote>    existing_track.track_txt);</blockquote></p>     <p><blockquote>   printf("\tNew text: ");</blockquote></p>     <p><blockquote>  } else {</blockquote></p>     <p><blockquote>   printf("\tTrack %d description: ", track_no);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  fgets(tmp_str, TMP_STRING_LEN, stdin);</blockquote></p>     <p><blockquote>  strip_return(tmp_str);</blockquote></p>     <p>12. Если для данной дорожки не существует элемент и пользователь его не добавил, предположите, что больше нет дорожек, которые надо добавить:</p>     <p><blockquote>  if (strlen(tmp_str) == 0) {</blockquote></p>     <p><blockquote>   if (existing_track.catalog[0] == '\0') {</blockquote></p>     <p><blockquote>    /* Нет в наличии элемента, поэтому вставка завершается */</blockquote></p>     <p><blockquote>    break;</blockquote></p>     <p><blockquote>   } else {</blockquote></p>     <p><blockquote>    /* Оставляем существующий элемент,</blockquote></p>     <p><blockquote>       переходам к следующей дорожке */</blockquote></p>     <p><blockquote>    track_no++;</blockquote></p>     <p><blockquote>    continue;</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p>13. Если пользователь введет единичный символ <blockquote>d</blockquote>, это приведет к удалению текущей дорожки и дорожек с большими номерами. Функция <blockquote>del_cdt_entry</blockquote> вернет <blockquote>false</blockquote>, если не сможет найти дорожку, которую следует удалить:</p>     <p><blockquote>  if ((strlen(tmp_str) == 1) &amp;&amp; tmp_str[0] == 'd') { /* Удаляет эту и оставшиеся дорожки */</blockquote></p>     <p><blockquote>   while (del_cdt_entry(entry_to_add_to-&gt;catalog, track_no)) {</blockquote></p>     <p><blockquote>    track_no++;</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p>14. В этом пункте приводится код для вставки новой дорожки или обновления существующей. Вы формируете элемент <blockquote>cdt_entry</blockquote> структуры <blockquote>new_track</blockquote> и затем вызываете функцию базы данных <blockquote>add_cdt_entry</blockquote> для того, чтобы включить его в базу данных:</p>     <p><blockquote>  strncpy(new_track. track_txt, tmp_str, TRACK_TTEXT_LEN - 1);</blockquote></p>     <p><blockquote>  strcpy(new_track.catalog, entry_to_add_to-&gt;catalog);</blockquote></p>     <p><blockquote>  new_track.track_no = track_no;</blockquote></p>     <p><blockquote>  if (!add_cdt_entry(new_track)) {</blockquote></p>     <p><blockquote>   fprintf(stderr, "Failed to add new track\n");</blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  track_no++;</blockquote></p>     <p><blockquote> } /* while */</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>15. Функция <blockquote>del_cat_entry</blockquote> удаляет элемент каталога. Никогда не разрешайте хранить дорожки для несуществующего элемента каталога.</p>     <p><blockquote>static void del_cat_entry(const cdc_entry *entry_to_delete) {</blockquote></p>     <p><blockquote> int track_no = 1;</blockquote></p>     <p><blockquote> int delete_ok;</blockquote></p>     <p><blockquote> display_cdc(entry_to_delete);</blockquote></p>     <p><blockquote> if (get_confirm("Delete this entry and all it's tracks? ")) {</blockquote></p>     <p><blockquote>  do {</blockquote></p>     <p><blockquote>   delete_ok = del_cdt_entry(entry_to_delete-&gt;catalog, track_no);</blockquote></p>     <p><blockquote>   track_no++;</blockquote></p>     <p><blockquote>  } while(delete_ok);</blockquote></p>     <p><blockquote>  if (!del_cdc_entry(entry_to_delete-&gt;catalog)) {</blockquote></p>     <p><blockquote>   fprintf(stderr, "Failed to delete entry\n");</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>16. Следующая функция — утилита для удаления всех дорожек элемента каталога:</p>     <p><blockquote>static void del_track_entries(const cdc_entry *entry_to_delete) {</blockquote></p>     <p><blockquote> int track_no = 1;</blockquote></p>     <p><blockquote> int delete_ok;</blockquote></p>     <p><blockquote> display_cdc(entry_to_delete);</blockquote></p>     <p><blockquote> if (get_confirm("Delete tracks for this entry? ")) {</blockquote></p>     <p><blockquote>  do {</blockquote></p>     <p><blockquote>   delete_ok = del_cdt_entry(entry_to_delete-&gt;catalog, track_no);</blockquote></p>     <p><blockquote>   track_no++;</blockquote></p>     <p><blockquote>  } while(delete_ok);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>17. Создайте очень простое средство поиска, в котором разрешите пользователю ввести строку и затем поищите элементы каталога, содержащие строку. Поскольку может быть несколько элементов с такой строкой, просто по очереди предлагаются пользователю все найденные:</p>     <p><blockquote>static cdc_entry find_cat(void) {</blockquote></p>     <p><blockquote> cdc_entry item_found;</blockquote></p>     <p><blockquote> char tmp_str[TMP_STRING_LEN + 1];</blockquote></p>     <p><blockquote> int first_call = 1;</blockquote></p>     <p><blockquote> int any_entry_found = 0;</blockquote></p>     <p><blockquote> int string ok;</blockquote></p>     <p><blockquote> int entry_selected = 0;</blockquote></p>     <p><blockquote> do {</blockquote></p>     <p><blockquote>  string_ok = 1;</blockquote></p>     <p><blockquote>  printf("Enter string to search for in catalog entry: ");</blockquote></p>     <p><blockquote>  fgets(tmp_str, TMP_STRING_LEN, stdin);</blockquote></p>     <p><blockquote>  strip_return(tmp_str);</blockquote></p>     <p><blockquote>  if (strlen(tmp_str) &gt; CAT_CAT_LEN) {</blockquote></p>     <p><blockquote>   fprintf(stderr, "Sorry, string too long, maximum %d \</blockquote></p>     <p><blockquote>    characters\n", CAT_CAT_LEN);</blockquote></p>     <p><blockquote>   string_ok = 0;</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> } while (!string_ok);</blockquote></p>     <p><blockquote> while (!entry_selected) {</blockquote></p>     <p><blockquote>  item_found = search_cdc_entry(tmp_str, &amp;firstcall);</blockquote></p>     <p><blockquote>  if (item_found.catalog[0] != '\0') {</blockquote></p>     <p><blockquote>   any_entry_found = 1;</blockquote></p>     <p><blockquote>   printf("\n");</blockquote></p>     <p><blockquote>   display_cdc(&amp;item_found);</blockquote></p>     <p><blockquote>   if (get_confirm("This entry? ")) {</blockquote></p>     <p><blockquote>    entry_selected = 1;</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>  } else {</blockquote></p>     <p><blockquote>   if (any_entry_found) printf("Sorry, no more matches found\n");</blockquote></p>     <p><blockquote>   else printf("Sorry, nothing found\n");</blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return(item_found);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>18. Функция <blockquote>list_tracks</blockquote> — утилита, которая выводит все дорожки для заданного элемента каталога:</p>     <p><blockquote>static void list_tracks(const cdc_entry *entry_to_use) {</blockquote></p>     <p><blockquote> int track_no = 1;</blockquote></p>     <p><blockquote> cdt_entry entry_found;</blockquote></p>     <p><blockquote> display_cdc(entry_to_use);</blockquote></p>     <p><blockquote> printf("\nTracks\n");</blockquote></p>     <p><blockquote> do {</blockquote></p>     <p><blockquote>  entry_found = get_cdt_entry(entry_to_use-&gt;catalog, track_no);</blockquote></p>     <p><blockquote>  if (entry_found.catalog[0]) {</blockquote></p>     <p><blockquote>   display_cdt(&amp;entry_found);</blockquote></p>     <p><blockquote>   track_no++;</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> } while(entry_found.catalog[0]);</blockquote></p>     <p><blockquote> (void)get_confirm("Press return");</blockquote></p>     <p><blockquote>} /* list_tracks */</blockquote></p>     <p>19. Функция <blockquote>count_all_entries</blockquote> подсчитывает все дорожки:</p>     <p><blockquote>static void count_all_entries(void) {</blockquote></p>     <p><blockquote> int cd_entries_found = 0;</blockquote></p>     <p><blockquote> int track_entries_found = 0;</blockquote></p>     <p><blockquote> cdc_entry cdc_found;</blockquote></p>     <p><blockquote> cdt_entry cdt_found;</blockquote></p>     <p><blockquote> int track_no = 1;</blockquote></p>     <p><blockquote> int first_time = 1;</blockquote></p>     <p><blockquote> char *search_string = "";</blockquote></p>     <p><blockquote> do {</blockquote></p>     <p><blockquote>  cdc_found = search_cdc_entry(search_string, &amp;first_time);</blockquote></p>     <p><blockquote>  if (cdc_found.catalog[0]) {</blockquote></p>     <p><blockquote>   cd_entries_found++;</blockquote></p>     <p><blockquote>   track_no = 1;</blockquote></p>     <p><blockquote>   do {</blockquote></p>     <p><blockquote>    cdt_found = get_cdt_entry(cdc_found.catalog, track_no);</blockquote></p>     <p><blockquote>    if (cdt_found.catalog[0]) {</blockquote></p>     <p><blockquote>     track_entries_found++;</blockquote></p>     <p><blockquote>     track_no++;</blockquote></p>     <p><blockquote>    }</blockquote></p>     <p><blockquote>   } while (cdt_found.catalog[0]);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> } while (cdc_found.catalog[0]);</blockquote></p>     <p><blockquote> printf("Found %d CDs, with a total of %d tracks\n",</blockquote></p>     <p><blockquote>  cd_entries_found, track_entries_found);</blockquote></p>     <p><blockquote> (void)get_confirm("Press return");</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>20. Теперь у вас есть утилита <blockquote>display_cdc</blockquote> для вывода элемента каталога:</p>     <p><blockquote>static void display_cdc(const cdc_entry *cdc_to_show) {</blockquote></p>     <p><blockquote> printf("Catalog: %s\n", cdc_to_show-&gt;catalog);</blockquote></p>     <p><blockquote> printf("\ttitle: %s\n", cdc_to_show-&gt;title);</blockquote></p>     <p><blockquote> printf("\ttype: %s\n", cdc_to_show-&gt;type);</blockquote></p>     <p><blockquote> printf("\tartist: %s\n", cdc_to_show-&gt;artist);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>и утилита <blockquote>display_cdt</blockquote> для отображения элемента-дорожки:</p>     <p><blockquote>static void display_cdt(const cdt_entry *cdt_to_show) {</blockquote></p>     <p><blockquote> printf("%d: %s\n", cdt_to_show-&gt;track_no,</blockquote></p>     <p><blockquote>  cdt_to_show-&gt;track_txt);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>21. Служебная функция <blockquote>strip_return</blockquote> удаляет завершающий строку символ перевода строки. Помните о том, что Linux, как и UNIX, использует один символ перевода строки для обозначения конца строки.</p>     <p><blockquote>static void strip_return(char *string_to_strip) {</blockquote></p>     <p><blockquote> int len;</blockquote></p>     <p><blockquote> len = strlen(string_to_strip);</blockquote></p>     <p><blockquote> if (string_to_strip[len - 1] == '\n')</blockquote></p>     <p><blockquote> string_to_strip[len - 1] = '\0';</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>22. Функция <blockquote>command_mode</blockquote> предназначена для синтаксического анализа аргументов командной строки. Функция <blockquote>getopt</blockquote> — хороший способ убедиться в том, что ваша программа принимает аргументы, соответствующие стандартным соглашениям, принятым в системе Linux.</p>     <p><blockquote>static int command_mode(int argc, char *argv[]) {</blockquote></p>     <p><blockquote> int c;</blockquote></p>     <p><blockquote> int result = EXIT_SUCCESS;</blockquote></p>     <p><blockquote> char *prog_name = argv[0];</blockquote></p>     <p><blockquote> /* Эти внешние переменные используются функцией getopt */</blockquote></p>     <p><blockquote> extern char *optarg;</blockquote></p>     <p><blockquote> extern optind, opterr, optopt;</blockquote></p>     <p><blockquote> while ((c = getopt(argc, argv, ":i")) != -1) {</blockquote></p>     <p><blockquote>  switch(c) {</blockquote></p>     <p><blockquote>  case 'i':</blockquote></p>     <p><blockquote>   if (!database_initialize(1)) {</blockquote></p>     <p><blockquote>    result = EXIT_FAILURE;</blockquote></p>     <p><blockquote>    fprintf(stderr, "Failed to initialize database\n");</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  case ':':</blockquote></p>     <p><blockquote>  case '?':</blockquote></p>     <p><blockquote>  default:</blockquote></p>     <p><blockquote>   fprintf(stderr, "Usage: %s [-i]\n", prog_name);</blockquote></p>     <p><blockquote>   result = EXIT_FAILURE;</blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  } /* switch */</blockquote></p>     <p><blockquote> } /* while */</blockquote></p>     <p><blockquote> return(result);</blockquote></p>     <p><blockquote>}</blockquote></p>     <b>Упражнение 7.16. Файл cd_access.c</b>     <p>Теперь переходите к функциям доступа к базе данных dbm.</p>     <p>1. Как обычно, начните с нескольких файлов <blockquote>#include</blockquote>. Далее примените директивы <blockquote>#define</blockquote> для задания файлов, которые будут использоваться для хранения данных:</p>     <p><blockquote>#define _XOPEN_SOURCE</blockquote></p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;fcntl.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <p><blockquote>#include &lt;ndbm.h&gt;</blockquote></p>     <p><blockquote>/* В некоторых дистрибутивах файл в предыдущей строке может быть придется заменить на gdbm-ndbm.h */</blockquote></p>     <p><blockquote>#include "cd_data.h"</blockquote></p>     <br>     <p><blockquote>#define CDC_FILE_BASE "cdc_data"</blockquote></p>     <p><blockquote>#define CDT_FILE_BASE "cdt_data"</blockquote></p>     <p><blockquote>#define CDC_FILE_DIR "cdc_data.dir"</blockquote></p>     <p><blockquote>#define CDC_FILE_PAG "cdc_data.pag"</blockquote></p>     <p><blockquote>#define CDT_FILE_DIR "cdt_data.dir"</blockquote></p>     <p><blockquote>#define CDT_FILE_PAG "cdt_data.pag"</blockquote></p>     <p>2. Используйте эти две переменные области действия файла для отслеживания текущей базы данных:</p>     <p><blockquote>static DBM *cdc_dbm_ptr = NULL;</blockquote></p>     <p><blockquote>static DBM *cdt_dbm_ptr = NULL;</blockquote></p>     <p>3. По умолчанию функция <blockquote>database_initialize</blockquote> открывает существующую базу данных, но передав ненулевой (т.е. true) параметр <blockquote>new_database</blockquote>, вы можете заставить ее создать новую (пустую) базу данных, при этом существующая база данных удаляется. Если база данных успешно инициализирована, также инициализированы и два ее указателя, указывающие на то, что база данных открыта.</p>     <p><blockquote>int database_initialize(const int new_database) {</blockquote></p>     <p><blockquote> int open_mode = O_CREAT | O_RDWR;</blockquote></p>     <p><blockquote> /* Если открыта какая-либо имеющаяся база данных, закрывает ее */</blockquote></p>     <p><blockquote> if (cdc_dbm_ptr) dbm_close(cdc_dbm_ptr);</blockquote></p>     <p><blockquote> if (cdt_dbm_ptr) dbm_close(cdt_dbm_ptr);</blockquote></p>     <p><blockquote> if (new_database) {</blockquote></p>     <p><blockquote>  /* Удаляет старые файлы */</blockquote></p>     <p><blockquote>  (void)unlink(CDC_FILE_PAG);</blockquote></p>     <p><blockquote>  (void)unlink(CDC_FILE_DIR);</blockquote></p>     <p><blockquote>  (void)unlink(CDT_FILE_PAG);</blockquote></p>     <p><blockquote>  (void)unlink(CDT_FILE_DIR);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> /* Открывает несколько новых файлов, создавая их при необходимости */</blockquote></p>     <p><blockquote> cdc_dbm_ptr = dbm_open(CDC_FILE_BASE, open_mode, 0644);</blockquote></p>     <p><blockquote> cdt_dbm_ptr = dbm_open(CDT_FILE_BASE, open_mode, 0644);</blockquote></p>     <p><blockquote> if (!cdc_dbm_ptr || !cdt_dbm_ptr) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Unable to create database\n");</blockquote></p>     <p><blockquote>  cdc_dbm_ptr = cdt_dbm_ptr = NULL;</blockquote></p>     <p><blockquote>  return (0);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return (1);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>4. Функция <blockquote>database_close</blockquote> просто закрывает базу данных, если она была открыта и устанавливает указатели базы данных в <blockquote>null</blockquote>, чтобы показать, что нет открытой базы данных:</p>     <p><blockquote>void database_close(void) {</blockquote></p>     <p><blockquote> if (cdc_dbm_ptr) dbm_close(cdc_dbm_ptr);</blockquote></p>     <p><blockquote> if (cdt_dbm_ptr) dbm_close(cdt_dbm_ptr);</blockquote></p>     <p><blockquote> cdc_dbm_ptr = cdt_dbm_ptr = NULL;</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>5. Далее у вас появляется функция, извлекающая единственный элемент каталога, когда передан указатель на строку текста из каталога. Если элемент не найден, у возвращенных данных пустое поле каталога:</p>     <p><blockquote>cdc_entry get_cdc_entry(const char *cd_catalog_ptr) {</blockquote></p>     <p><blockquote> cdc_entry entry_to_return;</blockquote></p>     <p><blockquote> char entry_to_find[CAT_CAT_LEN + 1];</blockquote></p>     <p><blockquote> datum local data datum;</blockquote></p>     <p><blockquote> datum local_key_datum;</blockquote></p>     <p><blockquote> memset(&amp;entry_to_return, '\0', sizeof(entry_to_return));</blockquote></p>     <p>6. Начните с некоторых имеющих смысл проверок, чтобы убедиться в том, что база данных открыта, и вы передали приемлемые параметры, т.е. ключ поиска содержит только допустимую строку и значения <blockquote>null</blockquote>:</p>     <p><blockquote> if (!cdc_dbm_ptr || !cdt_dbm_ptr) return (entry_to_return);</blockquote></p>     <p><blockquote> if (!cd_catalog_ptr) return (entry_to_return);</blockquote></p>     <p><blockquote> if (strlen(cd_catalog_ptr) &gt;= CAT_CAT_LEN) return (entry_to_return);</blockquote></p>     <p><blockquote> memset(&amp;entry_to_find, '\0', sizeof(entry_to_find));</blockquote></p>     <p><blockquote> strcpy(entry_to_find, cd_catalog_ptr);</blockquote></p>     <p>7. Задайте структуру <blockquote>datum</blockquote>, нужную функциям базы данных dbm, и используйте функцию <blockquote>dbm_fetch</blockquote> для извлечения данных. Если не извлечены никакие данные, вы возвращаете пустую структуру <blockquote>entry_to_return</blockquote>, которая была инициализирована ранее:</p>     <p><blockquote> local_key_datum.dptr = (void *) entry_to_find;</blockquote></p>     <p><blockquote> local_key_datum.dsize = sizeof(entry_to_find);</blockquote></p>     <p><blockquote> memset(&amp;local_data_datum, '\0', sizeof(local_data_datum));</blockquote></p>     <p><blockquote> local_data_datum = dbm_fetch(cdc_dbm_ptr, local_key_datum);</blockquote></p>     <p><blockquote> if (local_data_datum.dptr) {</blockquote></p>     <p><blockquote>  memcpy(&amp;entry_to_return, (char*)local_data_datum.dptr, local_data_datum.dsize);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return (entry_to_return);</blockquote></p>     <p><blockquote>} /* get_cdc_entry */</blockquote></p>     <p>8. Было бы неплохо иметь возможность получать также и одиночный элемент-дорожку, именно этим занимается следующая функция аналогично функции <blockquote>get_cdc_entry</blockquote>, но с указателем на строку каталога и номер дорожки в качестве параметров:</p>     <p><blockquote>cdt_entry get_cdt_entry(const char *cd_catalog_ptr, const int track_no) {</blockquote></p>     <p><blockquote> cdt_entry entry_to_return;</blockquote></p>     <p><blockquote> char entry_to_find[CAT_CAT_LEN + 10];</blockquote></p>     <p><blockquote> datum local_data_datum;</blockquote></p>     <p><blockquote> datum local_key_datum;</blockquote></p>     <p><blockquote> memset(&amp;entry_to_return, '\0', sizeof(entry_to_return));</blockquote></p>     <p><blockquote> if (!cdc_dbm_ptr || !cdt_dbm_ptr) return (entry_to_return);</blockquote></p>     <p><blockquote> if (!cd_catalog_ptr) return (entry_to_return);</blockquote></p>     <p><blockquote> if (strlen(cd_catalog_ptr) &gt;= CAT_CAT_LEN) return (entry_to_return);</blockquote></p>     <p><blockquote> /* Устанавливает ключ поиска, представляющий собой комбинацию</blockquote></p>     <p><blockquote>    элемента каталога и номера дорожки */</blockquote></p>     <p><blockquote> memset(&amp;entry_to_find, '\0', sizeof(entry_to_find));</blockquote></p>     <p><blockquote> sprintf(entry_to_find, "%s %d", cd_catalog_ptr, track_no);</blockquote></p>     <p><blockquote> local_key_datum.dptr = (void*)entry_to_find;</blockquote></p>     <p><blockquote> local_key_datum.dsize = sizeof(entry_to_find);</blockquote></p>     <p><blockquote> memset(&amp;local_data_datum, '\0', sizeof(local_data_datum));</blockquote></p>     <p><blockquote> local_data_datum = dbm_fetch(cdt_dbm_ptr, local_key_datum);</blockquote></p>     <p><blockquote> if (local_data_datum.dptr) {</blockquote></p>     <p><blockquote>  memcpy(&amp;entry_to_return, (char*)local_data_datum.dptr, local_data_datum.dsize);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return (entry_to_return);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>9. Следующая функция <blockquote>add_cdc_entry</blockquote> добавляет новый элемент каталога:</p>     <p><blockquote>int add_cdc_entry(const cdc_entry entry_to_add) {</blockquote></p>     <p><blockquote> char key_to_add[CAT_CAT_LEN + 1];</blockquote></p>     <p><blockquote> datum local_data_datum;</blockquote></p>     <p><blockquote> datum local_key_datum;</blockquote></p>     <p><blockquote> int result;</blockquote></p>     <p><blockquote> /* Проверяет инициализацию базы данных и корректность параметров */</blockquote></p>     <p><blockquote> if (!cdc_dbm_ptr || !cdt_dbm_ptr) return (0);</blockquote></p>     <p><blockquote> if (strlen(entry_to_add.catalog) &gt;= CAT_CAT_LEN) return (0);</blockquote></p>     <p><blockquote> /* Гарантирует включение в ключ поиска только корректной строки</blockquote></p>     <p><blockquote>    и значений null */</blockquote></p>     <p><blockquote> memset(&amp;key_to_add, '\0', sizeof(key_to_add));</blockquote></p>     <p><blockquote> strcpy(key_to_add, entry_to_add.catalog);</blockquote></p>     <p><blockquote> local_key_datum.dptr = (void*)key_to_add;</blockquote></p>     <p><blockquote> local_key_datum.dsize = sizeof(key_to_add);</blockquote></p>     <p><blockquote> local_data_datum.dptr = (void*)&amp;entry_to_add;</blockquote></p>     <p><blockquote> local_data_datum.dsize = sizeof(entry_to_add);</blockquote></p>     <p><blockquote> result = dbm_store(cdc_dbm_ptr, local_key_datum, local_data_datum, DBM_REPLACE);</blockquote></p>     <p><blockquote> /* dbm_store() применяет 0 для успешного завершения */</blockquote></p>     <p><blockquote> if (result == 0) return (1);</blockquote></p>     <p><blockquote> return (0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>10. Функция <blockquote>add_cdt_entry</blockquote> добавляет новый элемент-дорожку. Ключ доступа — это комбинация строки из каталога и номера дорожки:</p>     <p><blockquote>int add_cdt_entry(const cdt_entry entry_to_add) {</blockquote></p>     <p><blockquote> char key_to_add[CAT_CAT_LEN + 10];</blockquote></p>     <p><blockquote> datum local_data_datum;</blockquote></p>     <p><blockquote> datum local_key_datum;</blockquote></p>     <p><blockquote> int result;</blockquote></p>     <p><blockquote> if (!cdc_dbm_ptr || !cdt_dbm_ptr) return (0);</blockquote></p>     <p><blockquote> if (strlen(entry_to_add.catalog) &gt;= CAT_CAT_LEN) return (0);</blockquote></p>     <p><blockquote> memset(&amp;key_to_add, '\0 ', sizeof(key_to_add));</blockquote></p>     <p><blockquote> sprintf(key_to_add, "%s %d", entry_to_add.catalog, entry_to_add.track_no);</blockquote></p>     <p><blockquote> local_key_datum.dptr = (void*)key_to_add;</blockquote></p>     <p><blockquote> local_key_datum.dsize = sizeof(key_to_add);</blockquote></p>     <p><blockquote> local_data_daturn.dptr = (void*)&amp;entry_to_add;</blockquote></p>     <p><blockquote> local_data_datum.dsize = sizeof(entry_to_add);</blockquote></p>     <p><blockquote> result = dbm_store(cdt_dbm_ptr, local_key_datum, local_data_datum, DBM_REPLACE);</blockquote></p>     <p><blockquote> /* dbm_store() применяет 0 в случае успешного завершения</blockquote></p>     <p><blockquote>    и отрицательные числа для обозначения ошибок */</blockquote></p>     <p><blockquote> if (result == 0) return (1);</blockquote></p>     <p><blockquote> return (0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>11. Если вы можете вставлять строки, было бы лучше, если вы могли бы и удалять их. Следующая функция удаляет элементы каталога;</p>     <p><blockquote>int del_cdc_entry(const char *cd_catalog_ptr) {</blockquote></p>     <p><blockquote> char key_to_del[CAT_CAT_LEN +1];</blockquote></p>     <p><blockquote> datum local_key_datum;</blockquote></p>     <p><blockquote> int result;</blockquote></p>     <p><blockquote> if (!cdc_dbm_ptr || !cdt_dbm_ptr) return (0);</blockquote></p>     <p><blockquote> if (strlen(cd_catalog_ptr) &gt;= CAT_CAT_LEN) return (0);</blockquote></p>     <p><blockquote> memset(&amp;key_to_del, '\0', sizeof(key_to_del));</blockquote></p>     <p><blockquote> strcpy(key_to_del, cd_catalog_ptr);</blockquote></p>     <p><blockquote> local_key_datum.dptr = (void*)key_to_del;</blockquote></p>     <p><blockquote> local_key_datum.dsize = sizeof(key_to_del);</blockquote></p>     <p><blockquote> result = dbm_delete(cdc_dbm_ptr, local_key_datum);</blockquote></p>     <p><blockquote> /* dbm_delete() применяет 0 в случае успешного завершения */</blockquote></p>     <p><blockquote> if (result == 0) return (1);</blockquote></p>     <p><blockquote> return (0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>12. Далее приведена аналогичная функция для удаления дорожки. Помните о том, что ключ дорожки — это сложный индекс, состоящий из строки, принадлежащей элементу каталога, и номера дорожки:</p>     <p><blockquote>int del_cdt_entry(const char *cd_catalog_ptr, const int track_no) {</blockquote></p>     <p><blockquote> char key_to_del[CAT_CAT_LEN + 10];</blockquote></p>     <p><blockquote> datum local_key_datum;</blockquote></p>     <p><blockquote> int result;</blockquote></p>     <p><blockquote> if (!cdc_dbm_ptr || !cdt_dbm_ptr) return (0);</blockquote></p>     <p><blockquote> if (strlen(cd_catalog_ptr) &gt;= CAT_CAT_LEN) return (0);</blockquote></p>     <p><blockquote> memset(&amp;key_to_del, '\0', sizeof(key_to_del));</blockquote></p>     <p><blockquote> sprintf(key_to_del, "%s %d", cd_catalog_ptr, track_no);</blockquote></p>     <p><blockquote> local_key_datum.dptr = (void*)key_to_del;</blockquote></p>     <p><blockquote> local_key_datum.dsize = sizeof(key_to_del);</blockquote></p>     <p><blockquote> result = dbm_delete(cdt_dbm_ptr, local_key_datum);</blockquote></p>     <p><blockquote> /* dbm_delete() применяет 0 в случае успешного завершения */</blockquote></p>     <p><blockquote> if (result == 0) return (1);</blockquote></p>     <p><blockquote> return (0);</blockquote></p>     <p><blockquote>}</blockquote> </p>     <p>13. И последнее, но не по значимости, у вас есть простая функция поиска. Она не очень замысловата, но, тем не менее, показывает, как просматривать элементы dbm, если ключи заранее неизвестны.</p>     <p>Поскольку вы не знаете наперед, сколько будет элементов, вы создаете такую функцию, которая будет возвращать один элемент после каждого вызова. Если ничего не найдено, элемент будет пустым. Для просмотра всей базы данных начните с вызова этой функции с указателем на целое число <blockquote>*first_call_ptr</blockquote>, которое должно равняться 1 при первом вызове функции. Благодаря этому функция знает, что должна начать поиск с начала базы данных. В последующих вызовах переменная равна 0 и функция возобновляет поиск следом за последним найденным элементом.</p>     <p>Когда вы хотите перезапустить поиск, возможно, указав другой элемент каталога, вы должны снова вызвать эту функцию с параметром <blockquote>*first_call_ptr</blockquote>, равным <blockquote>true</blockquote>, что приведет к выполнению нового поиска.</p>     <p>Между вызовами функция хранит некоторую внутреннюю информацию о состоянии. Это скрывает от клиента сложность продолжения поиска и защищает секреты реализации функции поиска.</p>     <p>Если искомый текст указывает на символ <blockquote>null</blockquote>, все элементы считаются удовлетворяющими критериям поиска.</p>     <p><blockquote>cdc_entry search_cdc_entry(const char *cd_catalog_ptr,</blockquote></p>     <p><blockquote> int *first_call_ptr) {</blockquote></p>     <p><blockquote> static int local_first_call = 1;</blockquote></p>     <p><blockquote> cdc_entry entry_to_return;</blockquote></p>     <p><blockquote> datum local_data_datum;</blockquote></p>     <p><blockquote> static datum local_key_datum; /* обратите внимание,</blockquote></p>     <p><blockquote>                                  должна быть static */</blockquote></p>     <p><blockquote> memset(&amp;entry_to_return, '\0', sizeof(entry_to_return));</blockquote></p>     <p>14. Как всегда, начните с имеющих смысл проверок:</p>     <p><blockquote> if (!cdc_dbm_ptr || !cdt_dbm_ptr) return (entry_to_return);</blockquote></p>     <p><blockquote> if (!cd_catalog_ptr || !first_call_ptr) return (entry_to_return);</blockquote></p>     <p><blockquote> if (strlen(cd_catalog_ptr) &gt;= CAT_CAT_LEN) return (entry_to_return);</blockquote></p>     <p><blockquote> /* Защита от пропуска вызова с *first_call_ptr, равным true */</blockquote></p>     <p><blockquote> if (local_first_call) {</blockquote></p>     <p><blockquote>  local_first_call = 0;</blockquote></p>     <p><blockquote>  *first_call_ptr = 1;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p>15. Если эта функция была вызвана с параметром <blockquote>*first_call_ptr</blockquote>, равным <blockquote>true</blockquote>, вы должны продолжить (или заново начать) поиск от начала базы данных. Если <blockquote>*first_call_ptr</blockquote> не равен <blockquote>true</blockquote>, просто переходите к следующему ключу в базе данных:</p>     <p><blockquote> if (*first_call_ptr) {</blockquote></p>     <p><blockquote>  *first_call_ptr = 0;</blockquote></p>     <p><blockquote>  local_key_datum = dbm_firstkey(cdc_dbm_ptr);</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  local_key_datum = dbm_nextkey(cdc_dbm_ptr);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> do {</blockquote></p>     <p><blockquote>  if (local_key_datum.dptr != NULL) {</blockquote></p>     <p><blockquote>   /* Элемент был найден */</blockquote></p>     <p><blockquote>   local_data_datum = dbm_fetch(cdc_dhm_ptr, local_key_datum);</blockquote></p>     <p><blockquote>   if (local_data_datum.dptr) {</blockquote></p>     <p><blockquote>    memcpy(&amp;entry_to_return, (char*)local_data_datum.dptr, local_data_datum, dsize);</blockquote></p>     <p>16. Функция поиска включает очень простую проверку, позволяющую увидеть, входит ли строка поиска в текущий элемент каталога.</p>     <p><blockquote>    /* Проверяет, входит ли строка в текущий элемент */</blockquote></p>     <p><blockquote>    if (!strstr(entry_to_return.catalog, cd_catalog_ptr)) {</blockquote></p>     <p><blockquote>     memset(&amp;entry_to_return, '\0', sizeof(entry_to_return));</blockquote></p>     <p><blockquote>     local_key_datum = dbm_nextkey(cdc_dbm_ptr);</blockquote></p>     <p><blockquote>    }</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> } while (local_key_datum.dptr &amp;&amp; local_data_datum.dptr &amp;&amp;</blockquote></p>     <p><blockquote>    (entry_to_return.catalog[0] == '\0'));</blockquote></p>     <p><blockquote> return (entry_to_return);</blockquote></p>     <p><blockquote>} /* search_cdc_entry */</blockquote></p>     <p>Теперь вы готовы собрать все вместе с помощью следующего make-файла или файла сборки. Не слишком углубляйтесь в него сейчас, поскольку мы обсудим его работу в следующей главе. В данный момент просто наберите его и сохраните как Makefile.</p>     <p><blockquote>all: application</blockquote></p>     <br>     <p><blockquote>INCLUDE=/usr/include/gdbm LIBS=gdbm</blockquote></p>     <p><blockquote># В некоторых дистрибутивах вам, возможно, придется изменить предыдущую</blockquote></p>     <p><blockquote># строку, чтобы включить библиотеку совместимости, как показано далее</blockquote></p>     <p><blockquote># LIBS= -lgdbm_compat -lgdbm</blockquote></p>     <p><blockquote>CFIAGS=</blockquote></p>     <br>     <p><blockquote>app_ui.о: app_ui.с cd_data.h</blockquote></p>     <p><blockquote> gcc $(CFLAGS) -c app_ui.c</blockquote></p>     <br>     <p><blockquote>access.о: access.с cd_data.h</blockquote></p>     <p><blockquote> gcc $(CFLAGS) -I$(INCLUDE) -c access.с</blockquote></p>     <br>     <p><blockquote>application: app_ui.o access.о</blockquote></p>     <p><blockquote> gcc $(CFLAGS) -o application app_ui.o access.о -l$(LIBS)</blockquote></p>     <br>     <p><blockquote>clean:</blockquote></p>     <p><blockquote> rm -f application *.o</blockquote></p>     <br>     <p><blockquote>nodbmfiles:</blockquote></p>     <p><blockquote> rm -f *.dir *.pag</blockquote></p>     <p>Для компиляции вашего нового приложения управления коллекцией компакт- дисков наберите следующую команду в командной строке:</p>     <p><blockquote>$ <b>make</b></blockquote></p>     <p>Если все пройдет нормально, выполняемый файл application будет откомпилирован и помещен в текущий каталог.</p>              <a name="metkadoc24"><h1>Резюме</h1></a>    <p>В этой главе вы узнали о трех аспектах управления данными. Сначала вы познакомились с системой управления памятью в ОС Linux, и убедились в простоте ее применения, несмотря на то, что на низком уровне в нее включена реализация виртуальной памяти с подкачкой страниц. Вы также увидели, как она защищает операционную систему и другие программы от попыток несанкционированного доступа к памяти.</p>    <p>Затем мы перешли к рассмотрению того, как блокировка файлов позволяет многочисленным программам сотрудничать при получении доступа к данным. Сначала вы познакомились с простой двоичной схемой семафора и затем более сложной ситуацией, в которой вы блокируете участки файла, устанавливая разделяемый или исключительный доступ. Далее вы рассмотрели библиотеку dbm и ее возможности хранения и эффективного извлечения блоков данных благодаря очень гибкому механизму индексирования.</p>    <p>В заключение, применив dbm как средство хранения данных, мы переработали проектное решение и заново переписали пример приложения, управляющего базой данных компакт-дисков.</p>     <br><br>
<center><div align="center"><a href="index.php.html">Оглавление</a></div></center>




<br>
<script type="text/javascript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="https://www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script><br>

<noindex>
<div align="center">
<center>

<!-- SAPE RTB DIV 600x340 -->
<div id="SRTB_507029"></div>
<!-- SAPE RTB END -->

</center>
</div>
</noindex>

</td>
<td width="240" valign="top">

<br>

<div id="menu3">
<ul>
<li><a href="../../alternativnaja_medicina/index.html"><span>Альтернативная медицина</span></a></li>
<li><a href="../../astronomija_i_kosmos/index.html"><span>Астрономия и Космос</span></a></li>
<li><a href="../../biologija/index.html"><span>Биология</span></a></li>
<li><a href="../../voennaja_istorija/index.html"><span>Военная история</span></a></li>
<li><a href="../../geologija_i_geografija/index.html"><span>Геология и география</span></a></li>
<li><a href="../../gosudarstvo_i_pravo/index.html"><span>Государство и право</span></a></li>
<li><a href="../../delovaja_literatura/index.html"><span>Деловая литература</span></a></li>
<li><a href="../../domashnie_zhivotnye/index.html"><span>Домашние животные</span></a></li>
<li><a href="../../domovodstvo/index.html"><span>Домоводство</span></a></li>
<li><a href="../../zdorove/index.html"><span>Здоровье</span></a></li>
<li><a href="../../istorija/index.html"><span>История</span></a></li>
<li><a href="../index.html"><span>Компьютеры и Интернет</span></a></li>
<li><a href="../../kulinarija/index.html"><span>Кулинария</span></a></li>
<li><a href="../../kulturologija/index.html"><span>Культурология</span></a></li>
<li><a href="../../literaturovedenie/index.html"><span>Литературоведение</span></a></li>
<li><a href="../../matematika/index.html"><span>Математика</span></a></li>
<li><a href="../../medicina/index.html"><span>Медицина</span></a></li>
<li><a href="../../nauchnaja_literatura_prochee/index.html"><span>Науч. литер. - прочее</span></a></li>
<li><a href="../../pedagogika/index.html"><span>Педагогика</span></a></li>
<li><a href="../../politika/index.html"><span>Политика</span></a></li>
<li><a href="../../psihologija/index.html"><span>Психология</span></a></li>
<li><a href="../../religiovedenie/index.html"><span>Религиоведение</span></a></li>
<li><a href="../../sad_i_ogorod/index.html"><span>Сад и огород</span></a></li>
<li><a href="../../samosovershenstvovanie/index.html"><span>Самосовершенствование</span></a></li>
<li><a href="../../sdelai_sam/index.html"><span>Сделай сам</span></a></li>
<li><a href="../../sport/index.html"><span>Спорт</span></a></li>
<li><a href="../../tehnicheskie_nauki/index.html"><span>Технические науки</span></a></li>
<li><a href="../../transport_i_aviacija/index.html"><span>Транспорт и авиация</span></a></li>
<li><a href="../../uchebniki/index.html"><span>Учебники</span></a></li>
<li><a href="../../fizika/index.html"><span>Физика</span></a></li>
<li><a href="../../filosofija/index.html"><span>Философия</span></a></li>
<li><a href="../../himija/index.html"><span>Химия</span></a></li>
<li><a href="../../hobbi_i_remesla/index.html"><span>Хобби и ремесла</span></a></li>
<li><a href="../../shpargalki/index.html"><span>Шпаргалки</span></a></li>
<li><a href="../../yezoterika/index.html"><span>Эзотерика</span></a></li>
<li><a href="../../yurisprudencija/index.html"><span>Юриспруденция</span></a></li>
<li><a href="../../jazykoznanie/index.html"><span>Языкознание</span></a></li>
</ul>
</div>

<br>
<div align="center">
<center>
<noindex>

<!-- SAPE RTB DIV 240x400 -->
<div id="SRTB_507028"></div>
<!-- SAPE RTB END -->

</noindex>
</center>
</div>

</td>
</tr>
<tr>
<td colspan="3" align="center">


<hr>
<a href="../../index.html"><span>Главная</span></a> | 
<a rel="sidebar" href="p11.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a> | 
<a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a> | 
<a href="p11.php.html#" onClick="scroll(0,0); return false" title="наверх">Наверх</a>
</td>
</tr>
<tr>
<td colspan="3" valign="top" align="left">
<br>

 



</td>
</tr>
</table>

<noindex>
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter21717787 = new Ya.Metrika({id:21717787,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="http://mc.yandex.ru/watch/21717787" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

</noindex>
</center>
</div></body>
</html>