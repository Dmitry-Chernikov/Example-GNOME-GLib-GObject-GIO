<html>
<head>
<meta http-equiv="Content-Language" content="ru">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<link href="../../0img/style.css" rel="stylesheet" type="text/css" />
<link rel="SHORTCUT ICON" href="http://www.redov.ru/0img/favicon.ico" type="image/x-icon"> 
<title>Глава 10 Отладка / Основы программирования в Linux</title>
</head>
<body>
<div align="center">
<center>
<table border="0" cellpadding="0" cellspacing="0" width="1260">
<tr>
<td colspan="3" valign="top" align="left" height="100">
<table border="0" cellpadding="0" cellspacing="0" width="1260" height="100">
<tr>
<td valign="middle" align="center" width="350">
<a href="../../index.html"><img src="../../0img/logo.jpg" width="350" height="100" title="Онлайн библиотека redov.ru"/></a>
</td>
<td valign="middle" align="center" width="910">

<noindex>

<!-- SAPE RTB JS -->
<script
    async="async"
    src="http://cdn-rtb.sape.ru/rtb-b/js/393/2/106393.js"
    type="text/javascript">
</script>
<!-- SAPE RTB END -->

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507025"></div>
<!-- SAPE RTB END -->

</noindex>

</td>
</tr>
</table>
</td>
</tr>
<tr>
<td colspan="3" valign="middle" align="left">

<div id="menu">
<ul>
		<li><a href="../../index.html"><span>Главная</span></a></li>
		<li><a rel="sidebar" href="p14.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a></li>
		<li><a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a></li>
		<li><a href="p14.php.html#" onClick="scroll(0,9999999); return false"><span>Вниз</span></a></li>
</ul>
</div>


</td>
</tr>
<tr>
<td width="240" valign="top" align="center">

<br>
<noindex>
<!-- SAPE RTB DIV 160x600 -->
<div id="SRTB_733378"></div>
<!-- SAPE RTB END -->
</noindex>



</td>
<td valign="top" align="left" style="padding-left: 5; padding-right: 5" width="780">
<br>
<noindex>
<div align="center">

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507027"></div>
<!-- SAPE RTB END -->

</div>
</noindex>
<br>



<li><a href="p14.php.html#metkadoc2">     Типы ошибок     </a></li>
<li><a href="p14.php.html#metkadoc3">     Общие методы отладки     </a></li>
<li><a href="p14.php.html#metkadoc4">      Программа с ошибками      </a></li>
<li><a href="p14.php.html#metkadoc5">      Анализ кода      </a></li>
<li><a href="p14.php.html#metkadoc6">      Оснащение средствами контроля      </a></li>
<li><a href="p14.php.html#metkadoc7">      Контролируемое выполнение      </a></li>
<li><a href="p14.php.html#metkadoc8">     Отладка с помощью gdb     </a></li>
<li><a href="p14.php.html#metkadoc9">      Запуск gdb      </a></li>
<li><a href="p14.php.html#metkadoc10">      Выполнение программы      </a></li>
<li><a href="p14.php.html#metkadoc11">      Трассировка стека      </a></li>
<li><a href="p14.php.html#metkadoc12">      Просмотр переменных      </a></li>
<li><a href="p14.php.html#metkadoc13">      Вывод листинга программы      </a></li>
<li><a href="p14.php.html#metkadoc14">      Установка точек останова      </a></li>
<li><a href="p14.php.html#metkadoc15">      Вставка исправлений с помощью отладчика      </a></li>
<li><a href="p14.php.html#metkadoc16">      Дополнительные сведения о gdb      </a></li>
<li><a href="p14.php.html#metkadoc17">     Дополнительные средства отладки     </a></li>
<li><a href="p14.php.html#metkadoc18">      <i>Lint</i> удаление ошибок из ваших программ      </a></li>
<li><a href="p14.php.html#metkadoc19">      Средства, отслеживающие вызовы функций      </a></li>
<li><a href="p14.php.html#metkadoc20">      Выполнение профилирования с помощью <i>prof/gprof</i>      </a></li>
<li><a href="p14.php.html#metkadoc21">     Проверки соблюдения условий     </a></li>
<li><a href="p14.php.html#metkadoc22">     Устранение ошибок использования памяти     </a></li>
<li><a href="p14.php.html#metkadoc23">      ElectricFence      </a></li>
<li><a href="p14.php.html#metkadoc24">      <i>valgrind</i>      </a></li>
<li><a href="p14.php.html#metkadoc25">     Резюме      </a></li>
<a name="metkadoc1"><h1>Глава 10</p>    <p>Отладка</h1></a>       <p>По утверждению Software Engineering Institute (Институт программных разработок) и IEEE (Institute of Electrical and Electronics Engineers, Институт инженеров по электротехнике и электронике) в любом значимом фрагменте программного обеспечения первоначально всегда есть дефекты, примерно два на 100 строк программного кода. Эти ошибки приводят к тому, что программы и библиотеки не работают так, как требуется, часто заставляя программу вести себя иначе, чем предполагалось. Отслеживание ошибок, их идентификация и удаление могут потребовать от программиста больших затрат времени на этапе разработки.</p>    <p>В этой главе мы рассмотрим недочеты программного обеспечения и некоторые средства и методы исследования характерных примеров ошибочного поведения. Это не то же самое, что тестирование (задача проверки работы программы во всех возможных условиях или обстоятельствах), хотя тестирование и отладка конечно же взаимосвязаны, и многие ошибки обнаруживаются в процессе тестирования.</p>    <p>Будут обсуждаться следующие темы:</p>    <p>&#9633; типы ошибок;</p>    <p>&#9633; общие методы отладки;</p>    <p>&#9633; отладка с помощью gdb и других средств;</p>    <p>&#9633; проверка соблюдения условий (макрос <blockquote>assert</blockquote>);</p>    <p>&#9633; устранение ошибок использования памяти.</p>          <a name="metkadoc2"><h1>Типы ошибок</h1></a>    <p>Ошибка, как правило, возникает по одной из нескольких причин, каждая из которых предполагает конкретный метод выявления и устранения.</p>    <p>&#9633; <b>Ошибки описания или спецификации.</b> Если программа неверно определена, она, несомненно, не сможет выполняться, как требуется. Даже лучший программист в мире может порой написать неверную программу. Прежде чем приступить к программированию (или разработке), убедитесь в том, что вы точно знаете и четко представляете, что должна делать программа. Вы обнаружите и устраните множество ошибок спецификации (если не все), обсуждая требования и получая подтверждение их правильности у тех, кто будет применять вашу программу в дальнейшем.</p>    <p>&#9633; <b>Ошибки проектирования или разработки.</b> Перед созданием программы любого размера должны прорабатываться. Как правило, недостаточно просто сесть к клавиатуре компьютера, непосредственно набрать программный код и ждать, что программа сразу заработает. Нужно время, чтобы подумать о том, как написать программу, какие структуры данных потребуются и как они будут использоваться. Постарайтесь заранее разработать все в деталях, это убережет вас от многочисленных переработок программы в дальнейшем.</p>    <p>&#9633; <b>Ошибки кодирования.</b> Конечно, все делают ошибки при наборе. Создание программного кода из вашей разработки — неидеальный процесс. Именно здесь появляется много ошибок. Когда вы сталкиваетесь с ошибкой в программе, не упускайте возможности еще раз прочесть ваш исходный код или попросите об этом кого-нибудь. Просто поразительно, как много ошибок и недочетов можно обнаружить и устранить, обсуждая реализацию с кем-нибудь еще.</p>    <blockquote>     <b>Примечание</b>     <p>Языки программирования с компиляторами, такие как С, обладают возможностью поймать синтаксические ошибки в процессе компиляции, в то время как интерпретируемые языки, например язык командной оболочки Linux, могут обнаружить синтаксические ошибки только тогда, когда вы попытаетесь выполнить программу. Если проблема в коде обработки ошибки, нелегко будет выявить ее в ходе тестирования.</p>    </blockquote>    <p><b>&#9633;</b> Попытайтесь выполнить основную часть программы на бумаге, этот процесс называют<i> формальным прогоном.</i> Для наиболее важных подпрограмм запишите значения на входе и вычислите шаг за шагом выходные значения. Для отладки совсем не обязательно всегда применять компьютер, иногда именно компьютер создает проблемы. Даже разработчики, пишущие библиотеки, компиляторы и операционные системы, делают ошибки! С другой стороны, не спешите винить во всем используемые программные средства; гораздо вероятнее, что ошибка закралась в вашу новую программу, а не в компилятор.</p>          <a name="metkadoc3"><h1>Общие методы отладки</h1></a>         <p>Существует несколько разных подходов к отладке и тестированию типовой программы Linux. Обычно разработчик запускает программу и смотрит, что происходит. Если программа не работает, необходимо решить, что с ней делать. Можно изменить программу и попробовать снова (анализ программного кода, метод проб и ошибок), можно попытаться получить больше информации о том, что происходит внутри программы (оснащение контрольными средствами) или можно непосредственно проанализировать работу программы (контролируемое выполнение). Отладка включает в себя пять следующих этапов:</p>     <p>&#9633; тестирование — поиск существующих изъянов или ошибок;</p>     <p>&#9633; стабилизация — обеспечение повторяемости ошибок;</p>     <p>&#9633; локализация — определение строки кода, отвечающей за ошибку;</p>     <p>&#9633; корректировка — исправление программного кода;</p>     <p>&#9633; проверка — подтверждение того, что исправление работает.</p>             <a name="metkadoc4"><h1>Программа с ошибками</h1></a>     <p>Давайте рассмотрим пример программы, содержащей ошибки. Читая данную главу, вы будете пробовать отладить эту программу. Она написана во время разработки большой программной системы. Ее задача — протестировать единственную функцию <blockquote>sort</blockquote>, которая предназначена для реализации сортировки массива структур типа <blockquote>item</blockquote> методом "пузырька". Элементы сортируются по возрастанию поля <blockquote>key</blockquote>. Программа вызывает функцию <blockquote>sort</blockquote> для сортировки контрольного примера, чтобы протестировать функцию. В реальной жизни вы никогда не стали бы обращаться к этому конкретному алгоритму из-за его очень низкой эффективности. Мы же применяем его, потому что он короткий, относительно простой и его легко превратить в неправильный. На самом деле в стандартной библиотеке языка С есть функция с именем <blockquote>qsort</blockquote>, выполняющая эту задачу.</p>     <p>К сожалению, исходный код программы нелегко читается, в нем нет комментариев, и автор уже недоступен. Вам придется биться с ней самостоятельно, начиная с основной подпрограммы debug1.c.</p>     <p><blockquote>/*  1 */ typedef struct {</blockquote></p>     <p><blockquote>/*  2 */  char *data;</blockquote></p>     <p><blockquote>/*  3 */  int key;</blockquote></p>     <p><blockquote>/*  4 */ } item;</blockquote></p>     <p><blockquote>/*  5 */</blockquote></p>     <p><blockquote>/*  6 */ item array[] = {</blockquote></p>     <p><blockquote>/*  7 */  {"bill", 3},</blockquote></p>     <p><blockquote>/*  8 */  {"neil", 4},</blockquote></p>     <p><blockquote>/*  9 */  {"john", 2},</blockquote></p>     <p><blockquote>/* 10 */  {"rick", 5},</blockquote></p>     <p><blockquote>/* 11 */  {"alex", 1},</blockquote></p>     <p><blockquote>/* 12 */ };</blockquote></p>     <p><blockquote>/* 13 */</blockquote></p>     <p><blockquote>/* 14 */ sort(a, n)</blockquote></p>     <p><blockquote>/* 15 */ item *a;</blockquote></p>     <p><blockquote>/* 16 */ {</blockquote></p>     <p><blockquote>/* 17 */  int i = 0, j = 0;</blockquote></p>     <p><blockquote>/* 18 */  int s = 1;</blockquote></p>     <p><blockquote>/* 19 */</blockquote></p>     <p><blockquote>/* 20 */  for(; i &lt; n &amp;&amp; s != 0; i++) {</blockquote></p>     <p><blockquote>/* 21 */   s = 0;</blockquote></p>     <p><blockquote>/* 22 */   for(j = 0; j &lt; n; j++) {</blockquote></p>     <p><blockquote>/* 23 */    if(a[j].key &gt; a[j + 1].key) {</blockquote></p>     <p><blockquote>/* 24 */     item t = a[j];</blockquote></p>     <p><blockquote>/* 25 */     a[j] = a[j+1];</blockquote></p>     <p><blockquote>/* 26 */     a[j+1] = t;</blockquote></p>     <p><blockquote>/* 27 */     s++;</blockquote></p>     <p><blockquote>/* 28 */    }</blockquote></p>     <p><blockquote>/* 29 */   }</blockquote></p>     <p><blockquote>/* 30 */   n--;</blockquote></p>     <p><blockquote>/* 31 */  }</blockquote></p>     <p><blockquote>/* 32 */ }</blockquote></p>     <p><blockquote>/* 33 */</blockquote></p>     <p><blockquote>/* 34 */ main()</blockquote></p>     <p><blockquote>/* 35 */ {</blockquote></p>     <p><blockquote>/* 36 */  sort(array,5);</blockquote></p>     <p><blockquote>/* 37 */ }</blockquote></p>     <p>Теперь попытайтесь откомпилировать эту программу:</p>     <p><blockquote>$ <b>сс -о debug1 debug1.с</b></blockquote></p>     <p>Она компилируется успешно без каких-либо сообщений об ошибках или предупреждений.</p>     <p>Прежде чем выполнять эту программу, вставьте фрагмент кода для вывода результата. В противном случае вы не будете знать, отработала ли программа. Вы добавите несколько дополнительных строк для отображения массива после сортировки. Назовите новую версию debug2.c.</p>     <p><blockquote>/* 33 */ #include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>/* 34 */ main()</blockquote></p>     <p><blockquote>/* 35 */ {</blockquote></p>     <p><blockquote>/* 36 */  int i;</blockquote></p>     <p><blockquote>/* 37 */  sort(array, 5);</blockquote></p>     <p><blockquote>/* 38 */  for(i = 0; i &lt; 5; i++)</blockquote></p>     <p><blockquote>/* 39 */   printf("array[3d] = (%s, %d)\n",</blockquote></p>     <p><blockquote>/* 40 */    i, array[i].data, array[i].key);</blockquote></p>     <p><blockquote>/* 41 */ }</blockquote></p>     <p>Этот дополнительный код, строго говоря, не является частью, позже добавленной программистом. Мы заставили вас добавить его только для тестирования программы. Следует быть очень внимательным, чтобы не внести новых ошибок в ваш тестовый код. Теперь снова откомпилируйте программу и на этот раз выполните ее:</p>     <p><blockquote>$ <b>cc -о debug2 debug2.с</b></blockquote></p>     <p><blockquote>$ <b>./debug2</b></blockquote></p>     <p>Что произойдет, когда вы сделаете это, зависит от вашей версии Linux (или UNIX) и особенностей ее установки. В своих системах мы получили следующий результат:</p>     <p><blockquote>array[0] = {john, 2}</blockquote></p>     <p><blockquote>array[1] = {alex, 1}</blockquote></p>     <p><blockquote>array[2] = {(null), -1}</blockquote></p>     <p><blockquote>array[3] = {bill, 3}</blockquote></p>     <p><blockquote>array[4] = {neil, 4}</blockquote></p>     <p>В еще одной системе (запускающей другое ядро Linux) мы получили следующий вывод:</p>     <p><blockquote>Segmentation fault</blockquote></p>     <p>В вашей системе Linux вы увидите один из приведенных результатов или совсем другой. Мы рассчитывали получить приведенный далее вывод:</p>     <p><blockquote>array[0] = {alex, 1}</blockquote></p>     <p><blockquote>array[1] = {john, 2}</blockquote></p>     <p><blockquote>array[2] = {bill, 3}</blockquote></p>     <p><blockquote>array[3] = {neil, 4}</blockquote></p>     <p><blockquote>array[4] = {rick, 5}</blockquote></p>     <p>Ясно, что в данном программном коде есть серьезная ошибка. Он не выполняет сортировку корректно, если вообще работает, а если он завершается с ошибкой сегментации, то операционная система посылает сигнал программе, сообщая о том, что обнаружен несанкционированный доступ к памяти, и преждевременно завершает программу, чтобы не испортить данные в оперативной памяти.</p>     <p>Способность операционной системы обнаружить несанкционированный доступ к памяти зависит от настройки оборудования и некоторых тонкостей реализации системы управления памятью. В большинстве систем объем памяти, выделяемый программе операционной системой, больше реально используемого. Если несанкционированный доступ осуществляется к этому участку памяти, оборудование может не выявить несанкционированный доступ. Вот почему не все версии Linux и UNIX сгенерируют сигнал о нарушении сегментации.</p>     <blockquote>      <b>Примечание</b>      <p>Некоторые библиотечные функции, такие как <blockquote>printf</blockquote>, в определенных обстоятельствах также будут препятствовать некорректному доступу, например при использовании указателя <blockquote>null</blockquote>.</p>     </blockquote>     <p>Когда вы исследуете проблемы доступа к элементам массива, часто полезно увеличить размер этих элементов, поскольку это увеличит размер ошибки. Если вы читаете единственный байт за пределами массива байтов, это может вам сойти с рук, т.к. память, выделенная программе, будет округляться до величины, зависящей от операционной системы, возможно, равной 8 Кбайт.</p>     <p>Если вы увеличите размер элемента массива, заменив элемент типа <blockquote>item</blockquote> массивом из 4096 символов, любое обращение к несуществующему элементу массива, возможно, окажется за пределами выделенной памяти. Каждый элемент массива равен 4 Кбайт, поэтому некорректно используемый участок памяти будет находиться за концом массива на расстоянии от 0 до 4 Кбайт.</p>     <p>Если мы внесем эту поправку, назвав результат debug3.c, то получим ошибку сегментации в версиях Linux обоих авторов.</p>     <p><blockquote>/* 2 */ char data[4096];</blockquote></p>     <br>     <p><blockquote>$ <b>сс -о debug3 debug3.с</b></blockquote></p>     <p><blockquote>$ <b>./debug3</b></blockquote></p>     <p><blockquote>Segmentation fault</blockquote></p>     <p>Возможно, что какие-то варианты систем Linux или UNIX все еще не будут выдавать сообщение об ошибке сегментации. Когда стандарт ANSI С утверждает, что поведение не определено, на самом деле он разрешает программе делать все, что угодно. Это выглядит так, как будто мы написали не удовлетворяющую стандартам программу на языке С, и она может демонстрировать очень странное поведение! Как видите, изъян в программе переводит ее в категорию программ с непредсказуемым поведением.</p>             <a name="metkadoc5"><h1>Анализ кода</h1></a>     <p>Как мы упоминали ранее, часто, если программа не работает, как ожидалось, неплохо перечитать ее. Предположим, что мы просмотрели программный код примера этой главы и исправили в нем все очевидные ошибки.</p>     <blockquote>      <b>Примечание</b>      <p>Анализ кода — это термин, применяемый для обозначения более формального процесса, в ходе которого группа разработчиков тщательно просматривает несколько сотен строк программного кода, но масштаб не имеет значения, это все равно анализ кода, и он остается очень полезным методом поиска ошибок.</p>     </blockquote>     <p>Существуют средства, которые могут помочь в анализе кода, одно из самых очевидных — компилятор. Он сообщит вам о любых имеющихся в вашей программе синтаксических ошибках.</p>     <blockquote>      <b>Примечание</b>      <p>У некоторых компиляторов есть опции, формирующие предупреждения в сомнительных случаях, таких как отсутствие инициализации переменных или применение присваиваний в условиях. Например, компилятор GNU можно запускать со следующими опциями:</p>      <p><blockquote>gcc -Wall -pedantic -ansi</blockquote></p>      <p>Они порождают много предупреждений и дополнительных проверок на соответствие стандартам языка С. Рекомендуем взять за правило использование этих опций, особенно <blockquote>Wall</blockquote>. Она генерирует полезную информацию при обнаружении ошибок в программе.</p>     </blockquote>     <p>Чуть позже мы кратко обсудим и другие средства, <blockquote>lint</blockquote> и <blockquote>splint</blockquote>. Как и компилятор, они анализируют код и сообщают о фрагментах кода, которые могут быть некорректными.</p>             <a name="metkadoc6"><h1>Оснащение средствами контроля</h1></a>     <p>Оснащение средствами контроля — это вставка в программу кода для сбора дополнительной информации о поведении программы во время ее выполнения. Очень популярна вставка вызовов функции <blockquote>printf</blockquote> для вывода значений переменных на разных стадиях выполнения программы. Вы можете с пользой для себя добавить несколько вызовов <blockquote>printf</blockquote>, но должны знать о том, что этот процесс повлечет за собой дополнительные редактирование и компиляцию при любом изменении программы и, конечно, вам придется удалить код, когда ошибки будут исправлены.</p>     <p>Здесь могут помочь два метода оснащения средствами контроля. Первый использует препроцессор языка С для выборочного включения кода средств контроля так, что вам нужно только перекомпилировать программу для вставки или удаления отладочного кода. Сделать это можно очень просто, с помощью конструкций, подобных приведенным далее:</p>     <p><blockquote>#ifdef DEBUG</blockquote></p>     <p><blockquote> printf("variable x has value = %d\n", x);</blockquote></p>     <p><blockquote>#endif</blockquote></p>     <p>Вы можете компилировать программу с флагом компилятора <blockquote>-DDEBUG</blockquote> для определения символического имени <blockquote>DEBUG</blockquote> и включения дополнительного кода и без этого флага — для удаления отладочного кода. Можно создать и более сложный вариант использования пронумерованных отладочных макросов:</p>     <p><blockquote>#define BASIC_DEBUG 1</blockquote></p>     <p><blockquote>#define EXTRA_DEBUG 2</blockquote></p>     <p><blockquote>#define SUPER_DEBUG 4</blockquote></p>     <p><blockquote>#if (DEBUG &amp; EXTRA_DEBUG)</blockquote></p>     <p><blockquote> printf...</blockquote></p>     <p><blockquote>#endif</blockquote></p>     <p>В этом случае вы всегда должны определять макрос <blockquote>DEBUG</blockquote>, но можете настраивать объем отладочной информации или уровень детализации. Флаг компилятора <blockquote>-DDEBUG=5</blockquote> в нашем примере активизирует макросы <blockquote>BASIC_DEBUG</blockquote> и <blockquote>SUPER_DEBUG</blockquote>, но не <blockquote>EXTRA_DEBUG</blockquote>. Флаг <blockquote>DDEBUG=0</blockquote> отключит всю отладочную информацию. С другой стороны, вставка следующих строк устранит необходимость задания в командной строке <blockquote>DEBUG</blockquote>, если отладки не требуется.</p>     <p><blockquote>#ifndef DEBUG</blockquote></p>     <p><blockquote>#define DEBUG 0</blockquote></p>     <p><blockquote>#endif</blockquote></p>     <p>Несколько макросов, определенных препроцессором С, могут предоставить отладочную информацию. Эти макросы раскрываются для предоставления сведений о текущей компиляции (табл. 10.1).</p>     <p>Обратите внимание на то, что приведенные символические имена начинаются и заканчиваются двумя символами подчеркивания. Это стандартное правило для символических имен препроцессора, и вы должны аккуратно выбирать идентификаторы, чтобы избежать конфликтов. Термин "текущие" в предыдущих описаниях указывает на момент выполнения препроцессорной обработки, т.е. время и дата запуска компилятора и обработки файла.</p>     <br>     <p><b><i>Таблица 10.1</i></b></p>     <table>      <tr>       <th valign="top">Макрос</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>__LINE__</blockquote></td>       <td valign="top">Десятичная константа, предоставляющая номер текущей строки</td>      </tr>      <tr>       <td valign="top"><blockquote>__FILE__</blockquote></td>       <td valign="top">Строка, предоставляющая имя текущего файла</td>      </tr>      <tr>       <td valign="top"><blockquote>__DATE__</blockquote></td>       <td valign="top">Строка в форме "ммм дд гггг", текущая дата</td>      </tr>      <tr>       <td valign="top"><blockquote>__TIME__</blockquote></td>       <td valign="top">Строка в форме "чч:мм:сс", текущее время</td>      </tr>     </table>     <p>Выполните упражнение 10.1.</p>     <b>Упражнение 10.1. Отладочная информация</b>     <p>Далее приведена программа cinfo.c, которая выводит дату и время компиляции, если включен режим отладки.</p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote># include &lt;stdlib.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote>#ifdef DEBUG</blockquote></p>     <p><blockquote> printf("Compiled: " __DATE__ " at " __TIME__ "\n");</blockquote></p>     <p><blockquote> printf("This is line %d of file %s\n", __LINE__, __FILE__);</blockquote></p>     <p><blockquote>#endif</blockquote></p>     <p><blockquote> printf("hello world\n");</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Когда вы откомпилируете эту программу с включенным режимом отладки (используя флаг <blockquote>-DDEBUG</blockquote>), то увидите следующие сведения о компиляции:</p>     <p><blockquote>$ <b>cc -о cinfo -DDEBUG cinfo.c </b></blockquote></p>     <p><blockquote>$ <b>./cinfo</b></blockquote></p>     <p><blockquote>Compiled: Jun 30 2007 at 22:58:43</blockquote></p>     <p><blockquote>This is line 8 of file cinfo.c</blockquote></p>     <p><blockquote>hello world</blockquote></p>     <p><blockquote>$</blockquote></p>     <p><b>Как это работает</b></p>     <p>Препроцессор С, часть компилятора, отслеживает текущую строку и текущий файл во время компиляции. Он подставляет текущие (времени компиляции) значения этих переменных везде, где обнаруживает символические имена <blockquote>__LINE__</blockquote> и <blockquote>__FILE__</blockquote>. Дата и время компиляции становятся доступными аналогичным образом.</p>     <p>Поскольку <blockquote>__DATE__</blockquote> и <blockquote>__TIME__</blockquote> — строки, вы можете объединить их в функции <blockquote>printf</blockquote> с помощью строк формата, т.к. в языке С ANSI смежные строки воспринимаются как одна.</p>     <b>Отладка без перекомпиляции</b>     <p>Прежде чем двигаться дальше, стоит отметить, что существует способ применения функции <blockquote>printf</blockquote>, позволяющий отлаживать программу без применения метода <blockquote>#ifdef DEBUG</blockquote>, требующего перекомпиляции программы перед ее использованием.</p>     <p>Метод заключается во вставке глобальной переменной как флага отладки, разрешении опции <blockquote>-d</blockquote> в командной строке, которая дает возможность пользователю включить отладку даже после того, как программа была введена в эксплуатацию, и включении функции мониторинга процесса отладки. Теперь можно вкраплять в код программы строки, подобные следующим:</p>     <p><blockquote>if (debug) {</blockquote></p>     <p><blockquote> sprintf(msg, ...)</blockquote></p>     <p><blockquote> write_debug(msg)</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Записывать вывод отладки следует в стандартный поток ошибок <blockquote>stderr</blockquote> или, если это не годится из-за характера программы, используйте возможности мониторинга, предоставляемые функцией <blockquote>syslog</blockquote>.</p>     <p>Если вы вставляете в программу подобную трассировку для решения проблем, возникающих на этапе разработки, просто оставьте этот код в программе. Если вы будете чуть внимательнее, чем всегда, такой подход не вызовет никаких проблем. Выигрыш проявится, когда программа будет введена в эксплуатацию; если пользователи обнаружат проблему, они смогут выполнить программу в режиме отладки и диагностировать ошибки для вас. Вместо известия о том, что программа выдает сообщение о нарушении сегментации, они смогут написать, что конкретно делает программа в ходе выполнения, а не только описать свои действия. Разница может оказаться огромной.</p>     <p>У этого метода есть явный недостаток: программа становится больше, чем должна быть. В большинстве случаев это, скорее, мнимая проблема, чем реальная. Программа может стать на 20–30% больше, но чаще всего это не оказывает никакого существенного влияния на ее производительность. Снижение производительности наступает при увеличении размера на несколько порядков, а не на небольшую величину.</p>             <a name="metkadoc7"><h1>Контролируемое выполнение</h1></a>     <p>Вернемся к примеру программы. У вас есть ошибка. Вы можете изменить программу, вставив в нее дополнительный код для вывода значений переменных по мере выполнения программы, или применить отладчик для контроля над выполнением программы и просмотра ее состояния в ходе выполнения.</p>     <p>В коммерческих UNIX-системах есть ряд отладчиков, набор которых зависит от поставщика системы. Наиболее распространенные — adb, sdb, idebug и dbx. Более сложные отладчики позволяют просматривать с некоторой степенью детализации состояние программы на уровне исходного кода. Именно к таким относится отладчик GNU, gdb, который может применяться в системах Linux и многих вариантах UNIX. Существуют и внешние интерфейсы (или программы-клиенты) для gdb, делающие его более удобным для пользователя; к таким программам относятся xxgdb, KDbg и ddd. Некоторые IDE, например, те, с которыми вы познакомились в <i>главе 9,</i> также предоставляют средства отладки или внешний интерфейс для gdb. У редактора Emacs даже есть средство (gdb-mode), позволяющее запускать gdb в вашей программе, устанавливать точки останова и построчно просматривать выполнение исходного кода.</p>     <p>Для подготовки программы к отладке необходимо откомпилировать ее с одной или несколькими специальными опциями. Эти опции заставляют компилятор вставлять в программу дополнительную отладочную информацию. Она включает в себя идентификаторы и номера строк — сведения, которые отладчик может использовать, чтобы показать пользователю, до какого места в исходном программном коде дошло выполнение.</p>     <p>Флаг <blockquote>-g</blockquote> — один из обычно применяемых при компиляции программы с последующей отладкой. Вы должны указывать его при компиляции всех исходных файлов, которые нуждаются в отладке, а также для компоновщика, чтобы могли применяться специальные версии стандартной библиотеки С, обеспечивающие поддержку режима отладки в библиотечных функциях. Программа компилятора передаст флаг компоновщику автоматически. Отладка может применяться и с библиотеками, не откомпилированными для этой цели, но с меньшей гибкостью.</p>     <p>Отладочная информация может увеличить исполняемый файл во много (до десяти) раз. Несмотря на увеличение размера исполняемого файла (он займет больше места на диске), объем памяти, необходимый для выполнения программы, практически остается тем же самым. Перед вводом программы в эксплуатацию неплохо удалить из нее отладочную информацию, но только после того, как программа полностью отлажена.</p>     <blockquote>      <b>Примечание</b>      <p>Удалить отладочную информацию из исполняемого файла без повторной компиляции можно, выполнив команду <blockquote>strip &lt;<i>файл</i>&gt;</blockquote><i>.</i></p>     </blockquote>              <a name="metkadoc8"><h1>Отладка с помощью gdb</h1></a>         <p>Для отладки программы вы можете применять отладчик проекта GNU, gdb. Это очень мощный отладчик, который распространяется бесплатно и может использоваться на многих платформах UNIX. Он также служит отладчиком по умолчанию в системах Linux. gdb перенесен на многие другие платформы и может применяться для отладки встроенных систем реального времени.</p>             <a name="metkadoc9"><h1>Запуск gdb</h1></a>     <p>Перекомпилируйте программу примера для отладки и запустите gdb:</p>     <p><blockquote>$ <b>cc-g -o debug3 debug3.c</b></blockquote></p>     <p><blockquote>$ <b>gdb debug3</b></blockquote></p>     <p><blockquote>GNU gdb 6.6</blockquote></p>     <p><blockquote>Copyright (C) 2006 Free Software Foundation, Inc.</blockquote></p>     <p><blockquote>GDB is free software, covered by the GNU General Public License, and you</blockquote></p>     <p><blockquote>are welcome to change it and/or distribute copies of it under certain</blockquote></p>     <p><blockquote>conditions.</blockquote></p>     <p><blockquote>Type "show copying" to see the conditions.</blockquote></p>     <p><blockquote>There is absolutely no warranty for GDB. Type "show warranty" for</blockquote></p>     <p><blockquote>details.</blockquote></p>     <p><blockquote>This GDB was configured as "i586-suse-linux"...</blockquote></p>     <p><blockquote>Using host libthread_db library "/lib/libthread_db.so.1".</blockquote></p>     <p><blockquote>(gdb)</blockquote></p>     <p>У gdb есть довольно подробная интерактивная система помощи и полное справочное руководство, представляемое как набор файлов, которые можно просматривать с помощью программы <blockquote>info</blockquote> или из редактора Emacs.</p>     <p><blockquote>(gdb) <b>help</b></blockquote></p>     <p><blockquote>List of classes of commands:</blockquote></p>     <br>     <p><blockquote>aliases -- Aliases of other commands</blockquote></p>     <p><blockquote>breakpoints -- Making program stop at certain points</blockquote></p>     <p><blockquote>data -- Examining data</blockquote></p>     <p><blockquote>files -- Specifying and examining files</blockquote></p>     <p><blockquote>internals -- Maintenance commands</blockquote></p>     <p><blockquote>obscure -- Obscure features</blockquote></p>     <p><blockquote>running -- Running the program</blockquote></p>     <p><blockquote>stack -- Examining the stack</blockquote></p>     <p><blockquote>status -- Status inquiries</blockquote></p>     <p><blockquote>support -- Support facilities</blockquote></p>     <p><blockquote>tracepoints -- Tracing of program execution without stopping the program</blockquote></p>     <p><blockquote>user-defined -- User-defined commands</blockquote></p>     <br>     <p><blockquote>Type "help" followed by a class name for a list of commands in that class.</blockquote></p>     <p><blockquote>Type "help all" for the list of all commands.</blockquote></p>     <p><blockquote>Type "help" followed by command name for full documentation.</blockquote></p>     <p><blockquote>Type "apropos word" to search for commands related to "word".</blockquote></p>     <p><blockquote>Command name abbreviations are allowed if unambiguous,</blockquote></p>     <p><blockquote>(gdb)</blockquote></p>     <p>Сам по себе отладчик gdb — приложение, выполняющееся в текстовом режиме, но он предоставляет несколько сокращенных клавишных команд для выполнения повторяющихся задач. Во многих версиях есть редактирование в командной строке с хронологией команд, так что вы можете прокрутить список назад и выполнить ту же команду снова (попробуйте воспользоваться клавишами перемещения курсора). Все версии отладчика поддерживают "пустую команду"; нажатие клавиши &lt;Enter&gt; выполняет последнюю команду еще раз. Это особенно удобно при проверке выполнения программы в построчном режиме с помощью команд <blockquote>step</blockquote> или <blockquote>next</blockquote>.</p>     <p>Для завершения работы gdb применяйте команду <blockquote>quit</blockquote>.</p>             <a name="metkadoc10"><h1>Выполнение программы</h1></a>     <p>Выполнить программу можно с помощью команды <blockquote>run</blockquote>. Любые аргументы, переданные вами команде <blockquote>run</blockquote>, пересылаются в программу как ее собственные аргументы. В данном случае вам не нужны никакие аргументы.</p>     <p>Предположим, что ваша система, как и системы обоих авторов, теперь генерирует сообщение о нарушении сегментации памяти. Если нет, читайте дальше. Вы узнаете, что делать, когда одна из ваших программ действительно сгенерирует сообщение о нарушении сегментации. Если вы не получили такого сообщения, но хотите поработать с этим примером во время чтения книги, когда первая из проблем, связанных с доступом к памяти, будет устранена, можно взять программу из файла debug4.c.</p>     <p><blockquote>(gdb) <b>run</b></blockquote></p>     <p><blockquote>Starting program: /home/neil/BLP4e/chapter10/debug3</blockquote></p>     <br>     <p><blockquote>Program received signal SIGSEGV, Segmentation fault. </blockquote></p>     <p><blockquote>0x0804846f in sort (a=0x804a040, n=5) at debug3.c:23</blockquote></p>     <p><blockquote>23 /* 23 */ if(a[j].key &gt; a[j+1].key) {</blockquote></p>     <p><blockquote>(gdb)</blockquote></p>     <p>Программа, как и прежде, выполняется неверно. Когда программа дает сбой, gdb указывает причину и местонахождение. Теперь вы можете выяснять первопричину проблемы.</p>     <p>В зависимости от ядра вашей системы, версий библиотеки С и компилятора сбой программы может произойти в другом месте, например в строке 25, когда элементы массива меняются местами, а не в строке 23, когда сравниваются поля <blockquote>key</blockquote> элементов массива. Если это так, вы увидите следующее сообщение:</p>     <p><blockquote>Program received signal SIGSEGV, Segmentation fault.</blockquote></p>     <p><blockquote>0x8000613 in sort (a=0x8001764, n=5) at debug3.c:25</blockquote></p>     <p><blockquote>25 /* 25 */ a[j] = a[j+1];</blockquote></p>     <p>Вы все равно можете продолжать следить за примером сеанса работы gdb, который описывается далее.</p>             <a name="metkadoc11"><h1>Трассировка стека</h1></a>     <p>Программа была остановлена при выполнении функции <blockquote>sort</blockquote> в строке 23 исходного файла debug3.c. Если при компиляции вы не включили в программу дополнительную отладочную информацию (<blockquote>cc -g</blockquote>), то не сможете увидеть, где программа дала сбой, и использовать имена переменных для просмотра данных.</p>     <p>Увидеть, как вы добрались до этого места, можно с помощью команды <blockquote>backtrace</blockquote>:</p>     <p><blockquote>(gdb)<b> backtrace</b></blockquote></p>     <p><blockquote>#0 0x0804846f in sort (a=0x804a040, n=5) at debug3.c:23</blockquote></p>     <p><blockquote>#1 0x08048583 in main() at debug3.c:37</blockquote></p>     <p><blockquote>(gdb)</blockquote></p>     <p>Это очень простая программа и трассировка у нее короткая, т.к. вы не вызывали много функций из других функций. Вы только видите, что <blockquote>sort</blockquote> была вызвана из <blockquote>main</blockquote> в строке 37 того же файла debug3.c. Обычно проблема гораздо сложнее, и команда <blockquote>backtrace</blockquote> применяется для определения маршрута, который привел к месту ошибки. Эта информация очень полезна при отладке функций, вызываемых из множества разных мест.</p>     <p>У команды <blockquote>backtrace</blockquote> есть сокращенная форма <blockquote>bt</blockquote> и для совместимости с другими отладчиками есть команда <blockquote>where</blockquote>, выполняющая ту же функцию.</p>             <a name="metkadoc12"><h1>Просмотр переменных</h1></a>     <p>Отладчик вывел данные в момент остановки программы, и в трассировке стека показаны значения аргументов функции.</p>     <p>Функция <blockquote>sort</blockquote> была вызвана с параметром <blockquote>а</blockquote>, значение которого 0х804а040. Это адрес массива. Обычно он в различных системах разный и зависит от используемых компилятора и операционной системы.</p>     <p>Сбойная строка 23 — сравнение одного элемента массива с другим:</p>     <p><blockquote>/* 23 */ if (a[j].key &gt; a[j+1].key) {</blockquote></p>     <p>Отладчик можно применять для просмотра содержимого параметров функции, локальных переменных и глобальных данных. Команда <blockquote>print</blockquote> отображает содержимое переменных и других выражений:</p>     <p><blockquote>(gdb) <b>print j</b></blockquote></p>     <p><blockquote>$1 = 4</blockquote></p>     <p>Вы видите, что у локальной переменной <blockquote>j</blockquote> значение <blockquote>4</blockquote>. Любые значения, выводимые командами gdb, подобными данной, сохраняются для будущего использования в псевдопеременных. В данном случае переменной <blockquote>$1</blockquote> присвоено значение 4, на случай, если она вам позже понадобится. Последующие команды будут сохранять свои результаты в переменных <blockquote>$2</blockquote>, <blockquote>$3</blockquote> и т.д.</p>     <p>Значение переменной <blockquote>j</blockquote>, равное 4, означает, что программа попыталась выполнить оператор</p>     <p><blockquote>if (а[4].key &gt; а[4+1].key)</blockquote></p>     <p>У массива <blockquote>array</blockquote>, который вы передали функции <blockquote>sort</blockquote>, только пять элементов, которые пронумерованы от 0 до 4. Поэтому данный оператор считывает несуществующий элемент массива <blockquote>array[5]</blockquote>. Переменная цикла <blockquote>j</blockquote> приняла некорректное значение.</p>     <p>Если ваша программа завершилась в строке 25, система обнаружила чтение за пределами массива, только когда взялась за перестановку элементов массива, выполнив оператор</p>     <p><blockquote>/* 25 */ а[j] = a[j+1];</blockquote></p>     <p>который при <blockquote>j</blockquote>, равной 4, дает в результате</p>     <p><blockquote>а[4] = а[4+1];</blockquote></p>     <p>Просмотреть элементы передаваемого массива можно, применив выражение в команде <blockquote>print</blockquote>. В программе gdb вы можете использовать почти любое допустимое выражение языка С для вывода значения переменной, элемента массива или указателя.</p>     <p><blockquote>(gdb) <b>print а[3]</b></blockquote></p>     <p><blockquote>$2 = {data = "alex", '\0' &lt;repeats 4091 times&gt;, key = 1}</blockquote></p>     <p><blockquote>(gdb)</blockquote></p>     <p>Отладчик gdb сохраняет результаты выполнения команд в псевдопеременных вида <blockquote>$&lt;<i>номер</i>&gt;</blockquote>. Результат последней команды всегда хранится в псевдопеременной <blockquote>$</blockquote>, а предыдущей — в <blockquote>$$</blockquote>. Это позволяет результат одной команды использовать в другой. Например:</p>     <p><blockquote>(gdb) <b>print j</b></blockquote></p>     <p><blockquote>$3 = 4</blockquote></p>     <p><blockquote>(gdb) <b>print a[$-1].key</b></blockquote></p>     <p><blockquote>$4 = 1</blockquote></p>             <a name="metkadoc13"><h1>Вывод листинга программы</h1></a>     <p>Вы можете в программе gdb вывести на экран исходный текст программы с помощью команды <blockquote>list</blockquote>. Она выводит фрагмент кода, расположенного рядом с текущей позицией. Последующие вызовы <blockquote>list</blockquote> выведут остальной текст. Команде <blockquote>list</blockquote> можно задать в качестве аргумента имя функции, и команда отобразит фрагмент текста в этом месте программы, или можно указать пару номеров строк, и на экране появится текст программы, находящийся между этими строками.</p>     <p><blockquote>(gdb) <b>list</b></blockquote></p>     <p><blockquote>18 /* 18 */  int s = 1;</blockquote></p>     <p><blockquote>19 /* 19 */</blockquote></p>     <p><blockquote>20 /* 20 */  for(; i &lt; n &amp;&amp; s != 0; i++) {</blockquote></p>     <p><blockquote>21 /* 21 */   s = 0;</blockquote></p>     <p><blockquote>22 /* 22 */   for(j = 0; j &lt; n; j++) {</blockquote></p>     <p><blockquote>23 /* 23 */    if(a[j].key &gt; a[j+1].key) {</blockquote></p>     <p><blockquote>24 /* 24 */    item t = a[j];</blockquote></p>     <p><blockquote>25 /* 25 */    a[j] = a[j+1];</blockquote></p>     <p><blockquote>26 /* 26 */    a[j+1] = t;</blockquote></p>     <p><blockquote>27 /* 27 */    s++;</blockquote></p>     <p><blockquote>(gdb)</blockquote></p>     <p>В строке 22 задано выполнение цикла до тех пор, пока переменная <blockquote>j</blockquote> меньше <blockquote>n</blockquote>. В данном случае <blockquote>n</blockquote> равна 5, поэтому у <blockquote>j</blockquote> будет последнее значение 4, слишком большое. Значение 4 приводит к сравнению <blockquote>а[4]</blockquote> с <blockquote>а[5]</blockquote> и возможной их перестановке. Единственное решение этой конкретной проблемы — исправить условие завершения цикла на следующее: <blockquote>j &lt; n-1</blockquote>.</p>     <p>Давайте внесем это изменение, назовем новую программу debug4.c, откомпилируем ее и попробуем снова выполнить.</p>     <p><blockquote>/* 22 */   for(j = 0; j &lt; n-1; j++) {</blockquote></p>     <p><blockquote>$ <b>cc -g -o debug4 debug4.с</b></blockquote></p>     <p><blockquote>$ <b>./debug4</b></blockquote></p>     <p><blockquote>array[0] = {john, 2}</blockquote></p>     <p><blockquote>array[1] = {alex, 1}</blockquote></p>     <p><blockquote>array[2] = {bill, 3}</blockquote></p>     <p><blockquote>array[3] = {neil, 4}</blockquote></p>     <p><blockquote>array[4] = {rick, 5}</blockquote></p>     <p>Программа все еще не работает, поскольку она вывела неверно отсортированный список. Попробуем применить gdb для пошагового выполнения программы.</p>             <a name="metkadoc14"><h1>Установка точек останова</h1></a>     <p>Для обнаружения места сбоя в программе необходимо иметь возможность проследить за тем, что делает программа во время выполнения. Остановить ее в любой момент можно с помощью<i> точек останова.</i> Они останавливают программу и передают управление отладчику. Вы сможете проверить переменные и затем разрешить программе продолжить выполнение.</p>     <p>В функции <blockquote>sort</blockquote> есть два цикла. Внешний цикл с переменной цикла <blockquote>i</blockquote> выполняется для каждого элемента массива один раз. Внутренний или вложенный цикл меняет местами элемент с последующим, расположенным ниже в списке. Это создает эффект всплытия пузырьков, поднимая вверх меньшие элементы. После каждого выполнения внешнего цикла самый большой элемент опускается на дно. Вы можете убедиться в этом, остановив программу на внешнем цикле и просмотрев состояние массива.</p>     <p>Для установки точек останова применяется ряд команд. Их перечень получен отладчиком gdb с помощью команды <blockquote>help breakpoint</blockquote>:</p>     <p><blockquote>(gdb)<b> help breakpoint</b></blockquote></p>     <p><blockquote>Making program stop at certain points.</blockquote></p>     <br>     <p><blockquote>List of commands:</blockquote></p>     <p><blockquote>awatch -- Set a watchpoint for an expression</blockquote></p>     <p><blockquote>break -- Set breakpoint at specified line or function</blockquote></p>     <p><blockquote>catch -- Set catchpoints to catch events</blockquote></p>     <p><blockquote>clear -- Clear breakpoint at specified line or function</blockquote></p>     <p><blockquote>commands -- Set commands to be executed when a breakpoint is hit</blockquote></p>     <p><blockquote>condition -- Specify breakpoint number N to break only if COND is true</blockquote></p>     <p><blockquote>delete -- Delete some breakpoints or auto-display expressions</blockquote></p>     <p><blockquote>delete breakpoints -- Delete some breakpoints or auto-display expressions</blockquote></p>     <p><blockquote>delete checkpoint -- Delete a fork/checkpoint (experimental)</blockquote></p>     <p><blockquote>delete mem -- Delete memory region</blockquote></p>     <p><blockquote>delete tracepoints -- Delete specified tracepoints</blockquote></p>     <p><blockquote>disable -- Disable some breakpoints</blockquote></p>     <p><blockquote>disable breakpoints -- Disable some breakpoints</blockquote></p>     <p><blockquote>disable display -- Disable some expressions to be displayed when program stops</blockquote></p>     <p><blockquote>disable mem -- Disable memory region</blockquote></p>     <p><blockquote>disable tracepoints -- Disable specified tracepoints</blockquote></p>     <p><blockquote>enable -- Enable some breakpoints</blockquote></p>     <p><blockquote>enable delete -- Enable breakpoints and delete when hit</blockquote></p>     <p><blockquote>enable display -- Enable some expressions to be displayed when program stops</blockquote></p>     <p><blockquote>enable mem -- Enable memory region</blockquote></p>     <p><blockquote>enable once -- Enable breakpoints for one hit</blockquote></p>     <p><blockquote>enable tracepoints -- Enable specified tracepoints</blockquote></p>     <p><blockquote>hbreak -- Set a hardware assisted breakpoint</blockquote></p>     <p><blockquote>ignore -- Set ignore-count of breakpoint number N to COUNT</blockquote></p>     <p><blockquote>rbreak -- Set a breakpoint for all functions matching REGEXP</blockquote></p>     <p><blockquote>rwatch -- Set a read watchpoint for an expression</blockquote></p>     <p><blockquote>tbreak -- Set a temporary breakpoint</blockquote></p>     <p><blockquote>tcatch -- Set temporary catchpoints to catch events</blockquote></p>     <p><blockquote>thbreak -- Set a temporary hardware assisted breakpoint</blockquote></p>     <p><blockquote>watch -- Set a watchpoint for an expression</blockquote></p>     <br>     <p><blockquote>Type "help" followed by command name for full documentation.</blockquote></p>     <p><blockquote>Type "apropos word" to search for commands related to "word".</blockquote></p>     <p><blockquote>Command name abbreviations are allowed if unambiguous.</blockquote></p>     <p>Установите точку останова в строке 21 и выполните программу:</p>     <p><blockquote>$ <b>gdb debug4</b></blockquote></p>     <p><blockquote>(gdb) <b>break 21</b></blockquote></p>     <p><blockquote>Breakpoint 1 at 0x8048427: file debug4.c, line 21.</blockquote></p>     <p><blockquote>(gdb) <b>run</b></blockquote></p>     <p><blockquote>Starting program: /home/neil/BLP4e/chapter10/debug4</blockquote></p>     <br>     <p><blockquote>Breakpoint 1, sort (a=0x804a040, n=5) at debug4.c:21</blockquote></p>     <p><blockquote>21 /* 21 */    s = 0;</blockquote></p>     <p>Вы можете вывести значение массива и затем с помощью команды <blockquote>cont</blockquote> разрешить программе продолжить выполнение. Это позволит программе выполняться до тех пор, пока она не натолкнется на следующую точку останова, в нашем случае это снова строка 21. В любой момент времени может быть активно несколько точек останова:</p>     <p><blockquote>(gdb)<b> print array[0]</b></blockquote></p>     <p><blockquote>$1 = (data = "bill", '\0' &lt;repeats 4091 times&gt;, key = 3)</blockquote></p>     <p>Для вывода нескольких последовательных элементов массива можно применить конструкцию <blockquote>@&lt;<i>число</i>&gt;</blockquote>, чтобы заставить gdb вывести указанное количество элементов массива. Для того чтобы вывести все пять элементов, можно использовать следующую команду:</p>     <p><blockquote>(gdb) <b>print array[0]@5</b></blockquote></p>     <p><blockquote>$2 = {{data = "bill", '\0' &lt;repeats 4091 times&gt;, key = 3}, {</blockquote></p>     <p><blockquote>    data = "neil", '\0' &lt;repeats 4091 times&gt;, key =4}, {</blockquote></p>     <p><blockquote>    data = "john", '\0' &lt;repeats 4091 times&gt;, key =2}, {</blockquote></p>     <p><blockquote>    data = "rick", '\0' &lt;repeats 4091 times&gt;, key =5}, {</blockquote></p>     <p><blockquote>    data = "alex", '\0' &lt;repeats 4091 times&gt;, key = 1}}</blockquote></p>     <p>Учтите, что вывод немного подчищен, чтобы его легче было читать. Поскольку это первый проход цикла, массив еще не изменен. Когда вы разрешите программе продолжить выполнение, то увидите последовательные перестройки массива array, происходящие по мере выполнения программы:</p>     <p><blockquote>(gdb) <b>cont</b></blockquote></p>     <p><blockquote>Continuing.</blockquote></p>     <br>     <p><blockquote>Breakpoint 1, sort (a=0x8049580, n=4) at debug4.c:21</blockquote></p>     <p><blockquote>21 /* 21 */   s = 0;</blockquote></p>     <p><blockquote>(gdb) <b>print array[0]@5</b></blockquote></p>     <p><blockquote>$3 = {{data = "bill", '\0' &lt;repeats 4091 times&gt;, key = 3}, {</blockquote></p>     <p><blockquote>    data = "john", '\0' &lt;repeats 4091 times&gt;, key =2}, {</blockquote></p>     <p><blockquote>    data = "neil", '\0' &lt;repeats 4091 times&gt;, key = 4}, {</blockquote></p>     <p><blockquote>    data = "alex", '\0' &lt;repeats 4091 times&gt;, key =1}, {</blockquote></p>     <p><blockquote>    data = "rick", '\0' &lt;repeats 4091 times&gt;, key =5}}</blockquote></p>     <p><blockquote>(gdb)</blockquote></p>     <p>Можно воспользоваться командой <blockquote>display</blockquote>, чтобы задать в gdb автоматическое отображение массива при каждой остановке программы в точке останова:</p>     <p><blockquote>(gdb) <b>display array[0]@5</b></blockquote></p>     <p><blockquote>1: array[0]@5 = {{data = "bill", '\0' &lt;repeats 4091 times&gt;, key = 3}, {</blockquote></p>     <p><blockquote>    data = "john", '\0' &lt;repeats 4091 times&gt;, key = 2}, {</blockquote></p>     <p><blockquote>    data = "neil", '\0' &lt;repeats 4091 times&gt;, key = 4}, {</blockquote></p>     <p><blockquote>    data = "alex", '\0' &lt;repeats 4091 times&gt;, key = 1}, {</blockquote></p>     <p><blockquote>    data = "rick", '\0' &lt;repeats 4091 times&gt;, key, = 5}}</blockquote></p>     <p>Более того, вы можете изменить точку останова таким образом, что вместо остановки программы она просто отобразит данные, которые вы запросили, и продолжит выполнение. Для этого примените команду <blockquote>commands</blockquote>. Она позволит указать, какие команды отладчика выполнять при попадании в точку останова. Поскольку вы уже указали отображение, вам нужно лишь задать команду в точке останова для продолжения выполнения:</p>     <p><blockquote>(gdb)<b> commands</b></blockquote></p>     <p><blockquote>Type commands for when breakpoint 1 is hit, one per line.</blockquote></p>     <p><blockquote>End with a line saying just "end".</blockquote></p>     <p><blockquote>&gt; <b>cont</b></blockquote></p>     <p><blockquote>&gt; <b>end</b></blockquote></p>     <p>Теперь, когда вы разрешите программе продолжить выполнение, она продолжается до завершения, выводя значение массива каждый раз, когда оказывается вблизи внешнего цикла.</p>     <p><blockquote>(gdb) <b>cont</b></blockquote></p>     <p><blockquote>Continuing.</blockquote></p>     <br>     <p><blockquote>Breakpoint 1, sort (a=0x8049684, n=3) at debug4.c:21</blockquote></p>     <p><blockquote>21 /* 21 */    s = 0;</blockquote></p>     <p><blockquote>1: array[0]@5 = {{data = "john", '\000' &lt;repeats 4091 times&gt;, key = 2}, {</blockquote></p>     <p><blockquote>    data = "bill", '\000' &lt;repeats 4091 times&gt;, key =3}, {</blockquote></p>     <p><blockquote>    data = "alex", '\000' &lt;repeats 4091 times&gt;, key =1}, {</blockquote></p>     <p><blockquote>    data = "neil", '\000' &lt;repeats 4091 times&gt;, key =4}, {</blockquote></p>     <p><blockquote>    data = "rick", '\000' &lt;repeats 4091 times&gt;, key = 5}}</blockquote></p>     <br>     <p><blockquote>array[0] = {john, 2}</blockquote></p>     <p><blockquote>array[1] = {alex, 1}</blockquote></p>     <p><blockquote>array[2] = {bill, 3}</blockquote></p>     <p><blockquote>array[3] = {neil, 4}</blockquote></p>     <p><blockquote>array[4] = {rick, 5}</blockquote></p>     <p><blockquote>Program exited with code 025.</blockquote></p>     <p><blockquote>(gdb)</blockquote></p>     <p>Отладчик gdb сообщает о том, что программа завершается с необычным кодом завершения. Это происходит потому, что программа сама не вызывает <blockquote>exit</blockquote> и не возвращает значение из функции <blockquote>main</blockquote>. Код завершения в данном случае не имеет смысла, значимый код должен предоставляться вызовом функции <blockquote>exit</blockquote>.</p>     <p>Кажется, что программа не выполняет внешний цикл столько раз, сколько ожидалось. Вы можете увидеть, что значение параметра <blockquote>n</blockquote>, используемого в условии завершения цикла, уменьшается при каждом достижении точки останова. Это значит, что цикл не будет выполняться нужное число раз. Дело в уменьшении <blockquote>n</blockquote> в строке 30.</p>     <p><blockquote>/* 30 */   n--;</blockquote></p>     <p>Это попытка оптимизировать программу за счет того, что в конце каждого прохода внешнего цикла наибольший, элемент <blockquote>array</blockquote> окажется внизу и поэтому остается меньше элементов для сортировки. Но как видно, это мешает внешнему циклу и создает проблемы. Простейший способ исправления (хотя есть и другие) — удалить ошибочную строку. Давайте проверим, применив отладчик для корректировки, устранило ли такое исправление проблему.</p>             <a name="metkadoc15"><h1>Вставка исправлений с помощью отладчика</h1></a>     <p>Вы уже видели, что можно применять отладчик для установки точек останова и просмотра значений переменных. Применив точки останова с заданными действиями, можно проверить исправление, называемое "заплатой", перед тем, как изменять текст программы и выполнять ее повторную компиляцию. В данном случае нужно остановить программу в строке 30 и увеличить переменную <blockquote>n</blockquote>. В дальнейшем, когда строка 30 выполнится, значение останется неизменным.</p>     <p>Давайте перезапустим программу с самого начала. Прежде всего вы должны удалить вашу точку останова и отладочный вывод. С помощью команды info можно увидеть, какие точки останова и какой вывод вы включили:</p>     <p><blockquote>(gdb)<b> info display</b></blockquote></p>     <p><blockquote>Auto-display expressions now in effect:</blockquote></p>     <p><blockquote>Num Enb Expression</blockquote></p>     <p><blockquote>1: y array[0]@5 (gdb)<b> info break</b></blockquote></p>     <p><blockquote>Num Type       Disp Enb Address    What</blockquote></p>     <p><blockquote>1   breakpoint keep y   0x08048427 in sort at debug4.c:21</blockquote></p>     <p><blockquote>    breakpoint already hit 3 times</blockquote></p>     <p><blockquote>    cont</blockquote></p>     <p>Вы можете либо отключить эти точки останова, либо удалить их совсем. Если их отключить, у вас останется возможность включить их позже, когда понадобится.</p>     <p><blockquote>(gdb) <b>disable break 1</b></blockquote></p>     <p><blockquote>(gdb) <b>disable display 1</b></blockquote></p>     <p><blockquote>(gdb) <b>break 30</b></blockquote></p>     <p><blockquote>Breakpoint 2 at 0x8048545: file debug4.c, line 30.</blockquote></p>     <p><blockquote>(gdb) <b>commands 2</b></blockquote></p>     <p><blockquote>Type commands for when breakpoint 2 is hit, one per line.</blockquote></p>     <p><blockquote>End with a line saying just "end".</blockquote></p>     <p><blockquote>&gt;<b>set variable n = n+1</b></blockquote></p>     <p><blockquote>&gt;<b>cont</b></blockquote></p>     <p><blockquote>&gt;<b>end</b></blockquote></p>     <p><blockquote>(gdb) <b>run</b></blockquote></p>     <p><blockquote>Starting program: /home/neil/BLP4e/chapter10/debug4</blockquote></p>     <br>     <p><blockquote>Breakpoint 2, sort (a=0x804a040, n=5) at debug4.c:30</blockquote></p>     <p><blockquote>30 /* 30 */   n--;</blockquote></p>     <br>     <p><blockquote>Breakpoint 2, sort (a=0x804a040, n=5) at debug4.c:30</blockquote></p>     <p><blockquote>30 /* 30 */   n--;</blockquote></p>     <br>     <p><blockquote>Breakpoint 2, sort (a=0x804a040, n=5) at debug4.c:30</blockquote></p>     <p><blockquote>30 /* 30 */   n--;</blockquote></p>     <br>     <p><blockquote>Breakpoint 2, sort (a=0x804a040, n=5) at debug4.c:30</blockquote></p>     <p><blockquote>30 /* 30 */   n--;</blockquote></p>     <br>     <p><blockquote>Breakpoint 2, sort (a=0x804a040, n=5) at debug4.c:30</blockquote></p>     <p><blockquote>30 /* 30 */   n--;</blockquote></p>     <p><blockquote>array[0] = {alex, 1}</blockquote></p>     <p><blockquote>array[1] = {john, 2}</blockquote></p>     <p><blockquote>array[2] = {bill, 3}</blockquote></p>     <p><blockquote>array[3] = {neil, 4}</blockquote></p>     <p><blockquote>array[4] = {rick, 5}</blockquote></p>     <br>     <p><blockquote>Program exited with code 025.</blockquote></p>     <p><blockquote>(gdb)</blockquote></p>     <p>Программа выполняется полностью и выводит корректный результат. Теперь можно внести изменения и переходить к тестированию ее с большим объемом данных.</p>             <a name="metkadoc16"><h1>Дополнительные сведения о gdb</h1></a>     <p>Отладчик проекта GNU — исключительно мощный инструмент, способный снабжать множеством сведений о внутреннем состоянии выполняющихся программ. В системах, поддерживающих средство аппаратно устанавливаемых контрольных точек, можно применять gdb для наблюдения за изменениями переменных в режиме реального времени. Аппаратно устанавливаемые контрольные точки — это функция некоторых ЦПУ; такие процессоры способны автоматически останавливаться при возникновении определенных условий, обычно доступе к памяти в заданной области. Кроме того, gdb может следить (watch) за выражениями. Это означает, что с потерей производительности gdb может остановить программу, когда выражение принимает конкретное значение, независимо от того, в каком месте программы выполнялось вычисление.</p>     <p>Точки останова можно устанавливать со счетчиками и условиями, так что они включаются только после фиксированного числа проходов или при выполнении условия.</p>     <p>Отладчик gdb также способен подключаться к уже выполняющимся программам. Это очень полезно при отладке клиент-серверных систем, поскольку вы сможете отлаживать некорректно ведущий себя серверный процесс во время выполнения без необходимости останавливать и перезапускать его. Можно компилировать программы, например, с помощью строки <blockquote>gcc -O -g</blockquote>, чтобы получить преимущества от применения оптимизации и отладочной информации. Недостаток заключается в том, что оптимизация может слегка переупорядочить текст программы, поэтому, когда вы будете выполнять программу в пошаговом режиме, может оказаться, что вы "скачете вперед и назад" по строкам, чтобы добиться того эффекта, что и в первоначальном тексте программы.</p>     <p>Отладчик gdb можно также применять для отладки аварийно завершившихся программ. Системы Linux и UNIX при аварийном завершении программы часто создают дамп ядра в файле с именем core. Это отображение карты памяти программы, которое содержит значения глобальных переменных в момент возникновения сбоя. Вы сможете использовать gdb для того, чтобы определить место в программе, вызвавшее аварийное завершение. Дополнительную информацию см. в интерактивном справочном руководстве к gdb.</p>     <p>Отладчик gdb доступен в соответствии с требованиями Общедоступной лицензии проекта GNU и его поддерживает большинство систем UNIX. Мы настоятельно рекомендуем вам, как следует изучить его.</p>              <a name="metkadoc17"><h1>Дополнительные средства отладки</h1></a>         <p>Помимо полнофункциональных отладчиков, таких как gdb, Linux-системы обычно предоставляют и другие средства, которые можно применять для поддержки процесса отладки. Некоторые из них снабжают статической информацией о программе, другие обеспечивают динамический анализ.</p>     <p>Статический анализ предоставляет сведения только об исходном тексте программы. Программы ctags, cxref и cflow работают с исходными файлами и предлагают полезные данные о вызовах функций и их месте в программе.</p>     <p>Динамический анализ предоставляет информацию о том, как программа ведёт себя во время выполнения. Программы prof и gprof предлагают сведения о том, какие функции были выполнены, и сколько времени заняло их выполнение,</p>     <p>Давайте рассмотрим некоторые из этих средств и их вывод. Не все они будут доступны во всех системах, хотя у многих из этих средств есть свободно распространяемые версии.</p>             <a name="metkadoc18"><h1><i>Lint</i> удаление ошибок из ваших программ</h1></a>     <p>Первые системы UNIX предоставляли утилиту <blockquote>lint</blockquote>. Эта программа по существу — препроцессор компилятора С со вставленными тестами, обеспечивающими некоторые проверки с точки зрения здравого смысла и вывод предупреждений. Среди прочего она обнаруживает случаи применения переменных до того, как им было присвоено значение, или случаи неиспользования аргументов функций.</p>     <p>Более современные компиляторы C могут ценой производительности времени компиляции формировать аналогичные предупреждения. Утилиту <blockquote>lint</blockquote>, как таковую, обогнала стандартизация языка С. Поскольку средство основывалось на раннем компиляторе С, оно совсем не справляется с синтаксисом ANSI. Есть несколько коммерческих версий <blockquote>lint</blockquote> для UNIX и одна версия в Интернете для Linux, названная <blockquote>splint</blockquote>. Она известна под именем LClint, как часть проекта MIT (Massachusetts Institute of Technology, Массачусетский технологический институт), занимающегося разработкой средств формального описания. <blockquote>splint</blockquote>, средство подобное <blockquote>lint</blockquote>, может предоставлять полезные обзорные комментарии к программному коду. Найти <blockquote>splint</blockquote> можно по адресу <b>http://www.splint.org.</b></p>     <p>Далее приведена первоначальная версия (debug0.c) программы-примера, которую вы уже отладили.</p>     <p><blockquote>/*  1 */ typedef struct {</blockquote></p>     <p><blockquote>/*  2 */  char *data;</blockquote></p>     <p><blockquote>/*  3 */  int key;</blockquote></p>     <p><blockquote>/*  4 */ } item;</blockquote></p>     <p><blockquote>/*  5 */</blockquote></p>     <p><blockquote>/*  6 */ item array[j] = {</blockquote></p>     <p><blockquote>/*  7 */  {"bill", 3},</blockquote></p>     <p><blockquote>/*  8 */  {"neil", 4},</blockquote></p>     <p><blockquote>/*  9 */  {"john", 2},</blockquote></p>     <p><blockquote>/* 10 */  {"rick", 5},</blockquote></p>     <p><blockquote>/* 11 */  {"alex", 1},</blockquote></p>     <p><blockquote>/* 12 */ };</blockquote></p>     <p><blockquote>/* 13 */</blockquote></p>     <p><blockquote>/* 14 */ sort(a, n)</blockquote></p>     <p><blockquote>/* 15 */ item *a;</blockquote></p>     <p><blockquote>/* 16 */ {</blockquote></p>     <p><blockquote>/* 17 */  int i = 0, j = 0;</blockquote></p>     <p><blockquote>/* 18 */  int s;</blockquote></p>     <p><blockquote>/* 19 */</blockquote></p>     <p><blockquote>/* 20 */  for(; i &lt; n &amp; s != 0; i++) {</blockquote></p>     <p><blockquote>/* 21 */   s = 0;</blockquote></p>     <p><blockquote>/* 22 */   for(j = 0; j &lt; n; j++) {</blockquote></p>     <p><blockquote>/* 23 */    if(a[j].key &gt; a[j+1].key) {</blockquote></p>     <p><blockquote>/* 24 */     item t = a[j];</blockquote></p>     <p><blockquote>/* 25 */     a[j] = a[j+1];</blockquote></p>     <p><blockquote>/* 26 */     a[j+1] = t;</blockquote></p>     <p><blockquote>/* 27 */     s++;</blockquote></p>     <p><blockquote>/* 28 */    }</blockquote></p>     <p><blockquote>/* 29 */   }</blockquote></p>     <p><blockquote>/* 30 */   n--;</blockquote></p>     <p><blockquote>/* 31 */  }</blockquote></p>     <p><blockquote>/* 32 */ }</blockquote></p>     <p><blockquote>/* 33 */</blockquote></p>     <p><blockquote>/* 34 */ main()</blockquote></p>     <p><blockquote>/* 35 */ {</blockquote></p>     <p><blockquote>/* 36 */  sort(array,5);</blockquote></p>     <p><blockquote>/* 37 */ }</blockquote></p>     <p>В этой версии есть проблема в строке 20, где вместо предполагаемого оператора <blockquote>&amp;&amp;</blockquote> применяется оператор <blockquote>&amp;</blockquote>. Далее приведен отредактированный пример вывода <blockquote>splint</blockquote>, выполненной с этой версией программы. Обратите внимание на то, как она обнаруживает проблемы в строке 20 — тот факт, что вы не инициализировали переменную <blockquote>s</blockquote> и что возможны проблемы с условием из-за некорректного оператора.</p>     <p><blockquote>neil@susel03:~/BLP4e/chapter10&gt; <b>splint -strict debug0.c</b></blockquote></p>     <p><blockquote>Splint 3.1.1 --- 19 Mar 2005</blockquote></p>     <br>     <p><blockquote>debug0.c:7:18: Read-only string literal storage used as initial value for</blockquote></p>     <p><blockquote>               unqualified storage: array[0].data = "bill"</blockquote></p>     <p><blockquote>A read-only string literal is assigned to a non-observer reference. (Use -readonlytrans to inhibit warning)</blockquote></p>     <p><blockquote>debug0.c:8:18: Read-only string literal storage used as initial value for</blockquote></p>     <p><blockquote>               unqualified storage: array[1].data = "neil"</blockquote></p>     <p><blockquote>debug0.c:9:18: Read-only string literal storage used as initial value for</blockquote></p>     <p><blockquote>               unqualified storage: array[2].data = "john"</blockquote></p>     <p><blockquote>debug0.с:10:18: Read-only string literal storage used as initial value for</blockquote></p>     <p><blockquote>               unqualified storage: array[3].data = "rick"</blockquote></p>     <p><blockquote>debug0.c:11:18: Read-only string literal storage used as initial value for</blockquote></p>     <p><blockquote>               unqualified storage: array[4].data = "alex"</blockquote></p>     <p><blockquote>debug0.с:14:22: Old style function declaration</blockquote></p>     <p><blockquote> Function definition is in old style syntax. Standard prototype syntax is</blockquote></p>     <p><blockquote> preferred. (Use -oldstyle to inhibit warning)</blockquote></p>     <p><blockquote>debug0.с: (in function sort)</blockquote></p>     <p><blockquote><i>debug0.c:20:31: Variable s used before definition</i></blockquote></p>     <p><blockquote><i> An rvalue is used that may not be initialized to a value on some execution</i></blockquote></p>     <p><blockquote><i> path. (Use -usedef to inhibit warning)</i></blockquote></p>     <p><blockquote>debug0.с:20:23: Left operand of &amp; is not unsigned value (boolean):</blockquote></p>     <p><blockquote>               i &lt; n &amp; s != 0</blockquote></p>     <p><blockquote> An operand to a bitwise operator is not an unsigned values. This may have</blockquote></p>     <p><blockquote> unexpected results depending on the signed representations. (Use</blockquote></p>     <p><blockquote> -bitwisesigned to inhibit warning).</blockquote></p>     <p><blockquote><i>debug0.c:20:23: Test expression for for not boolean, type unsigned int:</i></blockquote></p>     <p><blockquote><i>               i &lt; n &amp; s != 0</i></blockquote></p>     <p><blockquote><i> Test expression type is not boolean or int. (Use -predboolint to inhibit </i></blockquote></p>     <p><blockquote><i> warning);</i></blockquote></p>     <p><blockquote>debug0.с:25:41: Undocumented modification of a[]: a[j] = a[j + 1]</blockquote></p>     <p><blockquote> An externally-visible object is modified by a function with no /*@modifies@*/</blockquote></p>     <p><blockquote> comment. The /*@modifies ... @*/ control comment can be used to give a</blockquote></p>     <p><blockquote> modifies list for an unspecified function. (Use -modnomods to inhibit</blockquote></p>     <p><blockquote> warning)</blockquote></p>     <p><blockquote>debug0.c:26:41: Undocumented modification of a[]: a[j + 1] = t</blockquote></p>     <p><blockquote>debug0.c:20:23: Operands of &amp; are non-integer (boolean) (in post loop test):</blockquote></p>     <p><blockquote>               i &lt; n &amp; s != 0</blockquote></p>     <p><blockquote> A primitive operation does not type check strictly. (Use -strictops to</blockquote></p>     <p><blockquote> inhibit warning)</blockquote></p>     <p><blockquote>debug0.с:32:14: Path with no return in function declared to return int</blockquote></p>     <p><blockquote> There is a path through a function declared to return a value on which there</blockquote></p>     <p><blockquote> is no return statement. This means the execution may fall through without</blockquote></p>     <p><blockquote> returning a meaningful result to the caller. (Use -noret to inhibit</blockquote></p>     <p><blockquote> warning)</blockquote></p>     <p><blockquote>debug0.с:34:13: Function main declared without parameter list</blockquote></p>     <p><blockquote> A function declaration does not have a parameter list. (Use -noparams</blockquote></p>     <p><blockquote> to inhibit warning)</blockquote></p>     <p><blockquote>debug0.с: (in function main)</blockquote></p>     <p><blockquote>debug0.с:36:22: Undocumented use of global array</blockquote></p>     <p><blockquote> A checked global variable is used in the function, but not listed in its</blockquote></p>     <p><blockquote> globals clause. By default, only globals specified in .lcl files are</blockquote></p>     <p><blockquote> checked.</blockquote></p>     <p><blockquote> To check all globals, use +allglobals. To check globals selectively use</blockquote></p>     <p><blockquote> /*@checked@*/ in the global declaration. (Use -globs to inhibit warning)</blockquote></p>     <p><blockquote>debug0.с:36:17: Undetected modification possible from call to unconstrained</blockquote></p>     <p><blockquote>               function sort: sort</blockquote></p>     <p><blockquote> An unconstrained function is called in a function body where</blockquote></p>     <p><blockquote> modifications are checked. Since the unconstrained function may modify</blockquote></p>     <p><blockquote> anything, there may be undetected modifications in the checked function.</blockquote></p>     <p><blockquote> (Use -modunconnomods to inhibit warning)</blockquote></p>     <p><blockquote>debug0.c:36:17: Return value (type int) ignored: sort(array, 5)</blockquote></p>     <p><blockquote> Result returned by function call is not used. If this is intended, can</blockquote></p>     <p><blockquote> cast result to (void) to eliminate message. (Use -retvalint to inhibit</blockquote></p>     <p><blockquote> warning)</blockquote></p>     <p><blockquote>debug0.c:37:14: Path with no return in function declared to return int</blockquote></p>     <p><blockquote>debug0.c:6:18: Variable exported but not used outside debug0: array</blockquote></p>     <p><blockquote> A declaration is exported, but not used outside this module. Declaration</blockquote></p>     <p><blockquote> can use static qualifier. (Use -exportlocal to inhibit warning)</blockquote></p>     <p><blockquote>debug0.c:14:13: Function exported but not used outside debug0: sort</blockquote></p>     <p><blockquote> debug0.c:15:17: Definition of sort</blockquote></p>     <p><blockquote>debug0.c:6:18: Variable array exported but not declared in header file</blockquote></p>     <p><blockquote> A variable declaration is exported, but does not appear in a header</blockquote></p>     <p><blockquote> file. (Used with exportheader.) (Use -exportheadervar to inhibit warning)</blockquote></p>     <p><blockquote>debug0.c:14:13: Function sort exported but not declared in header file</blockquote></p>     <p><blockquote> A declaration is exported, but does not appear in a header file. (Use</blockquote></p>     <p><blockquote> -exportheader to inhibit warning)</blockquote></p>     <p><blockquote>debug0.c:15:17: Definition of sort</blockquote></p>     <br>     <p><blockquote>Finished checking - 22 code warnings</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Утилита выражает неудовольствие по поводу объявления функций в старом стиле (не ANSI) и несоответствия типов значений, возвращаемых функциями, и самими величинами, которые они возвращают (или нет) в действительности. Эти предупреждения не влияют на работу программы, но должны быть выведены.</p>     <p>Она также обнаружила две реальные ошибки в следующем фрагменте кода:</p>     <p><blockquote>/* 18 */  int s;</blockquote></p>     <p><blockquote>/* 19 */</blockquote></p>     <p><blockquote>/* 20 */  for(; i &lt; n &amp; s != 0; i++) {</blockquote></p>     <p><blockquote>/* 21 */   s = 0;</blockquote></p>     <p>Средство splint определило (выделенные цветом строки предыдущего вывода), что переменная <blockquote>s</blockquote> используется в строке 20, но не была при этом инициализирована, и что оператор <blockquote>&amp;</blockquote> стоит на месте более обычного оператора <blockquote>&amp;&amp;.</blockquote> В данном случае старшинство оператора изменяет значение условия и создает проблему в программе.</p>     <p>Обе эти ошибки были исправлены при чтении исходного текста программы до запуска процесса отладки. Несмотря на то, что пример мало изобретателен и служит только для демонстрации, подобные ошибки регулярно возникают в реальных программах."</p>             <a name="metkadoc19"><h1>Средства, отслеживающие вызовы функций</h1></a>     <p>Три утилиты — <blockquote>ctags</blockquote>, <blockquote>cxref</blockquote> и <blockquote>cflow</blockquote> — формируют часть стандарта X/Open и, следовательно, должны включаться в системы, представляемые как системы UNIX с программными средствами разработки.</p>     <blockquote>      <b>Примечание</b>      <p>Эти утилиты и другие, упоминаемые в этой главе, могут не входить в состав вашего дистрибутива Linux. Если они пропущены, можно поискать их реализации в Интернете. Хорошая отправная точка (для дистрибутивов Linux, поддерживающих формат RPM-пакетов) — Web-сайты <b>http://rpmfind.net</b> и <b>http://rpm.pbone.net.</b> Можно попытаться поискать в нескольких репозитариях для конкретных дистрибутивов, включая <b>http://ftp.gwdg.de/pub/opensuse/</b> для openSUSE, <b>http://rpm.livna.org</b> для Fedora и <b>http://packages.slackware.it/</b> для Slackware.</p>     </blockquote>     <b><i>ctags</i></b>     <p>Программа <blockquote>ctags</blockquote> создает алфавитный указатель функций. Для каждой функции вы получаете перечень мест в программе, где она применяется, как алфавитный указатель к книге.</p>     <p><blockquote><b>ctags [-a] [-f <i>filename</i>] <i>sourcefile sourcefile ...</i></b></blockquote></p>     <p><blockquote><b>ctags -x <i>sourcefile sourcefile ...</i></b></blockquote></p>     <p>По умолчанию <blockquote>ctags</blockquote> создает в текущем каталоге файл с именем tags, содержащий для каждой функции, объявленной в любом из входных файлов исходного кода, строки следующего вида:</p>     <p><blockquote>announce app_ui.c /^static void announce(void) /</blockquote></p>     <p>Каждая строка файла содержит имя функции, файл, в котором она объявлена, и регулярное выражение, которое можно использовать для поиска описания функции в файле. Некоторые редакторы, например Emacs, могут применять файлы этого вида для навигации в исходном тексте программы.</p>     <p>Кроме того, с помощью опции <blockquote>-х</blockquote> в программе <blockquote>ctags</blockquote> (если она доступна в вашей версии программы) вы можете формировать строки аналогичного вида в стандартном файле вывода.</p>     <p><blockquote>find_cat 403 appui.с static cdc_entry find_cat(</blockquote></p>     <p>Можно перенаправить вывод в другой файл с помощью опции <blockquote>-f filename</blockquote> и добавить его в конец существующего файла, указав опцию <blockquote>-а</blockquote>.</p>     <b><i>cxref</i></b>     <p>Программа <blockquote>cxref</blockquote> анализирует исходный текст на языке С и формирует перекрестные ссылки. Она показывает, где в программе упоминается каждое символическое имя (переменная, директива <blockquote>#define</blockquote> и функция). Программа создает отсортированный список с указанием места определения каждого идентификатора, которое помечается звездочкой, как показано далее:</p>     <p><blockquote> SYMBOL                FILE  FUNCTION LINE</blockquote></p>     <p><blockquote> BASENID               prog.с      --  *12 *96 124 126 146 156 166</blockquote></p>     <p><blockquote> BINSIZE               prog.с      --  *30 197 198 199. 206</blockquote></p>     <p><blockquote>  BUFMAX               prog.с      --  *44 45 90</blockquote></p>     <p><blockquote>  BUFSIZ /usr/include/stdio.h      --  *4</blockquote></p>     <p><blockquote>     EOF /usr/include/stdio.h      --  *27</blockquote></p>     <p><blockquote>    argc               prog.с      --  36</blockquote></p>     <p><blockquote>                       prog.с    main  *37 61 81</blockquote></p>     <p><blockquote>    argv               prog.с      --  36</blockquote></p>     <p><blockquote>                       prog.с    main  *38 61</blockquote></p>     <p><blockquote>calldata               prog.с      --  *5</blockquote></p>     <p><blockquote>                       prog.с    main  64 188</blockquote></p>     <p><blockquote>  calls                prog.с      --  *19</blockquote></p>     <p><blockquote>                       prog.с     main 54</blockquote></p>     <p>На машине одного из авторов этой книги предыдущий вывод был сгенерирован в каталоге с исходными файлами приложения с помощью команды</p>     <p><blockquote>$ <b>cxref *.с *.h</b></blockquote></p>     <p>но точный синтаксис зависит от версии. См. документацию к вашей системе и интерактивное справочное руководство для получения дополнительной информации о том, включена ли программа <blockquote>cxref</blockquote> и как ее применять.</p>     <b><i>cflow</i></b>     <p>Программа <blockquote>cflow</blockquote> выводит <i>дерево вызовов функций </i>— схему, показывающую, какие функции вызывают другие функции, какие функции вызываются этими другими и т.д. Эта схема полезна для выяснения структуры программы, понимания ее принципов действия и наблюдения за влиянием изменений, внесенных в функцию. Некоторые версии программы <blockquote>cflow</blockquote> могут работать с объектными файлами так же, как с исходными. Подробности см. в интерактивном справочном руководстве.</p>     <p>Далее приведен пример вывода, полученный версией <blockquote>cflow </blockquote>(cflow-2.0), которая есть в Интернете и поддерживается Марти Лейснером (Marty Leisner).</p>     <p><blockquote>0  file_ungetc {prcc.c 997}</blockquote></p>     <p><blockquote>1  main {prcc.c 70}</blockquote></p>     <p><blockquote>2      getopt {}</blockquote></p>     <p><blockquote>3      show_all_lists {prcc.c 1070}</blockquote></p>     <p><blockquote>4          display_list {prcc.c 1056}</blockquote></p>     <p><blockquote>5              printf {}</blockquote></p>     <p><blockquote>6          exit {}</blockquote></p>     <p><blockquote>7      exit {}</blockquote></p>     <p><blockquote>9      usage {prcc.c 59}</blockquote></p>     <p><blockquote>10         fprintf {}</blockquote></p>     <p><blockquote>11         exit {}</blockquote></p>     <p>Пример информирует о том, что функция <blockquote>main</blockquote> вызывает (среди прочих) функцию <blockquote>show_all_lists</blockquote> и что <blockquote>show_all_lists</blockquote> в свою очередь вызывает функцию <blockquote>display_list</blockquote>, которая вызывает функцию <blockquote>printf</blockquote>.</p>     <p>У этой версии <blockquote>cflow</blockquote> есть опция <blockquote>-i</blockquote>, которая формирует инвертированный потоковый граф. Утилита <blockquote>cflow</blockquote> перечисляет для каждой функции другие функции, вызывающие данную. Звучит не очень понятно, но на самом деле все просто. Далее приведен пример:</p>     <p><blockquote>19  display_list {prcc.c 1056}</blockquote></p>     <p><blockquote>20      show_all_lists {prcc.c 1070}</blockquote></p>     <p><blockquote>21  exit {}</blockquote></p>     <p><blockquote>22      main {prcc.c 70}</blockquote></p>     <p><blockquote>23      show_all_lists {prcc.c 1070}</blockquote></p>     <p><blockquote>24      usage {prcc.c 59}</blockquote></p>     <p><blockquote>25  ...</blockquote></p>     <p><blockquote>74  printf {}</blockquote></p>     <p><blockquote>75      display_list {prcc.c 1056}</blockquote></p>     <p><blockquote>76      maketag {prcc.c 4 87}</blockquote></p>     <p><blockquote>77  show_all_lists {prcc.c 1070}</blockquote></p>     <p><blockquote>78      main {prcc.c 70}</blockquote></p>     <p><blockquote>79  ...</blockquote></p>     <p><blockquote>99  usage {prcc.c 59}</blockquote></p>     <p><blockquote>100     main {prcc.c 70}</blockquote></p>     <p>В примере показано, что функцию <blockquote>exit</blockquote>, например, вызывают функции <blockquote>main</blockquote>, <blockquote>show_all_lists</blockquote> и <blockquote>usage</blockquote>.</p>             <a name="metkadoc20"><h1>Выполнение профилирования с помощью <i>prof/gprof</i></h1></a>     <p>Методика, зачастую полезная при попытках выяснить проблемы снижения производительности программы, называется<i> профилированием выполнения</i> (execution profiling). Профиль программы, обычно поддерживаемый специальными опциями компилятора и вспомогательными программами, показывает, где программа тратит время.</p>     <p>Программа <blockquote>prof</blockquote> (и ее эквивалент в проекте GNU, <blockquote>gprof</blockquote>) выводит отчёт из файла трассировки выполнения, который формируется во время выполнения профилируемой программы. Профилируемый исполняемый файл создается с помощью флага компилятора <blockquote>-p</blockquote> (для <blockquote>prof</blockquote>) или флага <blockquote>-pg</blockquote> (для <blockquote>gprof</blockquote>).</p>     <p><blockquote>$ <b>cc -pg -о program program.с</b></blockquote></p>     <p>Программа компонуется со специальной библиотекой С, и в нее включается контрольный код. В конкретных системах он может отличаться, но общая цель — такая организация программы, которая позволяет часто прерывать выполнение и записывать этап выполнения. Контрольные данные записываются в файл mon.out (gmon.out для <blockquote>gprof</blockquote>) в текущем каталоге.</p>     <p><blockquote>$ <b>./program</b></blockquote></p>     <p><blockquote>$ <b>ls -ls</b></blockquote></p>     <p><blockquote>2 -rw-r--r-- 1 neil users 1294 Feb 4 11:48 gmon.out</blockquote></p>     <p>Программа prof/gprof читает эти контрольные данные и выводит отчет. См. подробности, касающиеся опций программы, в интерактивном справочном руководстве. Далее в качестве примера приведен вывод (сокращенный) программы gprof.</p>     <p><blockquote>cumulative  self    self   total</blockquote></p>     <p><blockquote>   time    seconds seconds  calls ms/call ms/call            name</blockquote></p>     <p><blockquote>   18.5       0.10    0.10   8664    0.01    0.03      doscan [4]</blockquote></p>     <p><blockquote>   18.5       0.20    0.10                            mcount (60)</blockquote></p>     <p><blockquote>   14.8       0.28    0.08  43320    0.00    0.00     _number [5]</blockquote></p>     <p><blockquote>    9.3       0.33    0.05   8664    0.01    0.01 _format_arg [6]</blockquote></p>     <p><blockquote>    7.4       0.37    0.04 112632    0.00    0.00     _ungetc [8]</blockquote></p>     <p><blockquote>    7.4       0.41    0.04   8757    0.00    0.00    _memccpy [9]</blockquote></p>     <p><blockquote>    7.4       0.45    0.04      1   40.00  390.02       _main [2]</blockquote></p>     <p><blockquote>    3.7       0.47    0.02     53    0.38    0.38      _read [12]</blockquote></p>     <p><blockquote>    3.7       0.49    0.02                             w4str [10]</blockquote></p>     <p><blockquote>    1.9       0.50    0.01  26034    0.00    0.00    _strlen [16]</blockquote></p>     <p><blockquote>    1.9       0.51    0.01   8664    0.00    0.00    strncmp [17]</blockquote></p>              <a name="metkadoc21"><h1>Проверки соблюдения условий</h1></a>    <p>Несмотря на то, что вставка на этапе разработки программы с помощью условной компиляции отладочного кода, такого как вызовы <blockquote>printf</blockquote>, распространена, иногда оставлять такие сообщения в поставляемой программе непрактично. Но часто проблемы возникают во время работы программы из-за некорректных допущений или исходных данных, а не из-за ошибок кодирования. Это события, которых "не может быть никогда". Например, функция может быть написана в расчете на то, что ее входные параметры будут в определенном диапазоне. Если передать ей некорректные данные, она может сделать некорректной работу всей системы.</p>    <p>В тех случаях, когда внутренняя логика системы нуждается в подкреплении, X/Open предоставляет макрос <blockquote>assert</blockquote>, применяемый для проверки правильности исходных данных и остановки выполнения программы в противном случае.</p>    <p><blockquote><b>#include &lt;assert.h&gt;</b></blockquote></p>    <p><blockquote><b>void assert(int expression)</b></blockquote></p>    <p>Макрос <blockquote>assert</blockquote> вычисляет выражение и, если оно не равно нулю, выводит некоторую диагностическую информацию о стандартной ошибке и вызывает функцию <blockquote>abort</blockquote> для завершения программы.</p>    <p>Заголовочный файл assert.h определяет макросы в зависимости от определения флага <blockquote>NDEBUG</blockquote>. Если <blockquote>NDEBUG</blockquote> определен во время обработки заголовочного файла, <blockquote>assert</blockquote> определяется по существу как ничто. Это означает, что вы можете отключить проверки заданных выражений во время компиляции, компилируя с опцией <blockquote>-DNDEBUG</blockquote> или вставив перед включением файла assert.h строку</p>    <p><blockquote>#define NDEBUG</blockquote></p>    <p>в каждый исходный файл.</p>    <p>Этот метод применения порождает проблему. Если вы используете <blockquote>assert</blockquote> во время тестирования, но отключите макрос в рабочем коде, в вашем рабочем коде может оказаться менее строгая проверка, чем применявшаяся в процессе его тестирования. Обычно макросы <blockquote>assert</blockquote> не оставляют включенными в рабочем коде — вряд ли вам понравится рабочий код, предоставляющий пользователю недружелюбное сообщение <blockquote>assert failed</blockquote> и останавливающий программу. Быть может, лучше написать свою отслеживающую ошибки подпрограмму, которая проверяет выражение, использовавшееся в макросе, но не нуждается в полном отключении в рабочем коде.</p>    <p>Вы также должны убедиться в том, что у выражения макроса <blockquote>assert</blockquote> нет побочных эффектов. Например, если вы применяете вызов функции с побочным эффектом, этот побочный эффект не проявится в рабочем коде с отключенными макросами <blockquote>assert</blockquote>.</p>    <p>Выполните упражнение 10.2.</p>    <b>Упражнение 10.2. Программа assert.c.</b>    <p>Далее приведена программа assert.c, определяющая функцию, которая должна принимать положительное значение. Она защищает от ввода некорректного аргумента благодаря применению макроса <blockquote>assert</blockquote>.</p>    <p>После включения заголовочного файла assert.h и функции "квадратный корень", проверяющей положительное значение параметра, вы можете писать функцию <blockquote>main</blockquote>.</p>    <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>    <p><blockquote>#include &lt;math.h&gt;</blockquote></p>    <p><blockquote>#include &lt;assert.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>    <br>    <p><blockquote>double my_sqrt(double x) {</blockquote></p>    <p><blockquote> assert(x &gt;= 0.0);</blockquote></p>    <p><blockquote> return sqrt(x);</blockquote></p>    <p><blockquote>}</blockquote></p>    <br>    <p><blockquote>int main() {</blockquote></p>    <p><blockquote> printf("sqrt +2 = %g\n", my_sqrt(2.0));</blockquote></p>    <p><blockquote> printf("sqrt -2 = %g\n", my_sqrt(-2.0));</blockquote></p>    <p><blockquote> exit(0);</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Теперь при выполнении программы вы увидите нарушение в макросе <blockquote>assert</blockquote> при передаче некорректного значения. Точный формат сообщения о нарушении условия макроса assert в разных системах разный.</p>    <p><blockquote>$ <b>сс -о assert assert.с -lm</b></blockquote></p>    <p><blockquote>$ <b>./assert</b></blockquote></p>    <p><blockquote>sqrt +2 = 1.41421</blockquote></p>    <p><blockquote>assert: assert.c:7: my_sqrt: Assertion 'x &gt;= 0.0' failed.</blockquote></p>    <p><blockquote>Aborted</blockquote></p>    <p><blockquote>$</blockquote></p>    <p><b>Как это работает</b></p>    <p>Когда вы попытаетесь вызвать функцию <blockquote>my_sqrt</blockquote> с отрицательным числом, макрос <blockquote>assert</blockquote> даст сбой. Он предоставляет файл и номер строки, в которой нарушено условие и само нарушенное условие. Программа завершается прерыванием <blockquote>abort</blockquote>. Это результат вызова <blockquote>abort</blockquote> макросом <blockquote>assert</blockquote>.</p>    <p>Если вы перекомпилируете программу с опцией <blockquote>-DNDEBUG</blockquote>, макрос <blockquote>assert</blockquote> не компилируется, и вы получаете <blockquote>NaN</blockquote> (Not a Number, не число) — значение, указывающее на неверный результат при вызове функции <blockquote>sqrt</blockquote> из функции <blockquote>my_sqrt</blockquote>.</p>    <p><blockquote>$ <b>cc -о assert -DNDEBUG assert.с -lm</b></blockquote></p>    <p><blockquote>$ <b>./assert</b></blockquote></p>    <p><blockquote>sqrt +2 = 1.41421</blockquote></p>    <p><blockquote>sqrt -2 = nan</blockquote></p>    <p><blockquote>$</blockquote></p>    <p>Некоторые более старые версии математической библиотеки генерируют исключение для математической ошибки, и ваша программа будет остановлена с сообщением "Floating point exception" ("Исключение для числа с плавающей точкой") вместо возврата NaN.</p>          <a name="metkadoc22"><h1>Устранение ошибок использования памяти</h1></a>         <p>Распределение динамической памяти — богатый источник ошибок, которые трудно выявить. Если вы пишете программу, применяющую функции <blockquote>malloc</blockquote> и <blockquote>free</blockquote> для распределения памяти, важно внимательно следить за блоками, которые вы выделяете, и быть уверенным в том, что не используется блок, который вы уже освободили.</p>     <p>Обычно блоки памяти выделяются функцией <blockquote>malloc</blockquote> и присваиваются переменным-указателям. Если переменная-указатель изменяется, и нет других указателей, указывающих на блок памяти, он становится недоступным. Это утечка памяти, вызывающая увеличение размера программы. Если вы потеряете большой объем памяти, скорость работы вашей системы, в конце концов, снизится, и система уйдет за пределы памяти.</p>     <p>Если вы записываете в область, расположенную после конца выделенного блока (или перед началом блока), вы с большой долей вероятности повредите структуры данных, используемые библиотекой malloc, следящей за распределением памяти. В этом случае в какой-то момент времени вызов <blockquote>malloc</blockquote> или даже <blockquote>free</blockquote> приведет к нарушению сегментации, и ваша программа завершится аварийно. Определение точного места возникновения сбоя может оказаться очень трудной задачей, поскольку нарушение могло возникнуть задолго до события, вызвавшего аварийное завершение программы.</p>     <p>Неудивительно, что существуют коммерческие и бесплатные средства, способные помочь в решении проблем этих двух типов. Например, есть много разных версий функций <blockquote>malloc</blockquote> и <blockquote>free</blockquote>, которые содержат дополнительный код для проверки выделения и освобождения блоков памяти и пытаются учесть двойное освобождение блока и другие типы неправильного использования памяти.</p>             <a name="metkadoc23"><h1>ElectricFence</h1></a>     <p>Библиотека ElectricFence была разработана Брюсом Перенсом (Bruce Perens). Она доступна как необязательный компонент в некоторых дистрибутивах Linux, таких как Red Hat (Enterprise и Fedora), SUSE и openSUSE, и может быть легко найдена в Интернете. Это средство пытается применять виртуальную память системы Linux для защиты памяти, используемой функциями <blockquote>malloc</blockquote> и <blockquote>free</blockquote>, и аварийного останова программы в момент повреждения памяти.</p>     <p>Выполните упражнение 10.3.</p>     <b>Упражнение 10.3. Применение библиотеки ElectricFence</b>     <p>Далее приведена программа efence.c, которая выделяет память с помощью функции <blockquote>malloc</blockquote> и пишет данные за концом выделенного блока. Познакомьтесь с ней и посмотрите, что произойдет.</p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> char *ptr = (char *)malloc(1024);</blockquote></p>     <p><blockquote> ptr[0] = 0;</blockquote></p>     <p><blockquote> /* Теперь пишет за пределы блока */</blockquote></p>     <p><blockquote> ptr[1024] = 0;</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Когда вы откомпилируете и выполните программу, то не увидите некорректного поведения. Однако вероятно, что область памяти, выделенная <blockquote>malloc</blockquote>, повреждена, и вы, в конце концов, попадете в беду.</p>     <p><blockquote>$ <b>cc -о efence efence.с</b></blockquote></p>     <p><blockquote>$ <b>./efence</b></blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Тем не менее, если вы возьмете ту же самую программу и скомпонуйте ее с библиотекой ElectricFence (libefence.a), то получите немедленный отклик:</p>     <p><blockquote>$ <b>cc -о efence efence.с -lefence</b></blockquote></p>     <p><blockquote>$ <b>./efence</b></blockquote></p>     <p><blockquote>Electric Fence 2.2.0 Copyright (С) 1987-1999 Bruce Perens &lt;bruce@perens.com&gt;</blockquote></p>     <p><blockquote>Segmentation fault</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Выполнение под контролем отладчика позволяет получить подробное описание проблемы;</p>     <p><blockquote>$ <b>cc -g -о efence efence.с -lefence</b></blockquote></p>     <p><blockquote>$ <b>gdb efence</b></blockquote></p>     <p><blockquote>(gdb) <b>run</b></blockquote></p>     <p><blockquote>Starting program: /home/neil/BLP4e/chapter10/efence</blockquote></p>     <br>     <p><blockquote>Electric Fence 2.2.0 Copyright (C) 1987-1999 Bruce Perens bruce@perens.com</blockquote></p>     <br>     <p><blockquote>Program received signal SIGSEGV, Segmentation fault.</blockquote></p>     <p><blockquote>[Switching to Thread 1024 (LWP 1869)]</blockquote></p>     <p><blockquote>0x08048512 in main () at efence.c:10</blockquote></p>     <p><blockquote>10  ptr[1024] = 0;</blockquote></p>     <p><blockquote>(gdb)</blockquote></p>     <p><b>Как это работает</b></p>     <p>Библиотека ElectricFence заменяет функцию <blockquote>malloc</blockquote> и связанные с ней функции версиями, применяющими аппаратные средства виртуальной памяти для защиты от несанкционированного доступа к памяти. При возникновении подобного обращения к памяти порождается сигнал нарушения сегментации и программа останавливается.</p>             <a name="metkadoc24"><h1><i>valgrind</i></h1></a>     <p>Средство <blockquote>valgrind</blockquote> способно обнаруживать многие из обсуждавшихся нами проблем (упражнение 10.4). Прежде всего, оно умеет находить ошибки доступа, к массиву и утечки памяти. Это средство, возможно, не включено в ваш дистрибутив Linux, но его можно найти на Web-сайте <b>http://valgrind.org.</b></p>     <p>Для применения <blockquote>valgrind</blockquote> даже не требуется перекомпиляции программы, и вы можете находить ошибки доступа к памяти в выполняющейся программе. Данное средство заслуживает внимания; оно применяется в основных разработках, включая среду KDE версии 3.</p>     <b>Упражнение 10.4. Средство <blockquote>valgrind</blockquote></b>     <p>Далее приведена программа checker.c, которая выделяет некоторый объем памяти, читает область памяти и записывает данные за пределами выделенного участка, а затем делает выделенный участок недоступным.</p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> char *ptr = (char *)malloc(1024);</blockquote></p>     <p><blockquote> char ch;</blockquote></p>     <p><blockquote> /* Неинициализированное чтение */</blockquote></p>     <p><blockquote> ch = ptr[1024];</blockquote></p>     <p><blockquote> /* Запись за пределами блока */</blockquote></p>     <p><blockquote> ptr[1024] = 0;</blockquote></p>     <p><blockquote> /* Потеря блока */</blockquote></p>     <p><blockquote> ptr = 0;</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Для применения <blockquote>valgrind</blockquote> вы просто выполняете команду <blockquote>valgrind</blockquote>, передав ей опции, задающие нужные виды проверок, и далее указав программу для выполнения с ее аргументами (если таковые есть).</p>     <p>При выполнении программы с <blockquote>valgrind</blockquote> вы увидите множество обнаруженных проблем:</p>     <p><blockquote>$ <b>valgrind --leak-check=yes -v ./checker</b></blockquote></p>     <p><blockquote>==4780== Memcheck, a memory error detector.</blockquote></p>     <p><blockquote>==4780== Copyright (C) 2002-2007, and GNU GPL'd, by Julian Seward et al.</blockquote></p>     <p><blockquote>==4780== Using LibVEX rev 1732, a library for dynamic binary translation.</blockquote></p>     <p><blockquote>==4780== Copyright (C) 2004-2007, and GNU GPL'd, by OpenWorks LLP.</blockquote></p>     <p><blockquote>==4780== Using valgrind-3.2.3, a dynamic binary instrumentation framework.</blockquote></p>     <p><blockquote>==4780== Copyright (C) 2000-2007, and GNU GPL'd, by Julian Seward et al.</blockquote></p>     <p><blockquote>==4780==</blockquote></p>     <p><blockquote>--4780-- Command line</blockquote></p>     <p><blockquote>--4780--    ./checker</blockquote></p>     <p><blockquote>--4780-- Startup, with flags:</blockquote></p>     <p><blockquote>--4780--    --leak-check=yes</blockquote></p>     <p><blockquote>--4780--    -v</blockquote></p>     <p><blockquote>--4780-- Contents of /рroc/version:</blockquote></p>     <p><blockquote>--4780-- Linux version 2-6.20.2-2-default (geeko@buildhost) (gcc version 4.1.3 20070218 (prerelease) (SUSE Linux)) #1 SMP Fri Mar 9 21:54:10 UTC 2007</blockquote></p>     <p><blockquote>--4780-- Arch and hwcaps: X86, x86-sse1-sse2</blockquote></p>     <p><blockquote>--4780-- Page sizes: currently 4096, max supported 4096</blockquote></p>     <p><blockquote>--4780-- Valgrind library directory: /usr/lib/valgrind</blockquote></p>     <p><blockquote>--4780-- Reading syms from /lib/ld-2.5.so (0x4000000)</blockquote></p>     <p><blockquote>--4780-- Reading syms from /home/neil/BLP4e/chapter10/checker (0x8048000)</blockquote></p>     <p><blockquote>--4780-- Reading syms from /usr/lib/valgrind/x86-linux/memcheck (0x38000000)</blockquote></p>     <p><blockquote>--4780--    object doesn't have a symbol table</blockquote></p>     <p><blockquote>--4780--    object doesn't have a dynamic symbol table</blockquote></p>     <p><blockquote>--4780-- Reading suppressions file: /usr/lib/valgrind/default.supp</blockquote></p>     <p><blockquote>--4780-- REDIR: 0x40158B0 (index) redirected to 0x38027EDB (???)</blockquote></p>     <p><blockquote>--4780-- Reading syms from /usr/lib/valgrind/x86-linux/vgpreload_core.so (0x401E000)</blockquote></p>     <p><blockquote>--4780--    object doesn't have a symbol table</blockquote></p>     <p><blockquote>--4780-- Reading syms from /usr/lib/valgrind/x86-linux/vgpreload_memcheck.so (0x4021000)</blockquote></p>     <p><blockquote>--4780--    object doesn't have a symbol table</blockquote></p>     <p><blockquote>==4780= WARNING: new redirection conflicts with existing -- ignoring it</blockquote></p>     <p><blockquote>--4780--    new: 0x040158B0 (index ) R-&gt; 0x04024490 index</blockquote></p>     <p><blockquote>--4780-- REDIR: 0x4015A50 (strlen) redirected to 0x4024540 (strlen)</blockquote></p>     <p><blockquote>--4780-- Reading syms from /lib/libc-2.5.so (0x4043000)</blockquote></p>     <p><blockquote>--4780-- REDIR: 0x40ADFF0 (rindex) redirected to 0x4024370 (rindex)</blockquote></p>     <p><blockquote>--4780-- REDIR: 0x40AAF00 (malloc) redirected to 0x4023700 (malloc)</blockquote></p>     <p><blockquote>==4780== Invalid read of size 1</blockquote></p>     <p><blockquote>==4780==    at 0x804842C: main (checker.с: 10)</blockquote></p>     <p><blockquote>==4780== Address 0x4170428 is 0 bytes after a block of size 1,024 alloc'd</blockquote></p>     <p><blockquote>==4780==    at 0x4023785: malloc (in /usr/lib/valgrind/x86-linux/vgpreload_memcheck.so)</blockquote></p>     <p><blockquote>==4780==    by 0x8048420: main (checker.c: 6)</blockquote></p>     <p><blockquote>=4780=</blockquote></p>     <p><blockquote>==4780== Invalid write of size 1</blockquote></p>     <p><blockquote>==4780==    at 0x804843A: main (checker.с: 13)</blockquote></p>     <p><blockquote>==4780== Address 0x4170428 is 0 bytes after a block of size 1,024 alloc'd</blockquote></p>     <p><blockquote>==4780==    at 0x4 023785: malloc (in /usr/lib/valgrind/x86-linux/vgpreload_memcheck.so)</blockquote></p>     <p><blockquote>==4780==    by 0x8048420: main (checker.c: 6)</blockquote></p>     <p><blockquote>--4780-- REDIR: 0x40A8BB0 (free) redirected to 0x402331A (free)</blockquote></p>     <p><blockquote>--4780-- REDIR: 0x40AEE70 (memset) redirected to 0x40248A0 (memset)</blockquote></p>     <p><blockquote>==4780==</blockquote></p>     <p><blockquote>==4780== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 3 from 1)</blockquote></p>     <p><blockquote>==4780==</blockquote></p>     <p><blockquote>==4780== 1 errors in context 1 of 2:</blockquote></p>     <p><blockquote>==4780== Invalid write of size 1</blockquote></p>     <p><blockquote>==4780==    at 0x804843A: main (checker.с: 13)</blockquote></p>     <p><blockquote>==4780== Address 0x4170428 is 0 bytes after a block of size 1,024 alloc'd</blockquote></p>     <p><blockquote>==4780==    at 0x4023785: malloc (in /usr/lib/valgrind/x86-linux/vgpreload_memcheck.so)</blockquote></p>     <p><blockquote>==4780==    by 0x80484 20: main (checker.c: 6)</blockquote></p>     <p><blockquote>==4780==</blockquote></p>     <p><blockquote>==4780== 1 errors in context 2 of 2:</blockquote></p>     <p><blockquote>==4780== Invalid read of size 1</blockquote></p>     <p><blockquote>==4780==    at 0x804842C: main (checker.c:10)</blockquote></p>     <p><blockquote>==4780== Address 0x4170428 is 0-bytes after a block of size 1,024 alloc'd</blockquote></p>     <p><blockquote>==4780==    at 0x4023785: malloc (in /usr/lib/valgrind/x86-linux/vgpreload_memcheck.so)</blockquote></p>     <p><blockquote>==4780==    by 0x8048420: main (checker.с: 6)</blockquote></p>     <p><blockquote>--4780--</blockquote></p>     <p><blockquote>--4780-- supp: 3 dl-hack3</blockquote></p>     <p><blockquote>==4780==</blockquote></p>     <p><blockquote>==4780== IN SUMMARY: 2 errors from 2 contexts (suppressed: 3 from 1)</blockquote></p>     <p><blockquote>==4780==</blockquote></p>     <p><blockquote>==4780== malloc/free: in use at exit: 1,024 bytes in 1 blocks.</blockquote></p>     <p><blockquote>==4780== malloc/free: 1 allocs, 0 frees, 1,024 bytes allocated.</blockquote></p>     <p><blockquote>==4780==</blockquote></p>     <p><blockquote>==4780== searching for pointers to 1 not-freed blocks.</blockquote></p>     <p><blockquote>==4780== checked 65,444 bytes.</blockquote></p>     <p><blockquote>==4780==</blockquote></p>     <p><blockquote>==4780==</blockquote></p>     <p><blockquote>==4780== 1,024 bytes in 1 blocks are definitely lost in loss record 1 of 1</blockquote></p>     <p><blockquote>==4780==    at 0x4023785: malloc (in /usr/lib/valgrind/x86-linux/vgpreload_memcheck.so)</blockquote></p>     <p><blockquote>==4780==    by 0x8048420: main (checker.c: 6)</blockquote></p>     <p><blockquote>==4780==</blockquote></p>     <p><blockquote>==4780== LEAK SUMMARY:</blockquote></p>     <p><blockquote>==4780==    definitely lost: 1,024 bytes in 1 blocks.</blockquote></p>     <p><blockquote>==4780==      possibly lost: 0 bytes in 0 blocks.</blockquote></p>     <p><blockquote>==4780==    still reachable: 0 bytes in 0 blocks.</blockquote></p>     <p><blockquote>==4780==         suppressed: 0 bytes in 0 blocks.</blockquote></p>     <p><blockquote>--4780--  memcheck: sanity checks: 0 cheap, 1 expensive</blockquote></p>     <p><blockquote>--4780--  memcheck: auxmaps: 0 auxmap entries (0k, 0M) in use</blockquote></p>     <p><blockquote>--4780--  memcheck: auxmaps: 0 searches, 0 comparisons</blockquote></p>     <p><blockquote>--4780--  memcheck: SMs: n_issued = 9 (144k, 0M)</blockquote></p>     <p><blockquote>--4780--  memcheck: SMs: n_deissued = 0 (0k, 0M)</blockquote></p>     <p><blockquote>--4780--  memcheck: SMs: max_noaccess = 65535 (1048560k, 1023M)</blockquote></p>     <p><blockquote>--4780--  memcheck: SMs: max_undefined = 0 (0k, 0M)</blockquote></p>     <p><blockquote>--4780--  memcheck: SMs: max_defined = 19 (304k, 0M)</blockquote></p>     <p><blockquote>--4780--  memcheck: SMs: max_non_DSМ = 9 (144k, 0M)</blockquote></p>     <p><blockquote>--4780--  memcheck: max sec V bit nodes: 0 (0k, 0M)</blockquote></p>     <p><blockquote>--4780--  memcheck: set_sec_vbits8 calls: 0 (new: 0, updates: 0)</blockquote></p>     <p><blockquote>--4780--  memcheck: max shadow mem size: 448k, 0M</blockquote></p>     <p><blockquote>--4780-- translate: fast SP updates identified: 1,456 ( 90.3%)</blockquote></p>     <p><blockquote>--4780-- translate: generic_known SP updates identified: 79 ( 4.9%)</blockquote></p>     <p><blockquote>--4780-- translate: generic_unknown SP updates identified: 76 ( 4.7%)</blockquote></p>     <p><blockquote>--4780--     tt/tc: 3,341 tt lookups requiring 3,360 probes</blockquote></p>     <p><blockquote>--4780--     tt/tc: 3,341 fast-cache updates, 3 flushes</blockquote></p>     <p><blockquote>--4780--  transtab: new 1,553 (33,037 -&gt; 538,097; ratio 162:10) [0 scs]</blockquote></p>     <p><blockquote>--4780--  transtab: dumped 0 (0 -&gt; ??)</blockquote></p>     <p><blockquote>--4780--  transtab: discarded 6 (143 -&gt; ??)</blockquote></p>     <p><blockquote>--4780-- scheduler: 21,623 jumps (bb entries).</blockquote></p>     <p><blockquote>--4780-- scheduler: 0/1,828 major/minor sched events.</blockquote></p>     <p><blockquote>--4780--    sanity: 1 cheap, 1 expensive checks.</blockquote></p>     <p><blockquote>--4780--    exectx: 30,011 lists, 6 contexts (avq 0 per list)</blockquote></p>     <p><blockquote>--4780--    exectx: 6 searches, 0 full compares (0 per 1000)</blockquote></p>     <p><blockquote>--4780--    exectx: 0 cmp2, 4 cmp4, 0 cmpAll $</blockquote></p>     <p>Вы видите, что обнаружены некорректные считывания и записи, и интересующие нас блоки памяти приводятся с указанием места, которое для них отведено. Для прерывания выполнения программы в ошибочном месте можно применить отладчик.</p>     <p>У программы <blockquote>valgrind</blockquote> есть много опций, включая подавление ошибок определенного типа и обнаружение утечки памяти. Для выявления такой утечки в примере вы должны использовать одну из опций, передаваемых <blockquote>valgrind</blockquote>. Для контроля утечек памяти после завершения программы следует задать опцию <blockquote>--leak-check=yes</blockquote>. Список опций можно получить с помощью команды <blockquote>valgrind --help</blockquote>.</p>     <p><b>Как это работает</b></p>     <p>Программа выполняется под контролем средства valgrind, которое перехватывает действия, совершаемые программой, и выполняет множество проверок, включая обращения к памяти. Если обращение относится к выделенному блоку памяти и некорректно, valgrind выводит сообщение. В конце программы выполняется подпрограмма "сбора мусора", которая определяет, есть ли выделенные и неосвобожденные блоки памяти. Об этих потерянных блоках выводится сообщение.</p>              <a name="metkadoc25"><h1>Резюме </h1></a>    <p>В этой главе обсуждались некоторые методы и средства отладки. Система Linux предоставляет ряд мощных инструментов для удаления ошибок из ваших программ. Вы устранили несколько ошибок в программе с помощью отладчика <strike>gdb</strike> и познакомились с некоторыми средствами статического анализа, такими как <blockquote>cflow</blockquote> и <blockquote>splint</blockquote>. В заключение были рассмотрены проблемы, возникающие при использовании динамически распределяемой памяти, и некоторые средства, способные помочь обнаружить их, например ElectricFence и <blockquote>valgrind</blockquote>.</p>    <p>Утилиты, обсуждавшиеся в этой главе, в основном хранятся на FTP-серверах в Интернете. Авторы, имеющие к ним отношение, могут порой сохранять авторские права на них. Информацию о многих утилитах можно найти в архиве Linux, по адресу <b>http://www.ibiblio.org/pub/Linux.</b> Мы надеемся, что новые версии будут появляться на этом Web-сайте по мере их выхода в свет. </p>     <br><br>
<center><div align="center"><a href="index.php.html">Оглавление</a></div></center>




<br>
<script type="text/javascript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="https://www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script><br>

<noindex>
<div align="center">
<center>

<!-- SAPE RTB DIV 600x340 -->
<div id="SRTB_507029"></div>
<!-- SAPE RTB END -->

</center>
</div>
</noindex>

</td>
<td width="240" valign="top">

<br>

<div id="menu3">
<ul>
<li><a href="../../alternativnaja_medicina/index.html"><span>Альтернативная медицина</span></a></li>
<li><a href="../../astronomija_i_kosmos/index.html"><span>Астрономия и Космос</span></a></li>
<li><a href="../../biologija/index.html"><span>Биология</span></a></li>
<li><a href="../../voennaja_istorija/index.html"><span>Военная история</span></a></li>
<li><a href="../../geologija_i_geografija/index.html"><span>Геология и география</span></a></li>
<li><a href="../../gosudarstvo_i_pravo/index.html"><span>Государство и право</span></a></li>
<li><a href="../../delovaja_literatura/index.html"><span>Деловая литература</span></a></li>
<li><a href="../../domashnie_zhivotnye/index.html"><span>Домашние животные</span></a></li>
<li><a href="../../domovodstvo/index.html"><span>Домоводство</span></a></li>
<li><a href="../../zdorove/index.html"><span>Здоровье</span></a></li>
<li><a href="../../istorija/index.html"><span>История</span></a></li>
<li><a href="../index.html"><span>Компьютеры и Интернет</span></a></li>
<li><a href="../../kulinarija/index.html"><span>Кулинария</span></a></li>
<li><a href="../../kulturologija/index.html"><span>Культурология</span></a></li>
<li><a href="../../literaturovedenie/index.html"><span>Литературоведение</span></a></li>
<li><a href="../../matematika/index.html"><span>Математика</span></a></li>
<li><a href="../../medicina/index.html"><span>Медицина</span></a></li>
<li><a href="../../nauchnaja_literatura_prochee/index.html"><span>Науч. литер. - прочее</span></a></li>
<li><a href="../../pedagogika/index.html"><span>Педагогика</span></a></li>
<li><a href="../../politika/index.html"><span>Политика</span></a></li>
<li><a href="../../psihologija/index.html"><span>Психология</span></a></li>
<li><a href="../../religiovedenie/index.html"><span>Религиоведение</span></a></li>
<li><a href="../../sad_i_ogorod/index.html"><span>Сад и огород</span></a></li>
<li><a href="../../samosovershenstvovanie/index.html"><span>Самосовершенствование</span></a></li>
<li><a href="../../sdelai_sam/index.html"><span>Сделай сам</span></a></li>
<li><a href="../../sport/index.html"><span>Спорт</span></a></li>
<li><a href="../../tehnicheskie_nauki/index.html"><span>Технические науки</span></a></li>
<li><a href="../../transport_i_aviacija/index.html"><span>Транспорт и авиация</span></a></li>
<li><a href="../../uchebniki/index.html"><span>Учебники</span></a></li>
<li><a href="../../fizika/index.html"><span>Физика</span></a></li>
<li><a href="../../filosofija/index.html"><span>Философия</span></a></li>
<li><a href="../../himija/index.html"><span>Химия</span></a></li>
<li><a href="../../hobbi_i_remesla/index.html"><span>Хобби и ремесла</span></a></li>
<li><a href="../../shpargalki/index.html"><span>Шпаргалки</span></a></li>
<li><a href="../../yezoterika/index.html"><span>Эзотерика</span></a></li>
<li><a href="../../yurisprudencija/index.html"><span>Юриспруденция</span></a></li>
<li><a href="../../jazykoznanie/index.html"><span>Языкознание</span></a></li>
</ul>
</div>

<br>
<div align="center">
<center>
<noindex>

<!-- SAPE RTB DIV 240x400 -->
<div id="SRTB_507028"></div>
<!-- SAPE RTB END -->

</noindex>
</center>
</div>

</td>
</tr>
<tr>
<td colspan="3" align="center">


<hr>
<a href="../../index.html"><span>Главная</span></a> | 
<a rel="sidebar" href="p14.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a> | 
<a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a> | 
<a href="p14.php.html#" onClick="scroll(0,0); return false" title="наверх">Наверх</a>
</td>
</tr>
<tr>
<td colspan="3" valign="top" align="left">
<br>

 



</td>
</tr>
</table>

<noindex>
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter21717787 = new Ya.Metrika({id:21717787,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="http://mc.yandex.ru/watch/21717787" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

</noindex>
</center>
</div></body>
</html>