<html>
<head>
<meta http-equiv="Content-Language" content="ru">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<link href="../../0img/style.css" rel="stylesheet" type="text/css" />
<link rel="SHORTCUT ICON" href="http://www.redov.ru/0img/favicon.ico" type="image/x-icon"> 
<title>Глава 14 Семафоры, совместно используемая память и очереди сообщений / Основы программирования в Linux</title>
</head>
<body>
<div align="center">
<center>
<table border="0" cellpadding="0" cellspacing="0" width="1260">
<tr>
<td colspan="3" valign="top" align="left" height="100">
<table border="0" cellpadding="0" cellspacing="0" width="1260" height="100">
<tr>
<td valign="middle" align="center" width="350">
<a href="../../index.html"><img src="../../0img/logo.jpg" width="350" height="100" title="Онлайн библиотека redov.ru"/></a>
</td>
<td valign="middle" align="center" width="910">

<noindex>

<!-- SAPE RTB JS -->
<script
    async="async"
    src="http://cdn-rtb.sape.ru/rtb-b/js/393/2/106393.js"
    type="text/javascript">
</script>
<!-- SAPE RTB END -->

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507025"></div>
<!-- SAPE RTB END -->

</noindex>

</td>
</tr>
</table>
</td>
</tr>
<tr>
<td colspan="3" valign="middle" align="left">

<div id="menu">
<ul>
		<li><a href="../../index.html"><span>Главная</span></a></li>
		<li><a rel="sidebar" href="p18.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a></li>
		<li><a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a></li>
		<li><a href="p18.php.html#" onClick="scroll(0,9999999); return false"><span>Вниз</span></a></li>
</ul>
</div>


</td>
</tr>
<tr>
<td width="240" valign="top" align="center">

<br>
<noindex>
<!-- SAPE RTB DIV 160x600 -->
<div id="SRTB_733378"></div>
<!-- SAPE RTB END -->
</noindex>



</td>
<td valign="top" align="left" style="padding-left: 5; padding-right: 5" width="780">
<br>
<noindex>
<div align="center">

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507027"></div>
<!-- SAPE RTB END -->

</div>
</noindex>
<br>



<li><a href="p18.php.html#metkadoc2">     Семафоры     </a></li>
<li><a href="p18.php.html#metkadoc3">      Описание семафора      </a></li>
<li><a href="p18.php.html#metkadoc4">      Теоретический пример      </a></li>
<li><a href="p18.php.html#metkadoc5">      Реализация семафоров в Linux      </a></li>
<li><a href="p18.php.html#metkadoc6">      Применение семафоров      </a></li>
<li><a href="p18.php.html#metkadoc7">     Совместно используемая память     </a></li>
<li><a href="p18.php.html#metkadoc8">      <i>shmget</i>      </a></li>
<li><a href="p18.php.html#metkadoc9">      <i>shmat</i>      </a></li>
<li><a href="p18.php.html#metkadoc10">      <i>shmdt</i>      </a></li>
<li><a href="p18.php.html#metkadoc11">      <i>shmctl</i>      </a></li>
<li><a href="p18.php.html#metkadoc12">     Очереди сообщений     </a></li>
<li><a href="p18.php.html#metkadoc13">      <i>msgget</i>      </a></li>
<li><a href="p18.php.html#metkadoc14">      <i>msgsnd</i>      </a></li>
<li><a href="p18.php.html#metkadoc15">      <i>msgrcv</i>      </a></li>
<li><a href="p18.php.html#metkadoc16">      <i>msgctl</i>      </a></li>
<li><a href="p18.php.html#metkadoc17">     Приложение для работы с базой данных компакт-дисков     </a></li>
<li><a href="p18.php.html#metkadoc18">      Пересмотр функций сервера      </a></li>
<li><a href="p18.php.html#metkadoc19">      Пересмотр функций клиента      </a></li>
<li><a href="p18.php.html#metkadoc20">     Команды состояния IPC     </a></li>
<li><a href="p18.php.html#metkadoc21">      Отображение состояния семафора      </a></li>
<li><a href="p18.php.html#metkadoc22">      Отображение состояния совместно используемой памяти      </a></li>
<li><a href="p18.php.html#metkadoc23">      Отображение состояния очереди сообщений      </a></li>
<li><a href="p18.php.html#metkadoc24">     Резюме     </a></li>
<a name="metkadoc1"><h1>Глава 14</p>    <p>Семафоры, совместно используемая память и очереди сообщений</h1></a>       <p>В этой главе мы обсудим набор средств, обеспечивающих взаимодействие процессов и первоначально введенных в версии ОС UNIX AT&amp;T System V.2. Поскольку все эти средства появились в одном выпуске системы и обладают одинаковым программным интерфейсом, их часто называют средствами IPC (Inter-Process Communication, взаимодействие между процессами) или более полно System V IPC. Как вы уже видели, это далеко не единственный способ установления связи между процессами, но термин "System V IPC" обычно применяется для обозначения именно этих конкретных средств.</p>    <p>В данной главе мы рассмотрим следующие темы:</p>    <p>&#9633; семафоры для управления доступом к ресурсам;</p>    <p>&#9633; совместно используемая память для эффективного использования общих данных разными программами;</p>    <p>&#9633; обмен сообщениями как легкий способ передачи данных между программами.</p>          <a name="metkadoc2"><h1>Семафоры</h1></a>         <p>Когда разрабатываются программы для многопользовательских или многозадачных систем или их комбинации, зачастую выясняется, что в программе есть важные разделы программного кода, в которых необходимо обеспечить единственному процессу (или одному потоку исполнения) монопольный доступ к ресурсу.</p>     <p>У семафоров сложный программный интерфейс. Но, к счастью, вы сможете предоставить существенно, упрощенный его вариант, достаточный для решения большинства проблем, требующих программирования семафоров. </p>     <p>В первом приложении-примере в<i> главе</i> 7, использующем средство dbm для доступа к базе данных, данные могли бы быть повреждены множественными программами, пытавшимися обновить базу данных в одно и то же время. Никакого сбоя не произойдет, если две разные программы запрашивают у двух разных пользователей ввод данных для базы данных, единственная потенциальная проблема кроется в частях программного кода, обновляющих базу данных. Эти секции программы, действительно выполняющие обновления и нуждающиеся в монопольном режиме выполнения, называются <i>критическими секциями.</i> Часто они занимают всего несколько строк кода в гораздо больших по объему программах.</p>     <p>Для устранения проблем, вызванных одновременным обращением нескольких программ к совместно используемому ресурсу, вам нужен способ генерации и применения маркера, гарантирующего в любой момент, времени доступ в критическую секцию только одному потоку исполнения. В<i> главе 12</i> вы вкратце познакомились с ориентированным на потоки использованием мьютексов или семафоров для управления доступом в критические секции многопоточной программы. В этой главе мы вернемся к теме семафоров, но акцентируем внимание на их применении для взаимодействия разных процессов.</p>     <blockquote>      <b>Примечание</b>      <p>Функции семафоров, применяемые в потоках и обсуждавшиеся в<i> главе 12,</i> не относятся к наиболее общим функциям, которые мы рассматриваем в этой главе, поэтому будьте внимательны и не путайте функции этих двух типов.</p>     </blockquote>     <p>Написать программный код общего назначения, который гарантирует одной программе монопольный доступ к конкретному ресурсу, на удивление сложно, несмотря на то, что существует решение, известное как алгоритм Деккера (Dekker's Algorithm). К сожалению, этот алгоритм полагается на состояние активного ожидания или спин-блокировки, в котором процесс выполняется непрерывно, ожидая изменения адреса памяти. В многозадачной среде, какой является ОС Linux, это нежелательные расходы ресурсов ЦПУ. Ситуация существенно облегчается, когда для обеспечения монопольного доступа есть аппаратная поддержка, обычно в виде специальных команд ЦПУ. Примером аппаратной поддержки могла бы быть команда обращения к ресурсу и приращения регистра атомарным образом, так чтобы никакая другая команда (даже прерывание) не могла появиться между операциями чтения/инкремента/записи.</p>     <p>Одним из возможных решений проблемы можно считать уже знакомое вам создание файла с помощью флага <blockquote>O_EXCL</blockquote> в функции <blockquote>open</blockquote>, обеспечивающей атомарное создание файла. Этот метод хорош для простых задач, но становится довольно путанным и очень неэффективным при решении более сложных примеров.</p>     <p>Важный шаг вперед в сфере параллельного программирования был сделан, когда голландский специалист в области компьютерных наук Эдсгер Дейкстра (Edsger Dijkstra) предложил идею семафоров. Как уже кратко упоминалось в<i> главе 12,</i> семафор — это специальная переменная, которая принимает только целые положительные значения и с помощью которой программы могут действовать только атомарно. В этой главе мы расширим данное ранее упрощенное определение. Будет более подробно рассказано, как действуют семафоры и как для взаимодействия отдельных процессов применяются функции общего назначения вместо особого случая многопоточных программ, которые рассматривались в<i> главе 12.</i></p>     <p>Определяя более строго, семафор — это специальная переменная, для которой разрешены только две операции, формально именуемые ожиданием или приостановкой (wait) и оповещением (signal). Поскольку в программировании Linux у приостановки и оповещения уже есть специальные значения, мы будем применять оригинальное обозначение:</p>     <p>&#9633; <blockquote>P</blockquote>(переменная-семафор) для приостановки (wait);</p>     <p>&#9633; <blockquote>V</blockquote>(переменная-семафор) для оповещения (signal).</p>     <p>Эти буквы взяты из голландских слов для приостановки (<i>passeren</i> — проходить, пропускать как в случае контрольной точки перед критической секцией) и для оповещения (<i>vrijgeven</i> — предоставлять или освобождать, как в случае отказа от контроля критической секции). Вы можете встретить термины "вверх" (up) и "вниз" (down), применяемые в отношении семафоров по аналогии с использованием сигнальных флажков.</p>             <a name="metkadoc3"><h1>Описание семафора</h1></a>     <p>Простейший семафор — это переменная, способная принимать только значения 0 и 1,<i> бинарный</i> или<i> двоичный</i> семафор. Это наиболее распространенный вид семафора. Семафоры, принимающие много положительных значений, называют семафорами<i> общего вида.</i> В оставшейся части главы мы сосредоточимся на двоичных семафорах.</p>     <p>Определения операций <blockquote>P</blockquote> и <blockquote>V</blockquote> удивительно просты. Предположим, что у вас есть переменная-семафор <blockquote>sv</blockquote>. В этом случае обе операции определяются так, как представлено в табл. 14.1.</p>     <br>     <p><b><i>Таблица 14.1</i></b></p>     <table>      <tr>       <th valign="top">Операция</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>Р(sv)</blockquote></td>       <td valign="top">Если <blockquote>sv</blockquote> больше нуля, она уменьшается на единицу. Если sv равна 0, выполнение данного процесса приостанавливается</td>      </tr>      <tr>       <td valign="top"><blockquote>V(sv)</blockquote></td>       <td valign="top">Если какой-то другой процесс был приостановлен в ожидании семафора <blockquote>sv</blockquote>, переменная заставляет его возобновить выполнение. Если ни один процесс не приостановлен в ожидании семафора <blockquote>sv</blockquote>, значение переменной увеличивается на единицу</td>      </tr>     </table>     <p>Другой способ описания семафора — считать, что переменная <blockquote>sv</blockquote>, равная <blockquote>true</blockquote>, когда доступна критическая секция, уменьшается на единицу с помощью <blockquote>P(sv)</blockquote> и становится равна <blockquote>false</blockquote>, когда критическая секция занята, и увеличивается на единицу операцией <blockquote>V(sv)</blockquote>, когда критическая секция снова доступна. Имейте в виду, что обычная переменная, которую вы уменьшаете и увеличиваете на единицу, не годится, т.к. в языках С, С++, C# или практически в любом традиционном языке программирования у вас нет возможности сформировать единую атомарную операцию, проверяющую, равна ли переменная <blockquote>true</blockquote>, и если это так, изменяющую ее значение на <blockquote>false</blockquote>. Именно эта функциональная возможность делает операции с семафором особенными.</p>             <a name="metkadoc4"><h1>Теоретический пример</h1></a>     <p>С помощью простого теоретического примера можно посмотреть, как действует семафор. Предположим, что у вас есть два процесса: proc1 и proc2, оба нуждающиеся в некоторый момент выполнения в монопольном доступе к базе данных. Вы определяете один бинарный семафор <blockquote>sv</blockquote>, который стартует со значением 1 и доступен обоим процессам. Далее обоим процессам нужно выполнить одну и ту же обработку для доступа к критической секции программного кода; эти два процесса могут быть двумя разными выполняющимися экземплярами одной и той же программы.</p>     <p>Оба процесса совместно используют переменную-семафор <blockquote>sv</blockquote>. Как только один процесс выполнил операцию <blockquote>P(sv)</blockquote>, он получил семафор и может войти в критическую секцию программы. Второму процессу вход в критическую секцию запрещен, т.к., когда он попытается выполнить операцию <blockquote>P(sv)</blockquote>, он вынужден будет ждать до тех пор, пока первый процесс не покинет критическую секцию и не выполнит операцию <blockquote>V(sv)</blockquote>, освобождающую семафор.</p>     <p>Требуемый псевдокод у обоих процессов идентичен:</p>     <p><blockquote>semaphore sv = 1;</blockquote></p>     <p><blockquote>loop forever {</blockquote></p>     <p><blockquote> P(sv);</blockquote></p>     <p><blockquote> critical code section;</blockquote></p>     <p><blockquote> V(sv);</blockquote></p>     <p><blockquote> noncritical code section;</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Код на удивление прост, потому что определение операций <blockquote>P</blockquote> и <blockquote>V</blockquote> наделяет их большими функциональными возможностями.</p>     <img src="image048.jpg"/>     <p><b>Рис. 14.1</b> </p>     <br>     <p>На рис. 14.1 показана схема действующих операций <blockquote>P</blockquote> и <blockquote>V</blockquote>, напоминающих ворота в критических секциях программного кода.</p>             <a name="metkadoc5"><h1>Реализация семафоров в Linux</h1></a>     <p>Теперь, когда вы увидели, что такое семафоры и как они действуют в теории, можно рассмотреть, как их свойства реализованы в ОС Linux. Интерфейс тщательно проработан и предлагает гораздо больше возможностей, чем обычно требуется. Все функции семафоров в Linux оперируют массивами семафоров общего вида, а не одним двоичным семафором. На первый взгляд кажется, что такой подход все усложняет, но если процесс нуждается в блокировке нескольких ресурсов, способность оперировать массивом семафоров — большое подспорье. В этой главе мы сосредоточимся на применении одиночных семафоров, поскольку в большинстве случаев это все, что вам нужно.</p>     <p>Далее приведены объявления функций семафоров:</p>     <p><blockquote><b>#include &lt;sys/sem.h&gt;</b></blockquote></p>     <p><blockquote><b>int semctl(int sem_id, int sem_num, int command, ...);</b></blockquote></p>     <p><blockquote><b>int semget(key_t key, int num_sems, int sem_flags);</b></blockquote></p>     <p><blockquote><b>int semop(int sem_id, struct sembuf *sem_ops, size_t num_sem_ops);</b></blockquote></p>     <blockquote>      <b>Примечание</b>      <p>Обычно заголовочный файл sys/sem.h опирается на два других заголовочных файла: sys/types.h и sys/ipc.h. Как правило, они автоматически включаются в программу файлом sys/sem.h и вам не нужно задавать их явно в директивах <i><blockquote><i>#</i>include</blockquote></i>.</p>      <p>Прорабатывая каждую функцию отдельно, помните о том, что все они спроектированы для использования массивов значений семафоров, что делает их работу существенно более сложной, чем та, что необходима для обработки одного семафора.</p>     </blockquote>     <p>Обратите внимание на то, что параметр <blockquote>key</blockquote> действует во многом как имя файла, т.к. он тоже представляет ресурс, который программы могут использовать и кооперироваться при этом, если соблюдают соглашение об общем имени для него. Аналогичным образом идентификатор, возвращаемый функцией <blockquote>semget</blockquote> и применяемый другими функциями, совместно использующими память, очень похож на файловый поток <blockquote>FILE*</blockquote>, возвращаемый функцией <blockquote>fopen</blockquote> и представляющий собой значение, применяемое процессом для доступа к совместно используемому файлу. Как и в случае файлов, у разных процессов будут разные идентификаторы семафоров, несмотря на то, что они ссылаются на один и тот же семафор. Такое применение ключа и идентификаторов — общее для всех средств IPC, обсуждаемых здесь, несмотря на то, что каждое средство применяет независимые ключи и идентификаторы.</p>     <b><i>semget</i></b>     <p>Функция <blockquote>semget</blockquote> создает новый семафор или получает ключ существующего семафора.</p>     <p><blockquote><b>int semget(key_t key, int num_sems, int sem_flags);</b></blockquote></p>     <p>Первый параметр <blockquote>key</blockquote> — целочисленное значение, позволяющее несвязанным процессам обращаться к одному и тому же семафору. Ко всем семафорам осуществляется непрямой доступ с помощью программы, предоставляющей ключ, для которого система затем генерирует идентификатор семафора. Ключ семафора применяется только в функции <blockquote>semget</blockquote>. Все остальные функции семафора используют идентификатор семафора, возвращаемый функцией <blockquote>semget</blockquote>.</p>     <p>Существует особое значение ключа семафора <blockquote>IPC_PRIVATE</blockquote>, которое предназначено для создания семафора, доступ к которому получает только процесс-создатель, но такой семафор редко бывает полезен. Для создания нового семафора следует задавать уникальное ненулевое целое число.</p>     <p>Параметр <blockquote>num_sems</blockquote> определяет количество требуемых семафоров. Почти всегда он равен 1.</p>     <p>Параметр <blockquote>sem_flags</blockquote> — набор флагов, очень похожих на флаги функции open. Младшие девять байтов — права доступа к семафору, ведущие себя, как права доступа к файлу. Кроме того, для создания нового семафора с помощью поразрядной операции <blockquote>OR</blockquote> их можно объединить со значением <blockquote>IPC_CREAT</blockquote>. Не считается ошибкой наличие флага <blockquote>IPC_CREAT</blockquote> и задание ключа существующего семафора. Флаг <blockquote>IPC_CREAT</blockquote> безмолвно игнорируется, если в нем нет нужды. Можно применять флаги <blockquote>IPC_CREAT</blockquote> и <blockquote>IPC_EXCL</blockquote> для гарантированного получения нового уникального семафора. Если семафор уже существует, функция вернет ошибку.</p>     <p>Функция <blockquote>semget</blockquote> вернет в случае успеха положительное (ненулевое) значение, представляющее собой идентификатор, применяемый остальными функциями семафора. В случае ошибки возвращается -1.</p>     <b><i>semop</i></b>     <p>Функция semop применяется для изменения значения семафора.</p>     <p><blockquote><b>int semop(int sem_id, struct sembuf *sem_ops, size_t num_sem_ops);</b></blockquote></p>     <p>Первый параметр <blockquote>sem_id</blockquote> — идентификатор семафора, возвращенный функцией <blockquote>semget</blockquote>. Второй параметр <blockquote>sem_ops</blockquote> — указатель на массив структур, у каждой из которых есть, по крайней мере, следующие элементы:</p>     <p><blockquote><b>struct sembuf {</b></blockquote></p>     <p><blockquote><b> short sem_num;</b></blockquote></p>     <p><blockquote><b> short sem_op;</b></blockquote></p>     <p><blockquote><b> short sem_flg;</b></blockquote></p>     <p><blockquote><b>}</b></blockquote></p>     <p>Первый параметр <blockquote>sem_num</blockquote> — номер семафора, обычно 0, если вы не работаете с массивом семафоров. Элемент <blockquote>sem_op</blockquote> — значение, на которое должен изменяться семафор. (Вы можете увеличивать и уменьшать семафор на значения, не равные 1.) Как правило, применяются только два значения: -1 для операции <blockquote>P</blockquote>, заставляющей ждать, пока семафор не станет доступен, и +1 для операции <blockquote>V</blockquote>, оповещающей о том, что в данный момент семафор доступен.</p>     <p>Последний элемент <blockquote>sem_flg</blockquote> обычно задается равным <blockquote>SEM_UNDO</blockquote>. Это значение заставляет операционную систему отслеживать изменения значения семафора, сделанные текущим процессом, и, если процесс завершается, не освободив семафор, позволяет операционной системе автоматически освободить семафор, если он удерживался этим процессом. Хорошо взять за правило установку <blockquote>sem_flg</blockquote>, равным <blockquote>SEM_UNDO</blockquote>, если вам не требуется иного поведения. Если же вы все-таки решили, что вам нужно значение, отличное от <blockquote>SEM_UNDO</blockquote>, очень важно быть последовательным, иначе вы можете оказаться в замешательстве относительно попыток ядра системы "убрать" ваши семафоры, когда ваш процесс завершается.</p>     <p>Все действия, предусмотренные <blockquote>semop</blockquote>, собраны вместе, чтобы избежать состояния гонок, вызванного использованием множественных семафоров. Все подробности функционирования <blockquote>semop</blockquote> можно найти на страницах интерактивного справочного руководства.</p>     <b><i>semctl</i></b>     <p>Функция <blockquote>semctl</blockquote> позволяет напрямую управлять данными семафора.</p>     <p><b><blockquote><b>int semctl (int sem_id, int sem_num, int command, ...);</b></blockquote></b></p>     <p>Первый параметр sem_id — идентификатор семафора, полученный от функции <blockquote>semget</blockquote>. Параметр <blockquote>sem_num</blockquote> — номер семафора. Он применяется при работе с массивом семафоров. Обычно этот параметр равен 0, первый и единственный семафор. Параметр <blockquote>command</blockquote> — предпринимаемое действие, и четвертый параметр, если присутствует, — <blockquote>union</blockquote> (объединение) типа <blockquote>semun</blockquote>, которое в соответствии со стандартом X/Open должно содержать как минимум следующие элементы:</p>     <p><blockquote><b>union semun {</b></blockquote></p>     <p><blockquote><b> int val;</b></blockquote></p>     <p><blockquote><b> struct semid_ds *buf;</b></blockquote></p>     <p><blockquote><b> unsigned short *array;</b></blockquote></p>     <p><blockquote><b>}</b></blockquote></p>     <p>В большинстве версий ОС Linux определение объединения <blockquote>semun</blockquote> включено в заголовочный файл (обычно sem.h), несмотря на то, что стандарт X/Open настаивает на том, что вы должны привести собственное объявление. Если вы поймете, что должны объявить его самостоятельно, проверьте, нет ли объявления этого объединения на страницах интерактивного справочного руководства, относящихся к функции <blockquote>semctl</blockquote>. Если вы найдете его, мы полагаем, что вы примените определение из вашего справочного руководства, даже если оно отличается от приведенного на страницах этой книги.</p>     <p>Существует множество разных значений параметра command, допустимых в функции <blockquote>semctl</blockquote>. Обычно применяются два из них, которые описаны далее. Более подробную информацию о функции <blockquote>semctl</blockquote> см. в интерактивном справочном руководстве.</p>     <p>Два часто используемых значения <blockquote>command</blockquote> таковы:</p>     <p>&#9633; <blockquote>SETVAL</blockquote> — применяется для инициализации семафора с заданным значением. Это значение передается как элемент <blockquote>val</blockquote> объединения <blockquote>semun</blockquote>. Такое действие необходимо для того, чтобы увеличить значение семафора перед первым его применением;</p>     <p>&#9633; <blockquote>IPC_RMID</blockquote> — применяется для удаления идентификатора семафора, когда он больше не нужен.</p>     <p>Функция <blockquote>semctl</blockquote> возвращает разные значения, зависящие от параметра <blockquote>command</blockquote>. Если значение команды — <blockquote>IPC_RMID</blockquote>, функция в случае успешного завершения вернет 0 и -1 в противном случае.</p>             <a name="metkadoc6"><h1>Применение семафоров</h1></a>     <p>Как видно из содержания предыдущих разделов, операции с семафорами могут быть очень сложными. Это не самое печальное, потому что программирование многих процессов или потоков с критическими секциями — очень трудная задача сама по себе, и наличие сложного программного интерфейса лишь увеличивает интеллектуальную нагрузку.</p>     <p>К счастью, большинство задач, нуждающихся в семафорах, можно решить, применяя единственный бинарный семафор — простейший тип семафора. В следующем примере (упражнение 14.1) вы используете полный программный интерфейс для создания очень простого интерфейса типа Р и V для бинарного семафора. Затем вы примените этот простенький интерфейс для демонстрации того, как функционируют семафоры.</p>     <p>В экспериментах с семафорами будет использоваться единственная программа sem1.с, которую вы сможете запускать несколько раз. Необязательный параметр будет применяться для того, чтобы показать, отвечает ли программа за создание и уничтожение семафора.</p>     <p>Вывод двух разных символов будет обозначать вход в критическую секцию и выход из нее. Программа, запущенная с параметром, выводит <blockquote>X</blockquote> при входе в критическую секцию и выходе из нее. Другие экземпляры запущенной программы будут выводить символ <blockquote>О</blockquote> при входе в свои критические секции и выходе из них. Поскольку в любой заданный момент времени только один процесс способен войти в свою критическую секцию, все символы <blockquote>X</blockquote> и <blockquote>O</blockquote> должны появляться парами.</p>     <b>Упражнение 14.1. Семафоры</b>     <p>1. После системных директив <blockquote>#include</blockquote> вы включаете файл semun.h. Он определяет объединение типа <blockquote>semun</blockquote> в соответствии со стандартом X/Open, если оно уже не описано в системном файле sys/sem.h. Далее следуют прототипы функций и глобальная переменная, расположенные перед входом в функцию <blockquote>main</blockquote>. В ней создается семафор с помощью вызова <blockquote>semget</blockquote>, который возвращает ID семафора. Если программа вызывается первый раз (т.е. вызывается с параметром и <blockquote>argc &gt; 1</blockquote>), выполняется вызов <blockquote>set_semvalue</blockquote> для инициализации семафора и переменной <blockquote>op_char</blockquote> присваивается значение <blockquote>O</blockquote>.</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/sem.h&gt;</blockquote></p>     <p><blockquote>#include "semun.h"</blockquote></p>     <br>     <p><blockquote>static int set_semvalue(void);</blockquote></p>     <p><blockquote>static void del_semvalue(void);</blockquote></p>     <p><blockquote>static int semaphore_p(void);</blockquote></p>     <p><blockquote>static int semaphore_v(void);</blockquote></p>     <p><blockquote>static int sem_id;</blockquote></p>     <br>     <p><blockquote>int main(int argc, char *argv[]) {</blockquote></p>     <p><blockquote> int i;</blockquote></p>     <p><blockquote> int pause_time;</blockquote></p>     <p><blockquote> char op_char = 'О';</blockquote></p>     <p><blockquote> srand((unsigned int)getpid());</blockquote></p>     <p><blockquote> sem_id = semget((key_t)1234, 1, 0666 | IPC_CREAT);</blockquote></p>     <p><blockquote> if (argc &gt;1) {</blockquote></p>     <p><blockquote>  if (!set_semvalue()) {</blockquote></p>     <p><blockquote>   fprintf(stderr, "Failed to initialize semaphore\n");</blockquote></p>     <p><blockquote>   exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  op_char = 'X';</blockquote></p>     <p><blockquote>  sleep(2);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p>2. Далее следует цикл, в котором 10 раз выполняется вход в критическую секцию и выход из нее. Вы сначала выполняете вызов функции <blockquote>semaphore_p</blockquote>, которая заставляет семафор ждать, когда эта программа будет готова войти в критическую секцию.</p>     <p><blockquote> for (i = 0; i &lt; 10; i++) {</blockquote></p>     <p><blockquote>  if (!semaphore_p()) exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote>  printf("%c", op_char);</blockquote></p>     <p><blockquote>  fflush(stdout);</blockquote></p>     <p><blockquote>  pause_time = rand() % 3;</blockquote></p>     <p><blockquote>  sleep(pause_time);</blockquote></p>     <p><blockquote>  printf("%c", op_char);</blockquote></p>     <p><blockquote>  fflush(stdout);</blockquote></p>     <p>3. После критической секции вы вызываете функцию <blockquote>semaphore_v</blockquote>, которая освобождает семафор перед повторным проходом цикла <blockquote>for</blockquote> после ожидания в течение случайного промежутка времени. После цикла выполняется вызов функции <blockquote>del_semvalue</blockquote> для очистки кода.</p>     <p><blockquote>  if (!semaphore_v()) exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote>  pause_time = rand() % 2;</blockquote></p>     <p><blockquote>  sleep(pause_time);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> printf("\n%d - finished\n", getpid());</blockquote></p>     <p><blockquote> if (argc &gt; 1) {</blockquote></p>     <p><blockquote>  sleep(10);</blockquote></p>     <p><blockquote>  del_semvalue();</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>4. Функция <blockquote>set_semvalue</blockquote> инициализирует семафор с помощью команды <blockquote>SETVAL</blockquote> в вызове <blockquote>semctl</blockquote>. Это следует сделать перед использованием семафора.</p>     <p><blockquote>static int set_semvalue(void) {</blockquote></p>     <p><blockquote> union semun sem_union;</blockquote></p>     <p><blockquote> sem_union.val = 1;</blockquote></p>     <p><blockquote> if (semctl(sem_id, 0, SETVAL, sem_union) == -1) return(0);</blockquote></p>     <p><blockquote> return(1);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>5. У функции <blockquote>del_semvalue</blockquote> почти та же форма за исключением того, что в вызове <blockquote>semctl</blockquote> применяется команда <blockquote>IPC_RMID</blockquote> для удаления ID семафора.</p>     <p><blockquote>static void del_semvalue(void) {</blockquote></p>     <p><blockquote> union semun sem_union;</blockquote></p>     <p><blockquote> if (semctl(sem_id, 0, IPC_RMID, sem_union) == -1)</blockquote></p>     <p><blockquote>  fprintf(stderr, "Failed to delete semaphore\n");</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>6. Функция semaphore_p изменяет счетчик семафора на -1. Это операция ожидания или приостановки процесса.</p>     <p><blockquote>static int semaphore_p(void) {</blockquote></p>     <p><blockquote> struct sembuf sem_b;</blockquote></p>     <p><blockquote> sem_b.sem_num = 0;</blockquote></p>     <p><blockquote> sem_b.sem_op = -1; /* P() */</blockquote></p>     <p><blockquote> sem_b.sem_flg = SEM_UNDO;</blockquote></p>     <p><blockquote> if (semop(sem_id, &amp;sem_b, 1) == -1) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "semaphore_p failed\n");</blockquote></p>     <p><blockquote>  return(0);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return(1);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>7. Функция <blockquote>semaphore_v</blockquote> аналогична за исключением задания элемента <blockquote>sem_op</blockquote> структуры <blockquote>sembuf</blockquote>, равного 1. Это операция "освобождения", в результате которой семафор снова становится доступен.</p>     <p><blockquote>static int semaphore_v(void) {</blockquote></p>     <p><blockquote> struct sembuf sem_b;</blockquote></p>     <p><blockquote> sem_b.sem_num = 0;</blockquote></p>     <p><blockquote> sem_b.sem_op = 1; /* V() */</blockquote></p>     <p><blockquote> sem_b.sem_flg = SEM_UNDO;</blockquote></p>     <p><blockquote> if (semop(sem_id, &amp;sem_b, 1) == -1) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "semaphore_v failed\n");</blockquote></p>     <p><blockquote>  return(0);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return(1);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Обратите внимание на то, что эта простая программа разрешает существование единственного двоичного семафора для каждой программы, хотя можно было бы увеличить количество, передав переменную семафора при необходимости. Обычно одного бинарного семафора достаточно.</p>     <p>Вы можете протестировать вашу программу, запустив ее несколько раз. В первый раз вы передадите параметр, чтобы сообщить программе о том, что она отвечает за создание и удаление семафора. У других экземпляров выполняющейся программы не будет параметра.</p>     <p>Далее приведен примерный вывод для двух запущенных экземпляров программы:</p>     <p><blockquote>$ <b>cc sem1.с -о sem1</b></blockquote></p>     <p><blockquote>$ <b>./sem1 1 &amp;</b></blockquote></p>     <p><blockquote>[1] 1082</blockquote></p>     <p><blockquote>$ <b>./sem1</b></blockquote></p>     <p><blockquote>OOXXOOXXOOXXOOXXOOXXOOOOXXOOXXOOXXOOXXXX</blockquote></p>     <p><blockquote>1083 - finished</blockquote></p>     <p><blockquote>1082 - finished </blockquote></p>     <p>Напоминаем, что символ <blockquote>О</blockquote> представляет первый запущенный экземпляр программы, а символ <blockquote>X</blockquote> — второй экземпляр выполняющейся программы. Поскольку каждый экземпляр программы выводит символ при входе в критическую секцию и при выходе из нее, каждый символ должен появляться только попарно. Как видите, символы <blockquote>О</blockquote> и <blockquote>Х</blockquote> на самом деле образуют пары, указывая на корректную обработку критических секций. Если программа не работает на вашей системе, можно применить команду <blockquote>stty -tostop</blockquote> перед запуском программы, чтобы гарантировать, что фоновая программа, генерирующая вывод на <blockquote>tty</blockquote>, не вызывает возбуждение сигнала.</p>     <p><b>Как это работает</b></p>     <p>Программа начинается с получения обозначения семафора на основе ключа (произвольного), который вы выбрали, применив функцию <blockquote>semget</blockquote>. Флаг <blockquote>IPC_CREAT</blockquote> приводит к созданию семафора, если он нужен.</p>     <p>Если у программы есть параметр, она отвечает за инициализацию семафора, которая выполняется функцией <blockquote>set_semvalue</blockquote>, упрощенным вариантом функции общего назначения <blockquote>semctl</blockquote>. Она также использует наличие параметра для определения символа вывода. Функция <blockquote>sleep</blockquote> просто предоставляет некоторое время для запуска других экземпляров программы до того, как данная программа выполнит слишком много проходов своего цикла. Для включения в программу нескольких псевдослучайных промежутков времени вы используете функции <blockquote>srand</blockquote> и <blockquote>rand</blockquote>.</p>     <p>Далее программа выполняет 10 раз операторы тела цикла с псевдослучайными периодами ожидания в своей критической и некритической секциях. Критическая секция охраняется вызовами ваших функций <blockquote>semaphore_p</blockquote> и <blockquote>semaphore_v</blockquote>, упрощенных интерфейсов функции более общего вида <blockquote>semop</blockquote>.</p>     <p>Перед удалением семафора программа, запущенная с параметром, ждет, пока завершится выполнение других экземпляров программы. Если семафор не удален, он будет продолжать существовать в системе, даже если нет программ, его использующих. В реальных программах очень важно убедиться в том, что вы случайно не оставили семафор после завершения выполнения. Он может вызвать проблемы при следующем запуске программы, кроме того, семафоры — разновидность ограниченных ресурсов, которые вы должны беречь.</p>              <a name="metkadoc7"><h1>Совместно используемая память</h1></a>         <p><i>Совместно используемая</i> или<i> разделяемая память</i> — вторая разновидность средств IPC. Она позволяет двум несвязанным процессам обращаться к одной и той же логической памяти. Хотя стандарт X/Open не требует этого, надо полагать, что большинство реализаций разделяемой памяти размещают память, совместно используемую разными процессами, так, что она ссылается на одну и ту же физическую память.</p>     <p>Совместно используемая память — это специальный диапазон адресов, создаваемых средствами IPC для одного процесса и включаемых в адресное пространство этого процесса. Другой процесс может затем "присоединить" тот же самый сегмент совместно используемой памяти к своему адресному пространству. Все процессы могут получать доступ к участкам памяти так, как будто эта память была выделена функцией <blockquote>malloc</blockquote>. Если один процесс записывает в совместно используемую память, изменения немедленно становятся видимыми любому другому процессу, имеющему доступ к этой совместно используемой памяти.</p>     <p>Совместно используемая память обеспечивает эффективный способ разделения и передачи данных между разными процессами. Сама по себе совместная используемая память не предоставляет никаких средств синхронизации, поэтому вы, как правило, вынуждены применять некоторые другие механизмы для синхронизации доступа к совместно используемой памяти. Обычно совместно используемая память применяется для обеспечения эффективного доступа к обширным областям памяти, а для синхронизации доступа к ней передаются небольшие сообщения.</p>     <p>Не существует автоматических средств для того, чтобы помешать второму процессу начать считывание совместно используемой памяти до того, как первый процесс закончит запись в нее. За синхронизацию доступа отвечает программист. На рис. 14.2 показан принцип работы совместно используемой памяти.</p>     <img src="image049.jpg"/>     <p><b>Рис. 14.2</b></p>     <br>     <p>Стрелки показывают отображение логического адресного пространства каждого процесса на доступную физическую память. На практике ситуация сложнее, потому что доступная память на самом деле представляет собой смесь физической памяти и страниц памяти, которые были выгружены на диск.</p>     <p>Функции для работы с совместно используемой памятью напоминают функции семафоров:</p>     <p><blockquote><b>#include &lt;sys/shm.h&gt;</b></blockquote></p>     <p><blockquote><b>void *shmat(int shm_id, const void *shm_addr, int shmflg);</b></blockquote></p>     <p><blockquote><b>int shmctl(int shm_id, int cmd, struct shmid_ds *buf);</b></blockquote></p>     <p><blockquote><b>int shmdt(const void *shm_addr);</b></blockquote></p>     <p><blockquote><b>int shmget(key_t key, size_t size, int shmflg);</b></blockquote></p>     <p>Как и в случае семафоров, заголовочные файлы sys/types.h и sys/ipc.h автоматически включаются в программу файлом shm.h.</p>             <a name="metkadoc8"><h1><i>shmget</i></h1></a>     <p>Создается совместно используемая память с помощью функции <blockquote>shmget</blockquote>:</p>     <p><b><blockquote><b>int shmget(key_t key, size_t size, int shmflg);</b></blockquote></b></p>     <p>Как и для семафоров, программа предоставляет <blockquote>key</blockquote>, фактически именующий сегмент совместно используемой памяти, а функция <blockquote>shmget</blockquote> возвращает идентификатор совместно используемой памяти, который применяется всеми последующими функциями для работы с этой областью памяти. Есть особое значение ключа <blockquote>IPC_PRIVATE</blockquote>, создающее для процесса частную, скрытую от других совместно используемую память. Обычно вы не будете пользоваться этим значением, да и кроме всего прочего в некоторых системах Linux можете обнаружить, что такая частная разделяемая память на самом деле далеко не частная.</p>     <p>Второй параметр <blockquote>size</blockquote> задает требуемый объем памяти в байтах.</p>     <p>Третий параметр <blockquote>shmflg</blockquote> содержит девять флагов прав доступа, которые используются так же, как флаги режима создающихся файлов. Для создания нового сегмента совместно используемой памяти специальный бит, описываемый <blockquote>IPC_CREAT</blockquote>, должен с помощью поразрядной операции <blockquote>OR</blockquote> быть объединен с правами доступа. Не считается ошибкой задание флага <blockquote>IPC_CREAT</blockquote> и передача ключа существующего сегмента совместно используемой памяти. Флаг <blockquote>IPC_CREAT</blockquote>, если в нем нет нужды, беззвучно игнорируется.</p>     <p>Флаги прав доступа к совместно используемой памяти очень полезны, поскольку позволяют процессу создать совместно используемую память, в которую могут писать процессы, принадлежащие создателю этой разделяемой памяти, а процессы, созданные другими пользователями, могут только читать этот сегмент памяти. Вы можете использовать этот механизм для обеспечения эффективного доступа к данным только для чтения, поместив их в совместно используемую память без какого- либо риска их повреждения другими пользователями.</p>     <p>Если совместно используемая память создана успешно, <blockquote>shmget</blockquote> вернет неотрицательное целое, идентификатор совместно используемой памяти. В случае аварийного завершения функция вернет -1.</p>             <a name="metkadoc9"><h1><i>shmat</i></h1></a>     <p>Когда вы впервые создаете сегмент совместно используемой памяти, он недоступен ни одному процессу. Для того чтобы обеспечить доступ к совместно используемой памяти, нужно присоединить ее к адресному пространству процесса. Делается это с помощью функции <blockquote>shmat</blockquote>:</p>     <p><blockquote><b>void *shmat(int shm_id, const void *shm_addr, int shmflg);</b></blockquote></p>     <p>Первый параметр <blockquote>shm_id</blockquote> — идентификатор совместно используемой области памяти, возвращаемый функцией <blockquote>shmget</blockquote>.</p>     <p>Второй параметр <blockquote>shm_addr</blockquote> — адрес, по которому совместно используемая память присоединяется к текущему процессу. Почти всегда его следует задавать пустым указателем, что позволяет системе выбрать адрес для доступа к совместно используемой памяти.</p>     <p>Третий параметр <blockquote>shmflg</blockquote> — набор поразрядных флагов. Два возможных значения: <blockquote>SHM_RND</blockquote>, в сочетании с <blockquote>shm_addr</blockquote> управляющее адресом, по которому присоединяется к процессу совместно используемая память, и <blockquote>SHM_RDONLY</blockquote>, которое делает присоединенную память доступной только для чтения. Очень редко возникает необходимость управлять адресом присоединения совместно используемой памяти. Как правило, следует позволить системе выбрать для вас адрес, поскольку в противном случае приложение станет в значительной степени аппаратно-зависимым.</p>     <p>Если вызов <blockquote>shmat</blockquote> завершился успешно, он вернет указатель на первый байт совместно используемой памяти. В случае аварийного завершения возвращается -1.</p>     <p>Наличие доступа для чтения совместно используемой памяти и записи в нее зависит от владельца (создателя сегмента совместно используемой памяти), прав доступа и владельца текущего процесса. Права доступа к совместно используемой памяти подобны правам доступа к файлам.</p>     <p>Исключение из этого правила возникает, если выражение <blockquote>shmflg &amp; SHM_RDONLY</blockquote> равно <blockquote>true</blockquote>. В этом случае в совместно используемую память нельзя писать, даже если права доступа предоставляют такую возможность.</p>             <a name="metkadoc10"><h1><i>shmdt</i></h1></a>     <p>Функция <blockquote>shmdt</blockquote> отсоединяет совместно используемую память от текущего процесса. Она принимает указатель на адрес, возвращенный функцией <blockquote>shmat</blockquote>. В случае успеха функция вернет 0, в случае ошибки - -1. Имейте в виду, что отсоединение совместно используемой памяти не уничтожает ее, а только делает эту память недоступной для текущего процесса.</p>             <a name="metkadoc11"><h1><i>shmctl</i></h1></a>     <p>Функции управления совместно используемой памятью (к счастью) гораздо проще аналогичных, но более сложных функций для семафоров:</p>     <p><blockquote><b>int shmctl(int shm_id, int command, struct shmid_ds *buf);</b></blockquote></p>     <p>У структуры типа <blockquote>shmid_ds</blockquote> есть, как минимум, следующие элементы:</p>     <p><blockquote><b>struct shmid_ds {</b></blockquote></p>     <p><blockquote><b> uid_t shm_perm.uid;</b></blockquote></p>     <p><blockquote><b> uid_t shm_perm.gid;</b></blockquote></p>     <p><blockquote><b> mode_t shm_perm.mode;</b></blockquote></p>     <p><blockquote><b>}</b></blockquote></p>     <p>Первый параметр <blockquote>shm_id</blockquote> — идентификатор, возвращаемый функцией <blockquote>shmget</blockquote>.</p>     <p>Второй параметр <blockquote>command</blockquote> содержит предпринимаемое действие. Он может принимать три значения, перечисленные в табл. 14.2.</p>     <br>     <p><b><i>Таблица 14.2</i></b></p>     <table>      <tr>       <th valign="top">Значение</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>IPC_STAT</blockquote></td>       <td valign="top">Задаёт данные в структуре <blockquote>shmid_ds</blockquote>, отображающие значения, связанные с совместно используемой памятью</td>      </tr>      <tr>       <td valign="top"><blockquote>IPC_SET</blockquote></td>       <td valign="top">Устанавливает значения, связанные с совместно используемой памятью в соответствии с данными из структуры типа <blockquote>shmid_ds</blockquote>, если у процесса есть право на это действие</td>      </tr>      <tr>       <td valign="top"><blockquote>IPC_RMID</blockquote></td>       <td valign="top">Удаляет сегмент совместно используемой памяти</td>      </tr>     </table>     <p>Третий параметр <blockquote>buf</blockquote> — указатель на структуру, содержащую режимы и права доступа для совместно используемой памяти.</p>     <p>В случае успеха возвращает 0, в случае ошибки — -1. В стандарте X/Open не описано, что произойдет, если вы попытаетесь удалить присоединенный к процессу сегмент совместно используемой памяти. Обычно присоединенный, но удаленный сегмент совместно используемой памяти продолжает функционировать до тех пор, пока не будет отсоединен от последнего процесса. Но поскольку это поведение не задано в стандарте, на него лучше не рассчитывать.</p>     <p>Выполните упражнение 14.2.</p>     <b>Упражнение 14.2. Совместно используемая память</b>     <p>После знакомства с функциями совместно используемой памяти можно написать программу для их использования. В данном упражнении вы напишите пару программ: shm1.c и shm2.c. Первая (потребитель) создаст сегмент разделяемой памяти и затем отобразит любые данные, записанные в него. Вторая (поставщик) присоединит существующий сегмент совместно используемой памяти и позволит вам ввести данные в этот сегмент.</p>     <p>1. Сначала создайте общий заголовочный файл для описания совместно используемой памяти, которую вы хотите предоставить. Назовите его shm_com.h.</p>     <p><blockquote>#define TEXT_SZ 2048</blockquote></p>     <br>     <p><blockquote>struct shared_use_st {</blockquote></p>     <p><blockquote> int written_by_you;</blockquote></p>     <p><blockquote> char some_text[TEXT_SZ];</blockquote></p>     <p><blockquote>};</blockquote></p>     <p>В файле определена структура, которая будет применяться в обеих программах: потребителе и поставщике. Вы используете флаг <blockquote>written_by_you</blockquote> типа <blockquote>int</blockquote> для того, чтобы сообщить потребителю о том, что данные записаны в оставшуюся часть структуры, и произвольно решаете, что необходимо передать до 2 Кбайт текста.</p>     <p>2. Первая программа shm1.c — потребитель. После заголовочных файлов создается сегмент совместно используемой памяти (размер равен вашей структуре, описывающей совместно используемую память) с помощью вызова <blockquote>shmget</blockquote> с заданным битом <blockquote>IPC_CREAT</blockquote>.</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/shm.h&gt;</blockquote></p>     <p><blockquote>#include "shm_com.h"</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int running = 1;</blockquote></p>     <p><blockquote> void *shared_memory = (void *)0;</blockquote></p>     <p><blockquote> struct shared_use_st *shared_stuff;</blockquote></p>     <p><blockquote> int shmid;</blockquote></p>     <p><blockquote> srand((unsigned int)getpid());</blockquote></p>     <p><blockquote> shmid = shmget((key_t)1234, sizeof(struct shared_use_st),</blockquote></p>     <p><blockquote>  0666 | IPC_CREAT);</blockquote></p>     <p><blockquote> if (shmid == -1) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "shmget failed\n");</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p>3. Теперь вы делаете совместно используемую память доступной программе.</p>     <p><blockquote> shared_memory = shmat(shmid, (void *)0, 0);</blockquote></p>     <p><blockquote> if (shared memory == (void *)-1) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "shmat failed\n");</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> printf("Memory attached at %X\n", (int)shared_memory);</blockquote></p>     <p>4. В следующем фрагменте программы сегмент <blockquote>shared_memory</blockquote> присваивается переменной <blockquote>shared_stuff</blockquote>, из которой затем выводится любой текст, содержащийся в <blockquote>some_text</blockquote>. Цикл продолжает выполняться до тех пор, пока не найдена строка <blockquote>end</blockquote> в элементе <blockquote>some_text</blockquote>. Вызов функции <blockquote>sleep</blockquote> заставляет программу-потребителя оставаться в своей критической секции, что вынуждает поставщика ждать.</p>     <p><blockquote> shared_stuff = (struct shared_use_st *)shared_memory;</blockquote></p>     <p><blockquote> shared_stuff-&gt;written_by_you = 0;</blockquote></p>     <p><blockquote> while (running) {</blockquote></p>     <p><blockquote>  if (shared_stuff-&gt;written_by_you) {</blockquote></p>     <p><blockquote>   printf("You wrote: %s", shared_stuff-&gt;some_text);</blockquote></p>     <p><blockquote>   sleep(rand() % 4);</blockquote></p>     <p><blockquote>   /* Заставляет другой процесс ждать нас! */</blockquote></p>     <p><blockquote>   shared_stuff-&gt;written_by_you = 0;</blockquote></p>     <p><blockquote>   if (strncmp(shared_stuff-&gt;some_text, "end", 3) == 0) {</blockquote></p>     <p><blockquote>    running = 0;</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p>5. В заключение совместно используемая память отсоединяется и удаляется.</p>     <p><blockquote> if (shmdt(shared_memory) == -1) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "shmdt failed\n");</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> if (shmctl(shmid, IPC_RMID, 0) == -1) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "shmctl(IPC_RMID) failed\n");</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>6. Вторая программа shm2.c — поставщик; она позволяет вводить данные для потребителей. Программа очень похожа на shm1.c и выглядит следующим образом.</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/shm.h&gt;</blockquote></p>     <p><blockquote>#include "shm_com.h"</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int running = 1;</blockquote></p>     <p><blockquote> void *shared_memory = (void *)0;</blockquote></p>     <p><blockquote> struct shared_use_st *shared_stuff;</blockquote></p>     <p><blockquote> char buffer[BUFSIZ];</blockquote></p>     <p><blockquote> int shmid;</blockquote></p>     <p><blockquote> shmid = shmget((key_t)1234, sizeof(struct shared_use_st), 0666 | IPC_CREAT);</blockquote></p>     <p><blockquote> if (shmid == -1) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "shmget failed\n");</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> shared_memory = shmat(shmid, (void *)0, 0);</blockquote></p>     <p><blockquote> if (shared_memory == (void *)-1) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "shmat failed\n");</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> printf("Memory attached at %X\n", (int)shared_memory);</blockquote></p>     <p><blockquote> shared_stuff = (struct shared_use_st *)shared_memory;</blockquote></p>     <p><blockquote> while (running) {</blockquote></p>     <p><blockquote>  while (shared_stuff-&gt;written_by_you == 1) {</blockquote></p>     <p><blockquote>   sleep(1);</blockquote></p>     <p><blockquote>   printf("waiting for client...\n");</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  printf("Enter same text: ");</blockquote></p>     <p><blockquote>  fgets(buffer, BUFSIZ, stdin);</blockquote></p>     <p><blockquote>  strncpy(shared_stuff-&gt;some_text, buffer, TEXT_SZ);</blockquote></p>     <p><blockquote>  shared_stuff-&gt;written_by_you = 1;</blockquote></p>     <p><blockquote>  if (strncmp(buffer, "end", 3) == 0) {</blockquote></p>     <p><blockquote>   running = 0;</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> if (shmdt(shared_memory) == -1) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "shmdt failed\n");</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Когда вы выполните эти программы, то получите образец вывода, подобный следующему:</p>     <p><blockquote>$ .<b>/shm1 &amp;</b></blockquote></p>     <p><blockquote>[1] 294</blockquote></p>     <p><blockquote>Memory attached at 40017000</blockquote></p>     <p><blockquote>$ <b>./shm2</b></blockquote></p>     <p><blockquote>Memory attached at 40017000</blockquote></p>     <p><blockquote>Enter some text: <b>hello</b></blockquote></p>     <p><blockquote>You wrote: hello</blockquote></p>     <p><blockquote>waiting for client...</blockquote></p>     <p><blockquote>waiting for client...</blockquote></p>     <p><blockquote>Enter some text:<b> Linux!</b></blockquote></p>     <p><blockquote>You wrote: Linux!</blockquote></p>     <p><blockquote>waiting for client...</blockquote></p>     <p><blockquote>waiting for client...</blockquote></p>     <p><blockquote>waiting for client...</blockquote></p>     <p><blockquote>Enter some text: <b>end</b></blockquote></p>     <p><blockquote>You wrote: end</blockquote></p>     <p><blockquote>$</blockquote></p>     <p><b>Как это работает</b></p>     <p>Первая программа shm1 создает сегмент совместно используемой памяти и затем присоединяет его к своему адресному пространству. Вы накладываете структуру <blockquote>shared_use_st</blockquote> на начальную область совместно используемой памяти. У нее есть флаг <blockquote>written_by_you</blockquote>, который устанавливается, когда данные доступны. Если флаг установлен, программа считывает текст, выводит его и сбрасывает флаг, чтобы показать, что данные прочитаны. Для корректного выхода из цикла примените специальную строку <blockquote>end</blockquote>. Далее программа отсоединяет сегмент совместно используемой памяти и удаляет его.</p>     <p>Вторая программа shm2 получает и присоединяет тот же самый сегмент совместно используемой памяти, поскольку она применяет тот же ключ 1234. Затем она просит пользователя ввести текст. Если флаг <blockquote>written_by_you</blockquote> установлен, shm2 знает, что клиентский процесс еще не считал предыдущую порцию данных и ждет завершения чтения. Когда другой процесс очищает флаг, shm2 записывает новые данные и устанавливает флаг. Она также пользуется магической строкой <blockquote>end</blockquote> для завершения записи и отсоединения сегмента совместно используемой памяти.</p>     <p>Обратите внимание на то, что вы вынуждены с помощью флага <blockquote>written_by_you</blockquote> предоставить собственный очень грубый механизм синхронизации, который включает очень неэффективное активное ожидание (с непрерывным циклом). Такой подход сохраняет простоту примера, но в реальных программах вам следует применить семафор либо передать сообщение с помощью неименованного канала или сообщений IPC (которые будут обсуждаться в следующем разделе), либо сгенерировать сигнал (как показано в <i>главе 11</i>), чтобы обеспечить более эффективный механизм синхронизации между читающей и пишущей частями приложения.</p>              <a name="metkadoc12"><h1>Очереди сообщений</h1></a>         <p>Теперь рассмотрим третье и последнее средство System V IPC: очереди сообщений. Во многом очереди сообщений похожи на именованные каналы, но без сложностей, сопровождающих открытие и закрытие канала. Однако применение очереди сообщений не избавляет вас от проблем, возникающих при использовании именованных каналов, например блокировки заполненных каналов.</p>     <p>Очереди сообщений предоставляют очень легкий и эффективный способ передачи данных между двумя несвязанными процессами. У них есть преимущество по сравнению с именованными каналами, заключающееся в том, что очередь сообщений существует независимо как от отправляющего, так и от принимающего процессов, что устраняет некоторые трудности, возникающие при синхронизации открытия и закрытия именованных каналов.</p>     <p>Очереди сообщений обеспечивают отправку блока данных из одного процесса в другой. Кроме того, каждый блок данных наделяется типом, и принимающий процесс может получать независимо блоки данных, имеющие разные типы. Хорошо и то, что, отправляя сообщения, вы можете почти полностью избежать проблем синхронизации и блокировки, связанных с именованными каналами. Еще лучше то, что вы можете проявить предусмотрительность в отношении неотложных в том или ином смысле сообщений. К недостаткам следует отнести то, что, как и в случае каналов, в системе существует ограничение максимального объема блока данных и максимального объема всех блоков данных во всех очередях.</p>     <p>Наложив эти ограничения, стандарт X/Open не позаботился о способе выяснения их числовых значений за исключением того, что превышение ограничений — достаточное основание для аварийного завершения функций обработки очереди сообщений. В ОС Linux есть два определения: <blockquote>MSGMAX</blockquote> и <blockquote>MSGMNB</blockquote>, которые задают максимальный объем в байтах отдельного сообщения и максимальный объем очереди соответственно. В других системах эти макросы могут отличаться или просто отсутствовать.</p>     <p>Далее приведены объявления функций для работы с очередями сообщений:</p>     <p><blockquote><b>#include &lt;sys/msg.h&gt;</b></blockquote></p>     <p><blockquote><b>int msgctl(int msqid, int cmd, struct msqid_ds *buf);</b></blockquote></p>     <p><blockquote><b>int msgget(key_t key, int msgflg);</b></blockquote></p>     <p><blockquote><b>int msgrcv(int msqid, void *msg_ptr, size_t msg_sz, long int msgtype, int msgflg);</b></blockquote></p>     <p><blockquote><b>int msgsnd(int msqid, const void *msg_ptr, size_t msg_sz, int msgflg);</b></blockquote></p>     <p>Как и в случае семафоров или совместно используемой памяти, заголовочные файлы sys/types.h и sys/ipc.h обычно автоматически включаются заголовочным файлом msg.h.</p>             <a name="metkadoc13"><h1><i>msgget</i></h1></a>     <p>Очередь сообщений создается и предоставляет к себе доступ с помощью функции <blockquote>msgget</blockquote>:</p>     <p><blockquote><b>int msgget(key_t key, int msgflg);</b></blockquote></p>     <p>Программа должна предоставить значение параметра <blockquote>key</blockquote>, которое, как и в других средствах IPC, задает имя конкретной очереди сообщений. С помощью специального значения <blockquote>IPC_PRIVATE</blockquote> создается скрытая или частная очередь, которая теоретически доступна только текущему процессу. Как и в случае семафоров и совместно используемой памяти, в некоторых системах Linux такая очередь может не быть частной. Поскольку от скрытой или частной очереди очень мало пользы, это не слишком важная проблема. Как и раньше, второй параметр <blockquote>msgflg</blockquote> состоит из девяти флагов прав доступа. Для создания новой очереди сообщений специальный бит со значением <blockquote>IPC_CREAT</blockquote> должен быть объединен с правами доступа поразрядной операцией <blockquote>OR</blockquote>. Не считается ошибкой установка флага <blockquote>IPC_CREAT</blockquote> и задание ключа уже существующей очереди сообщений. Если очередь уже есть, флаг <blockquote>IPC_CREAT</blockquote> безмолвно игнорируется.</p>     <p>Функция <blockquote>msgget</blockquote> вернет положительное число, идентификатор очереди; в случае успешного завершения и -1 в случае сбоя.</p>             <a name="metkadoc14"><h1><i>msgsnd</i></h1></a>     <p>Функция <blockquote>msgsnd</blockquote> позволяет добавить сообщение в очередь сообщений:</p>     <p><b><blockquote><b>int msgsnd(int msqid, const void *msg_ptr, size_t msg_sz, int msgflg);</b></blockquote></b></p>     <p>Структура сообщения ограничена двумя способами. Во-первых, она должна быть меньше системного ограничения, и во-вторых, она должна начинаться с элемента типа <blockquote>long int</blockquote>, который будет использован как тип сообщения в получающей функции. Если вы применяете сообщения, лучше всего определить структуру сообщения следующим образом.</p>     <p><blockquote><b>struct my_message {</b></blockquote></p>     <p><blockquote><b> long int message_type;</b></blockquote></p>     <p><blockquote><b> /* Данные, которые вы собираетесь передавать */</b></blockquote></p>     <p><blockquote><b>}</b></blockquote></p>     <p>Поскольку элемент <blockquote>message_type</blockquote> используется при получении сообщения, вы не можете его просто игнорировать. Вы должны включить его в вашу структуру данных, и будет разумно инициализировать его с помощью известного значения.</p>     <p>Первый параметр <blockquote>msqid</blockquote> — идентификатор очереди сообщений, возвращаемый функцией <blockquote>msgget</blockquote>.</p>     <p>Второй параметр <blockquote>msg_ptr</blockquote> — указатель на отправляемое сообщение, которое должно начинаться с элемента типа <blockquote>long int</blockquote>, как описывалось ранее.</p>     <p>Третий параметр <blockquote>msg_sz</blockquote> — объем сообщения, на которое указывает <blockquote>msg_ptr</blockquote>. Этот объем не должен включать элемент типа <blockquote>long int</blockquote>, содержащий тип сообщения.</p>     <p>Четвертый параметр <blockquote>msgflg</blockquote> управляет действиями, предпринимаемыми при заполнении текущей очереди сообщений или достижении общесистемного ограничения для очередей сообщений. Если в параметре <blockquote>msgflg</blockquote> установлен флаг <blockquote>IPC_NOWAIT</blockquote>, функция вернет управление немедленно без отправки сообщения и возвращаемое значение будет равно -1. Если в параметре <blockquote>msgflg</blockquote> флаг <blockquote>IPC_NOWAIT</blockquote> сброшен, процесс отправки будет приостановлен в ожидании освобождения доступного объема в очереди.</p>     <p>В случае успеха функция вернет 0, а в случае аварийного завершения — -1. Если вызов был успешен, копия данных сообщения принимается и помещается в очередь сообщений.</p>             <a name="metkadoc15"><h1><i>msgrcv</i></h1></a>     <p>Функция <blockquote>msgrcv</blockquote> извлекает сообщения из очереди сообщений:</p>     <p><blockquote><b>int msgrcv(int msqid, void *msg_ptr, size_t msg_sz, long int msgtype, int msgflg);</b></blockquote></p>     <p>Первый параметр <blockquote>msqid</blockquote> — идентификатор очереди сообщений, возвращенный функцией msgget.</p>     <p>Второй параметр <blockquote>msg_ptr</blockquote> — указатель на получаемое сообщение, которое должно начинаться с элемента типа <blockquote>long int</blockquote>, как описывалось ранее в функции <blockquote>msgsnd</blockquote>.</p>     <p>Третий параметр <blockquote>msg_sz</blockquote> — размер сообщения, на которое указывает <blockquote>msg_ptr</blockquote>, без элемента типа <blockquote>long int</blockquote>, содержащего тип сообщения.</p>     <p>Четвертый параметр <blockquote>msgtype</blockquote> типа <blockquote>long int</blockquote> позволяет реализовать простую форму приоритетного получения. Если значение <blockquote>msgtype</blockquote> равно 0, извлекается первое доступное сообщение в очереди. Если значение параметра больше нуля, извлекается первое сообщение с таким же типом сообщения. Если оно меньше нуля, извлекается первое сообщение с таким же типом сообщения или со значением, по абсолютной величине меньшим, чем <blockquote>msgtype</blockquote>.</p>     <p>На практике все гораздо проще. Если вы просто хотите получать сообщения в порядке их отправления, задайте <blockquote>msgtype</blockquote>, равным 0. Если нужно извлекать сообщения только с определенным типом, задайте <blockquote>msgtype</blockquote>, равным этому значению. Если вам необходимо получать сообщения с типом не превышающим <blockquote>n</blockquote>, задайте <blockquote>msgtype</blockquote>, равным <blockquote>-n</blockquote>.</p>     <p>Четвертый параметр <blockquote>msgflg</blockquote> управляет действиями в случае отсутствия сообщения подходящего типа, которое ожидает извлечения. Если в параметре <blockquote>msgflg</blockquote> установлен флаг <blockquote>IPC_NOWAIT</blockquote>, вызов вернет управление программе немедленно с возвращаемым значением -1. Если флаг <blockquote>IPC_NOWAIT</blockquote> в <blockquote>msgflg</blockquote> сброшен, процесс будет приостановлен в ожидании прибытия сообщения подходящего типа.</p>     <p>В случае успешного завершения функция msgrcv вернет количество байтов, помещенных в буфер приема, сообщение копируется в выделяемый пользователем буфер, на который указывает <blockquote>msg_ptr</blockquote>, и данные удаляются из очереди сообщений. В случае ошибки функция вернет -1.</p>             <a name="metkadoc16"><h1><i>msgctl</i></h1></a>     <p>Последняя функция обработки очереди сообщений <blockquote>msgctl</blockquote> очень похожа на функцию управления для совместно используемой памяти:</p>     <p><blockquote>int msgctl(int msqid; int command, struct msqid_ds *buf);</blockquote></p>     <p>Структура <blockquote>msqid_ds</blockquote> содержит, как минимум, следующие элементы:</p>     <p><blockquote><b>struct msqid_ds {</b></blockquote></p>     <p><blockquote><b> uid_t msg_perm.uid;</b></blockquote></p>     <p><blockquote><b> uid_t msg_perm.gid;</b></blockquote></p>     <p><blockquote><b> mode_t msg_perm.mode;</b></blockquote></p>     <p><blockquote><b>}</b></blockquote></p>     <p>Первый параметр <blockquote>msqid</blockquote> — идентификатор, возвращаемый функцией <blockquote>msgget</blockquote>.</p>     <p>Второй параметр <blockquote>command</blockquote> задает предпринимаемое действие. Он может принимать три значения, перечисленные в табл. 14.3.</p>     <br>     <p><i><b>Таблица 14.3</b></i></p>     <table>      <tr>       <th valign="top">Значение</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>IPC_STAT</blockquote></td>       <td valign="top">Задает данные в структуре <blockquote>msqid_ds</blockquote>, отображающие значения, связанные с очередью сообщений</td>      </tr>      <tr>       <td valign="top"><blockquote>IPC_SET</blockquote></td>       <td valign="top">Если у процесса есть на это право, это действие устанавливает значения, связанные с очередью сообщений, в соответствии с данными структуры <blockquote>msqid_ds</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>IPC_RMID</blockquote></td>       <td valign="top">Удаляет очередь сообщений</td>      </tr>     </table>     <p>В случае успешного завершения возвращает 0, в случае аварийного — -1. Если очередь сообщений удаляется, когда процесс ожидает в функции <blockquote>msgsnd</blockquote> или <blockquote>msgrcv</blockquote>, функция отправки или получения сообщения завершается аварийно.</p>     <p>Выполните упражнение 14.3.</p>     <b>Упражнение 14.3. Очереди сообщений</b>     <p>Теперь, когда вы познакомились с объявлениями, относящимися к очередям сообщений, можно посмотреть, как они действуют на практике. Как и раньше, вы напишите две программы: msg1.c для получения и msg2.c для отправки сообщений. Вы разрешите обеим программам создавать очередь сообщений, но используете для удаления очереди программу-приемник после того, как она получит последнее сообщение.</p>     <p>1. Далее приведена программа-приемник msg1 .с:</p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <p><blockquote>#include &lt;errno.h&gt;</blockquote></p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/msg.h&gt;</blockquote></p>     <br>     <p><blockquote>struct my_msg_st {</blockquote></p>     <p><blockquote> long int my_msg_type;</blockquote></p>     <p><blockquote> char some_text[BUFSIZ];</blockquote></p>     <p><blockquote>};</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int running = 1;</blockquote></p>     <p><blockquote> int msgid;</blockquote></p>     <p><blockquote> struct my_msg_st some_data;</blockquote></p>     <p><blockquote> long int msg_to_receive = 0;</blockquote></p>     <p>2. Прежде всего, задайте очередь сообщений:</p>     <p><blockquote> msgid = msgget((key_t)1234, 0666 | IPC_CREAT);</blockquote></p>     <p><blockquote> if (msgid == -1) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "msgget failed with error: %d\n", errno);</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p>3. Далее сообщения извлекаются из очереди до тех пор, пока не будет обнаружено сообщение <blockquote>end</blockquote>. В конце очередь сообщений удаляется.</p>     <p><blockquote> while (running) {</blockquote></p>     <p><blockquote>  if (msgrcv(msgid, (void *)&amp;some_data, BUFSIZ, msg_to_receive, 0) == -1) {</blockquote></p>     <p><blockquote>   fprintf(stderr, "msgrcv failed with error: %d\n", errno);</blockquote></p>     <p><blockquote>   exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  printf("You wrote: %s", some_data.some_text);</blockquote></p>     <p><blockquote>  if (strncmp(some_data.some_text, "end", 3) == 0) {</blockquote></p>     <p><blockquote>   running = 0;</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> if (msgctl(msgid, IPC_RMID, 0) == -1) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "msgctl(IPC_RMID) failed\n");</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>4. Программа-отправитель msg2.c очень похожа на программу msg1.с. В функции main удалите объявление <blockquote>msg_to_receive</blockquote> и замените его переменной <blockquote>buffer[BUFSIZ]</blockquote>. Уберите из программы удаление очереди и внесите следующие изменения в цикл с управляющей переменной <blockquote>running</blockquote>. Теперь у вас появился вызов функции msgsnd для отправки введенного текста в очередь сообщений. Далее приведена программа msg2.c с отличиями от программы msg1.с, выделенными цветом.</p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <p><blockquote>#include &lt;errno.h&gt;</blockquote></p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/msg.h&gt;</blockquote></p>     <p><blockquote>#define MAX_TEXT 512</blockquote></p>     <br>     <p><blockquote>struct my_msg_st {</blockquote></p>     <p><blockquote> long int my_msg_type;</blockquote></p>     <p><blockquote> char some_text[MAX_TEXT];</blockquote></p>     <p><blockquote>};</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int running = 1;</blockquote></p>     <p><blockquote> struct my_msg_st some_data;</blockquote></p>     <p><blockquote> int msgid;</blockquote></p>     <p><blockquote><i> char buffer = [BUFSIZ];</i></blockquote></p>     <p><blockquote> msgid = msgget((key_t)1234, 0666 | IPC_CREAT);</blockquote></p>     <p><blockquote> if (msgid == -1) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "msgget failed with error: %d\n", errno);</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> while (running) {</blockquote></p>     <p><blockquote><i>  printf("Enter some text: ");</i></blockquote></p>     <p><blockquote><i>  fgets(buffer, BUFSIZ, stdin);</i></blockquote></p>     <p><blockquote><i>  some_data.my_msg_type = 1;</i></blockquote></p>     <p><blockquote><i>  strcpy(some_data.some_text, buffer);</i></blockquote></p>     <p><blockquote><i>  if (msgsnd(msgid, (void*)&amp;some_data, MAX_TEXT, 0)) == -1) {</i></blockquote></p>     <p><blockquote><i>   fpintf(stderr, "msgsnd failed\n");</i></blockquote></p>     <p><blockquote><i>   exit(EXIT_FAILURE);</i></blockquote></p>     <p><blockquote><i>  }</i></blockquote></p>     <p><blockquote><i>  if (strncmp(buffer, "end", 3) == 0) {</i></blockquote></p>     <p><blockquote><i>   running = 0;</i></blockquote></p>     <p><blockquote><i>  }</i></blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>В отличие от примера с каналами, процессам нет нужды предоставлять метод их собственной синхронизации. Это существенное преимущество сообщений по сравнению с каналами.</p>     <p>Если в очереди сообщений есть место, отправитель может создать очередь, поместить в нее какие-либо данные и завершить выполнение еще до того, как начнет выполняться приемник. Первой следует запускать программу-отправителя msg2. Далее приведен пример вывода:</p>     <p><blockquote>$ <b>./msg2</b></blockquote></p>     <p><blockquote>Enter some text: <b>hello</b></blockquote></p>     <p><blockquote>Enter some text: <b>How are you today?</b></blockquote></p>     <p><blockquote>Enter some text: <b>end</b></blockquote></p>     <p><blockquote>$ <b>./msg1</b></blockquote></p>     <p><blockquote>You wrote: hello</blockquote></p>     <p><blockquote>You wrote: How are you today?</blockquote></p>     <p><blockquote>You wrote: end</blockquote></p>     <p><b>Как это работает</b></p>     <p>Программа-отправитель создает очередь сообщений с помощью функции <blockquote>msgget</blockquote>; далее она добавляет сообщения в очередь, применяя функцию <blockquote>msgsnd</blockquote>. Программа-приемник получает идентификатор очереди сообщений с помощью функции <blockquote>msgget</blockquote> и получает сообщения до тех пор, пока не будет найден специальный текст <blockquote>end</blockquote>. Затем программа приводит все в порядок, удаляя очередь сообщений с помощью функции <blockquote>msgctl</blockquote>.</p>              <a name="metkadoc17"><h1>Приложение для работы с базой данных компакт-дисков</h1></a>         <p>Сейчас подходящий момент для модификации вашего приложения, управляющего базой данных компакт-дисков, с помощью средств IPC, с которыми вы познакомились в этой главе.</p>     <p>Вы могли бы применить множество разных комбинаций трех разновидностей средств IPC, но поскольку информация, которую следует передавать, очень мала по объему, есть смысл реализовать передачу запросов и ответов непосредственно с помощью очередей сообщений.</p>     <p>Если объемы данных, которые вы должны передавать, были бы велики, можно было бы рассмотреть передачу реальных данных в совместно используемой памяти, одновременно применяя семафоры или сообщения для отправки маркера или "опознавательного знака", информирующего другой процесс о наличии данных в совместно используемой памяти.</p>     <p>Интерфейс очереди сообщений устраняет проблему, которая у вас была в<i> главе 11, </i>когда вы нуждались в открытом канале у обоих процессов в момент передачи данных. Применение очередей сообщений позволяет одному процессу поместить сообщения в очередь, даже если этот процесс в данный момент — единственный пользователь очереди.</p>     <p>Вам нужно ответить лишь на один важный вопрос: как возвращать ответы клиентам? Простым решением было бы наличие одной очереди для сервера и по одной очереди для каждого клиента. Если одновременно существует много клиентов, такой подход может вызвать проблемы, т.к. потребуется большое количество очередей. Используя в сообщении поле идентификатора сообщения, вы сможете разрешить всем клиентам пользоваться одной очередью и адресовать ответные сообщения конкретным клиентским процессам с помощью включенного в сообщение идентификатора клиентского процесса. Далее каждый клиент может извлекать сообщения, адресованные только ему, оставляя сообщения для других клиентов в очереди.</p>     <p>Для преобразования приложения, работающего с базой данных компакт-дисков, с помощью средств IPC вам придется заменить только файл pipe_imp.c из сопроводительного программного кода к<i> главе 13.</i> Далее мы рассмотрим важные разделы замещающего файла ipc_imp.c.</p>             <a name="metkadoc18"><h1>Пересмотр функций сервера</h1></a>     <p>Сначала нужно обновить серверные функции.</p>     <p>1. Прежде всего, включите необходимые заголовочные файлы, объявите несколько ключей очередей сообщений и структуру для хранения данных сообщения:</p>     <p><blockquote>#include "cd_data.h"</blockquote></p>     <p><blockquote>#include "cliserv.h"</blockquote></p>     <p><blockquote>#include &lt;sys/msg.h&gt;</blockquote></p>     <br>     <p><blockquote>#define SERVER_MQUEUE 1234</blockquote></p>     <p><blockquote>#define CLIENT_MQUEUE 4321</blockquote></p>     <br>     <p><blockquote>struct msg_passed {</blockquote></p>     <p><blockquote> long int msg_key; /* Используется для клиентского pid */</blockquote></p>     <p><blockquote> message_db_t real message;</blockquote></p>     <p><blockquote>};</blockquote></p>     <p>2. Две глобальные переменные хранят идентификаторы двух очередей, возвращаемые функцией <blockquote>msgget</blockquote>:</p>     <p><blockquote>static int serv_qid = -1;</blockquote></p>     <p><blockquote>static int cli_qid = -1;</blockquote></p>     <p>3. Сделайте сервер ответственным за создание обеих очередей сообщений:</p>     <p><blockquote>int server starting() {</blockquote></p>     <p><blockquote>#if DEBUG_TRACE</blockquote></p>     <p><blockquote> printf("%d :- server_starting()\n", getpid());</blockquote></p>     <p><blockquote>#endif</blockquote></p>     <p><blockquote> serv_qid = msgget((key_t)SERVER_MQUEUE, 0666 | IPC_CREAT);</blockquote></p>     <p><blockquote> if (serv_qid == -1) return(0);</blockquote></p>     <p><blockquote> cli_qid = msgget((key_t)CLIENT_MQUEUE, 0666 | IPC_CREAT);</blockquote></p>     <p><blockquote> if (cli_qid == -1) return(0);</blockquote></p>     <p><blockquote> return(1);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>4. За удаление очереди, если она существует, также отвечает сервер. Когда сервер заканчивает работу, вы задаете недопустимые значения вашим глобальным переменным. Это позволит выловить любые ошибки при попытке сервера отправить сообщения после вызова функции <blockquote>server_ending</blockquote>:</p>     <p><blockquote>void server_ending() {</blockquote></p>     <p><blockquote>#if DEBUG_TRACE</blockquote></p>     <p><blockquote> printf("%d :- server_ending()\n", getpid());</blockquote></p>     <p><blockquote>#endif</blockquote></p>     <p><blockquote> (void)msgctl(serv_qid, IPC_RMID, 0);</blockquote></p>     <p><blockquote> (void)msgctl(cli_qid, IPC_RMID, 0);</blockquote></p>     <p><blockquote> servqid = -1;</blockquote></p>     <p><blockquote> cliqid = -1;</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>5. Серверная функция <blockquote>read</blockquote> читает из очереди сообщение любого типа (т.е. от любого клиента) и возвращает часть сообщения с данными (пропуская тип сообщения):</p>     <p><blockquote>int read_request_from_client(message_db_t *rec_ptr) {</blockquote></p>     <p><blockquote> struct msg_passed my_msg;</blockquote></p>     <p><blockquote>#if DEBUG_TRACE</blockquote></p>     <p><blockquote> printf("%d :- read_request_from_client()\n", getpid());</blockquote></p>     <p><blockquote>#endif</blockquote></p>     <p><blockquote> if (msgrcv(serv_qid, (void *)&amp;my_msg, sizeof(*rec_ptr), 0, 0) == -1) {</blockquote></p>     <p><blockquote>  return(0);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> *rec_ptr = my_msg.real_message;</blockquote></p>     <p><blockquote> return(1);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>6. При отправке сообщения для его адресации используется ID клиентского процесса, хранящийся в запросе:</p>     <p><blockquote>int send_resp_to_client(const message_db_t mess_to_send) {</blockquote></p>     <p><blockquote> struct msg_passed my_msg;</blockquote></p>     <p><blockquote>#if DEBUG_TRACE</blockquote></p>     <p><blockquote> printf("%d :- send_resp_to_client()\n", getpid());</blockquote></p>     <p><blockquote>#endif</blockquote></p>     <p><blockquote> my_msg.real_message = mess_to_send;</blockquote></p>     <p><blockquote> my_msg.msg_key = mess_to_send.client_pid;</blockquote></p>     <p><blockquote> if (msgsnd(cli_qid, (void *)&amp;my_msg, sizeof(mess_to_send), 0) == -1) {</blockquote></p>     <p><blockquote>  return(0);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return(1);</blockquote></p>     <p><blockquote>}</blockquote></p>             <a name="metkadoc19"><h1>Пересмотр функций клиента</h1></a>     <p>Теперь нужно внести изменения в клиентские функции.</p>     <p>1. Когда клиент стартует, ему нужно найти идентификаторы серверной и клиентской очередей. Клиент не создает очереди. Если сервер не работает, эта функция завершится аварийно, поскольку не существует очередей сообщений.</p>     <p><blockquote>int client starting() {</blockquote></p>     <p><blockquote>#if DEBUG_TRACE</blockquote></p>     <p><blockquote> printf("%d :- client_starting\n", getpid());</blockquote></p>     <p><blockquote>#endif</blockquote></p>     <p><blockquote> serv_qid = msgget((key_t)SERVER_MQUEUE, 0666);</blockquote></p>     <p><blockquote> if (serv_qid == -1) return(0);</blockquote></p>     <p><blockquote> cli_qid = msgget((key_t)CLIENT_MQUEUE, 0666);</blockquote></p>     <p><blockquote> if (cli_qid == -1) return(0);</blockquote></p>     <p><blockquote> return(1);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>2. Как и в случае сервера, когда клиент завершает работу, вы задаете некорректные значения глобальных переменных. Это позволит выявить ошибки при попытке клиента отправлять сообщения после вызова функции <blockquote>client_ending</blockquote>.</p>     <p><blockquote>void client_ending() {</blockquote></p>     <p><blockquote>#if DEBUG_TRACE</blockquote></p>     <p><blockquote> printf("%d :- client_ending()\n", getpid());</blockquote></p>     <p><blockquote>#endif</blockquote></p>     <p><blockquote> serv_qid = -1;</blockquote></p>     <p><blockquote> cli_qid = -1;</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>3. Для отправки сообщения серверу сохраните данные в своей структуре. Учтите, что вы должны задать ключ сообщения. Поскольку 0 — недопустимое значение для ключа, незаданный ключ означает, что он принимает (очевидно) случайное значение, поэтому иногда эта функция может возвращать ошибку, если значение оказывается нулевым.</p>     <p><blockquote>int send_mess_to_server(message_db_t mess_to_send) {</blockquote></p>     <p><blockquote> struct msg_passed my_msg;</blockquote></p>     <p><blockquote>#if DEBUG_TRACE</blockquote></p>     <p><blockquote> printf("%d send_mess_to_server()\n", getpid());</blockquote></p>     <p><blockquote>#endif</blockquote></p>     <p><blockquote> my_msg.real_message = mess_to_send;</blockquote></p>     <p><blockquote> my_msg.msg_key = mess_to_send.client_pid;</blockquote></p>     <p><blockquote> if (msgsnd(serv_qid, (void *)&amp;my_msg, sizeof(mess_to_send) , 0) == -1) {</blockquote></p>     <p><blockquote>  perror("Message send failed");</blockquote></p>     <p><blockquote>  return(0);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return(1);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>4. При получении сообщения от сервера клиент использует ID процесса для получения только сообщений, адресованных ему, пропуская сообщения, предназначенные другим клиентам.</p>     <p><blockquote>int read_resp_from_server(message_db_t *rec_ptr) {</blockquote></p>     <p><blockquote> struct msg_passed mymsg;</blockquote></p>     <p><blockquote>#if DEBUG_TRACE</blockquote></p>     <p><blockquote> printf("%d :- read_resp_from_server()\n", getpid());</blockquote></p>     <p><blockquote>#endif</blockquote></p>     <p><blockquote> if (msgrcv(cli_qid, (void *)&amp;my_msg, sizeof(*rec_ptr), getpid(), 0) == -1) {</blockquote></p>     <p><blockquote>  return(0);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> *rec_ptr = my_msg.real_message;</blockquote></p>     <p><blockquote> return(1);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>5. Для сохранения совместимости с файлом pipe_imp.c необходимо объявить четыре дополнительные функции. Но в вашей программе они будут пустыми. Операции, которые они реализовывали в случае применения каналов, больше не нужны.</p>     <p><blockquote>int start_resp_to_client(const message_db_t mess_to_send) {</blockquote></p>     <p><blockquote> return(1);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p><blockquote>void end_resp_to_client(void) {}</blockquote></p>     <p><blockquote>int start_resp_from_server(void) {</blockquote></p>     <p><blockquote> return(1);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p><blockquote>void end_resp_from_server(void) {}</blockquote></p>     <p>Теперь вы можете просто запустить сервер, выполняющий в фоновом режиме реальное сохранение и извлечение данных, и затем выполнить клиентское приложение для подключения к серверу с помощью сообщений.</p>     <p>Все, что вы должны сделать, — это заменить интерфейсные функции из <i>главы 11 </i>другой реализацией, применяющей очереди сообщений. Преобразование приложения для использования очередей сообщений показывает мощь этого средства IPC, т.к. вам требуется меньше функций, чем в случае применения каналов, и даже эти необходимые функции гораздо проще, чем в предыдущей версии приложения.</p>              <a name="metkadoc20"><h1>Команды состояния IPC</h1></a>         <p>Несмотря на то, что для соответствия требованиям X/Open этого не требуется, большинство систем Linux предоставляет набор команд, обеспечивающих доступ к данным IPC в режиме командной строки и удаление потерянных средств IPC. Существуют команды <blockquote>ipcs</blockquote> и <blockquote>ipcrm</blockquote>, очень полезные при разработке программ.</p>     <p>Один из досадных недостатков средств IPC состоит в том, что плохо написанная программа или программа, по какой-либо причине завершившаяся аварийно, может оставить свои ресурсы IPC (например, данные в очереди сообщений) еще долго блуждающими в системе без определенной цели после завершения программы. Такое поведение может привести к аварийному завершению нового запуска программы, поскольку она рассчитывает начать выполнение в очищенной системе, а на самом деле находит эти блуждающие ресурсы. Команды состояния (<blockquote>ipcs</blockquote>) и удаления (<blockquote>ipcrm</blockquote>) позволяют проверить систему и очистить ее от ненужных средств IPC.</p>             <a name="metkadoc21"><h1>Отображение состояния семафора</h1></a>     <p>Для проверки состояния семафоров в системе примените команду <blockquote>ipcs -s</blockquote>. Если какие-то семафоры присутствуют, вывод команды будет выглядеть следующим образом:</p>     <p><blockquote>$ <b>ipcs -s</b></blockquote></p>     <p><blockquote>------ Semaphore Arrays ------</blockquote></p>     <p><blockquote>key        semid owner perms nsems</blockquote></p>     <p><blockquote>0x4d00df1a 768   rick  666   1</blockquote></p>     <p>Для удаления семафоров, случайно оставленных программами, вы можете использовать команду <blockquote>ipcrm</blockquote>. Для удаления только что отображенного семафора примените (в Linux) следующую команду:</p>     <p><blockquote>$ <b>ipcrm -s 768</b></blockquote></p>     <p>В некоторых более старых системах Linux используется несколько иной синтаксис команды:</p>     <p><blockquote>$ <b>ipcrm sem 768</b></blockquote></p>     <p>Но этот устаревший стиль редко встречается в наше время. Формат, подходящий для вашей конкретной системы, ищите на страницах интерактивного справочного руководства.</p>             <a name="metkadoc22"><h1>Отображение состояния совместно используемой памяти</h1></a>     <p>Многие системы предоставляют программы режима командной строки для доступа не только к сведениям о семафорах, но и к подробным данным совместно используемой памяти. К ним относятся команды <blockquote>ipcs -m</blockquote> и <blockquote>ipcrm -m &lt;<i>id</i>&gt;</blockquote> (или <blockquote>ipcrm shm &lt;<i>id</i>&gt;</blockquote>).</p>     <p>Далее приведен пример вывода команды <blockquote>ipcs -m</blockquote>:</p>     <p><blockquote>$ <b>ipcs -m</b></blockquote></p>     <p><blockquote>------ Shared Memory Segments ------</blockquote></p>     <p><blockquote>key        shmid owner perms bytes nattch status</blockquote></p>     <p><blockquote>0x00000000 384   rick  666   4096  2      dest</blockquote></p>     <p>Здесь показан единственный сегмент совместно используемой памяти объемом 4 Кбайт, присоединенный к двум процессам.</p>     <p>Команда <blockquote>ipcrm -m &lt;<i>id</i>&gt;</blockquote> позволяет удалить совместно используемую память. Она бывает полезной, когда программа завершается аварийно при попытке убрать такую память.</p>             <a name="metkadoc23"><h1>Отображение состояния очереди сообщений</h1></a>     <p>Для очередей сообщений предназначены команды <blockquote>ipcs -q</blockquote> и <blockquote>ipcrm -q &lt;<i>id</i></blockquote>&gt; (или <blockquote>ipcrm msg &lt;<i>id</i>&gt;</blockquote>).</p>     <p>Далее приведен пример вывода команды <blockquote>ipcs -q</blockquote>:</p>     <p><blockquote>$ <b>ipcs -q</b></blockquote></p>     <p><blockquote>------ Message Queues ------</blockquote></p>     <p><blockquote>key        msqid owner perms used-bytes messages</blockquote></p>     <p><blockquote>0x000004d2 3384  rick  666   2048       2</blockquote></p>     <p>В нем показаны в очереди сообщений два сообщения общим объемом 2048 байтов. Команда <blockquote>ipcrm -q &lt;<i>id</i>&gt;</blockquote> позволяет удалить очередь сообщений.</p>              <a name="metkadoc24"><h1>Резюме</h1></a>    <p>В этой главе вы познакомились с тремя разновидностями средств взаимосвязи процессов, которые стали широко применяться в ОС UNIX System V.2 и были доступны в системе Linux, начиная с ранних версий ее дистрибутивов. Вы рассмотрели предлагаемые ими сложные функциональные возможности и, после того как поняли принципы их функционирования, оценили обеспечиваемое ими эффективное решение для удовлетворения многих потребностей межпроцессного взаимодействия. </p>     <br><br>
<center><div align="center"><a href="index.php.html">Оглавление</a></div></center>




<br>
<script type="text/javascript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="https://www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script><br>

<noindex>
<div align="center">
<center>

<!-- SAPE RTB DIV 600x340 -->
<div id="SRTB_507029"></div>
<!-- SAPE RTB END -->

</center>
</div>
</noindex>

</td>
<td width="240" valign="top">

<br>

<div id="menu3">
<ul>
<li><a href="../../alternativnaja_medicina/index.html"><span>Альтернативная медицина</span></a></li>
<li><a href="../../astronomija_i_kosmos/index.html"><span>Астрономия и Космос</span></a></li>
<li><a href="../../biologija/index.html"><span>Биология</span></a></li>
<li><a href="../../voennaja_istorija/index.html"><span>Военная история</span></a></li>
<li><a href="../../geologija_i_geografija/index.html"><span>Геология и география</span></a></li>
<li><a href="../../gosudarstvo_i_pravo/index.html"><span>Государство и право</span></a></li>
<li><a href="../../delovaja_literatura/index.html"><span>Деловая литература</span></a></li>
<li><a href="../../domashnie_zhivotnye/index.html"><span>Домашние животные</span></a></li>
<li><a href="../../domovodstvo/index.html"><span>Домоводство</span></a></li>
<li><a href="../../zdorove/index.html"><span>Здоровье</span></a></li>
<li><a href="../../istorija/index.html"><span>История</span></a></li>
<li><a href="../index.html"><span>Компьютеры и Интернет</span></a></li>
<li><a href="../../kulinarija/index.html"><span>Кулинария</span></a></li>
<li><a href="../../kulturologija/index.html"><span>Культурология</span></a></li>
<li><a href="../../literaturovedenie/index.html"><span>Литературоведение</span></a></li>
<li><a href="../../matematika/index.html"><span>Математика</span></a></li>
<li><a href="../../medicina/index.html"><span>Медицина</span></a></li>
<li><a href="../../nauchnaja_literatura_prochee/index.html"><span>Науч. литер. - прочее</span></a></li>
<li><a href="../../pedagogika/index.html"><span>Педагогика</span></a></li>
<li><a href="../../politika/index.html"><span>Политика</span></a></li>
<li><a href="../../psihologija/index.html"><span>Психология</span></a></li>
<li><a href="../../religiovedenie/index.html"><span>Религиоведение</span></a></li>
<li><a href="../../sad_i_ogorod/index.html"><span>Сад и огород</span></a></li>
<li><a href="../../samosovershenstvovanie/index.html"><span>Самосовершенствование</span></a></li>
<li><a href="../../sdelai_sam/index.html"><span>Сделай сам</span></a></li>
<li><a href="../../sport/index.html"><span>Спорт</span></a></li>
<li><a href="../../tehnicheskie_nauki/index.html"><span>Технические науки</span></a></li>
<li><a href="../../transport_i_aviacija/index.html"><span>Транспорт и авиация</span></a></li>
<li><a href="../../uchebniki/index.html"><span>Учебники</span></a></li>
<li><a href="../../fizika/index.html"><span>Физика</span></a></li>
<li><a href="../../filosofija/index.html"><span>Философия</span></a></li>
<li><a href="../../himija/index.html"><span>Химия</span></a></li>
<li><a href="../../hobbi_i_remesla/index.html"><span>Хобби и ремесла</span></a></li>
<li><a href="../../shpargalki/index.html"><span>Шпаргалки</span></a></li>
<li><a href="../../yezoterika/index.html"><span>Эзотерика</span></a></li>
<li><a href="../../yurisprudencija/index.html"><span>Юриспруденция</span></a></li>
<li><a href="../../jazykoznanie/index.html"><span>Языкознание</span></a></li>
</ul>
</div>

<br>
<div align="center">
<center>
<noindex>

<!-- SAPE RTB DIV 240x400 -->
<div id="SRTB_507028"></div>
<!-- SAPE RTB END -->

</noindex>
</center>
</div>

</td>
</tr>
<tr>
<td colspan="3" align="center">


<hr>
<a href="../../index.html"><span>Главная</span></a> | 
<a rel="sidebar" href="p18.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a> | 
<a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a> | 
<a href="p18.php.html#" onClick="scroll(0,0); return false" title="наверх">Наверх</a>
</td>
</tr>
<tr>
<td colspan="3" valign="top" align="left">
<br>

 



</td>
</tr>
</table>

<noindex>
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter21717787 = new Ya.Metrika({id:21717787,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="http://mc.yandex.ru/watch/21717787" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

</noindex>
</center>
</div></body>
</html>