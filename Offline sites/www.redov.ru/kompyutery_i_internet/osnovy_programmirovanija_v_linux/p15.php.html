<html>
<head>
<meta http-equiv="Content-Language" content="ru">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<link href="../../0img/style.css" rel="stylesheet" type="text/css" />
<link rel="SHORTCUT ICON" href="http://www.redov.ru/0img/favicon.ico" type="image/x-icon"> 
<title>Глава 11 Процессы и сигналы / Основы программирования в Linux</title>
</head>
<body>
<div align="center">
<center>
<table border="0" cellpadding="0" cellspacing="0" width="1260">
<tr>
<td colspan="3" valign="top" align="left" height="100">
<table border="0" cellpadding="0" cellspacing="0" width="1260" height="100">
<tr>
<td valign="middle" align="center" width="350">
<a href="../../index.html"><img src="../../0img/logo.jpg" width="350" height="100" title="Онлайн библиотека redov.ru"/></a>
</td>
<td valign="middle" align="center" width="910">

<noindex>

<!-- SAPE RTB JS -->
<script
    async="async"
    src="http://cdn-rtb.sape.ru/rtb-b/js/393/2/106393.js"
    type="text/javascript">
</script>
<!-- SAPE RTB END -->

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507025"></div>
<!-- SAPE RTB END -->

</noindex>

</td>
</tr>
</table>
</td>
</tr>
<tr>
<td colspan="3" valign="middle" align="left">

<div id="menu">
<ul>
		<li><a href="../../index.html"><span>Главная</span></a></li>
		<li><a rel="sidebar" href="p15.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a></li>
		<li><a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a></li>
		<li><a href="p15.php.html#" onClick="scroll(0,9999999); return false"><span>Вниз</span></a></li>
</ul>
</div>


</td>
</tr>
<tr>
<td width="240" valign="top" align="center">

<br>
<noindex>
<!-- SAPE RTB DIV 160x600 -->
<div id="SRTB_733378"></div>
<!-- SAPE RTB END -->
</noindex>



</td>
<td valign="top" align="left" style="padding-left: 5; padding-right: 5" width="780">
<br>
<noindex>
<div align="center">

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507027"></div>
<!-- SAPE RTB END -->

</div>
</noindex>
<br>



<li><a href="p15.php.html#metkadoc2">     Что такое процесс?     </a></li>
<li><a href="p15.php.html#metkadoc3">     Структура процесса     </a></li>
<li><a href="p15.php.html#metkadoc4">      Таблица процессов      </a></li>
<li><a href="p15.php.html#metkadoc5">      Просмотр процессов      </a></li>
<li><a href="p15.php.html#metkadoc6">      Системные процессы      </a></li>
<li><a href="p15.php.html#metkadoc7">      Планирование процессов      </a></li>
<li><a href="p15.php.html#metkadoc8">     Запуск новых процессов     </a></li>
<li><a href="p15.php.html#metkadoc9">      Замена образа процесса      </a></li>
<li><a href="p15.php.html#metkadoc10">      Дублирование образа процесса      </a></li>
<li><a href="p15.php.html#metkadoc11">      Ожидание процесса      </a></li>
<li><a href="p15.php.html#metkadoc12">      Процессы-зомби      </a></li>
<li><a href="p15.php.html#metkadoc13">      Перенаправление ввода и вывода      </a></li>
<li><a href="p15.php.html#metkadoc14">      Потоки       </a></li>
<li><a href="p15.php.html#metkadoc15">     Сигналы     </a></li>
<li><a href="p15.php.html#metkadoc16">      Отправка сигналов      </a></li>
<li><a href="p15.php.html#metkadoc17">      Множества сигналов      </a></li>
<li><a href="p15.php.html#metkadoc18">     Резюме      </a></li>
<a name="metkadoc1"><h1>Глава 11</p>    <p>Процессы и сигналы</h1></a>       <p>Процессы и сигналы формируют главную часть операционной среды Linux. Они управляют почти всеми видами деятельности ОС Linux и UNIX-подобных компьютерных систем. Понимание того, как Linux и UNIX управляют процессами, сослужит добрую службу системным и прикладным программистам или системным администраторам.</p>    <p>В этой главе вы узнаете, как обрабатываются процессы в рабочей среде Linux и как точно установить, что делает компьютер в любой заданный момент времени. Вы также увидите, как запускать и останавливать другие процессы в ваших собственных программах, как заставить процессы отправлять и получать сообщения и как избежать процессов-зомби. В частности, вы узнаете о:</p>    <p>&#9633; структуре процесса, его типе и планировании;</p>    <p>&#9633; разных способах запуска новых процессов;</p>    <p>&#9633; порождающих (родительских), порожденных (дочерних) процессах и процессах-зомби;</p>    <p>&#9633; сигналах и их применении.</p>          <a name="metkadoc2"><h1>Что такое процесс?</h1></a>    <p>Стандарты UNIX, а именно IEEE Std 1003.1, 2004 Edition, определяют процесс как "адресное пространство с одним или несколькими потоками, выполняющимися в нем, и системные ресурсы, необходимые этим потокам. Мы будем рассматривать потоки в<i> главе 12,</i> а пока будем считать процессом просто любую выполняющуюся программу.</p>    <p>Многозадачные системы, такие как Linux, позволяют многим программам выполняться одновременно. Каждый экземпляр выполняющейся программы создает процесс. Это особенно заметно в оконной системе, например Window System (часто называемой просто X). Как и ОС Windows, X предоставляет графический пользовательский интерфейс, позволяющий многим приложениям выполняться одновременно. Каждое приложение может отображаться в одном или нескольких окнах.</p>    <p>Будучи многопользовательской системой, Linux разрешает многим пользователям одновременно обращаться к системе. Каждый пользователь в одно и то же время может запускать много программ или даже несколько экземпляров одной и той же программы. Сама система выполняет в это время другие программы, управляющие системными ресурсами и контролирующие доступ пользователей.</p>    <p>Как вы видели в<i> главе 4</i>, выполняющаяся программа или процесс состоит из программного кода, данных, переменных (занимающих системную память), открытых файлов (файловых дескрипторов) и окружения. Обычно в системе Linux процессы совместно используют код и системные библиотеки, так что в любой момент времени в памяти находится только одна копия программного кода.</p>          <a name="metkadoc3"><h1>Структура процесса</h1></a>         <p>Давайте посмотрим, как организовано сосуществование двух процессов в операционной системе. Если два пользователя neil и rick запускают в одно и то же время программу grep для поиска разных строк в различных файлах, применяемые для этого процессы могут выглядеть так, как показано на рис. 11.1.</p>     <img src="image037.jpg"/>     <p><b>Рис. 11.1</b> </p>     <br>     <p>Если вы сможете выполнить команду <blockquote>ps</blockquote>, как в приведенном далее коде, достаточно быстро и до того, как завершатся поиски строк, вывод будет выглядеть подобно следующим строкам:</p>     <p><blockquote>$ <b>ps -ef</b></blockquote></p>     <p><blockquote>UID  PID PPID С STIME TTY  TIME     CMD</blockquote></p>     <p><blockquote>rick 101 96   0 18:24 tty2 00:00:00 grep troi nextgen.doc</blockquote></p>     <p><blockquote>neil 102 92   0 18:24 tty4 00:00:00 grep kirk trek.txt</blockquote></p>     <p>Каждому процессу выделяется уникальный номер, именуемый<i> идентификатором процесса</i> или PID. Обычно это положительное целое в диапазоне от 2 до 32 768. Когда процесс стартует, в последовательности выбирается следующее неиспользованное число. Когда все номера будут исчерпаны, выбор опять начнется с 2. Номер 1 обычно зарезервирован для специального процесса <blockquote>init</blockquote>, который управляет другими процессами. Мы скоро вернемся к процессу <blockquote>init</blockquote>. А пока вы видите, что двум процессам, запущенным пользователями neil и rick, выделены идентификаторы 101 и 102.</p>     <p>Код программы, которая будет выполняться командой <blockquote>grep</blockquote>, хранится в файле на диске. Обычно процесс Linux не может писать в область памяти, применяемую для хранения кода программы, поэтому программный код загружается в память как доступный только для чтения. На рис. 11.1 видно, что несмотря на то, что в данную область нельзя писать, она может безопасно использоваться совместно.</p>     <p>Системные библиотеки также можно совместно использовать. Следовательно, в памяти нужна, например, только одна копия функции <blockquote>printf</blockquote>, даже если многие выполняющиеся программы вызывают ее. Эта схема более сложная, но аналогичная той, которую используют для работы динамически подключаемые библиотеки в ОС Windows.</p>     <p>Как видно из приведенной схемы, дополнительное преимущество заключается в том, что дисковый файл, содержащий исполняемую программу <blockquote>grep</blockquote>, меньше, т.к. не включает программный код совместно используемой библиотеки. Возможно, для одной программы это не слишком ощутимый выигрыш, но извлечение часто используемых подпрограмм, к примеру, из стандартной библиотеки С экономит значительный объем для операционной системы в целом.</p>     <p>Конечно не все, что нужно программе, может быть совместно использовано. Например, переменные отдельно используются каждым процессом. В данном примере искомая строка, передаваемая команде <blockquote>grep</blockquote>, — это переменная <blockquote>s</blockquote>, принадлежащая пространству данных каждого процесса. Эти пространства разделены и, как правило, не могут читаться другим процессом. Файлы, которые применяются в двух командах grep, тоже разные; у каждого процесса есть свой набор файловых дескрипторов, используемых для доступа к файлам.</p>     <p>Кроме того, у каждого процесса есть собственный стек, применяемый для локальных переменных в функциях и для управления вызовами функций и возвратом из них. У процесса также собственное окружение, содержащее переменные окружения, которые могут задаваться только для применения в данном процессе, например, с помощью функций <blockquote>putenv</blockquote> и <blockquote>getenv</blockquote>, как было показано в<i> главе 4.</i> Процесс должен поддерживать собственный счетчик программы, запись того места, до которого он добрался за время выполнения, или<i> поток исполнения.</i> В следующей главе вы увидите, что процессы могут иметь несколько потоков исполнения.</p>     <p>Во многих системах Linux и некоторых системах UNIX существует специальный набор "файлов" в каталоге /proc. Это скорее специальные, чем истинные файлы, т.к. позволяют "заглянуть внутрь" процессов во время их выполнения, как если бы они были файлами в каталогах, В<i> главе 3</i> мы приводили краткий обзор файловой системы /proc.</p>     <p>И наконец, поскольку Linux, как и UNIX, обладает системой виртуальной памяти, которая удаляет страницы кода и данных на жесткий диск, можно управлять гораздо большим количеством процессов, чем позволяет объем физической памяти.</p>             <a name="metkadoc4"><h1>Таблица процессов</h1></a>     <p><i>Таблица процессов</i> Linux подобна структуре данных, описывающей все процессы, загруженные в текущий момент, например, их PID, состояние и строку команды, разновидность информационного вывода команды <blockquote>ps</blockquote>. Операционная система управляет процессами с помощью их идентификаторов, PID, которые применяются как указатели в таблице процессов. У таблицы ограниченный размер, поэтому число процессов, поддерживаемых системой, ограничено. В первых системах UNIX оно равнялось 256 процессам. Более современные реализации значительно ослабили это ограничение и ограничены только объемом памяти, доступным для формирования элемента таблицы процессов.</p>             <a name="metkadoc5"><h1>Просмотр процессов</h1></a>     <p>Команда <blockquote>ps</blockquote> показывает выполняемые вами процессы, процессы, выполняемые другим пользователем, или все процессы в системе. Далее приведен еще один пример вывода:</p>     <p><blockquote>$ <b>ps -ef</b></blockquote></p>     <p><blockquote>UID  PID PPID  С STIME  TTY      TIME CMD</blockquote></p>     <p><blockquote>root 433  425  0 18:12  tty1 00:00:00 [bash]</blockquote></p>     <p><blockquote>rick 445  426  0 18:12  tty2 00:00:00 -bash</blockquote></p>     <p><blockquote>rick 456  427  0 18:12  tty3 00:00:00 [bash]</blockquote></p>     <p><blockquote>root 467  433  0 18:12  tty1 00:00:00 sh /usr/X11R6/bin/startx</blockquote></p>     <p><blockquote>root 474  467  0 18:12  tty1 00:00:00 xinit /etc/X11/xinit/xinitrc --</blockquote></p>     <p><blockquote>root 478  474  0 18:12  tty1 00:00:00 /usr/bin/gnome-session</blockquote></p>     <p><blockquote>root 487    1  0 18:12  tty1 00:00:00 gnome-smproxy --sm-client-id def</blockquote></p>     <p><blockquote>root 493    1  0 18:12  tty1 00:00:01 [enlightenment]</blockquote></p>     <p><blockquote>root 506    1  0 18:12  tty1 00:00:03 panel --sm-client-id defaults</blockquote></p>     <p><blockquote>root 508    1  0 18:12  tty1 00:00:00 xscreensaver -no-splash -timeout</blockquote></p>     <p><blockquote>root 510    1  0 18:12  tty1 00:00:01 gmc --sm-client-id default10</blockquote></p>     <p><blockquote>root 512    1  0 18:12  tty1 00:00:01 gnome-help-browser --sm-client-i</blockquote></p>     <p><blockquote>root 649  445  0 18:24  tty2 00:00:00 su</blockquote></p>     <p><blockquote>root 653  649  0 18:24  tty2 00:00:00 bash</blockquote></p>     <p><blockquote>neil 655  428  0 18:24  tty4 00:00:00 -bash</blockquote></p>     <p><blockquote>root 713    1  2 18:27  tty1 00:00:00 gnome-terminal</blockquote></p>     <p><blockquote>root 715  713  0 18:28  tty1 00:00:00 gnome-pty-helper</blockquote></p>     <p><blockquote>root 717  716 13 18:28 pts/0 00:00:01 emacs</blockquote></p>     <p><blockquote>root 718  653  0 18:28  tty2 00:00:00 ps -ef</blockquote></p>     <p>Вывод отображает информацию о многих процессах, включая процессы, запущенные редактором Emacs в графической среде X ОС Linux. Например, столбец <blockquote>TTY</blockquote> показывает, с какого терминала стартовал процесс, столбец <blockquote>TIME</blockquote> показывает время ЦПУ, затраченное к данному моменту, а столбец <blockquote>CMD</blockquote> — команду, примененную для запуска процесса. Давайте познакомимся поближе с некоторыми из этих процессов.</p>     <p><blockquote>neil 655  428  0 18:24  tty4 00:00:00 -bash</blockquote></p>     <p>Начальная регистрация была произведена на консоли номер 4. Это просто консоль на данном компьютере. Выполняемая программа командной оболочки — это стандартная оболочка Linux, <blockquote>bash</blockquote>.</p>     <p><blockquote>root 467  433  0 18:12  tty1 00:00:00 sh /usr/X11R6/bin/startx</blockquote></p>     <p>X Window System была запущена командой <blockquote>startx</blockquote>. Это сценарий командной оболочки, который запускает сервер X и выполняет некоторые начальные программы системы X.</p>     <p><blockquote>root 717  716 13 18:28 pts/0 00:00:01 emacs</blockquote></p>     <p>Этот процесс представляет окно в системе X, выполняющее программу Emacs. Он был запущен оконным диспетчером в ответ на запрос нового окна. Командной оболочке был назначен новый псевдотерминал pts/0 для считывания и записи.</p>     <p><blockquote>root 512    1  0 18:12  tty1 00:00:01 gnome-help-browser --sm-client-i</blockquote></p>     <p>Это обозреватель системы помощи среды GNOME, запущенный оконным диспетчером.</p>     <p>По умолчанию программа <blockquote>ps</blockquote> выводит только процессы, поддерживающие подключение к терминалу, консоли, последовательной линии связи или псевдотерминалу. Другие процессы выполняются без взаимодействия с пользователем на терминале. Обычно это системные процессы, которые система Linux применяет для управления совместно используемыми ресурсами. Команду <blockquote>ps</blockquote> можно применять для отображения всех таких процессов, использовав опцию <blockquote>-е</blockquote> и запросив "полную" информацию с помощью опции <blockquote>-f</blockquote>.</p>     <blockquote>      <b>Примечание</b>      <p>Точная синтаксическая запись команды <blockquote>ps</blockquote> и формат вывода могут немного отличаться в разных системах. Версия GNU команды <blockquote>ps</blockquote>, применяемая в Linux, поддерживает опции, взятые из нескольких предшествующих реализаций <blockquote>ps</blockquote>, включая варианты из UNIX-систем BSD и AT&amp;T, и добавляет множество своих опций. См. интерактивное справочное руководство для получения подробных сведений о доступных опциях и форматах вывода команды <blockquote>ps</blockquote>.</p>     </blockquote>             <a name="metkadoc6"><h1>Системные процессы</h1></a>     <p>Далее приведено несколько процессов, выполнявшихся в другой системе Linux. Вывод был сокращен для облегчения понимания. В следующих примерах вы увидите, как определить состояние или статус процесса. Вывод командой <blockquote>ps</blockquote> столбца <blockquote>STAT</blockquote> предоставляет коды текущего состояния процесса. Самые широко распространенные коды перечислены в табл. 11.1. Смысл некоторых из них станет понятен чуть позже в этой главе. Другие же не рассматриваются в данной книге и их можно спокойно игнорировать.</p>     <br>     <p><b><i>Таблица 11.1</i></b></p>     <table>      <tr>       <th valign="top">Код STAT</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>S</blockquote></td>       <td valign="top">Спящий. Обычно ждет появления события, такого как сигнал или активизация ввода</td>      </tr>      <tr>       <td valign="top"><blockquote>R</blockquote></td>       <td valign="top">Выполняющийся. Строго говоря "работоспособный", т.е. в очереди на выполнение, либо выполняющийся, либо готовый к выполнению</td>      </tr>      <tr>       <td valign="top"><blockquote>D</blockquote></td>       <td valign="top">Непрерывно спящий (ожидающий). Обычно ждущий завершения ввода или вывода</td>      </tr>      <tr>       <td valign="top"><blockquote>T</blockquote></td>       <td valign="top">Остановленный. Обычно остановленный системой управления заданиями командной оболочки или находящийся под контролем отладчика</td>      </tr>      <tr>       <td valign="top"><blockquote>Z</blockquote></td>       <td valign="top">Умерший или процесс-зомби</td>      </tr>      <tr>       <td valign="top"><blockquote>N</blockquote></td>       <td valign="top">Задача с низким приоритетом, "nice"</td>      </tr>      <tr>       <td valign="top"><blockquote>W</blockquote></td>       <td valign="top">Разбитый на страницы (не используется в Linux с ядром версии 2.6 и последующих версий)</td>      </tr>      <tr>       <td valign="top"><blockquote>S</blockquote></td>       <td valign="top">Ведущий процесс сеанса</td>      </tr>      <tr>       <td valign="top"><blockquote>+</blockquote></td>       <td valign="top">Процесс в группе фоновых процессов</td>      </tr>      <tr>       <td valign="top"><blockquote>l</blockquote></td>       <td valign="top">Многопотоковый процесс</td>      </tr>      <tr>       <td valign="top"><blockquote>&lt;</blockquote></td>       <td valign="top">Задача с высоким приоритетом</td>      </tr>     </table>     <p><blockquote>$ <b>ps ах</b></blockquote></p>     <p><blockquote>PID   TTY   STAT TIME COMMAND</blockquote></p>     <p><blockquote>1     ?     Ss   0:03 init [5]</blockquote></p>     <p><blockquote>2     ?     S    0:00 [migration/0]</blockquote></p>     <p><blockquote>3     ?     SN   0:00 [ksoftirqd/0]</blockquote></p>     <p><blockquote>4     ?     S&lt;   0:05 [events/0]</blockquote></p>     <p><blockquote>5     ?     S&lt;   0:00 [khelper]</blockquote></p>     <p><blockquote>6     ?     S&lt;   0:00 [kthread]</blockquote></p>     <p><blockquote>840   ?     S&lt;   2:52 [kjournald]</blockquote></p>     <p><blockquote>888   ?     S&lt;s  0:03 /sbin/udevd --daemon</blockquote></p>     <p><blockquote>3069  ?     Ss   0:00 /sbin/acpid</blockquote></p>     <p><blockquote>3098  ?     Ss   0:11 /usr/sbin/hald --daemon=yes</blockquote></p>     <p><blockquote>3099  ?     S    0:00 hald-runner</blockquote></p>     <p><blockquote>8357  ?     Ss   0:03 /sbin/syslog-ng</blockquote></p>     <p><blockquote>8677  ?     Ss   0:00 /opt/kde3/bin/kdm</blockquote></p>     <p><blockquote>9119  ?     S    0:11 konsole [kdeinit]</blockquote></p>     <p><blockquote>9120  pts/2 Ss   0:00 /bin/bash</blockquote></p>     <p><blockquote>9151  ?     Ss   0:00 /usr/sbin/cupsd</blockquote></p>     <p><blockquote>9457  ?     Ss   0:00 /usr/sbin/cron</blockquote></p>     <p><blockquote>9479  ?     Ss   0:00 /usr/sbin/sshd -o PidFile=/var/run/sshd.init.pid</blockquote></p>     <p><blockquote>9618  tty1  Ss+  0:00 /sbin/mingetty --noclear tty1</blockquote></p>     <p><blockquote>9619  tty2  Ss+  0:00 /sbin/mingetty tty2</blockquote></p>     <p><blockquote>9621  tty3  Ss+  0:00 /sbin/mingetty tty3</blockquote></p>     <p><blockquote>9622  tty4  Ss+  0:00 /sbin/mingetty tty4</blockquote></p>     <p><blockquote>9623  tty5  Ss+  0:00 /sbin/mingetty tty5</blockquote></p>     <p><blockquote>9638  tty6  Ss+  0:00 /sbin/mingetty tty6</blockquote></p>     <p><blockquote>10359 tty1  Ss+ 10:05 /usr/bin/Xorg -br -nolisten tcp :0 vt7 -auth</blockquote></p>     <p><blockquote>10360 ?     S    0:00 -:0</blockquote></p>     <p><blockquote>10381 ?     Ss   0:00 /bin/sh /usr/bin/kde</blockquote></p>     <p><blockquote>10438 ?     Ss   0:00 /usr/bin/ssh-agent /bin/bash /etc/X11/xinit/xinitrc</blockquote></p>     <p><blockquote>10478 ?     S    0:00 start_kdeinit --new-startup +kcminit_startup</blockquote></p>     <p><blockquote>10479 ?     Ss   0:00 kdeinit Running...</blockquote></p>     <p><blockquote>10500 ?     S    0:53 kdesktop [kdeinit]</blockquote></p>     <p><blockquote>10502 ?     S    1:54 kicker [kdeinit]</blockquote></p>     <p><blockquote>10524 ?     Sl   0:47 beagled /usr/lib/beagle/BeagleDaemon.exe --bg</blockquote></p>     <p><blockquote>10530 ?     S    0:02 opensuseupdater</blockquote></p>     <p><blockquote>10539 ?     S    0:02 kpowersave [kdeinit]</blockquote></p>     <p><blockquote>10541 ?     S    0:03 klipper [kdeinit]</blockquote></p>     <p><blockquote>10555 ?     S    0:01 kio_uiserver [kdeinit]</blockquote></p>     <p><blockquote>10688 ?     S    0:53 konsole [kdeinit]</blockquote></p>     <p><blockquote>10689 pts/1 Ss+  0:07 /bin/bash</blockquote></p>     <p><blockquote>10784 ?     S    0:00 /opt/kde3/bin/kdesud</blockquote></p>     <p><blockquote>11052 ?     S    0:01 [pdflush]</blockquote></p>     <p><blockquote>19996 ?     SN1  0:20 beagled-helper /usr/lib/beagle/IndexHelper.exe</blockquote></p>     <p><blockquote>20254 ?     S    0:00 qmgr -1 -t fifo -u</blockquote></p>     <p><blockquote>21192 ?     Ss   0:00 /usr/sbin/ntpd -p /var/run/ntp/ntpd.pid -u ntp -i /v</blockquote></p>     <p><blockquote>21198 ?     S    0:00 pickup -1 -t fifo -u</blockquote></p>     <p><blockquote>21475 pts/2 R+   0:00 ps ax</blockquote></p>     <p>Здесь вы видите на самом деле очень важный процесс</p>     <p><blockquote>1     ?     Ss   0:03 init [5]</blockquote></p>     <p>В основном каждый процесс запускается другим процессом, называемым<i> родительским</i> или<i> порождающим процессом.</i> Подобным образом запущенный процесс называют<i> дочерним</i> или<i> порожденным.</i> Когда стартует ОС Linux, она выполняет единственную программу, первого предка и процесс с номером 1, <blockquote>init</blockquote>. Это, если хотите, диспетчер процессов операционной системы и прародитель всех процессов. Другие системные процессы, с которыми вы вскоре встретитесь, запускаются процессом <blockquote>init</blockquote> или другим процессом, запущенным процессом <blockquote>init</blockquote>.</p>     <p>Один из таких примеров — процедура регистрации. Процесс <blockquote>init</blockquote> запускает программу <blockquote>getty</blockquote> для каждого последовательного терминала или модема коммутируемой линии передачи, которые можно применять для регистрации. Эти процессы отображены в следующем выводе команды <blockquote>ps</blockquote>:</p>     <p><blockquote>9619  tty2  Ss+  0:00 /sbin/mingetty tty2</blockquote></p>     <p>Процессы <blockquote>getty</blockquote> ждут работы на терминале, приглашая пользователя зарегистрироваться хорошо всем знакомой строкой, и затем передают управление программе регистрации, которая устанавливает окружение пользователя и в конце запускает сеанс командной оболочки. Когда пользовательский сеанс командной оболочки завершается, процесс <blockquote>init</blockquote> запускает новый процесс <blockquote>getty</blockquote>.</p>     <p>Как видите, способность запускать новые процессы и ждать их окончания — одна из основных характеристик системы. Позже в этой главе вы узнаете, как выполнять аналогичные задачи в ваших собственных программах с помощью системных вызовов <blockquote>fork</blockquote>, <blockquote>exec</blockquote> и <blockquote>wait</blockquote>.</p>             <a name="metkadoc7"><h1>Планирование процессов</h1></a>     <p>В следующем примере вывода команды <blockquote>ps</blockquote> приведен элемент списка для самой команды <blockquote>ps</blockquote>.</p>     <p><blockquote>21475 pts/2 R+   0:00 ps ax</blockquote></p>     <p>Эта строка означает, что процесс <blockquote>21475</blockquote> находится в состоянии выполнения (<blockquote>R</blockquote>) и выполняет он команду <blockquote>ps ах</blockquote>. Таким образом, процесс описан в своем собственном выводе! Индикатор состояния показывает только то, что программа готова к выполнению, а не то, что она обязательно выполняется в данный момент. На однопроцессорном компьютере в каждый момент времени может выполняться только один процесс, в то время как другие процессы ждут своего рабочего периода. Эти периоды, называемые квантами времени, очень короткие и создают впечатление одновременного выполнения программ. Опция <blockquote>R+</blockquote> просто показывает, что данная программа — фоновая задача, не ждущая завершения других процессов или окончания ввода или вывода данных. Именно поэтому можно увидеть два таких процесса, приведенные в списке вывода <blockquote>команды</blockquote> ps. (Другой, часто встречающийся процесс, помечаемый как выполняющийся, — дисплейный сервер системы X.)</p>     <p>Ядро Linux применяет планировщик процессов для того, чтобы решить, какой процесс получит следующий квант времени. Решение принимается исходя из приоритета процесса (мы обсуждали приоритеты процессов в<i> главе 4).</i> Процессы с высоким приоритетом выполняются чаще, а другие, такие как низкоприоритетные фоновые задачи, — реже. В ОС Linux процессы не могут превысить выделенный им квант времени. Они преимущественно относятся к разным задачам, поэтому приостанавливаются и возобновляются без взаимодействия друг с другом. В более старых системах, например Windows 3.<i>х,</i> как правило, для возобновления других процессов требовалось явное согласие процесса.</p>     <p>В многозадачных системах, таких как Linux, несколько программ могут претендовать на один и тот же ресурс, поэтому программы с короткими рабочими циклами, прерывающиеся для ввода, считаются лучше ведущими себя, чем программы, прибирающие к рукам процессор для продолжительного вычисления какого-либо значения или непрерывных запросов к системе, касающихся готовности ввода данных. Хорошо ведущие себя программы называют nice-программами (привлекательными программами) и в известном смысле эту "привлекательность" можно измерить. Операционная система определяет приоритет процесса на основе значения "nice", по умолчанию равного 0, и поведения программы. Программы, выполняющиеся без пауз в течение долгих периодов, как правило, получают более низкие приоритеты. Программы, делающие паузы время от времени, например в ожидании ввода, получают награду. Это помогает сохранить отзывчивость программы, взаимодействующей с пользователем; пока она ждет какого-либо ввода от пользователя, система увеличивает ее приоритет, чтобы, когда программа будет готова возобновить выполнение, у нее был высокий приоритет. Задать значение <blockquote>nice</blockquote> для процесса можно с помощью команды <blockquote>nice</blockquote>, а изменить его — с помощью команды <blockquote>renice</blockquote>. Команда <blockquote>nice</blockquote> увеличивает на 10 значение <blockquote>nice</blockquote> процесса, присваивая ему более низкий приоритет. Просмотреть значения <blockquote>nice</blockquote> активных процессов можно с помощью опций <blockquote>-l</blockquote> или <blockquote>-f</blockquote> (для полного вывода) команды <blockquote>ps</blockquote>. Интересующие вас значения представлены в столбце <blockquote>NI</blockquote> (nice).</p>     <p><blockquote>$ <b>ps -l</b></blockquote></p>     <p><blockquote>  F S UID  PID PPID С PRI NI ADDR SZ WCHAN  TTY   TIME     CMD</blockquote></p>     <p><blockquote>000 S 500 1259 1254 0  75  0 -   710 wait4  pts/2 00:00:00 bash</blockquote></p>     <p><blockquote>000 S 500 1262 1251 0  75  0 -   714 wait4  pts/1 00:00:00 bash</blockquote></p>     <p><blockquote>000 S 500 1313 1262 0  75  0 -  2762 schedu pts/1 00:00:00 emacs</blockquote></p>     <p><blockquote>000 S 500 1362 1262 2  80  0 -   789 schedu pts/1 00:00:00 oclook</blockquote></p>     <p><blockquote>000 R 500 1363 1262 0  81  0 -   782 -      pts/1 00:00:00 ps</blockquote></p>     <p>Как видно из списка, программа <blockquote>oclock</blockquote> выполняется (как процесс 1362) со значением <blockquote>nice</blockquote> по умолчанию. Если бы она была запущена командой</p>     <p><blockquote>$ <b>nice oclock &amp;</b></blockquote></p>     <p>то получила бы значение <blockquote>nice</blockquote> +10. Если вы откорректируете это значение командой</p>     <p><blockquote>$ <b>renice 10 1362</b></blockquote></p>     <p><blockquote>1362: old priority 0, new priority 10</blockquote></p>     <p>программа <blockquote>oclock</blockquote> будет выполняться реже. Увидеть измененное значение nice можно снова с помощью команды <blockquote>ps</blockquote>:</p>     <p><blockquote>$ ps -l</blockquote></p>     <p><blockquote>F   S UID  PID PPID С PRI NI ADDR SZ WCHAN  TTY   TIME     CMD</blockquote></p>     <p><blockquote>000 S 500 1259 1254 0  75  0 -   710 wait4  pts/2 00:00:00 bash</blockquote></p>     <p><blockquote>000 S 500 1262 1251 0  75  0 -   714 wait4  pts/1 00:00:00 bash</blockquote></p>     <p><blockquote>000 S 500 1313 1262 0  75  0 -  2762 schedu pts/1 00:00:00 emacs</blockquote></p>     <p><blockquote>000 S 500 1362 1262 0  90 10 -   789 schedu pts/1 00:00:00 oclock</blockquote></p>     <p><blockquote>000 R 500 1365 1262 0  81  0 -   782 -      pts/1 00:00:00 ps</blockquote></p>     <p>Столбец состояния теперь также содержит <blockquote>N</blockquote>, указывая на то, что значение <blockquote>nice</blockquote> было изменено по сравнению с принятым по умолчанию:</p>     <p><blockquote>$ <b>ps х</b></blockquote></p>     <p><blockquote>PID  TTY   STAT TIME COMMAND</blockquote></p>     <p><blockquote>1362 pts/1 SN   0:00 oclock</blockquote></p>     <p>Поле <blockquote>PPID</blockquote> в выводе команды <blockquote>ps</blockquote> содержит ID родительского процесса (PID), либо процесса, запустившего данный процесс, либо, если этот процесс уже не выполняется, процесса <blockquote>init</blockquote> (PID, равный 1).</p>     <p>Планировщик процессов ОС Linux решает, какому процессу разрешить выполнение, на основе приоритета. Конкретные реализации конечно отличаются, но высокоприоритетные процессы выполняются чаще. В некоторых случаях низкоприоритетные процессы не выполняются совсем, если высокоприоритетные процессы готовы к выполнению.</p>              <a name="metkadoc8"><h1>Запуск новых процессов</h1></a>         <p>Применив библиотечную функцию <blockquote>system</blockquote>, вы можете заставить программу выполняться из другой программы и тем самым создать новый процесс:</p>     <p><blockquote><b>#include &lt;stdlib.h&gt;</b></blockquote></p>     <p><blockquote><b>int system(const char *string);</b></blockquote></p>     <p>Функция <blockquote>system</blockquote> выполняет команду, переданную ей как строку, и ждет ее завершения. Команда выполняется, как если бы командной оболочке была передана следующая команда:</p>     <p><blockquote>$ <b>sh -с string</b></blockquote></p>     <p>Функция <blockquote>system</blockquote> возвращает код 127, если командная оболочка не может быть запущена для выполнения команды, и -1 в случае другой ошибки. Иначе <blockquote>system</blockquote> вернет код завершения команды.</p>     <p>Выполните упражнение 11.1.</p>     <b>Упражнение 11.1. Функция <blockquote>system</blockquote></b>     <p>Вы можете использовать <blockquote>system</blockquote> для написания программы, выполняющей команду <blockquote>ps</blockquote>. Хотя нельзя сказать, что она необычайно полезна, вы увидите, как применять этот метод в последующих примерах. (Для простоты примера мы не проверяем, работает ли на самом деле системный вызов.)</p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> printf("Running ps with system\n");</blockquote></p>     <p><blockquote> system("ps ax");</blockquote></p>     <p><blockquote> printf("Done \n");</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Когда вы откомпилируете и выполните программу system1.с, то получите вывод, похожий на приведенный далее:</p>     <p><blockquote>$ <b>./system1</b></blockquote></p>     <p><blockquote>Running ps with system</blockquote></p>     <p><blockquote> PID TTY   STAT TIME COMMAND</blockquote></p>     <p><blockquote>   1 ?     Ss   0:03 init [5]</blockquote></p>     <p><blockquote>...</blockquote></p>     <p><blockquote>1262 pts/1 Ss   0:00 /bin/bash</blockquote></p>     <p><blockquote>1273 pts/2 S    0:00 su -</blockquote></p>     <p><blockquote>1274 pts/2 S+   0:00 -bash</blockquote></p>     <p><blockquote>1463 pts/2 SN   0:00 oclock</blockquote></p>     <p><blockquote>1465 pts/1 S    0:01 emacs Makefile</blockquote></p>     <p><blockquote>1480 pts/1 S+   0:00 ./system1</blockquote></p>     <p><blockquote>1481 pts/1 R+    0:00 ps ax</blockquote></p>     <p><blockquote>Done.</blockquote></p>     <p>Поскольку функция <blockquote>system</blockquote> применяет командную оболочку для запуска нужной программы, вы можете перевести ее в фоновый режим, заменив вызов функции в файле system1.с на следующий:</p>     <p><blockquote>system("ps ах &amp;");</blockquote></p>     <p>Когда вы откомпилируете и выполните эту версию программы, то получите следующий вывод:</p>     <p><blockquote>$ <b>./system2</b></blockquote></p>     <p><blockquote>Running ps with system</blockquote></p>     <p><blockquote> PID TTY  STAT TIME COMMAND</blockquote></p>     <p><blockquote>   1 ?    S    0:03 init [5]</blockquote></p>     <p><blockquote> ...</blockquote></p>     <p><blockquote>Done.</blockquote></p>     <p><blockquote>$ 1274 pts/2 3+ 0:00 -bash</blockquote></p>     <p><blockquote>1463 pts/2 SN  0:00 oclock</blockquote></p>     <p><blockquote>1465 pts/1 S   0:01 emacs Makefile</blockquote></p>     <p><blockquote>1484 pts/1 R   0:00 ps ax</blockquote></p>     <p><b>Как это работает</b></p>     <p>В первом примере программа вызывает функцию <blockquote>system</blockquote> со строкой "<blockquote>ps ах</blockquote>", выполняющую программу <blockquote>ps</blockquote>. Когда команда <blockquote>ps</blockquote> завершается, вызов <blockquote>system</blockquote> возвращает управление программе. Функция <blockquote>system</blockquote> может быть очень полезной, но она тоже ограничена. Поскольку программа вынуждена ждать, пока не завершится процесс, начатый вызовом <blockquote>system</blockquote>, вы не можете продолжить выполнение других задач.</p>     <p>Во втором примере вызов функции <blockquote>system</blockquote> вернет управление программе, как только завершится команда командной оболочки. Поскольку это запрос на выполнение программы в фоновом режиме, командная оболочка вернет управление в программу, как только будет запущена программа <blockquote>ps</blockquote>, ровно то же, что произошло бы при вводе в строку приглашения командной оболочки команды</p>     <p><blockquote>$ <b>ps ах &amp;</b></blockquote></p>     <p>Далее программа system2 выводит <blockquote>Done.</blockquote> и завершается до того, как у команды <blockquote>ps</blockquote> появится возможность отобразить до конца весь свой вывод. Вывод <blockquote>ps</blockquote> продолжает формироваться после завершения system2 и в этом случае не включает в список элемент, описывающий процесс <blockquote>system2</blockquote>. Такое поведение процесса может сильно сбить с толку пользователей. Для того чтобы умело применять процессы, вы должны лучше управлять их действиями. Давайте рассмотрим низкоуровневый интерфейс для создания процесса, <blockquote>exec</blockquote>.</p>     <blockquote>      <b>Примечание</b>      <p>Вообще применение функции <blockquote>system</blockquote> — далеко не идеальный способ создания процессов, потому что запускаемая программа использует командную оболочку. Он неэффективен вдвойне: и потому что перед запуском программы запускается оболочка, и потому что сильно зависим от варианта установки командной оболочки и применяемого окружения. В следующем разделе вы увидите гораздо более удачный способ запуска программ, который почти всегда предпочтительней применения вызова <blockquote>system</blockquote>.</p>     </blockquote>             <a name="metkadoc9"><h1>Замена образа процесса</h1></a>     <p>Существует целое семейство родственных функций, сгруппированных под заголовком <blockquote>exec</blockquote>. Они отличаются способом запуска процессов и представлением аргументов программы. Функция <blockquote>exec</blockquote> замещает текущий процесс новым, заданным в аргументе <blockquote>path</blockquote> или <blockquote>file</blockquote>. Функции <blockquote>exec</blockquote> можно применять для передачи выполнения вашей программы другой программе. Например, перед запуском другого приложения с политикой ограниченного применения вы можете проверить имя пользователя и пароль. Функции <blockquote>exec</blockquote> более эффективны по сравнению с <blockquote>system</blockquote>, т.к. исходная программа больше не будет выполняться после запуска новой программы.</p>     <p><blockquote><b>#include &lt;unistd.h&gt;</b></blockquote></p>     <p><blockquote><b>char **environ;</b></blockquote></p>     <p><blockquote><b>int execl(const char *path, const char *arg0, ..., (char *)0);</b></blockquote></p>     <p><blockquote><b>int execlp(const char *file, const char *arg0, ..., (char *)0);</b></blockquote></p>     <p><blockquote><b>int execle(const char *path, const char *arg0, ..., (char *)0,</b></blockquote></p>     <p><blockquote><b> char *const envp[]);</b></blockquote></p>     <p><blockquote><b>int execv(const char *path, char *const argv[]);</b></blockquote></p>     <p><blockquote><b>int execvp(const char *file, char *const argv[]);</b></blockquote></p>     <p><blockquote><b>int execve(const char *path, char *const argv[], char *const envp[]);</b></blockquote></p>     <p>Эти функции делятся на два вида. <blockquote>execl</blockquote>, <blockquote>execlp</blockquote> и <blockquote>execle</blockquote> принимают переменное число аргументов, заканчивающихся указателем <blockquote>null</blockquote>. У <blockquote>execv</blockquote> и <blockquote>execvp</blockquote> второй аргумент — массив строк. В обоих случаях новая программа стартует с заданными аргументами, представленными в массиве <blockquote>argv</blockquote>, передаваемом функции <blockquote>main</blockquote>.</p>     <p>Эти функции реализованы, как правило, с использованием <blockquote>execve</blockquote>, хотя нет обязательных требований на этот счет.</p>     <p>Функции, имена которых содержат суффикс <blockquote>p</blockquote>, отличаются тем, что ищут переменную окружения <blockquote>PATH</blockquote> для определения исполняемого файла новой программы. Если эта переменная не позволяет найти нужный файл, необходимо передать функции как параметр абсолютное имя файла, включающее каталоги.</p>     <p>Передать значение окружению программы может глобальная переменная <blockquote>environ</blockquote>. Другой вариант — дополнительный аргумент в функциях <blockquote>execle</blockquote> и <blockquote>execve</blockquote>, способный передавать строки, используемые как окружение новой программы.</p>     <p>Если вы хотите применить функцию <blockquote>exec</blockquote> для запуска программы <blockquote>ps</blockquote>, можно выбирать любую функцию из семейства <blockquote>exec</blockquote>, как показано в вызовах приведенного далее фрагмента программного кода:</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <br>     <p><blockquote>/* Пример списка аргументов */</blockquote></p>     <p><blockquote>/* Учтите, что для argv[0] необходимо имя программы */</blockquote></p>     <p><blockquote>char *const ps_argv[] = {"ps", "ax", 0};</blockquote></p>     <p><blockquote>/* He слишком полезный пример окружения */</blockquote></p>     <p><blockquote>char *const ps_envp[] = {"PATH=/bin:/usr/bin", "TERM=console", 0};</blockquote></p>     <br>     <p><blockquote>/* Возможные вызовы функций exec */</blockquote></p>     <p><blockquote>execl("/bin/ps", "ps", "ax", 0);</blockquote></p>     <p><blockquote>/* предполагается, что ps в /bin */</blockquote></p>     <p><blockquote>execlp("ps", "ps", "ax", 0);</blockquote></p>     <p><blockquote>/* предполагается, что /bin в PATH */</blockquote></p>     <p><blockquote>execle("/bin/ps", "ps", "ax", 0, ps_envp);</blockquote></p>     <p><blockquote>/* передается свое окружение */</blockquote></p>     <p><blockquote>execv("/bin/ps", ps_argv);</blockquote></p>     <p><blockquote>execvp("ps", ps_argv);</blockquote></p>     <p><blockquote>execve("/bin/ps", ps_argv, ps_envp);</blockquote></p>     <p>А теперь выполните упражнение 11.2.</p>     <b>Упражнение 11.2. Функция <blockquote>execlp</blockquote></b>     <p>Давайте изменим пример и используем вызов <blockquote>execlp</blockquote>:</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote><i> printf("Running ps with execlp\n");</i></blockquote></p>     <p><blockquote><i> execlp("ps", "ps", "ax", 0);</i></blockquote></p>     <p><blockquote> printf("Done.\n");</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Когда вы выполните эту программу, рехес.с, то получите обычный вывод команды <blockquote>ps</blockquote>, но без сообщения <blockquote>Done</blockquote>. Кроме того, обратите внимание на то, что в выводе нет процесса с именем <blockquote>рехес</blockquote>:</p>     <p><blockquote>$ <b>./рехес</b></blockquote></p>     <p><blockquote>Running ps with execlp</blockquote></p>     <p><blockquote> PID TTY   STAT TIME COMMAND</blockquote></p>     <p><blockquote>1    ?     S    0:03 init [5]</blockquote></p>     <p><blockquote>...</blockquote></p>     <p><blockquote>1262 pts/1 Ss   0:00 /bin/bash</blockquote></p>     <p><blockquote>1273 pts/2 S    0:00 su -</blockquote></p>     <p><blockquote>1274 pts/2 S+   0:00 -bash</blockquote></p>     <p><blockquote>1463 pts/1 SN   0:00 oclock</blockquote></p>     <p><blockquote>1465 pts/1 S    0:01 emacs Makefile</blockquote></p>     <p><blockquote>1514 pts/1 R+   0:00 ps ax</blockquote></p>     <p><b>Как это работает</b></p>     <p>Программа выводит первое сообщение и затем вызывает функцию <blockquote>execlp</blockquote>, которая ищет каталоги, заданные в переменной окружения <blockquote>PATH</blockquote> для обнаружения программы <blockquote>ps</blockquote>. Далее она выполняет команду вместо программы <blockquote>рехес</blockquote>, запустив ее так, как будто вы ввели команду командной оболочки</p>     <p><blockquote>$ <b>ps ax</b></blockquote></p>     <p>Когда <blockquote>ps</blockquote> завершается, вы получаете новую строку приглашения командной оболочки. Возврата в программу <blockquote>рехес</blockquote> не происходит, поэтому второе сообщение не выводится. PID нового процесса тот же, что и у исходного, то же самое можно сказать о PID родительского процесса и значении <blockquote>nice</blockquote>. В сущности, происходит следующее: выполняющаяся программа запустила на выполнение новый код и новый исполняемый файл, заданный в вызове функции <blockquote>exec</blockquote>.</p>     <p>Существует ограничение для общего размера списка аргументов и окружения процесса, запускаемого функциями <blockquote>exec</blockquote>. Оно задается в переменной <blockquote>ARG_MAX</blockquote> и в системах Linux равно 128 Кбайт. В других системах может задаваться меньший предельный размер, что способно порождать проблемы. Стандарт POSIX гласит, что <blockquote>ARG_MAX</blockquote> должна быть не менее 4096 байтов.</p>     <p>Функции <blockquote>exec</blockquote>, как правило, не возвращаются в программу до тех пор, пока не возникла ошибка, в этом случае задается переменная <blockquote>errno</blockquote> и функция <blockquote>exec</blockquote> возвращает -1.</p>     <p>Новые процессы, запущенные exec, наследуют многие свойства исходного процесса. В частности, открытые файловые дескрипторы остаются открытыми в новом процессе, пока не установлен их флаг <blockquote>FD_CLOEXEC</blockquote> (close on exec) (подробную информацию см. в описании системного вызова <blockquote>fcntl</blockquote> в <i>главе 3</i>). Любые открытые в исходном процессе потоки каталогов закрываются.</p>             <a name="metkadoc10"><h1>Дублирование образа процесса</h1></a>     <p>Для применения процессов, выполняющих несколько функций одновременно, можно либо использовать потоки, обсуждаемые в<i> главе 12,</i> либо создавать в программе полностью отдельный процесс, как делает <blockquote>init</blockquote>, вместо замещения текущего потока исполнения, как в случае применения функции <blockquote>exec</blockquote>.</p>     <p>Создать новый процесс можно с помощью вызова <blockquote>fork</blockquote>. Системный вызов дублирует текущий процесс, создавая новый элемент в таблице процессов с множеством атрибутов, таких же как у текущего процесса. Новый процесс почти идентичен исходному, выполняет тот же программный код, но в своем пространстве данных, окружении и со своими файловыми дескрипторами. В комбинации с функциями <blockquote>exec</blockquote> вызов <blockquote>fork</blockquote> — все, что вам нужно для создания новых процессов.</p>     <p><blockquote><b>#include &lt;sys/types.h&gt;</b></blockquote></p>     <p><blockquote><b>#include &lt;unistd.h&gt;</b></blockquote></p>     <p><blockquote><b>pid_t fork(void);</b></blockquote></p>     <p>Как видно из рис. 11.2, вызов <blockquote>fork</blockquote> возвращает в родительский процесс PID нового дочернего процесса. Новый процесс продолжает выполнение так же, как и исходный, за исключением того, что в дочерний процесс вызов <blockquote>fork</blockquote> возвращает 0. Это позволяет родительскому и дочернему процессам определить, "кто есть кто".</p>     <img src="image038.jpg"/>     <p><b>Рис. 11.2</b> </p>     <br>     <p>Если вызов <blockquote>fork</blockquote> завершается аварийно, он возвращает -1. Обычно это происходит из-за ограничения числа дочерних процессов, которые может иметь родительский процесс (<blockquote>CHILD_MAX</blockquote>), в этом случае переменной <blockquote>errno</blockquote> будет присвоено значение <blockquote>EAGAIN</blockquote>. Если для элемента таблицы процессов недостаточно места или не хватает виртуальной памяти, переменная <blockquote>errno</blockquote> получит значение <blockquote>ENOMEM</blockquote>.</p>     <p>Далее приведен фрагмент типичного программного кода, использующего вызов <blockquote>fork</blockquote>:</p>     <p><blockquote>pid_t new_pid;</blockquote></p>     <p><blockquote>new_pid = fork();</blockquote></p>     <p><blockquote>switch(new_pid) {</blockquote></p>     <p><blockquote>case -1:</blockquote></p>     <p><blockquote> /* Ошибка */</blockquote></p>     <p><blockquote> break;</blockquote></p>     <p><blockquote>case 0:</blockquote></p>     <p><blockquote> /* Мы — дочерний процесс */</blockquote></p>     <p><blockquote> break;</blockquote></p>     <p><blockquote>default:</blockquote></p>     <p><blockquote> /* Мы — родительский процесс */</blockquote></p>     <p><blockquote> break;</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Выполните упражнение 11.3.</p>     <b>Упражнение 11.3. Системный вызов <blockquote>fork</blockquote></b>     <p>Давайте рассмотрим простой пример fork1.с:</p>     <p><blockquote>#include &lt;sys/types.h&gt;</blockquote></p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> pid_t pid;</blockquote></p>     <p><blockquote> char* message;</blockquote></p>     <p><blockquote> int n;</blockquote></p>     <p><blockquote> printf("fork program starting\n");</blockquote></p>     <p><blockquote> pid = fork();</blockquote></p>     <p><blockquote> switch(pid) {</blockquote></p>     <p><blockquote> case -1:</blockquote></p>     <p><blockquote>  perror("fork failed");</blockquote></p>     <p><blockquote>  exit(1);</blockquote></p>     <p><blockquote> case 0:</blockquote></p>     <p><blockquote>  message = "This is the child";</blockquote></p>     <p><blockquote>  n = 5;</blockquote></p>     <p><blockquote>  break;</blockquote></p>     <p><blockquote> default:</blockquote></p>     <p><blockquote>  message = "This is the parent";</blockquote></p>     <p><blockquote>  n = 3;</blockquote></p>     <p><blockquote>  break;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> for (; n &gt; 0; n--) {</blockquote></p>     <p><blockquote>  puts(message);</blockquote></p>     <p><blockquote>  sleep(1);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Эта программа выполняет два процесса. Дочерний процесс создается и выводит пять раз сообщение. Исходный процесс (родитель) выводит сообщение только три раза. Родительский процесс завершается до того, как дочерний процесс выведет все свои сообщения, поэтому в вывод попадает очередное приглашение командной оболочки.</p>     <p><blockquote>$ <b>./fork1</b></blockquote></p>     <p><blockquote>fork program starting</blockquote></p>     <p><blockquote>This is the child</blockquote></p>     <p><blockquote>This is the parent</blockquote></p>     <p><blockquote>This is the parent</blockquote></p>     <p><blockquote>This is the child</blockquote></p>     <p><blockquote>This is the parent</blockquote></p>     <p><blockquote>This is the child</blockquote></p>     <p><blockquote>$ This is the child</blockquote></p>     <p><blockquote>This is the child</blockquote></p>     <p><b>Как это работает</b></p>     <p>Когда вызывается <blockquote>fork</blockquote>, эта программа делится на два отдельных процесса. Родительский процесс идентифицируется ненулевым возвращаемым из <blockquote>fork</blockquote> значением и используется для задания количества сообщений, выводимых с интервалом в одну секунду.</p>             <a name="metkadoc11"><h1>Ожидание процесса</h1></a>     <p>Когда вы запускаете дочерний процесс с помощью вызова <blockquote>fork</blockquote>, он начинает жить собственной жизнью и выполняется независимо. Иногда вам нужно знать, когда закончился дочерний процесс. Например, в предыдущей программе родительский процесс завершается раньше дочернего, и вы получаете слегка беспорядочный вывод, потому что дочерний процесс продолжает выполняться. Вы можете с помощью системного вызова <blockquote>wait</blockquote> заставить родительский процесс дождаться завершения дочернего процесса перед своим продолжением.</p>     <p><blockquote><b>#include &lt;sys/types.h&gt;</b></blockquote></p>     <p><blockquote><b>#include &lt;sys/wait.h&gt;</b></blockquote></p>     <p><blockquote><b>pid_t wait(int *stat_loc);</b></blockquote></p>     <p>Системный вызов <blockquote>wait</blockquote> заставляет родительский процесс сделать паузу до тех пор, пока один из его дочерних процессов не остановится. Вызов возвращает PID дочернего процесса. Обычно это дочерний процесс, который завершился. Сведения о состоянии позволяют родительскому процессу определить статус завершения дочернего процесса, т.е. значение, возвращенное из функции <blockquote>main</blockquote> или переданное функции <blockquote>exit</blockquote>. Если <blockquote>stat_loc</blockquote> не равен пустому указателю, информация о состоянии будет записана в то место, на которое указывает этот параметр.</p>     <p>Интерпретировать информацию о состоянии процесса можно с помощью макросов, описанных в файле sys/wait.h и приведенных в табл. 11.2.</p>     <br>     <p><b><i>Таблица 11.2</i></b></p>     <table>      <tr>       <th valign="top">Макрос</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>WIFEXITED(stat_val)</blockquote></td>       <td valign="top">Ненулевой, если дочерний процесс завершен нормально</td>      </tr>      <tr>       <td valign="top"><blockquote>WEXITSTATUS(stat_val)</blockquote></td>       <td valign="top">Если <blockquote>WIFEXITED</blockquote> ненулевой, возвращает код завершения дочернего процесса</td>      </tr>      <tr>       <td valign="top"><blockquote>WIFSIGNALED(stat_val)</blockquote></td>       <td valign="top">Ненулевой, если дочерний процесс завершается неперехватываемым сигналом</td>      </tr>      <tr>       <td valign="top"><blockquote>WTERMSIG(stat_val)</blockquote></td>       <td valign="top">Если <blockquote>WIFSIGNALED</blockquote> ненулевой, возвращает номер сигнала</td>      </tr>      <tr>       <td valign="top"><blockquote>WIFSTOPPED(stat_val)</blockquote></td>       <td valign="top">Ненулевой, если дочерний процесс остановился</td>      </tr>      <tr>       <td valign="top"><blockquote>WSTOPSIG(stat_val)</blockquote></td>       <td valign="top">Если <blockquote>WIFSTOPPED</blockquote> ненулевой, возвращает номер сигнала</td>      </tr>     </table>     <p>Выполните упражнение 11.4.</p>     <b>Упражнение 11.4. Системный вызов <blockquote>wait</blockquote></b>     <p>В этом упражнении вы слегка измените программу, чтобы можно было подождать и проверить код состояния дочернего процесса. Назовите новую программу wait.c.</p>     <p><blockquote>#include &lt;sys/types.h&gt;</blockquote></p>     <p><blockquote><i>#include &lt;sys/wait.h&gt;</i></blockquote></p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> pid_t pid;</blockquote></p>     <p><blockquote> char* message;</blockquote></p>     <p><blockquote> int n;</blockquote></p>     <p><blockquote><i> int exit_code;</i></blockquote></p>     <p><blockquote> printf("fork program starting\n");</blockquote></p>     <p><blockquote> pid = fork();</blockquote></p>     <p><blockquote> switch(pid) {</blockquote></p>     <p><blockquote> case -1:</blockquote></p>     <p><blockquote>  perror("fork failed");</blockquote></p>     <p><blockquote>  exit(1);</blockquote></p>     <p><blockquote> case 0:</blockquote></p>     <p><blockquote>  message = "This is the child";</blockquote></p>     <p><blockquote>  n = 5;</blockquote></p>     <p><blockquote><i>  exit_code = 37;</i></blockquote></p>     <p><blockquote>  break;</blockquote></p>     <p><blockquote> default:</blockquote></p>     <p><blockquote>  message = "This is the parent";</blockquote></p>     <p><blockquote>  n = 3;</blockquote></p>     <p><blockquote><i>  exit_code = 0;</i></blockquote></p>     <p><blockquote>  break;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> for (; n &gt; 0; n--) {</blockquote></p>     <p><blockquote>  puts(message);</blockquote></p>     <p><blockquote>  sleep(1);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p>Следующий фрагмент программы ждет окончания дочернего процесса:</p>     <p><blockquote> if (pid != 0) {</blockquote></p>     <p><blockquote>  int stat_val;</blockquote></p>     <p><blockquote>  pid_t child_pid;</blockquote></p>     <p><blockquote>  child_pid = wait(&amp;stat_val);</blockquote></p>     <p><blockquote>  printf("Child has finished: PID = %d\n", child_pid);</blockquote></p>     <p><blockquote>  if (WIFEXITED(stat_val))</blockquote></p>     <p><blockquote>   printf("Child exited with code %d\n", WEXITSTATUS(stat_val));</blockquote></p>     <p><blockquote>  else printf("Child terminated abnormally\n");</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> exit(exit_code);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Когда вы выполните эту программу, то увидите, что родительский процесс ждет дочерний:</p>     <p><blockquote>$ <b>./wait</b></blockquote></p>     <p><blockquote>fork program starting</blockquote></p>     <p><blockquote>This is the child</blockquote></p>     <p><blockquote>This is the parent</blockquote></p>     <p><blockquote>This is the parent</blockquote></p>     <p><blockquote>This is the child</blockquote></p>     <p><blockquote>This is the parent</blockquote></p>     <p><blockquote>This is the child</blockquote></p>     <p><blockquote>This is the child</blockquote></p>     <p><blockquote>This is the child</blockquote></p>     <p><blockquote>Child has finished: PID = 1582</blockquote></p>     <p><blockquote>Child exited with code 37</blockquote></p>     <p><blockquote>$</blockquote></p>     <p><b>Как это работает</b></p>     <p>Родительский процесс, получивший ненулевое значение, возвращенное из вызова <blockquote>fork</blockquote>, применяет системный вызов <blockquote>wait</blockquote> для приостановки своего выполнения до тех пор, пока информация о состоянии дочернего процесса не станет доступной. Это произойдет, когда дочерний процесс вызовет функцию <blockquote>exit</blockquote>; мы присвоили ему код завершения 37. Далее родительский процесс продолжается, определяет, протестировав значение, возвращенное вызовом <blockquote>wait</blockquote>, что дочерний процесс завершился нормально, и извлекает код завершения из информации о состоянии процесса.</p>             <a name="metkadoc12"><h1>Процессы-зомби</h1></a>     <p>Применение вызова <blockquote>fork</blockquote> для создания процессов может оказаться очень полезным, но вы должны отслеживать дочерние процессы. Когда дочерний процесс завершается, связь его с родителем сохраняется до тех пор, пока родительский процесс в свою очередь не завершится нормально, или не вызовет <blockquote>wait</blockquote>. Следовательно, запись о дочернем процессе не исчезает из таблицы процессов немедленно. Становясь неактивным, дочерний процесс все еще остается в системе, поскольку его код завершения должен быть сохранен, на случай если родительский процесс в дальнейшем вызовет <blockquote>wait</blockquote>. Он становится умершим или<i> процессом-зомби.</i></p>     <p>Вы сможете увидеть создание процесса-зомби, если измените количество сообщений в программе из примера с вызовом <blockquote>fork</blockquote>. Если дочерний процесс выводит меньше сообщений, чем родительский, он закончится первым и будет существовать как зомби, пока не завершится родительский процесс.</p>     <b>Упражнение 11.5. Зомби</b>     <p>Программа fork2.c такая же, как программа fork1.с, за исключением того, что количества сообщений, выводимых родительским и дочерним процессами, поменяли местами. Далее приведены соответствующие строки кода:</p>     <p><blockquote>switch (pid) {</blockquote></p>     <p><blockquote>case -1:</blockquote></p>     <p><blockquote> perror("fork failed");</blockquote></p>     <p><blockquote> exit(1);</blockquote></p>     <p><blockquote>case 0:</blockquote></p>     <p><blockquote> message = "This is the child";</blockquote></p>     <p><blockquote><i> n = 3;</i></blockquote></p>     <p><blockquote> break;</blockquote></p>     <p><blockquote>default:</blockquote></p>     <p><blockquote> message = "This is the parent";</blockquote></p>     <p><blockquote><i> n = 5;</i></blockquote></p>     <p><blockquote> break;</blockquote></p>     <p><blockquote>}</blockquote></p>     <p><b>Как это работает</b></p>     <p>Если вы выполните только что приведенную программу с помощью команды <blockquote>./fork2 &amp;</blockquote> и затем вызовите программу <blockquote>ps</blockquote> после завершения дочернего процесса, но до окончания родительского, то увидите строку, подобную следующей. (Некоторые системы могут сказать <blockquote>&lt;zombie&gt;</blockquote> вместо <blockquote>&lt;defunct&gt;</blockquote>.)</p>     <p><blockquote>$ <b>ps -аl</b></blockquote></p>     <p><blockquote>  F S UID  PID PPID С PRI NI ADDR SZ WCHAN  TTY   TIME     CMD</blockquote></p>     <p><blockquote>004 S   0 1273 1259 0  75  0 -   589 wait4  pts/2 00:00:00 su</blockquote></p>     <p><blockquote>000 S   0 1274 1273 0  75  0 -   731 schedu pts/2 00:00:00 bash</blockquote></p>     <p><blockquote>000 S 500 1463 1262 0  75  0 -   788 schedu pts/1 00:00:00 oclock</blockquote></p>     <p><blockquote>000 S 500 1465 1262 0  75  0 -  2569 schedu pts/1 00:00:01 emacs</blockquote></p>     <p><blockquote>000 S 500 1603 1262 0  75  0 -   313 schedu pts/1 00:00:00 fork2</blockquote></p>     <p><blockquote><i>003 Z 500 1604 1603 0  75  0 -     0 do_exi pts/1 00:00:00 fork2 &lt;defunct&gt;</i></blockquote></p>     <p><blockquote>000 R 500 1605 1262 0  81  0 -   781 -      pts/1 00:00:00 ps</blockquote></p>     <p>Если родительский процесс завершится необычно, дочерний процесс автоматически получит в качестве родителя процесс с PID, равным 1 (init). Теперь дочерний процесс — зомби, который уже не выполняется, но унаследован процессом <blockquote>init</blockquote> из-за необычного окончания родительского процесса. Зомби останется в таблице процессов, пока не пойман процессом <blockquote>init</blockquote>. Чем больше таблица, тем медленнее эта процедура. Следует избегать процессов-зомби, поскольку они потребляют ресурсы до тех пор, пока процесс init не вычистит их.</p>     <p>Есть еще один системный вызов, который можно применять для ожидания дочернего процесса. Он называется <blockquote>waitpid</blockquote> и применяется для ожидания завершения определенного процесса.</p>     <p><blockquote><b>#include &lt;sys/types.h&gt;</b></blockquote></p>     <p><blockquote><b>#include &lt;sys/wait.h&gt;</b></blockquote></p>     <p><blockquote><b>pid_t waitpid(pid_t pid, int *stat_loc, int options);</b></blockquote></p>     <p>Аргумент <blockquote>pid</blockquote> — конкретный дочерний процесс, окончания которого нужно ждать. Если он равен –1, <blockquote>waitpid</blockquote> вернет информацию о любом дочернем процессе. Как и вызов <blockquote>wait</blockquote>, он записывает информацию о состоянии процесса в место, указанное аргументом <blockquote>stat_loc</blockquote>, если последний не равен пустому указателю. Аргумент <blockquote>options</blockquote> позволяет изменить поведение <blockquote>waitpid</blockquote>. Наиболее полезная опция <blockquote>WNOHANG</blockquote> мешает вызову <blockquote>waitpid</blockquote> приостанавливать выполнение вызвавшего его процесса. Ее можно применять для выяснения, завершился ли какой-либо из дочерних процессов, и если нет, то продолжать выполнение. Остальные опции такие же, как в вызове <blockquote>wait</blockquote>.</p>     <p>Итак, если вы хотите, чтобы родительский процесс периодически проверял, завершился ли конкретный дочерний процесс, можно использовать следующий вызов:</p>     <p><blockquote>waitpid(child_pid, (int *)0, WNOHANG);</blockquote></p>     <p>Он вернет ноль, если дочерний процесс не завершился и не остановлен, или <blockquote>child_pid</blockquote>, если это произошло. Вызов waitpid вернет -1 в случае ошибки и установит переменную <blockquote>errno</blockquote>. Это может произойти, если нет дочерних процессов (<blockquote>errno</blockquote> равна <blockquote>ECHILD</blockquote>), если вызов прерван сигналом (<blockquote>EINTR</blockquote>) или аргумент <blockquote>options</blockquote> неверный (<blockquote>EINVAL</blockquote>).</p>             <a name="metkadoc13"><h1>Перенаправление ввода и вывода</h1></a>     <p>Вы можете применить ваши знания о процессах для изменения поведения программ, используя тот факт, что открытые файловые дескрипторы сохраняются вызовами <blockquote>fork</blockquote> и <blockquote>exec</blockquote>. Следующий пример из упражнения 11.6 содержит программу-фильтр, которая читает из стандартного ввода и пишет в свой стандартный вывод, выполняя при этом некоторое полезное преобразование.</p>     <p>Далее приведена программа очень простой фильтрации upper.c, которая читает ввод и преобразует строчные буквы в прописные:</p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;ctype.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int ch;</blockquote></p>     <p><blockquote> while ((ch = getchar()) != EOF) {</blockquote></p>     <p><blockquote>  putchar(toupper(ch));</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Когда вы выполните программу, она сделает то, что и ожидалось:</p>     <p><blockquote>$ <b>./upper</b></blockquote></p>     <p><blockquote>hello THERE</blockquote></p>     <p><blockquote>HELLO THERE</blockquote></p>     <p><blockquote><b>^D</b></blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Вы, конечно, можете применить ее для преобразования символов файла, используя перенаправление, применяемое командной оболочкой:</p>     <p><blockquote>$ <b>cat file.txt</b></blockquote></p>     <p><blockquote>this is the file, file.txt, it is all lower case.</blockquote></p>     <p><blockquote>$ <b>./upper &lt; file.txt</b></blockquote></p>     <p><blockquote>THIS IS THE FILE, FILE.TXT, IT IS ALL LOWER CASE.</blockquote></p>     <p>Что если вы хотите применить этот фильтр из другой программы? Программа useupper.c принимает имя файла как аргумент и откликается сообщением об ошибке при некорректном вызове:</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <br>     <p><blockquote>int main(int argc, char *argv[]) {</blockquote></p>     <p><blockquote> char *filename;</blockquote></p>     <p><blockquote> if (argc != 2) {</blockquote></p>     <p><blockquote>  fprintf (stderr, "usage: useupper file\n");</blockquote></p>     <p><blockquote>  exit(1);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> filename = argv[1];</blockquote></p>     <p>Вы повторно открываете стандартный ввод, снова при этом проверяете наличие любых ошибок, а затем применяете функцию <blockquote>execl</blockquote> для вызова программы upper:</p>     <p><blockquote> if (!freopen(filename, "r", stdin)) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "could not redirect stdin from file %s\n", filename);</blockquote></p>     <p><blockquote>  exit(2);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> execl("./upper", "upper", 0);</blockquote></p>     <p>He забудьте, что <blockquote>execl</blockquote> заменяет текущий процесс, если ошибок нет, оставшиеся строки не выполняются.</p>     <p><blockquote> perror("could not exec ./upper");</blockquote></p>     <p><blockquote> exit(3);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p><b>Как это работает</b></p>     <p>Когда вы выполняете эту программу, ей можно передать файл для преобразования в прописные буквы. Работа делается программой upper, которая не обрабатывает аргументы с именами файлов. Обратите внимание на то, что вам не нужен исходный код программы upper; таким способом можно запустить любую исполняемую программу.</p>     <p><blockquote>$ <b>./useupper file.txt</b></blockquote></p>     <p><blockquote>THIS IS THE FILE, FILE.TXT, IT IS ALL LOWER CASE.</blockquote></p>     <p>Программа useupper применяет <blockquote>freopen</blockquote> для закрытия стандартного ввода и связывания потока файла с файлом, заданным как аргумент программы. Затем она вызывает <blockquote>execl</blockquote>, чтобы заменить код выполняемого процесса кодом программы upper. Поскольку файловые дескрипторы сохраняются, пройдя сквозь вызов <blockquote>execl</blockquote>, программа upper выполняется так же, как при вводе ее в строке командной оболочки</p>     <p><blockquote>$ <b>./upper &lt; file.txt</b></blockquote></p>             <a name="metkadoc14"><h1>Потоки </h1></a>     <p>Процессы Linux могут взаимодействовать, отправлять друг другу сообщения и прерываться друг другом. Они могут даже организоваться и совместно использовать сегменты памяти, но они остаются обособленными объектами операционной системы. Процессы не настроены на совместное использование переменных.</p>     <p>Существует класс процесса, именуемый<i> потоком</i> (thread), который доступен во многих системах UNIX и Linux. Несмотря на то, что потоки трудно, программировать, они могут быть очень важны для некоторых приложений, таких как многопоточные серверы баз данных. Программирование потоков в Linux (и вообще в UNIX) не так распространено, как применение множественных процессов, поскольку процессы Linux очень легко применять и программирование множественных взаимодействующих процессов гораздо легче программирования потоков. Потоки обсуждаются в<i> главе 12.</i></p>              <a name="metkadoc15"><h1>Сигналы</h1></a>         <p><i>Сигнал</i> — это событие, генерируемое системами UNIX и Linux в ответ на некоторую ситуацию, получив сообщение о котором процесс, в свою очередь, может предпринять какое-то действие. Мы применяем термин<i> "возбуждать"</i> (raise) для обозначения генерации сигнала и термин<i> "захватывать"</i> (catch) для обозначения получения или приема сигнала. Сигналы возбуждаются некоторыми ошибочными ситуациями, например нарушениями сегментации памяти, ошибками процессора при выполнении операций с плавающей точкой или некорректными командами. Они генерируются командной оболочкой и обработчиками терминалов для вызова прерываний и могут явно пересылаться от одного процесса к другому как способ передачи информации или коррекции поведения. Во всех этих случаях программный интерфейс один и тот же. Сигналы могут возбуждаться, улавливаться и соответственно обрабатываться или (по крайней мере, некоторые) игнорироваться.</p>     <p>Имена сигналов задаются с помощью включенного заголовочного файла signal.h. Они начинаются с префикса <blockquote>SIG</blockquote> и включают приведенные в табл. 11.3 сигналы.</p>     <br>     <p><b><i>Таблица 11.3</i></b></p>     <table>      <tr>       <th valign="top">Имя сигнала</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>SIGABORT</blockquote></td>       <td valign="top">*Процесс аварийно завершается</td>      </tr>      <tr>       <td valign="top"><blockquote>SIGALRM</blockquote></td>       <td valign="top">Сигнал тревоги</td>      </tr>      <tr>       <td valign="top"><blockquote>SIGFPE</blockquote></td>       <td valign="top">*Исключение операции с плавающей точкой</td>      </tr>      <tr>       <td valign="top"><blockquote>SIGHUP</blockquote></td>       <td valign="top">Неожиданный останов или разъединение</td>      </tr>      <tr>       <td valign="top"><blockquote>SIGILL</blockquote></td>       <td valign="top">*Некорректная команда</td>      </tr>      <tr>       <td valign="top"><blockquote>SIGINT</blockquote></td>       <td valign="top">Прерывание терминала</td>      </tr>      <tr>       <td valign="top"><blockquote>SIGKILL</blockquote></td>       <td valign="top">Уничтожение (не может быть перехвачен или игнорирован)</td>      </tr>      <tr>       <td valign="top"><blockquote>SIGPIPE</blockquote></td>       <td valign="top">Запись в канал без считывателя</td>      </tr>      <tr>       <td valign="top"><blockquote>SIGQUIT</blockquote></td>       <td valign="top">Завершение работы терминала</td>      </tr>      <tr>       <td valign="top"><blockquote>SIGSEGV</blockquote></td>       <td valign="top">*Некорректный доступ к сегменту памяти</td>      </tr>      <tr>       <td valign="top"><blockquote>SIGTERM</blockquote></td>       <td valign="top">Завершение, выход</td>      </tr>      <tr>       <td valign="top"><blockquote>SIGUSR1</blockquote></td>       <td valign="top">Сигнал 1, определенный пользователем</td>      </tr>      <tr>       <td valign="top"><blockquote>SIGUSR2</blockquote></td>       <td valign="top">Сигнал 2, определенный пользователем</td>      </tr>     </table>     <p>*Могут быть также предприняты действия, зависящие от конкретной реализации.</p>     <br>     <p>Если процесс получает один из этих сигналов без предварительной подготовки к его перехвату, процесс будет немедленно завершен. Обычно при этом создается файл с дампом ядра. Этот файл в текущем каталоге, названный core, представляет собой образ процесса, который может оказаться полезным при отладке.</p>     <p>К дополнительным относятся сигналы, приведенные в табл. 11.4.</p>     <br>     <p><b><i>Таблица 11.4</i></b></p>     <table>      <tr>       <th valign="top">Имя сигнала</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>SIGCHLD</blockquote></td>       <td valign="top">Дочерний процесс остановлен или завершился</td>      </tr>      <tr>       <td valign="top"><blockquote>SIGCONT</blockquote></td>       <td valign="top">Продолжить выполнение, если процесс был приостановлен</td>      </tr>      <tr>       <td valign="top"><blockquote>SIGSTOP</blockquote></td>       <td valign="top">Остановить выполнение (не может захватываться или игнорироваться)</td>      </tr>      <tr>       <td valign="top"><blockquote>SIGTSTP</blockquote></td>       <td valign="top">Сигнал останова, посылаемый с терминала</td>      </tr>      <tr>       <td valign="top"><blockquote>SIGTTIN</blockquote></td>       <td valign="top">Фоновый процесс пытается читать</td>      </tr>      <tr>       <td valign="top"><blockquote>SIGTTOU</blockquote></td>       <td valign="top">Фоновый процесс пытается писать</td>      </tr>     </table>     <p>Сигнал <blockquote>SIGCHLD</blockquote> может быть полезен для управления дочерними процессами. По умолчанию он игнорируется. Остальные сигналы заставляют процессы, получившие их, остановиться, за исключением сигнала <blockquote>SIGCONT</blockquote>, который вызывает возобновление процесса. Они применяются программами командной оболочки для контроля работы и редко используются в пользовательских программах.</p>     <p>Чуть позже мы рассмотрим более подробно первую группу сигналов. Пока же достаточно знать, что если командная оболочка и драйвер терминала нормально настроены, ввод символа прерывания (обычно от нажатия комбинации клавиш &lt;Ctrl&gt;+&lt;C&gt;) с клавиатуры приведет к отправке сигнала <blockquote>SIGINT</blockquote> приоритетному процессу, т.е. программе, выполняющейся в данный момент. Это вызовет завершение программы, если в ней не предусмотрен перехват сигнала,</p>     <p>Если вы хотите отправить сигнал не текущей приоритетной задаче, а другому процессу, используйте команду <blockquote>kill</blockquote>. Она принимает для отправки процессу в качестве необязательного параметра имя сигнала или его номер и PID (который, как правило, можно определить с помощью команды ps). Например, для отправки сигнала "останов или разъединение" командной оболочке, выполняющейся на другом терминале с PID 512, вы должны применить следующую команду:</p>     <p><blockquote>$ <b>kill -HUP 512</b></blockquote></p>     <p>Удобный вариант команды <blockquote>kill</blockquote> — команда <blockquote>killall</blockquote>, которая позволяет отправить сигнал всем процессам, выполняющим конкретную команду. Не все системы UNIX поддерживают ее, но ОС Linux, как правило, поддерживает. Этот вариант полезен, когда вы не знаете PID процесса или хотите отправить сигнал нескольким разным процессам, выполняющим одну и ту же команду. Обычное применение — заставить программу <blockquote>inetd</blockquote> перечитать параметры настройки. Для этого можно воспользоваться следующей командой:</p>     <p><blockquote>$ <b>killall -HUP inetd</b></blockquote></p>     <p>Программы могут обрабатывать сигналы с помощью библиотечной функции <blockquote>signal</blockquote>.</p>     <p><blockquote><b>#include &lt;signal.h&gt;</b></blockquote></p>     <p><blockquote><b>void (*signal(int sig, void (*func)(int)))(int);</b></blockquote></p>     <p>Это довольно сложное объявление говорит о том, что <blockquote>signal</blockquote> — это функция, принимающая два параметра, <blockquote>sig</blockquote> и <blockquote>func</blockquote>. Сигнал, который нужно перехватить или игнорировать, задается аргументом <blockquote>sig</blockquote>. Функция, которую следует вызвать при получении заданного сигнала, содержится в аргументе <blockquote>func</blockquote>. Эта функция должна принимать единственный аргумент типа <blockquote>int</blockquote> (принятый сигнал) и иметь тип <blockquote>void</blockquote>. Функция сигнала возвращает функцию того же типа, которая является предыдущим значением функции, заданной для обработки сигнала, или одно из двух специальных значений:</p>     <p>&#9633; <blockquote>SIG_IGN</blockquote> — игнорировать сигнал;</p>     <p>&#9633; <blockquote>SIG_DFL</blockquote> — восстановить поведение по умолчанию.</p>     <p>Пример сделает все понятным. В упражнении 11.7 вы напишете программу ctrlc.c, которая реагирует на нажатие комбинации клавиш &lt;Ctrl&gt;+&lt;C&gt; вместо обычного завершения выводом соответствующего сообщения. Повторное нажатие &lt;Ctrl&gt;+&lt;C&gt; завершает программу.</p>     <b>Упражнение 11.7. Обработка сигнала</b>     <p>Функция <blockquote>ouch</blockquote> реагирует на сигнал, передаваемый в параметре <blockquote>sig</blockquote>. Эта функция будет вызываться, когда возникнет сигнал. Она выводит сообщение и затем восстанавливает обработку сигнала по умолчанию для сигнала SIGINT (генерируется при нажатии комбинации клавиш &lt;Ctrl&gt;+&lt;C&gt;).</p>     <p><blockquote>#include &lt;signal.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <br>     <p><blockquote>void ouch(int sig) {</blockquote></p>     <p><blockquote> printf("OUCH! - I got signal %d\n", sig);</blockquote></p>     <p><blockquote> (void)signal(SIGINT, SIG_DFL);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Функция <blockquote>main</blockquote> должна взаимодействовать с сигналом <blockquote>SIGINT</blockquote>, генерируемым при нажатии комбинации клавиш &lt;Ctrl&gt;+&lt;C&gt;. В остальное время она находится в бесконечном цикле, выводя один раз в секунду сообщение.</p>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> (void)signal(SIGINT, ouch);</blockquote></p>     <p><blockquote> while(1) {</blockquote></p>     <p><blockquote>  printf("Hello World!\n");</blockquote></p>     <p><blockquote>  sleep(1);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Ввод комбинации клавиш &lt;Ctrl&gt;+&lt;C&gt; (отображается как <blockquote>^C</blockquote> в следующем далее выводе) в первый раз заставляет программу отреагировать и продолжиться. Когда вы нажимаете &lt;Ctrl&gt;+&lt;C&gt; снова, программа завершается, т.к. сигнал <blockquote>SIGINT</blockquote> вернул программе стандартное поведение, заставляющее ее завершиться.</p>     <p><blockquote>$ <b>./ctrlcl</b></blockquote></p>     <p><blockquote>Hello World!</blockquote></p>     <p><blockquote>Hello World!</blockquote></p>     <p><blockquote>Hello World!</blockquote></p>     <p><blockquote>Hello World!</blockquote></p>     <p><blockquote><b>^C</b></blockquote></p>     <p><blockquote>OUCH! - I got signal 2</blockquote></p>     <p><blockquote>Hello World!</blockquote></p>     <p><blockquote>Hello World!</blockquote></p>     <p><blockquote>Hello World!</blockquote></p>     <p><blockquote>Hello World!</blockquote></p>     <p><blockquote><b>^C</b></blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Как видно из данного примера, функция обработки сигнала принимает один целочисленный параметр — номер сигнала, приводящий к вызову функции. Это удобно, если одна и та же функция применяется для обработки нескольких сигналов. В данном случае вы выводите значение <blockquote>SIGINT</blockquote>, которое в этой системе оказывается равным 2. Не стоит полагаться на стандартные числовые значения сигналов, в новых программах всегда пользуйтесь именами сигналов.</p>     <blockquote>      <b>Примечание</b>      <p>Вызывать из обработчика сигнала все функции, например, <blockquote>printf</blockquote>, небезопасно. Удобный метод — использовать флаг, устанавливаемый в обработчике сигнала, и затем проверять этот флаг в функции <blockquote>main</blockquote> и выводить сообщение, если нужно. В конце этой главы вы найдете список вызовов, которые можно безопасно применять в теле обработчиков сигналов.</p>     </blockquote>     <p><b>Как это работает</b></p>     <p>Программа устроена так, что, когда вы задаете сигнал <blockquote>SIGINT</blockquote>, нажимая комбинацию клавиш &lt;Ctrl&gt;+&lt;C&gt;, вызывает функцию <blockquote>ouch</blockquote>. После того как функция прерывания <blockquote>ouch</blockquote> завершится, программа продолжает выполняться, но восстанавливает реакцию на сигнал, принятую по умолчанию. (У разных версий UNIX, в особенности у потомков системы Berkeley UNIX, в течение многих лет сложилось разное поведение при получении сигналов. Если вы хотите восстановить поведение по умолчанию после возникновения сигнала, лучше всего запрограммировать его на конкретные действия.) Когда программа получает второй сигнал <blockquote>SIGINT</blockquote>, она выполняет стандартное действие, приводящее к завершению программы.</p>     <p>Если вы хотите сохранить обработчик сигнала и продолжать реагировать на комбинацию клавиш &lt;Ctrl&gt;+&lt;C&gt;, вам придется восстановить его, вызвав функцию <blockquote>signal</blockquote> еще раз. Это приведет к возникновению короткого промежутка времени, начиная с запуска функции прерывания и до момента восстановления обработчика сигнала, в течение которого сигнал не будет обрабатываться. Если второй сигнал будет получен в этот период, вопреки вашим желаниям программа может завершиться.</p>     <blockquote>      <b>Примечание</b>      <p>Мы не рекомендуем вам пользоваться функцией <blockquote>signal</blockquote> для перехвата сигналов. Мы включили ее в книгу, потому что она будет часто встречаться в более старых программах. Позже вы увидите <blockquote>sigaction</blockquote>, более четко определенный и надежный интерфейс, который следует применять в новых программах.</p>     </blockquote>     <p>Функция <blockquote>signal</blockquote> возвращает предыдущее значение обработчика для заданного типа сигнала, если таковой есть, или в противном случае <blockquote>SIG_ERR</blockquote> с установкой положительного значения в переменной <blockquote>errno</blockquote>. Если задан неверный сигнал или делается попытка обработать сигнал, который не может быть перехвачен или игнорироваться, например <blockquote>SIGKILL</blockquote>, переменной <blockquote>errno</blockquote> присваивается значение <blockquote>EINVAL</blockquote>.</p>             <a name="metkadoc16"><h1>Отправка сигналов</h1></a>     <p>Процесс может отправить сигнал другому процессу, включая себя самого, с помощью вызова функции <blockquote>kill</blockquote>. Вызов завершится аварийно, если у программы нет полномочий на отправку сигнала, часто потому что процесс-получатель принадлежит другому пользователю. Эта функция эквивалентна команде оболочки с тем же именем.</p>     <p><blockquote><b>#include &lt;sys/types.h&gt;</b></blockquote></p>     <p><blockquote><b>#include &lt;signal.h&gt;</b></blockquote></p>     <p><blockquote><b>int kill(pid_t pid, int sig);</b></blockquote></p>     <p>Функция <blockquote>kill</blockquote> посылает заданный сигнал <blockquote>sig</blockquote> процессу с идентификатором, заданным в аргументе <blockquote>pid</blockquote>. В случае успеха она возвращает 0. Для отправки сигнала посылающий процесс должен иметь право на выполнение этого действия. Обычно это означает, что у обоих процессов должен быть один и тот же идентификатор пользователя ID (т.е. вы можете отправить сигнал только одному из собственных процессов, хотя суперпользователь может отправлять сигналы любому процессу).</p>     <p>Функция <blockquote>kill</blockquote> завершится аварийно, вернет -1 и установит значение переменной <blockquote>errno</blockquote>, если задан неверный сигнал, (<blockquote>errno</blockquote> равна <blockquote>EINVAL</blockquote>), у процесса нет полномочий (<blockquote>EPERM</blockquote>) или заданный процесс не существует (<blockquote>ESRCH</blockquote>).</p>     <p>Сигналы предоставляют полезное средство, именуемое будильником или сигналом тревоги. Вызов функции <blockquote>alarm</blockquote> может применяться для формирования сигнала <blockquote>SIGALRM</blockquote> в определенное время в будущем.</p>     <p><blockquote><b>#include &lt;unistd.h&gt;</b></blockquote></p>     <p><blockquote><b>unsigned int alarm(unsigned int seconds);</b></blockquote></p>     <p>Вызов <blockquote>alarm</blockquote> намечает доставку сигнала <blockquote>SIGALRM</blockquote> через <blockquote>seconds</blockquote> секунд. В действительности сигнал будильника будет доставлен чуть позже из-за обработки задержек и учета неопределенностей. Значение 0 отменяет любой невыполненный запрос на сигнал будильника. Вызов функции <blockquote>alarm</blockquote> до получения сигнала может вызвать сброс графика доставки. У каждого процесса может быть только один невыполненный сигнал будильника. Функция <blockquote>alarm</blockquote> возвращает количество секунд, оставшихся до отправки любого невыполненного вызова, <blockquote>alarm</blockquote>, или -1 в случае аварийного завершения.</p>     <p>Для того чтобы увидеть как работает функция <blockquote>alarm</blockquote>, можно сымитировать ее действие, используя вызовы <blockquote>fork</blockquote>, <blockquote>sleep</blockquote> и <blockquote>signal</blockquote> (упражнение 11.8). Программа сможет запустить новый процесс с единственной целью — отправить сигнал спустя какое- то время.</p>     <b>Упражнение 11.8 Будильник</b>     <p>В программе alarm.c первая функция, <blockquote>ding</blockquote>, имитирует будильник.</p>     <p><blockquote>#include &lt;sys/types.h&gt;</blockquote></p>     <p><blockquote>#include &lt;signal.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <br>     <p><blockquote>static int alarm_fired = 0;</blockquote></p>     <p><blockquote>void ding(int sig) {</blockquote></p>     <p><blockquote> alarm_fired = 1;</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>В функции <blockquote>main</blockquote> вы заставляете дочерний процесс ждать пять секунд перед отправкой сигнала <blockquote>SIGALRM</blockquote> в свой родительский процесс:</p>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> pid_t pid;</blockquote></p>     <p><blockquote> printf("alarm application starting\n");</blockquote></p>     <p><blockquote> pid = fork();</blockquote></p>     <p><blockquote> switch(pid) {</blockquote></p>     <p><blockquote> case -1:</blockquote></p>     <p><blockquote>  /* Аварийное завершение */</blockquote></p>     <p><blockquote>  perror("fork failed");</blockquote></p>     <p><blockquote>  exit(1);</blockquote></p>     <p><blockquote> case 0:</blockquote></p>     <p><blockquote>  /* Дочерний процесс */</blockquote></p>     <p><blockquote>  sleep(5);</blockquote></p>     <p><blockquote>  kill(getppid(), SIGALRM);</blockquote></p>     <p><blockquote>  exit(0);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p>Родительский процесс устроен так, что перехватывает сигнал <blockquote>SIGALRM</blockquote> с помощью вызова <blockquote>signal</blockquote> и затем ждет неизбежности:</p>     <p><blockquote> /* Если мы оказались здесь, то мы — родительский процесс */</blockquote></p>     <p><blockquote> printf("waiting for alarm to go off\n");</blockquote></p>     <p><blockquote> (void)signal(SIGALRM, ding);</blockquote></p>     <p><blockquote> pause();</blockquote></p>     <p><blockquote> if (alarm_fired) printf("Ding!\n");</blockquote></p>     <p><blockquote> printf("done\n");</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Когда вы выполните программу, то увидите, что она делает паузу на пять секунд, в течение которых ждет имитации будильника:</p>     <p><blockquote>$ <b>./alarm</b></blockquote></p>     <p><blockquote>alarm application starting</blockquote></p>     <p><blockquote>waiting for alarm to go off</blockquote></p>     <p><blockquote>&lt;5 second pause&gt;</blockquote></p>     <p><blockquote>Ding!</blockquote></p>     <p><blockquote>done $</blockquote></p>     <p>В этой программе вводится новая функция <blockquote>pause</blockquote>, которая просто приостанавливает выполнение программы до появления сигнала. Когда она получит сигнал, выполняется любой установленный обработчик, и выполнение продолжается как обычно. Она объявляется следующим образом:</p>     <p><blockquote><b>#include &lt;unistd.h&gt;</b></blockquote></p>     <p><blockquote><b>int pause(void);</b></blockquote></p>     <p>Функция возвращает -1 (если следующий полученный сигнал не вызвал завершения программы) с переменной <blockquote>errno</blockquote>, равной <blockquote>EINTR</blockquote>, в случае прерывания сигналом. Лучше для ожидания сигналов применять функцию <blockquote>sigsuspend</blockquote>, которую мы обсудим чуть позже в этой главе.</p>     <p><b>Как это работает</b></p>     <p>Программа имитации будильника запускает новый процесс вызовом <blockquote>fork</blockquote>. Этот дочерний процесс ожидает пять секунд и затем посылает сигнал <blockquote>SIGALRM</blockquote> своему родителю. Родитель подготавливается к получению сигнала <blockquote>SIGALRM</blockquote> и затем делает паузу до тех пор, пока не будет получен сигнал. Функция <blockquote>printf</blockquote> не вызывается непосредственно в обработчике, вместо этого вы устанавливаете флаг, который проверяете позже.</p>     <p>Применение сигналов и приостановка выполнения — важные составляющие программирования в ОС Linux. Это означает, что программа необязательно должна выполняться все время. Вместо того чтобы долго работать в цикле, проверяя, не произошло ли событие, она может ждать его наступления. Это особенно важно в многопользовательской среде, где процессы совместно используют один процессор, и такой вид деятельного ожидания оказывает большое влияние на производительность системы. Особая проблема, связанная с сигналами, заключается в том, что вы никогда не знаете наверняка, что произойдет, если сигнал появится в середине системного вызова? (Ответ весьма неудовлетворительный: все зависит от ситуации.) Вообще следует беспокоиться только о "медленных" системных вызовах, таких как считывание с терминала, когда системный вызов может вернуться с ошибкой, если сигнал появится во время его пребывания в режиме ожидания. Если вы начнете применять сигналы в своих программах, нужно учитывать, что некоторые системные вызовы могут закончиться аварийно, если сигнал создаст ошибочную ситуацию, которую вы могли не принимать во внимание до того, как добавили обработку сигналов.</p>     <p>Нужно тщательно программировать сигналы, потому что существует ряд "состояний гонок", возникающих в программах, применяющих сигналы. Например, если вы намерены вызвать pause для ожидания сигнала и этот сигнал возникнет до вызова pause, ваша программа может ждать неопределенно долго события, которое не произойдет. Новоиспеченный программист сталкивается с множеством таких состояний гонок, важных проблем синхронизации или согласования времени. Всегда очень внимательно проверяйте программный код, использующий сигналы.</p>     <b>Надежный интерфейс сигналов</b>     <p>Мы рассмотрели подробно возбуждение и перехват сигналов с помощью <blockquote>signal</blockquote> и родственных функций, поскольку они очень часто применяются в старых UNIX-программах. Тем не менее, стандарты X/Open и спецификации UNIX рекомендуют более современный программный интерфейс для сигналов <blockquote>sigaction</blockquote>, который более надежен.</p>     <p><blockquote><b>#include &lt;signal.h&gt;</b></blockquote></p>     <p><blockquote><b>int sigaction&lt;int sig, const struct sigaction *act, struct sigaction *oact);</b></blockquote></p>     <p>Структура <blockquote>sigaction</blockquote>, применяемая для определения действий, предпринимаемых при получении сигнала, заданного в аргументе <blockquote>sig</blockquote>, определена в файле signal.h и как минимум включает следующие элементы:</p>     <p><blockquote>void (*)(int)sa_handler /* функция, SIG_DFL или SIG_IGN */</blockquote></p>     <p><blockquote>sigset_t sa_mask        /* сигналы, заблокированные для sa_handler */</blockquote></p>     <p><blockquote>int sa_flags            /* модификаторы действий сигнала */</blockquote></p>     <p>Функция <blockquote>sigaction</blockquote> задает действие, связанное с сигналом <blockquote>sig</blockquote>. Если <blockquote>oact</blockquote> не <blockquote>null</blockquote>, <blockquote>sigaction</blockquote> записывает предыдущее действие для сигнала в указанное <blockquote>oact</blockquote> место. Если <blockquote>act</blockquote> равен <blockquote>null</blockquote>, это все, что делает функция <blockquote>sigaction</blockquote>. Если указатель <blockquote>act</blockquote> не <blockquote>null</blockquote>, задается действие для указанного сигнала.</p>     <p>Как и функция <blockquote>signal</blockquote>, <blockquote>sigaction</blockquote> возвращает 0 в случае успешного выполнения и -1 в случае ошибки. Переменная <blockquote>errno</blockquote> получит значение <blockquote>EINVAL</blockquote>, если заданный сигнал некорректен или была предпринята попытка захватить или проигнорировать сигнал, который нельзя захватывать или игнорировать.</p>     <p>В структуре <blockquote>sigaction</blockquote>, на которую указывает аргумент <blockquote>act</blockquote>, <blockquote>sa_handler</blockquote> — это указатель на функцию, вызываемую при получении сигнала <blockquote>sig</blockquote>. Она очень похожа на функцию <blockquote>func</blockquote>, которая, как вы видели раньше, передавалась функции <blockquote>signal</blockquote>. Вы можете применять специальные значения <blockquote>SIG_IGN</blockquote> и <blockquote>SIG_DFL</blockquote> в поле <blockquote>sa_handler</blockquote> для обозначения того, что сигнал должен игнорироваться или должно быть восстановлено действие по умолчанию, соответственно.</p>     <p>Поле <blockquote>sa_mask</blockquote> описывает множество сигналов, которые будут добавлены в маску сигналов процесса перед вызовом функции <blockquote>sa_handler</blockquote>. Это множество сигналов, которые блокируются и не должны доставляться процессу. Такое поведение мешает возникновению ситуации, описанной ранее, в которой сигнал был получен до того, как его обработчик дошел до завершения. Применение поля <blockquote>sa_mask</blockquote> может устранить это состояние гонок.</p>     <p>Однако сигналы, захватываемые обработчиками, заданными в структуре <blockquote>sigaction</blockquote>, по умолчанию не восстанавливаются, и нужно задать в поле <blockquote>sa_flags</blockquote> значение <blockquote>SA_RESETHAND</blockquote>, если хотите добиться поведения, виденного вами раньше при обсуждении функции <blockquote>signal</blockquote>. Прежде чем обсуждать подробнее <blockquote>sigaction</blockquote>, давайте перепишем программу ctrlc.c, применяя <blockquote>sigaction</blockquote> вместо функции <blockquote>signal</blockquote> (упражнение 11.9).</p>     <b>Упражнение 11.9. Функция <blockquote>sigaction</blockquote></b>     <p>Внесите приведенные далее изменения, так чтобы сигнал <blockquote>SIGINT</blockquote> перехватывался <blockquote>sigaction</blockquote>. Назовите новую программу ctrlc2.c.</p>     <p><blockquote>#include &lt;signal.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <br>     <p><blockquote>void ouch(int sig) {</blockquote></p>     <p><blockquote> printf("OUCH! - I got signal %d\n", sig);</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> struct sigaction act;</blockquote></p>     <p><blockquote><i> act.sa_handler = ouch;</i></blockquote></p>     <p><blockquote><i> sigemptyset(&amp;act.sa_mask);</i></blockquote></p>     <p><blockquote><i> act.sa_flags = 0;</i></blockquote></p>     <p><blockquote><i> sigaction(SIGINT, &amp;act, 0);</i></blockquote></p>     <p><blockquote> while (1) {</blockquote></p>     <p><blockquote>  printf("Hello World!\n");</blockquote></p>     <p><blockquote>  sleep(1);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Когда вы выполните эту версию программы, то всегда будете получать сообщение при нажатии комбинации клавиш &lt;Ctrl&gt;+&lt;C&gt;, поскольку <blockquote>SIGINT</blockquote> обрабатывается неоднократно функцией <blockquote>sigaction</blockquote>. Для завершения программы следует нажать комбинацию клавиш &lt;Ctrl&gt;+&lt;\&gt;, которая генерирует по умолчанию сигнал <blockquote>SIIGQUIT</blockquote>.</p>     <p><blockquote>$ <b>./ctrlc2</b></blockquote></p>     <p><blockquote>Hello World!</blockquote></p>     <p><blockquote>Hello World!</blockquote></p>     <p><blockquote>Hello World!</blockquote></p>     <p><blockquote><b>^C</b></blockquote></p>     <p><blockquote>OUCH! - I got signal 2</blockquote></p>     <p><blockquote>Hello World!</blockquote></p>     <p><blockquote>Hello World!</blockquote></p>     <p><blockquote><b>^C</b></blockquote></p>     <p><blockquote>OUCH! - I got signal 2</blockquote></p>     <p><blockquote>Hello World!</blockquote></p>     <p><blockquote>Hello World!</blockquote></p>     <p><blockquote><b>^\</b></blockquote></p>     <p><blockquote>Quit</blockquote></p>     <p><blockquote>$</blockquote></p>     <p><b>Как это работает</b></p>     <p>Программа вместо функции <blockquote>signal</blockquote> вызывает <blockquote>sigaction</blockquote> для задания функции <blockquote>ouch</blockquote> как обработчика сигнала, возникающего при нажатии комбинации клавиш &lt;Ctrl&gt;+&lt;C&gt; (<blockquote>SIGINT</blockquote>). Прежде всего, она должна определить структуру <blockquote>sigaction</blockquote>, содержащую обработчик, маску сигналов и флаги, В данном случае вам не нужны никакие флаги, и создается пустая маска сигналов с помощью новой функции <blockquote>sigemptyset</blockquote>.</p>     <blockquote>      <b>Примечание</b>      <p>После выполнения программы вы можете обнаружить дамп ядра (в файле core). Его можно безбоязненно удалить.</p>     </blockquote>             <a name="metkadoc17"><h1>Множества сигналов</h1></a>     <p>В заголовочном файле signal.h определены тип <blockquote>sigset_t</blockquote> и функции, применяемые для манипулирования множествами сигналов. Эти множества используются в <blockquote>sigaction</blockquote> и других функциях для изменения поведения процесса при получении сигналов.</p>     <p><blockquote><b>#include &lt;signal.h&gt;</b></blockquote></p>     <p><blockquote><b>int sigaddset(sigset_t *set, int signo);</b></blockquote></p>     <p><blockquote><b>int sigemptyset(sigset_t *set);</b></blockquote></p>     <p><blockquote><b>int sigfillset(sigset_t *set);</b></blockquote></p>     <p><blockquote><b>int sigdelset(sigset_t *set, int signo);</b></blockquote></p>     <p>Приведенные функции выполняют операции, соответствующие их названиям, <blockquote>sigemptyset</blockquote> инициализирует пустое множество сигналов. Функция <blockquote>sigfillset</blockquote> инициализирует множество сигналов, заполняя его всеми заданными сигналами, <blockquote>sigaddset</blockquote> и <blockquote>sigdelset</blockquote> добавляют заданный сигнал (<blockquote>signo</blockquote>) в множество сигналов и удаляют его из множества. Они все возвращают 0 в случае успешного завершения и -1 в случае ошибки, заданной в переменной <blockquote>errno</blockquote>. Единственная определенная ошибка <blockquote>EINVAL</blockquote> описывает сигнал как некорректный.</p>     <p>Функция <blockquote>sigismember</blockquote> определяет, включен ли заданный сигнал в множество сигналов. Она возвращает 1, если сигнал является элементом множества, 0, если нет и -1 с <blockquote>errno</blockquote>, равной <blockquote>EINVAL</blockquote>, если сигнал неверный.</p>     <p><blockquote><b>#include &lt;signal.h&gt;</b></blockquote></p>     <p><blockquote><b>int sigismember(sigset_t *set, int signo);</b></blockquote></p>     <p>Маска сигналов процесса задается и просматривается с помощью функции <blockquote>sigprocmask</blockquote>. Маска сигналов — это множество сигналов, которые заблокированы в данный момент и не будут приниматься текущим процессом.</p>     <p><blockquote><b>#include &lt;signal.h&gt;</b></blockquote></p>     <p><blockquote><b>int sigprocmask(int how, const sigset_t *set, sigset_t *oset);</b></blockquote></p>     <p>Функция <blockquote>sigprocmask</blockquote> может изменять маску сигналов процесса разными способами в соответствии с аргументом <blockquote>how</blockquote>. Новые значения маски сигналов передаются в аргументе <blockquote>set</blockquote>, если он не равен <blockquote>null</blockquote>, а предыдущая маска сигналов будет записана в множество сигналов <blockquote>oset</blockquote>.</p>     <p>Аргумент <blockquote>how</blockquote> может принимать одно из следующих значений:</p>     <p>&#9633; <blockquote>SIG_BLOCK</blockquote> — сигналы аргумента <blockquote>set</blockquote> добавляются к маске сигналов;</p>     <p>&#9633; <blockquote>SIG_SETMASK</blockquote> —маска сигналов задается аргументом <blockquote>set</blockquote>;</p>     <p>&#9633; <blockquote>SIG_UNBLOCK</blockquote> — сигналы в аргументе <blockquote>set</blockquote> удаляются из маски сигналов.</p>     <p>Если аргумент <blockquote>set</blockquote> равен <blockquote>null</blockquote>, значение <blockquote>how</blockquote> не используется и единственная цель вызова — перенести значение текущей маски сигналов в аргумент <blockquote>oset</blockquote>.</p>     <p>Если функция <blockquote>sigprocmask</blockquote> завершается успешно, она возвращает 0. Функция вернет -1, если параметр <blockquote>how</blockquote> неверен, в этом случае переменная <blockquote>errno</blockquote> будет равна <blockquote>EINVAL</blockquote>.</p>     <p>Если сигнал заблокирован процессом, он не будет доставлен, но останется ждать обработки. Программа может определить с помощью функции <blockquote>sigpending</blockquote>, какие из заблокированных ею сигналов ждут обработки.</p>     <p><blockquote><b>#include &lt;signal.h&gt;</b></blockquote></p>     <p><blockquote><b>int sigpending(sigset_t *set);</b></blockquote></p>     <p>Она записывает множество сигналов, заблокированных от доставки и ждущих обработки, в множество сигналов, на которое указывает аргумент <blockquote>set</blockquote>. Функция возвращает 0 при успешном завершении и -1 в противном случае с переменной <blockquote>errno</blockquote>, содержащей ошибку. Данная функция может пригодиться, когда программе потребуется обрабатывать сигналы и управлять моментом вызова функции обработки.</p>     <p>С помощью функции <blockquote>sigsuspend</blockquote> процесс может приостановить выполнение, пока не будет доставлен один сигнал из множества сигналов. Это более общая форма функции <blockquote>pause</blockquote>, с которой вы уже встречались.</p>     <p><blockquote><b>#include &lt;signal.h&gt;</b></blockquote></p>     <p><blockquote><b>int sigsuspend(const sigset_t *sigmask);</b></blockquote></p>     <p>Функция <blockquote>sigsuspend</blockquote> замещает маску сигналов процесса множеством сигналов, заданным в аргументе <blockquote>sigmask</blockquote>, и затем приостанавливает выполнение. Оно будет возобновлено после выполнения функции обработки сигнала. Если полученный сигнал завершает программу, <blockquote>sigsuspend</blockquote> никогда не вернет ей управление. Если полученный сигнал не завершает программу, <blockquote>sigsuspend</blockquote> вернет с переменной <blockquote>errno</blockquote>, равной <blockquote>EINTR</blockquote>.</p>     <b>Флаги <i>sigaction</i></b>     <p>Поле <blockquote>sa_flags</blockquote> структуры <blockquote>sigaction</blockquote>, применяемой в функции <blockquote>sigaction</blockquote>, может содержать значения, изменяющие поведение сигнала (табл. 11.5).</p>     <br>     <p><b><i>Таблица 11.5</i></b></p>     <table>      <tr>       <th valign="top">Имя сигнала</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>SA_NOCLDSTOP</blockquote></td>       <td valign="top">Не генерируется <blockquote>SIGCHLD</blockquote>, когда дочерние процессы остановлены</td>      </tr>      <tr>       <td valign="top"><blockquote>SA_RESETHAND</blockquote></td>       <td valign="top">Восстанавливает при получении действие, соответствующее значению <blockquote>SIG_DFL</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>SA_RESTART</blockquote></td>       <td valign="top">Перезапускает прерванные функции вместо ошибки <blockquote>EINTR</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>SA_NODEFER</blockquote></td>       <td valign="top">При перехвате сигнала не добавляет его а маску сигналов</td>      </tr>     </table>     <p>Флаг <blockquote>SA_RESETHAND</blockquote> может применяться для автоматической очистки функции сигнала при захвате сигнала, как мы видели раньше.</p>     <p>Многие системные вызовы, которые использует программа, прерываемые, т.е. при получении сигнала они вернутся с ошибкой и переменная <blockquote>errno</blockquote> получит значение <blockquote>EINTR</blockquote>, чтобы указать, что функция вернула управление в результате получения сигнала. Поведение требует повышенного внимания со стороны приложения, использующего сигналы. Если в поле <blockquote>sa_flags</blockquote> функции <blockquote>sigaction</blockquote> установлен флаг <blockquote>SA_RESTART</blockquote>, функция, которая в противном случае могла быть прервана сигналом, вместо этого будет возобновлена, как только выполнится функция обработки сигнала.</p>     <p>Обычно, когда функция обработки сигнала выполняется, полученный сигнал добавляется в маску сигналов процесса во время работы функции обработки. Это препятствует последующему появлению того же сигнала, заставляющему функцию обработки сигнала выполняться снова. Если функция не реентерабельная, вызов ее другим экземпляром сигнала до того, как она завершит обработку первого сигнала, может создать проблемы. Но если установлен флаг <blockquote>SA_NODEFER</blockquote>, маска сигнала не меняется при получении этого сигнала.</p>     <p>Функция обработки сигнала может быть прервана в середине и вызвана снова чем-нибудь еще. Когда вы возвращаетесь к первому вызову функции, крайне важно, чтобы она все еще действовала корректно. Она должна быть не просто рекурсивной (вызывающей саму себя), а реентерабельной (в нее можно войти и выполнить ее снова). Подпрограммы ядра, обслуживающие прерывания и имеющие дело с несколькими устройствами одновременно, должны быть реентерабельными, поскольку высокоприоритетное прерывание может "войти" в тот код, который выполняется.</p>     <p>Функции, которые безопасно вызываются в обработчике сигнала и в стандарте X/Open гарантированно описанные либо как реентерабельные, либо как самостоятельно не возбуждающие сигналов, перечислены в табл. 11.6.</p>     <p>Все функции, не включенные в табл. 11.6, следует считать небезопасными в том, что касается сигналов.</p>     <br>     <p><b><i>Таблица 11.6</i></b></p>     <table>      <tr>       <td valign="top"><blockquote>access</blockquote></td>       <td valign="top"><blockquote>alarm</blockquote></td>       <td valign="top"><blockquote>cfgetispeed</blockquote></td>       <td valign="top"><blockquote>cfgetospeed</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>cfsetispeed</blockquote></td>       <td valign="top"><blockquote>cfsetospeed</blockquote></td>       <td valign="top"><blockquote>chdir</blockquote></td>       <td valign="top"><blockquote>chmod</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>chown</blockquote></td>       <td valign="top"><blockquote>close</blockquote></td>       <td valign="top"><blockquote>creat</blockquote></td>       <td valign="top"><blockquote>dup2</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>dup</blockquote></td>       <td valign="top"><blockquote>execle</blockquote></td>       <td valign="top"><blockquote>execve</blockquote></td>       <td valign="top"><blockquote>exit</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>fcntl</blockquote></td>       <td valign="top"><blockquote>fork</blockquote></td>       <td valign="top"><blockquote>fstat</blockquote></td>       <td valign="top"><blockquote>getegid</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>geteuid</blockquote></td>       <td valign="top"><blockquote>getgid</blockquote></td>       <td valign="top"><blockquote>getgroups</blockquote></td>       <td valign="top"><blockquote>getpgrp</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>getpid</blockquote></td>       <td valign="top"><blockquote>getppid</blockquote></td>       <td valign="top"><blockquote>getuid</blockquote></td>       <td valign="top"><blockquote>kill</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>link</blockquote></td>       <td valign="top"><blockquote>lseek</blockquote></td>       <td valign="top"><blockquote>mkdir</blockquote></td>       <td valign="top"><blockquote>mkfifo</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>open</blockquote></td>       <td valign="top"><blockquote>pathconf</blockquote></td>       <td valign="top"><blockquote>pause</blockquote></td>       <td valign="top"><blockquote>pipe</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>read</blockquote></td>       <td valign="top"><blockquote>rename</blockquote></td>       <td valign="top"><blockquote>rmdir</blockquote></td>       <td valign="top"><blockquote>setgid</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>setpgid</blockquote></td>       <td valign="top"><blockquote>setsid</blockquote></td>       <td valign="top"><blockquote>setuid</blockquote></td>       <td valign="top"><blockquote>sigaction</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>sigaddset</blockquote></td>       <td valign="top"><blockquote>sigdelset</blockquote></td>       <td valign="top"><blockquote>sigemptyset</blockquote></td>       <td valign="top"><blockquote>sigfillset</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>sigismember</blockquote></td>       <td valign="top"><blockquote>signal</blockquote></td>       <td valign="top"><blockquote>sigpending</blockquote></td>       <td valign="top"><blockquote>sigprocmask</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>sigsuspend</blockquote></td>       <td valign="top"><blockquote>sleep</blockquote></td>       <td valign="top"><blockquote>stat</blockquote></td>       <td valign="top"><blockquote>sysconf</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>tcdrain</blockquote></td>       <td valign="top"><blockquote>tcflow</blockquote></td>       <td valign="top"><blockquote>tcflush</blockquote></td>       <td valign="top"><blockquote>tcgetattr</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>tcgetpgrp</blockquote></td>       <td valign="top"><blockquote>tcsendbreak</blockquote></td>       <td valign="top"><blockquote>tcsetattr</blockquote></td>       <td valign="top"><blockquote>tcsetpgrp</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>time</blockquote></td>       <td valign="top"><blockquote>times</blockquote></td>       <td valign="top"><blockquote>umask</blockquote></td>       <td valign="top"><blockquote>uname</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>unlink</blockquote></td>       <td valign="top"><blockquote>utime</blockquote></td>       <td valign="top"><blockquote>wait</blockquote></td>       <td valign="top"><blockquote>waitpid</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>write</blockquote></td>       <td valign="top"> </td>       <td valign="top"> </td>       <td valign="top"> </td>      </tr>     </table>     <b>Общая сводка сигналов</b>     <p>В этом разделе мы перечисляем сигналы, в которых нуждаются программы Linux и UNIX для обеспечения стандартных реакций.</p>     <p>Стандартное действие для сигналов, перечисленных в табл. 11.7, — аварийное завершение процесса со всеми последствиями вызова функции <blockquote>_exit</blockquote> (которая похожа на <blockquote>exit</blockquote>, но не выполняет никакой очистки перед возвратом управления ядру). Тем не менее, состояние становится доступным функции <blockquote>wait</blockquote>, а функция <blockquote>waitpid</blockquote> указывает на аварийное завершение, вызванное описанным сигналом.</p>     <br>     <p><b><i>Таблица 11.7</i></b></p>     <table>      <tr>       <th valign="top">Имя сигнала</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>SIGALRM</blockquote></td>       <td valign="top">Генерируется таймером, установленным функцией <blockquote>alarm</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>SIGHUP</blockquote></td>       <td valign="top">Посылается управляющему процессу отключающимся терминалом или управляющим процессом во время завершения каждому процессу с высоким приоритетом</td>      </tr>      <tr>       <td valign="top"><blockquote>SIGINT</blockquote></td>       <td valign="top">Обычно возбуждается с терминала при нажатии комбинации клавиш &lt;Ctrl&gt;+&lt;C&gt; или сконфигурированного символа прерывания</td>      </tr>      <tr>       <td valign="top"><blockquote>SIGKILL</blockquote></td>       <td valign="top">Обычно используется из командной оболочки для принудительного завершения процесса с ошибкой, т.к. этот сигнал не может быть перехвачен или проигнорирован</td>      </tr>      <tr>       <td valign="top"><blockquote>SIGPIPE</blockquote></td>       <td valign="top">Генерируется при попытке записи в канал при отсутствии связанного с ним считывателя</td>      </tr>      <tr>       <td valign="top"><blockquote>SIGTERM</blockquote></td>       <td valign="top">Отправляется процессу как требование завершиться. Применяется UNIX при выключении для запроса остановки системных сервисов. Это сигнал, по умолчанию посылаемый командой <blockquote>kill</blockquote></td>      </tr>      <tr>       <td valign="top"><blockquote>SIGUSR1</blockquote>, <blockquote>SIGUSR2</blockquote></td>       <td valign="top">Может использоваться процессами для взаимодействия друг с другом, возможно, чтобы заставить их сообщить информацию о состоянии</td>      </tr>     </table>     <p>По умолчанию сигналы, перечисленные в табл. 11.8, также вызывают преждевременное завершение. Кроме того, могут выполняться действия, зависящие от реализации, например, создание файла core.</p>     <br>     <p><b><i>Таблица 11.8</i></b></p>     <table>      <tr>       <th valign="top">Имя сигнала</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>SIGFPE</blockquote></td>       <td valign="top">Генерируется исключительной ситуацией во время операций с плавающей точкой</td>      </tr>      <tr>       <td valign="top"><blockquote>SIGILL</blockquote></td>       <td valign="top">Процессор выполнил недопустимую команду. Обычно возбуждается испорченной программой или некорректным модулем совместно используемой памяти</td>      </tr>      <tr>       <td valign="top"><blockquote>SIGQUIT</blockquote></td>       <td valign="top">Обычно возбуждается с терминала при нажатии комбинации клавиш &lt;Ctrl&gt;+&lt;\&gt; или сконфигурированного символа завершения (quit)</td>      </tr>      <tr>       <td valign="top"><blockquote>SIGSEGV</blockquote></td>       <td valign="top">Нарушение сегментации, обычно возбуждается при чтении из некорректного участка памяти или записи в него, а также выход за границы массива или разыменование неверного указателя. Перезапись локального массива и повреждение стека могут вызвать сигнал <blockquote>SIGSEGV</blockquote> при возврате функции по неверному адресу</td>      </tr>     </table>     <p>При получении одного из сигналов, приведенных в табл. 11.9, по умолчанию процесс приостанавливается.</p>     <br>     <p><b><i>Таблица 11.9</i></b></p>     <table>      <tr>       <th valign="top">Имя сигнала</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>SIGSTOP</blockquote></td>       <td valign="top">Останавливает выполнение (не может быть захвачен или проигнорирован)</td>      </tr>      <tr>       <td valign="top"><blockquote>SIGTSTP</blockquote></td>       <td valign="top">Сигнал останова терминала часто возбуждается нажатием комбинации клавиш &lt;Ctrl&gt;+&lt;Z&gt;</td>      </tr>      <tr>       <td valign="top"><blockquote>SIGTTIN</blockquote>, <blockquote>SIGTTOU</blockquote></td>       <td valign="top">Применяются командной оболочкой для обозначения того, что фоновые задания остановлены, т.к. им необходимо прочесть данные с терминала или выполнить вывод</td>      </tr>     </table>     <p>Сигнал <blockquote>SIGCONT</blockquote> возобновляет остановленный процесс и игнорируется при получении неостановленным процессом. Сигнал <blockquote>SIGCHLD</blockquote> по умолчанию игнорируется (табл. 11.10).</p>     <br>     <p><b><i>Таблица 11.10</i></b></p>     <table>      <tr>       <th valign="top">Имя сигнала</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>SIGCONT</blockquote></td>       <td valign="top">Продолжает выполнение, если процесс остановлен</td>      </tr>      <tr>       <td valign="top"><blockquote>SIGCHLD</blockquote></td>       <td valign="top">Возбуждается, когда останавливается или завершается дочерний процесс</td>      </tr>     </table>              <a name="metkadoc18"><h1>Резюме </h1></a>    <p>В этой главе вы убедились, что процессы — это основной компонент операционной системы Linux. Вы узнали, как они могут запускаться, завершаться и просматриваться и как вы можете применять их для решения задач программирования. Вы также познакомились с сигналами, которые могут использоваться для управления действиями выполняющихся программ. Вы убедились, что все процессы Linux, вплоть до <blockquote>init</blockquote> включительно, используют одни и те же системные вызовы, доступные любому программисту.</p>     <br><br>
<center><div align="center"><a href="index.php.html">Оглавление</a></div></center>




<br>
<script type="text/javascript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="https://www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script><br>

<noindex>
<div align="center">
<center>

<!-- SAPE RTB DIV 600x340 -->
<div id="SRTB_507029"></div>
<!-- SAPE RTB END -->

</center>
</div>
</noindex>

</td>
<td width="240" valign="top">

<br>

<div id="menu3">
<ul>
<li><a href="../../alternativnaja_medicina/index.html"><span>Альтернативная медицина</span></a></li>
<li><a href="../../astronomija_i_kosmos/index.html"><span>Астрономия и Космос</span></a></li>
<li><a href="../../biologija/index.html"><span>Биология</span></a></li>
<li><a href="../../voennaja_istorija/index.html"><span>Военная история</span></a></li>
<li><a href="../../geologija_i_geografija/index.html"><span>Геология и география</span></a></li>
<li><a href="../../gosudarstvo_i_pravo/index.html"><span>Государство и право</span></a></li>
<li><a href="../../delovaja_literatura/index.html"><span>Деловая литература</span></a></li>
<li><a href="../../domashnie_zhivotnye/index.html"><span>Домашние животные</span></a></li>
<li><a href="../../domovodstvo/index.html"><span>Домоводство</span></a></li>
<li><a href="../../zdorove/index.html"><span>Здоровье</span></a></li>
<li><a href="../../istorija/index.html"><span>История</span></a></li>
<li><a href="../index.html"><span>Компьютеры и Интернет</span></a></li>
<li><a href="../../kulinarija/index.html"><span>Кулинария</span></a></li>
<li><a href="../../kulturologija/index.html"><span>Культурология</span></a></li>
<li><a href="../../literaturovedenie/index.html"><span>Литературоведение</span></a></li>
<li><a href="../../matematika/index.html"><span>Математика</span></a></li>
<li><a href="../../medicina/index.html"><span>Медицина</span></a></li>
<li><a href="../../nauchnaja_literatura_prochee/index.html"><span>Науч. литер. - прочее</span></a></li>
<li><a href="../../pedagogika/index.html"><span>Педагогика</span></a></li>
<li><a href="../../politika/index.html"><span>Политика</span></a></li>
<li><a href="../../psihologija/index.html"><span>Психология</span></a></li>
<li><a href="../../religiovedenie/index.html"><span>Религиоведение</span></a></li>
<li><a href="../../sad_i_ogorod/index.html"><span>Сад и огород</span></a></li>
<li><a href="../../samosovershenstvovanie/index.html"><span>Самосовершенствование</span></a></li>
<li><a href="../../sdelai_sam/index.html"><span>Сделай сам</span></a></li>
<li><a href="../../sport/index.html"><span>Спорт</span></a></li>
<li><a href="../../tehnicheskie_nauki/index.html"><span>Технические науки</span></a></li>
<li><a href="../../transport_i_aviacija/index.html"><span>Транспорт и авиация</span></a></li>
<li><a href="../../uchebniki/index.html"><span>Учебники</span></a></li>
<li><a href="../../fizika/index.html"><span>Физика</span></a></li>
<li><a href="../../filosofija/index.html"><span>Философия</span></a></li>
<li><a href="../../himija/index.html"><span>Химия</span></a></li>
<li><a href="../../hobbi_i_remesla/index.html"><span>Хобби и ремесла</span></a></li>
<li><a href="../../shpargalki/index.html"><span>Шпаргалки</span></a></li>
<li><a href="../../yezoterika/index.html"><span>Эзотерика</span></a></li>
<li><a href="../../yurisprudencija/index.html"><span>Юриспруденция</span></a></li>
<li><a href="../../jazykoznanie/index.html"><span>Языкознание</span></a></li>
</ul>
</div>

<br>
<div align="center">
<center>
<noindex>

<!-- SAPE RTB DIV 240x400 -->
<div id="SRTB_507028"></div>
<!-- SAPE RTB END -->

</noindex>
</center>
</div>

</td>
</tr>
<tr>
<td colspan="3" align="center">


<hr>
<a href="../../index.html"><span>Главная</span></a> | 
<a rel="sidebar" href="p15.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a> | 
<a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a> | 
<a href="p15.php.html#" onClick="scroll(0,0); return false" title="наверх">Наверх</a>
</td>
</tr>
<tr>
<td colspan="3" valign="top" align="left">
<br>

 



</td>
</tr>
</table>

<noindex>
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter21717787 = new Ya.Metrika({id:21717787,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="http://mc.yandex.ru/watch/21717787" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

</noindex>
</center>
</div></body>
</html>