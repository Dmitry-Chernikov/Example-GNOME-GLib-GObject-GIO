<html>
<head>
<meta http-equiv="Content-Language" content="ru">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<link href="../../0img/style.css" rel="stylesheet" type="text/css" />
<link rel="SHORTCUT ICON" href="http://www.redov.ru/0img/favicon.ico" type="image/x-icon"> 
<title>Глава 6 Управление текстовыми экранами с помощью библиотеки curses / Основы программирования в Linux</title>
</head>
<body>
<div align="center">
<center>
<table border="0" cellpadding="0" cellspacing="0" width="1260">
<tr>
<td colspan="3" valign="top" align="left" height="100">
<table border="0" cellpadding="0" cellspacing="0" width="1260" height="100">
<tr>
<td valign="middle" align="center" width="350">
<a href="../../index.html"><img src="../../0img/logo.jpg" width="350" height="100" title="Онлайн библиотека redov.ru"/></a>
</td>
<td valign="middle" align="center" width="910">

<noindex>

<!-- SAPE RTB JS -->
<script
    async="async"
    src="http://cdn-rtb.sape.ru/rtb-b/js/393/2/106393.js"
    type="text/javascript">
</script>
<!-- SAPE RTB END -->

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507025"></div>
<!-- SAPE RTB END -->

</noindex>

</td>
</tr>
</table>
</td>
</tr>
<tr>
<td colspan="3" valign="middle" align="left">

<div id="menu">
<ul>
		<li><a href="../../index.html"><span>Главная</span></a></li>
		<li><a rel="sidebar" href="p10.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a></li>
		<li><a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a></li>
		<li><a href="p10.php.html#" onClick="scroll(0,9999999); return false"><span>Вниз</span></a></li>
</ul>
</div>


</td>
</tr>
<tr>
<td width="240" valign="top" align="center">

<br>
<noindex>
<!-- SAPE RTB DIV 160x600 -->
<div id="SRTB_733378"></div>
<!-- SAPE RTB END -->
</noindex>



</td>
<td valign="top" align="left" style="padding-left: 5; padding-right: 5" width="780">
<br>
<noindex>
<div align="center">

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507027"></div>
<!-- SAPE RTB END -->

</div>
</noindex>
<br>



<li><a href="p10.php.html#metkadoc2">     Компиляция с библиотекой curses     </a></li>
<li><a href="p10.php.html#metkadoc3">     Терминология библиотеки curses и общие представления     </a></li>
<li><a href="p10.php.html#metkadoc4">     Экран     </a></li>
<li><a href="p10.php.html#metkadoc5">      Вывод на экран      </a></li>
<li><a href="p10.php.html#metkadoc6">      Считывание с экрана      </a></li>
<li><a href="p10.php.html#metkadoc7">      Очистка экрана      </a></li>
<li><a href="p10.php.html#metkadoc8">      Перемещение курсора      </a></li>
<li><a href="p10.php.html#metkadoc9">      Атрибуты символов      </a></li>
<li><a href="p10.php.html#metkadoc10">     Клавиатура     </a></li>
<li><a href="p10.php.html#metkadoc11">      Режимы клавиатуры      </a></li>
<li><a href="p10.php.html#metkadoc12">      Клавиатурный ввод      </a></li>
<li><a href="p10.php.html#metkadoc13">     Окна     </a></li>
<li><a href="p10.php.html#metkadoc14">      Структура <i>WINDOW</i>      </a></li>
<li><a href="p10.php.html#metkadoc15">      Универсальные функции      </a></li>
<li><a href="p10.php.html#metkadoc16">      Перемещение и обновление окна      </a></li>
<li><a href="p10.php.html#metkadoc17">      Оптимизация обновлений экрана      </a></li>
<li><a href="p10.php.html#metkadoc18">     Вложенные окна     </a></li>
<li><a href="p10.php.html#metkadoc19">     Дополнительная клавиатура     </a></li>
<li><a href="p10.php.html#metkadoc20">     Применение цвета     </a></li>
<li><a href="p10.php.html#metkadoc21">      Переопределение цветов      </a></li>
<li><a href="p10.php.html#metkadoc22">     Панели      </a></li>
<li><a href="p10.php.html#metkadoc23">     Приложение, управляющее коллекцией компакт-дисков     </a></li>
<li><a href="p10.php.html#metkadoc24">      Начало нового приложения для работы с коллекцией компакт-дисков      </a></li>
<li><a href="p10.php.html#metkadoc25">      Взгляд на функцию<i> main</i>      </a></li>
<li><a href="p10.php.html#metkadoc26">      Формирование меню      </a></li>
<li><a href="p10.php.html#metkadoc27">      Управление базой данных      </a></li>
<li><a href="p10.php.html#metkadoc28">      Запросы к базе данных компакт-дисков      </a></li>
<li><a href="p10.php.html#metkadoc29">     Резюме      </a></li>
<a name="metkadoc1"><h1>Глава 6</p>    <p>Управление текстовыми экранами с помощью библиотеки curses</h1></a>       <p>В<i> главе 5</i> вы узнали, как улучшить управление вводом символов и как обеспечить вывод символов способом, не зависящим от особенностей конкретного терминала. Проблема использования общего терминального интерфейса (GTI или termios) и манипулирование escape-последовательностями с помощью tparm и родственных функций заключается в необходимости применения большого объема программного кода низкого уровня. Для многих программ предпочтительней интерфейс высокого уровня. Мы хотели бы иметь возможность просто рисовать на экране и применять библиотеку функций для автоматического отслеживания аппаратных характеристик терминала.</p>    <p>В этой главе вы узнаете именно о такой библиотеке, называемой curses. Стандарт curses очень важен как компромисс между простыми "строковыми" программами и полностью графическими (которые обычно труднее программировать) программами в графической оболочке X Window System, такими как GTK+/GNOME и Qt/KDE, В ОС Linux есть библиотека svgatib (Super VGA Library, библиотека низкоуровневой графики), но она не является стандартной библиотекой UNIX, поэтому обычно не доступна в других UNIX-подобных операционных системах.</p>    <p>Библиотека curses применяется во многих полноэкранных приложениях как довольно легкий и аппаратно-независимый способ разработки полноэкранных, хотя и символьных программ. Такие программы почти всегда легче писать с помощью библиотеки curses, чем непосредственно применять escape-последовательности. Эта библиотека также может управлять клавиатурой, обеспечивая легкий в использовании, не блокирующий режим ввода символов.</p>    <p>Вы можете столкнуться с тем, что несколько примеров из этой главы не всегда будут отображаться на простой консоли Linux так, как вы ожидали. Бывают случаи, когда сочетание библиотеки curses и определения консоли терминала получается немного не согласованным и приводит в результате к несколько странным компоновкам при использовании curses. Но если для отображения вывода применить графическую оболочку X Window System и окно xterm, все встанет на свои места.</p>    <p>В этой главе обсуждаются следующие темы:</p>    <p>&#9633; применение библиотеки curses:</p>    <p>&#9633; основные идеи curses;</p>    <p>&#9633; управление базовыми вводом и выводом;</p>    <p>&#9633; использование множественных окон;</p>    <p>&#9633; применение режима дополнительной клавиатуры (keypad mode);</p>    <p>&#9633; добавление цвета.</p>    <p>Мы закончим главу переработкой на языке С программы, управляющей коллекцией компакт-дисков, подытожив все, чему вы научились к этому моменту.</p>          <a name="metkadoc2"><h1>Компиляция с библиотекой curses</h1></a>    <p>Библиотека curses получила свое название благодаря способности оптимизировать перемещение курсора и минимизировать необходимые обновления экрана, а следовательно, уменьшить количество символов, нуждающихся в пересылке на текстовый терминал. Несмотря на то, что сейчас количество символов вывода гораздо менее важно, чем во времена неинтеллектуальных терминалов и низкоскоростных модемов, библиотека curses выжила как полезное дополнение к набору инструментов программиста.</p>    <p>Поскольку curses — это библиотека, для ее применения необходимо включить в программу заголовочный файл, объявления функций и макросы из соответствующей системной библиотеки. Существует несколько разных реализаций библиотеки curses. Первоначальная версия появилась в системе BSD UNIX и затем была включена в разновидности UNIX стиля System V прежде, чем была стандартизована группой X/Open. Система Linux использует вариант ncurses ("new curses") — свободно распространяемую версию System V Release 4.0 curses, разработанную для Linux. Эта реализация хорошо переносится на другие версии UNIX, хотя и содержит несколько непереносимых дополнительных функций. Есть даже версии библиотеки для MS-DOS и Windows. Если вы увидите, что библиотека curses, поставляемая с вашей версией системы UNIX, не поддерживает некоторые функции, попытайтесь получить копию альтернативной библиотеки ncurses. Обычно пользователи ОС Linux обнаруживают уже установленную библиотеку ncurses или, по крайней мере, ее компоненты, необходимые для выполнения программ на базе библиотеки curses. Если инструментальные библиотеки для нее заранее не установлены в вашем дистрибутиве (нет файла curses.h или файла библиотеки curses для редактирования связей), для большинства основных дистрибутивов их всегда можно найти в виде стандартного пакета с именем наподобие ibncurses5-dev.</p>    <blockquote>     <b>Примечание</b>     <p>В стандарте X/Open определены два варианта curses: базовый и расширенный. Расширенный вариант библиотеки curses содержит разнородную кучу дополнительных функций, включая ряд функций для обработки многостолбцовых символов и подпрограммы управления цветом. Кроме приведенного далее в этой главе описания способов управления цветом, мы будем в основном привязаны к функциям базовой версии библиотеки.</p>    </blockquote>    <p>При компиляции программ, использующих curses, следует подключить заголовочный файл curses.h и на этапе редактирования связей саму библиотеку с помощью аргумента -lcurses. Во многих системах Linux вы можете применять просто библиотеку curses, а потом обнаружить, что на самом деле вы пользуетесь усовершенствованной, более новой реализацией ncurses.</p>    <p>Для того чтобы проверить, как установлена библиотека curses в вашей системе, выполните команду</p>    <p><blockquote>ls -l /usr/include/*curses.h</blockquote></p>    <p>для просмотра заголовочных файлов и</p>    <p><blockquote>ls -l /usr/lib/lib*curses*</blockquote></p>    <p>для проверки библиотечных файлов. Если вы увидите, что curses.h и ncurses.h — прямо связанные файлы, и существует файл библиотеки ncurses, то у вас есть возможность компилировать файлы из этой главы с помощью следующей команды:</p>    <p><blockquote>$ <b>gcc program. с -о program -lcurses</b></blockquote></p>    <p>Если установка curses в вашей системе не использует автоматически ncurses, вы сможете явно задать использование ncurses, включив файл ncurses.h вместо файла curses.h и выполнив следующую команду:</p>    <p><blockquote>$ <b>gcc -I/usr/include/ncurses program.с -о program -lncurses</b></blockquote></p>    <p>в которой опция <blockquote>-I</blockquote> задает каталог для поиска заголовочного файла.</p>    <blockquote>     <b>Примечание</b>     <p>В загружаемом коде сценария Makefile предполагается, что в установленной у вас системе по умолчанию применяется библиотека curses, поэтому вы должны заменить его или откомпилировать вручную, если в вашей системе это не так.</p>    </blockquote>    <p>Если вы точно не знаете, как установлена библиотека curses в вашей системе, обратитесь к страницам интерактивного справочного руководства, посвященным ncurses, или просмотрите другую интерактивную документацию; обычное место ее хранения — каталог /usr/share/doc/, в котором вы найдете каталог curses или ncurses часто с присоединенным в конце номером версии.</p>          <a name="metkadoc3"><h1>Терминология библиотеки curses и общие представления</h1></a>    <p>Подпрограммы curses действуют на экранах, в окнах и вложенных окнах или подокнах.<i> Экран</i> — это устройство (обычно экран терминала, но может быть и экран эмулятора терминала xterm), на который вы записываете информацию. Он занимает все доступное пространство дисплея этого устройства, Если экран — окно терминала в графическом окне, то он представляет собой совокупность всех доступных символьных позиций в окне терминала. Всегда существует, по крайней мере, одно окно curses с именем <blockquote>stdscr</blockquote>, совпадающее по размеру с физическим экраном. Вы можете создавать дополнительные окна с размером, меньшим, чем размер экрана. Окна могут накладываться друг на друга и иметь много вложенных окон, но каждое из них всегда должно находиться внутри родительского окна.</p>    <p>Библиотека curses поддерживает две структуры данных, действующие как отображение экрана терминала: <blockquote>stdscr</blockquote> и <blockquote>curscr</blockquote>. Структура <blockquote>stdscr</blockquote>, наиболее важная из двух, обновляется, когда функции curses формируют вывод. Структура данных <blockquote>stdscr</blockquote> — "стандартный экран". Она действует во многом так же, как стандартный вывод stdout из библиотеки stdio. Эта структура — стандартное окно вывода в программах, использующих библиотеку curses. Структура <blockquote>curscr</blockquote> похожа на <blockquote>stdscr</blockquote>, но хранит внешний вид отображаемого в текущий момент экрана. Вывод, записанный в структуру <blockquote>stdscr</blockquote>, не появляется на экране до тех пор, пока программа не вызовет функцию <blockquote>refresh</blockquote>, в которой библиотека curses сравнивает содержимое <blockquote>stdscr</blockquote> (как должен выглядеть экран) со второй структурой <blockquote>curscr</blockquote> (как выглядит экран в данный момент). Затем <blockquote>curses</blockquote> использует различия между этими двумя структурами для обновления экрана.</p>    <p>Некоторым программам с использованием curses нужно знать, что библиотека поддерживает структуру <blockquote>stdscr</blockquote>, которая применяется в нескольких функциях curses как параметр. Однако действительная структура <blockquote>stdscr</blockquote> реализуется по-разному, и к ней никогда не следует обращаться напрямую. У программ с использованием curses практически нет нужды в применении структуры <blockquote>curscr</blockquote>.</p>    <p>Таким образом, процесс вывода символов в программе с применением curses выглядит следующим образом:</p>    <p>1. Используется функция библиотеки curses для обновления логического экрана.</p>    <p>2. Запрашивается у библиотеки curses обновление физического экрана с помощью функции <blockquote>refresh</blockquote>.</p>    <p>Преимущество двухшагового подхода помимо большей легкости при программировании — очень эффективный вариант обновления экрана curses. Это может быть не столь важно для экрана консоли, но становится существенным показателем, если программа выполняется через медленное сетевое соединение.</p>    <p>Программа с использованием curses выполнит множество вызовов функций вывода на логический экран, возможно, перемещая курсор по всему экрану для того, чтобы достичь нужной позиции вывода текста или рисования линий и рамок. На каком-то этапе пользователю потребуется увидеть весь этот вывод. Когда это произойдет (обычно во время вызова функции <blockquote>refresh</blockquote>), библиотека curses найдет оптимальный способ формирования физического экрана, соответствующего логическому. Применяя нужные характеристики терминала и оптимизируя перемещения курсора, curses часто обновляет экран, выводя гораздо меньше символов по сравнению со всеми операциями записи на экран, если бы они выполнялись немедленно.</p>    <p>Макет логического экрана — это символьный массив, упорядоченный по строкам и столбцам, с начальной позицией экрана (0, 0) в левом верхнем углу (рис. 6.1).</p>    <img src="image012.jpg"/>    <p><b>Рис. 6.1</b></p>    <br>    <p>Во всех функциях библиотеки curses применяются координаты со значением<i> у </i>(строки) перед значением <i>х</i> (столбцы). Каждая позиция хранит не только символ, расположенный в этом месте экрана, но и его атрибуты. Атрибуты, которые можно отобразить, зависят от физических характеристик терминала, но, как правило, они включают жирное начертание и подчеркивание символа. На консолях Linux вам также доступны негативное изображение и цвет, о которых речь пойдет далее в этой главе.</p>    <p>Поскольку библиотека curses нуждается в создании и удалении некоторых временных структур данных, все программы с использованием curses должны инициализировать библиотеку перед применением и затем разрешить ей восстановить первоначальные установки после ее применения. Делается это с помощью вызовов пары функций: <blockquote>initscr</blockquote> и <blockquote>endwin</blockquote> (упражнение 6.1).</p>    <b>Упражнение 6.1. Программа с использованием curses, выводящая приветствие</b>    <p>В этом примере вы напишите очень простую использующую curses программу screen1.c, чтобы показать эти и другие базовые функции в действии. Далее будут описаны их прототипы.</p>    <p>1. Вставьте заголовочный файл curses.h и в функцию <blockquote>main</blockquote>, включите вызовы для инициализации и возврата в исходное состояние библиотеки curses:</p>    <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>    <p><blockquote>#include &lt;curses.h&gt;</blockquote></p>    <br>    <p><blockquote>int main() {</blockquote></p>    <p><blockquote> initscr();</blockquote></p>    <p><blockquote> ...</blockquote></p>    <p><blockquote> endwin();</blockquote></p>    <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>2. Внутрь поместите код для перемещения курсора в точку (5, 15) на логическом экране, выведите приветствие "Hello World" и обновите реальный экран. В заключение примените вызов <blockquote>sleep(2</blockquote>) для того, чтобы приостановить выполнение программы на две секунды и просмотреть вывод на экран перед ее завершением:</p>    <p><blockquote>move(5, 15);</blockquote></p>    <p><blockquote>printw("%s", "Hello World");</blockquote></p>    <p><blockquote>refresh();</blockquote></p>    <p><blockquote>sleep(2);</blockquote></p>    <p>Пока программа выполняется, вы видите фразу "Hello World" в левом верхнем квадранте пустого экрана (рис. 6.2).</p>    <img src="image013.jpg"/>    <p><b>Рис. 6.2</b></p>    <br>    <p><b>Как это работает</b></p>    <p>Эта программа инициализирует библиотеку curses, перемещает курсор в заданную точку экрана и отображает некоторый текст. После короткой паузы она закрывает библиотеку и завершается.</p>          <a name="metkadoc4"><h1>Экран</h1></a>         <p>Как: вы уже видели, все программы с использованием curses должны начинаться с вызова функции <blockquote>initscr</blockquote> и заканчиваться вызовом функции <blockquote>endwin</blockquote>. Далее приведены их описания из заголовочного файла.</p>     <p><blockquote><b>#include &lt;curses.h&gt;</b></blockquote></p>     <p><blockquote><b>WINDOW *initscr(void);</b></blockquote></p>     <p><blockquote><b>int endwin(void);</b></blockquote></p>     <p>Функция <blockquote>initscr</blockquote> должна вызываться только один раз в каждой программе. В случае успешного завершения она возвращает указатель на структуру <blockquote>stdscr</blockquote>. Если функция заканчивается аварийно, она просто выводит диагностическое сообщение об ошибке и вызывает завершение программы.</p>     <p>Функция <blockquote>endwin</blockquote> возвращает константу OK в случае успешного завершения и err в случае неудачи. Вы можете вызвать ее для того, чтобы покинуть curses, а позже возобновить функционирование библиотеки curses, вызвав <blockquote>clearok(stdscr, 1)</blockquote> и <blockquote>refresh</blockquote>. Это позволит библиотеке совершенно забыть, как выглядит физический экран, и заставит ее выполнить полное обновление экрана.</p>             <a name="metkadoc5"><h1>Вывод на экран</h1></a>     <p>Для обновления экрана предоставляется несколько базовых функций.</p>     <p><blockquote><b>#include &lt;curses.h&gt;</b></blockquote></p>     <p><blockquote><b>int addch(const chtype char_to_add);</b></blockquote></p>     <p><blockquote><b>int addchstr(chtype *const string_to_add);</b></blockquote></p>     <p><blockquote><b>int printw(char *format, ...);</b></blockquote></p>     <p><blockquote><b>int refresh(void);</b></blockquote></p>     <p><blockquote><b>int box(WINDOW *win_ptr, chtype vertical_char, chtype horizontal_char);</b></blockquote></p>     <p><blockquote><b>int insch(chtype char_to_insert);</b></blockquote></p>     <p><blockquote><b>int insertln(void);</b></blockquote></p>     <p><blockquote><b>int delch(void);</b></blockquote></p>     <p><blockquote><b>int deleteln(void);</b></blockquote></p>     <p><blockquote><b>int beep(void);</b></blockquote></p>     <p><blockquote><b>int flash(void);</b></blockquote></p>     <p>У библиотеки curses есть свой символьный тип данных <blockquote>chtype</blockquote>, который может содержать больше разрядов, чем стандартный тип <blockquote>char</blockquote>. В стандартной версии ncurses для ОС Linux <blockquote>chtype</blockquote> на самом деле — синоним стандартного типа <blockquote>unsigned long</blockquote>.</p>     <p>Функции <blockquote>addch</blockquote> и <blockquote>addchstr</blockquote> вставляют заданные символ или строку в текущую позицию на экране. Функция <blockquote>printw</blockquote> форматирует строку так же, как функция <blockquote>printf</blockquote>, и помещает в текущую позицию на экране. Функция <blockquote>refresh</blockquote> вызывает обновление физического экрана, возвращая <blockquote>OK</blockquote> в случае успеха и <blockquote>ERR</blockquote> при возникновении ошибки. Функция <blockquote>box</blockquote> позволяет нарисовать рамку вокруг окна.</p>     <blockquote>      <b>Примечание</b>      <p>В стандартной библиотеке curses вы можете применять только "обычные" символы для рисования горизонтальных и вертикальных линий. В расширенной версии библиотеки можно использовать два определения, <blockquote>ASC_VLINE</blockquote> и <blockquote>ACS_HLINE</blockquote>, для вывода символов вертикальных и горизонтальных линий соответственно, которые позволят нарисовать внешне более привлекательную рамку. Для этого ваш терминал должен поддерживать символы псевдографики. Обычно они лучше отображаются в окне эмулятора xterm, чем на стандартной консоли, но их поддержка полна корректировок или "заплат", поэтому мы полагаем, что вы откажетесь от их применения, если важна переносимость вашей программы.</p>     </blockquote>     <p>Функция <blockquote>insch</blockquote> вставляет символ, сдвигая имеющиеся символы вправо. При этом не определено, что произойдет в конце строки, результат зависит от используемого терминала. Функция <blockquote>insertln</blockquote> вставляет пустую строку, перемещая имеющиеся строки на одну вниз. Функции <blockquote>delch</blockquote> и <blockquote>deleteln</blockquote> аналогичны функциям <blockquote>insert</blockquote>.</p>     <p>Для получения звука можно вызвать функцию <blockquote>beep</blockquote>. Немногие терминалы не способны издавать звуки, в этом случае некоторые установки библиотеки curses при вызове <blockquote>beep</blockquote> заставят экран мигать. Если вы работаете в густонаселенном офисе и звуковые сигналы могут издавать многие компьютеры, возможно, вы сочтете мигание предпочтительным режимом. Как и ожидалось, функция <blockquote>flash</blockquote> вызывает мигание экрана, если это невозможно, она попробует заставить терминал издать звуковой сигнал взамен.</p>             <a name="metkadoc6"><h1>Считывание с экрана</h1></a>     <p>Вы можете считывать символы с экрана, хотя эта функциональная возможность применяется нечасто, поскольку гораздо легче отслеживать то, что выводится. Если вам все-таки это потребуется, выполняйте считывание с помощью следующих функций:</p>     <p><blockquote><b>#include &lt;curses.h&gt;</b></blockquote></p>     <p><blockquote><b>chtype inch(void);</b></blockquote></p>     <p><blockquote><b>int instr(char *string);</b></blockquote></p>     <p><blockquote><b>int innstr(char *string, int number_of_characters);</b></blockquote></p>     <p>Функция <blockquote>inch</blockquote> должна быть всегда доступна, а функции <blockquote>instr</blockquote> и <blockquote>innstr</blockquote> не всегда поддерживаются. Функция <blockquote>inch</blockquote> возвращает символ из текущей позиции курсора на экране и данные о его атрибутах. Обратите внимание на то, что функция возвращает значение не <blockquote>char</blockquote>, a <blockquote>chtype</blockquote>, в то время как функции <blockquote>instr</blockquote> и <blockquote>innstr</blockquote> пишут в массивы с элементами типа <blockquote>char</blockquote>.</p>             <a name="metkadoc7"><h1>Очистка экрана</h1></a>     <p>Существует четыре основных способа очистки области экрана:</p>     <p><blockquote><b>#include &lt;curses.h&gt;</b></blockquote></p>     <p><blockquote><b>int erase (void);</b></blockquote></p>     <p><blockquote><b>int clear(void);</b></blockquote></p>     <p><blockquote><b>int clrtobot(void);</b></blockquote></p>     <p><blockquote><b>int clrtoeol(void);</b></blockquote></p>     <p>Функция <blockquote>erase</blockquote> записывает пробелы во все позиции экрана. Функция <blockquote>clear</blockquote>, как и <blockquote>erase</blockquote>, очищает экран, но вызывает перерисовку экрана с помощью внутреннего вызова низкоуровневой функции clear<blockquote>o</blockquote>k, которая выполняет последовательность очистки экрана и новое отображение экрана при следующем вызове <blockquote>refresh</blockquote>.</p>     <p>Функция <blockquote>clear</blockquote> обычно применяет команду терминала, которая очищает весь экран, а не пытается стереть текущие непробельные символы во всех точках экрана. Это делает функцию <blockquote>clear</blockquote> надежным средством очистки экрана. Сочетание функции <blockquote>clear</blockquote> с последующей функцией <blockquote>refresh</blockquote> может обеспечить удобную команду перерисовки экрана в том случае, когда изображение на экране беспорядочно или испорчено каким-либо образом.</p>     <p>Функция <blockquote>clrtobot</blockquote> очищает экран, начиная с текущей позиции курсора и далее до конца экрана, а функция <blockquote>clrtoeol</blockquote> очищает экран, начиная с текущей позиции курсора до конца строки, в которой находится курсор.</p>             <a name="metkadoc8"><h1>Перемещение курсора</h1></a>     <p>Для перемещения курсора применяется единственная функция с дополнительной командой, управляющей положением курсора после обновления экрана.</p>     <p><blockquote><b>#include &lt;curses.h&gt;</b></blockquote></p>     <p><blockquote><b>int move(int new_y, int new_x);</b></blockquote></p>     <p><blockquote><b>int leaveok(WINDOW *window_ptr, bool leave_flag);</b></blockquote></p>     <p>Функция <blockquote>move</blockquote> просто переносит позицию логического курсора в заданное место на экране. Напоминаем о том, что начало экранных координат (0, 0) находится в левом верхнем углу экрана. В большинстве версий библиотеки curses две глобальные целочисленные переменные, <blockquote>LINES</blockquote> и <blockquote>COLUMNS</blockquote>, определяют размер физического экрана и могут применяться для определения максимально допустимых значений параметров <blockquote>new_y</blockquote> и <blockquote>new_x</blockquote>. Вызов <blockquote>move</blockquote> сам по себе не приводит к перемещению физического курсора. Он только изменяет позицию на логическом экране, в которой появится следующий вывод. Если вы хотите, чтобы экранный курсор переместился немедленно после вызова функции move, вставьте следом за ним вызов функции <blockquote>refresh</blockquote>.</p>     <p>Функция <blockquote>leaveok</blockquote> устанавливает флаг, управляющий положением курсора на физическом экране после его обновления. По умолчанию флаг равен <blockquote>false</blockquote>, и после вызова <blockquote>refresh</blockquote> аппаратный курсор остается в той же точке экрана, что и логический курсор. Если флаг равен <blockquote>true</blockquote>, аппаратный курсор можно оставить в случайно выбранной точке экрана. Как правило, значение, устанавливаемое по умолчанию, предпочтительней, т.к. курсор остается в не лишенной смысла позиции.</p>             <a name="metkadoc9"><h1>Атрибуты символов</h1></a>     <p>У всех символов, обрабатываемых curses, могут быть определенные атрибуты, управляющие способом отображения символа на экране при условии, что оборудование, применяемое для их отображения, поддерживает требуемый атрибут. Определены следующие атрибуты: <blockquote>A_BLINK</blockquote>, <blockquote>A_BOLD</blockquote>, <blockquote>A_DIM</blockquote>, <blockquote>A_REVERSE</blockquote>, <blockquote>A_STANDOUT</blockquote> и <blockquote>A_UNDERLINE</blockquote>. Вы можете использовать перечисленные далее функции для установки атрибутов по одному или все вместе.</p>     <p><blockquote><b>#include &lt;curses.h&gt;</b></blockquote></p>     <p><blockquote><b>int attron(chtype attribute);</b></blockquote></p>     <p><blockquote><b>int attroff(chtype attribute);</b></blockquote></p>     <p><blockquote><b>int attrset(chtype attribute);</b></blockquote></p>     <p><blockquote><b>int standout(void);</b></blockquote></p>     <p><blockquote><b>int standend(void);</b></blockquote></p>     <p>Функция <blockquote>attrset</blockquote> устанавливает атрибуты curses, функции <blockquote>attron</blockquote> и <blockquote>attroff</blockquote> включают и отключают заданные атрибуты, не портя остальные, а функции <blockquote>standout</blockquote> и <blockquote>standend</blockquote> обеспечивают более выразительный режим выделения или "лучший из всех" режим. На большинстве терминалов выбирается инверсия.</p>     <p>Выполните упражнение 6.2.</p>     <b>Упражнение 6.2. Перемещение, вставка и атрибуты</b>     <p>Теперь, когда вы знаете больше об управлении экраном, можно испытать более сложный пример moveadd.c. Вы включите несколько вызовов функций <blockquote>refresh</blockquote> и <blockquote>sleep</blockquote> в этот пример, чтобы на каждом шаге видеть, как выглядит экран. Обычно программы с использованием библиотеки curses стараются обновлять экран как можно реже, поскольку это не слишком высокопроизводительная операция. Программный код написан с некоторой долей искусственности для обеспечения большей наглядности.</p>     <p>1. Для начала вставьте несколько заголовочных файлов, определите несколько символьных массивов и указатель на них, а затем инициализируйте структуры библиотеки curses:</p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <p><blockquote>#include &lt;curses.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> const char witch_one[] = " First Witch ";</blockquote></p>     <p><blockquote> const char witch_two[] = " Second Witch ";</blockquote></p>     <p><blockquote> const char *scan_ptr;</blockquote></p>     <p><blockquote> initscr();</blockquote></p>     <p>2. Теперь для трех начальных текстовых фрагментов, которые появляются на экране через определенные интервалы, включите и отключите соответствующие флаги атрибутов;</p>     <p><blockquote> move(5, 15);</blockquote></p>     <p><blockquote> attron(A_BOLD);</blockquote></p>     <p><blockquote> printw("%s", "Macbeth");</blockquote></p>     <p><blockquote> attroff(A_BOLD);</blockquote></p>     <p><blockquote> refresh();</blockquote></p>     <p><blockquote> sleep(1);</blockquote></p>     <p><blockquote> move(8, 15);</blockquote></p>     <p><blockquote> attron(A_STANDOUT);</blockquote></p>     <p><blockquote> printw("%s", "Thunder and Lightning");</blockquote></p>     <p><blockquote> attroff(A_STANDOUT);</blockquote></p>     <p><blockquote> refresh();</blockquote></p>     <p><blockquote> sleep(1);</blockquote></p>     <p><blockquote> move(10, 10);</blockquote></p>     <p><blockquote> printw("%s", "When shall we three meet again");</blockquote></p>     <p><blockquote> move(11, 23);</blockquote></p>     <p><blockquote> printw("%s", "In thunder, lightning, or in rain ?");</blockquote></p>     <p><blockquote> move(13, 10);</blockquote></p>     <p><blockquote> printw("%s", "When the hurlyburly's done, ");</blockquote></p>     <p><blockquote> move(14, 23);</blockquote></p>     <p><blockquote> printw("%s", "When the battle's lost and won.");</blockquote></p>     <p><blockquote> refresh();</blockquote></p>     <p><blockquote> sleep(1);</blockquote></p>     <p>3. Действующие лица идентифицированы, и их имена выводятся посимвольно:</p>     <p><blockquote> attron(A_DIM);</blockquote></p>     <p><blockquote> scan_ptr = witch_one + strlen(witch_one) - 1;</blockquote></p>     <p><blockquote> while (scan_ptr != witch_one) {</blockquote></p>     <p><blockquote>  move(10, 10);</blockquote></p>     <p><blockquote>  insch(*scan_ptr--);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> scan_ptr = witch_two + strlen(witch_two) - 1;</blockquote></p>     <p><blockquote> while (scan_ptr != witch_two) {</blockquote></p>     <p><blockquote>  move(13, 10);</blockquote></p>     <p><blockquote>  insch(*scan_ptr--);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> attroff(A_DIM);</blockquote></p>     <p><blockquote> refresh();</blockquote></p>     <p><blockquote> sleep(1);</blockquote></p>     <p>4. В заключение переместите курсор в правый нижний угол экрана, а затем подготовьте и выполните завершение:</p>     <p><blockquote> move(LINES - 1, COLS - 1);</blockquote></p>     <p><blockquote> refresh();</blockquote></p>     <p><blockquote> sleep(1);</blockquote></p>     <p><blockquote> endwin();</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Когда вы выполните программу, заключительный экран будет выглядеть так, как показано на рис. 6.3. К сожалению, снимок экрана не дает полного впечатления и не показывает курсор, установленный в правом нижнем углу экрана. Эмулятор xterm может быть более подходящей средой для точного отображения программ, чем обычная консоль.</p>     <img src="image014.jpg"/>     <p><b>Рис. 6.3</b></p>     <br>     <p><b>Как это работает</b></p>     <p>После инициализации некоторых переменных и экрана с помощью библиотеки curses вы применили функции <blockquote>move</blockquote> для перемещения курсора по экрану. Посредством функций <blockquote>attron</blockquote> и <blockquote>attroff</blockquote> вы управляли атрибутами текста, выводимого в заданную точку экрана. Далее перед закрытием библиотеки curses и завершением программа продемонстрировала, как вставлять символы функцией <blockquote>insch</blockquote>.</p>              <a name="metkadoc10"><h1>Клавиатура</h1></a>         <p>Наряду с предоставлением интерфейса, облегчающего управление экраном, библиотека curses также предлагает средства, облегчающие управление клавиатурой.</p>             <a name="metkadoc11"><h1>Режимы клавиатуры</h1></a>     <p>Процедуры считывания с клавиатуры управляются режимами. Режимы устанавливаются с помощью следующих функций:</p>     <p><blockquote><b>#include &lt;curses.h&gt;</b></blockquote></p>     <p><blockquote><b>int echo(void);</b></blockquote></p>     <p><blockquote><b>int noecho(void);</b></blockquote></p>     <p><blockquote><b>int cbreak(void);</b></blockquote></p>     <p><blockquote><b>int nocbreak(void);</b></blockquote></p>     <p><blockquote><b>int raw(void);</b></blockquote></p>     <p><blockquote><b>int noraw(void);</b></blockquote></p>     <p>Функции <blockquote>echo</blockquote> и <blockquote>noecho</blockquote> просто включают и отключают отображение символов, набираемых на клавиатуре. Оставшиеся четыре функции управляют тем, как символы, набранные на терминале, становятся доступны программе с применением curses. Для того чтобы понять функцию <blockquote>cbreak</blockquote>, необходимо иметь представление о стандартном режиме ввода. Когда программа, использующая библиотеку curses, стартует с вызова функции <blockquote>initscr</blockquote>, устанавливается режим ввода, называемый <i>режимом с обработкой</i> (cooked mode). Это означает построчную обработку, т.е. ввод становится доступен программе после нажатия пользователем клавиши &lt;Enter&gt; (или &lt;Return&gt; на некоторых клавиатурах). Специальные символы на клавиатуре включены, поэтому набор соответствующих клавиатурных последовательностей может сгенерировать сигнал в программе. Управление потоком, если терминал запускается с терминала, также включено. Вызывая функцию <blockquote>cbreak</blockquote>, программа может установить режим ввода <blockquote>cbreak</blockquote>, в котором символы становятся доступными программе сразу после их набора, а не помещаются в буфер и передаются программе только после нажатия клавиши &lt;Enter&gt;. Как и в режиме с обработкой, специальные символы клавиатуры действуют, а простые клавиши, например &lt;Backspace&gt;, передаются для обработки непосредственно в программу, поэтому если вы хотите, чтобы нажатие клавиши &lt;Backspace&gt; приводило к привычным действиям, то вы должны запрограммировать их самостоятельно.</p>     <p>Вызов функции <blockquote>raw</blockquote> отключает обработку специальных символов, поэтому становится невозможной генерация сигналов или управление потоком с помощью набранных на клавиатуре специальных символьных последовательностей. Вызов функции <blockquote>nocbreak</blockquote> возвращает режим ввода в режим с обработкой символов, но режим обработки специальных символов не изменяет; вызов <blockquote>noraw</blockquote> восстанавливает и режим с обработкой, и обработку специальных символов.</p>             <a name="metkadoc12"><h1>Клавиатурный ввод</h1></a>     <p>Чтение с клавиатуры — очень простая операция. К основным функциям чтения относятся следующие:</p>     <p><blockquote><b>#include &lt;curses.h&gt;</b></blockquote></p>     <p><blockquote><b>int getch(void);</b></blockquote></p>     <p><blockquote><b>int getstr(char *string);</b></blockquote></p>     <p><blockquote><b>int getnstr(char *string, int number_of_characters);</b></blockquote></p>     <p><blockquote><b>int scanw(char *format, ...);</b></blockquote></p>     <p>Все они действуют подобно своим аналогам, не входящим в библиотеку curses, <blockquote>getchar</blockquote>, <blockquote>gets</blockquote> и <blockquote>scanf</blockquote>. Обратите внимание на то, что у функции <blockquote>getstr</blockquote> нет возможности ограничить длину возвращаемой строки, поэтому применять ее следует с большой осторожностью. Если ваша версия библиотеки curses поддерживает функцию <blockquote>getnstr</blockquote>, позволяющую ограничить количество считываемых символов, всегда применяйте ее вместо функции <blockquote>getstr</blockquote>. Это очень напоминает поведение функций <blockquote>gets</blockquote> и <blockquote>fgets</blockquote>, с которыми вы познакомились в<i> главе 3.</i></p>     <p>В упражнении 6.3 для демонстрации управления клавиатурой приведен пример короткой программы ipmode.c.</p>     <b>Упражнение 6.3. Режим клавиатуры и ввод</b>     <p>1. Наберите программу и включите в нее начальные вызовы библиотеки curses:</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;curses.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <p><blockquote>#define PW_LEN 256</blockquote></p>     <p><blockquote>#define NAME_LEN 256</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> char name[NAME_LEN];</blockquote></p>     <p><blockquote> char password[PW_LEN];</blockquote></p>     <p><blockquote> const char *real_password = "xyzzy";</blockquote></p>     <p><blockquote> int i = 0;</blockquote></p>     <p><blockquote> initscr();</blockquote></p>     <p><blockquote> move(5, 10);</blockquote></p>     <p><blockquote> printw("%s", "Please login:");</blockquote></p>     <p><blockquote> move(7, 10);</blockquote></p>     <p><blockquote> printw("%s", "User name: ");</blockquote></p>     <p><blockquote> getstr(name);</blockquote></p>     <p><blockquote> move(9, 10);</blockquote></p>     <p><blockquote> printw("%s", "Password: ");</blockquote></p>     <p><blockquote> refresh();</blockquote></p>     <p>2. Когда пользователь вводит свой пароль, необходимо остановить отображение символов на экране. Далее сравните введенный пароль со строкой xyzzy:</p>     <p><blockquote> cbreak();</blockquote></p>     <p><blockquote> noecho();</blockquote></p>     <p><blockquote> memset(password, '\0', sizeof(password));</blockquote></p>     <p><blockquote> while (i &lt; PW_LEN) {</blockquote></p>     <p><blockquote>  password[i] = getch();</blockquote></p>     <p><blockquote>  if (password[i] == '\n') break;</blockquote></p>     <p><blockquote>  move(8, 20 + i);</blockquote></p>     <p><blockquote>  addch('*');</blockquote></p>     <p><blockquote>  refresh();</blockquote></p>     <p><blockquote>  i++;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p>3. В заключение восстановите отображение символов и выведите сообщение об успешном или неудачном завершении:</p>     <p><blockquote> echo();</blockquote></p>     <p><blockquote> nocbreak();</blockquote></p>     <p><blockquote> move(11, 10);</blockquote></p>     <p><blockquote> if (strncmp(real_password, password, strlen(real_password)) == 0)</blockquote></p>     <p><blockquote>   printw("%s", "Correct");</blockquote></p>     <p><blockquote> else printw("%s", "Wrong");</blockquote></p>     <p><blockquote> printw("%s", " password");</blockquote></p>     <p><blockquote> refresh();</blockquote></p>     <p><blockquote> sleep(2);</blockquote></p>     <p><blockquote> endwin();</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p><b>Как это работает</b></p>     <p>Остановив отображение клавиатурного ввода и установив режим <blockquote>cbreak</blockquote>, вы выделяете область памяти, готовую к приему пароля. Каждый введенный символ пароля немедленно обрабатывается, и на экран выводится <blockquote>*</blockquote> в следующей позиции курсора. Вам необходимо каждый раз обновлять экран и сравнивать с помощью функции <blockquote>strcmp</blockquote> две строки: введенный и реальный пароли.</p>     <blockquote>      <b>Примечание</b>      <p>Если вы пользуетесь очень старой версией библиотеки curses, вам, возможно, понадобится выполнить дополнительный вызов функции <blockquote>refresh</blockquote> перед вызовом функции <blockquote>getstr</blockquote>. В библиотеке ncurses вызов <blockquote>getstr</blockquote> обновляет экран автоматически.</p>     </blockquote>              <a name="metkadoc13"><h1>Окна</h1></a>         <p>До сих пор вы использовали терминал как средство полноэкранного вывода. Это вполне подходит для маленьких простых программ, но библиотека curses идет гораздо дальше. Вы можете на физическом экране одновременно отображать множество окон разных размеров. Многие из описанных в этом разделе функций поддерживаются в терминах стандарта X/Open так называемой "расширенной" версией curses. Но поскольку они поддерживаются библиотекой ncurses, не велика проблема сделать их доступными на большинстве платформ. Пора идти дальше и применить множественные окна. Вы увидите, как обобщаются до сих пор использовавшиеся команды и применяются в сценариях с множественными окнами.</p>             <a name="metkadoc14"><h1>Структура <i>WINDOW</i></h1></a>     <p>Несмотря на то, что мы уже упоминали стандартный экран <blockquote>stdscr</blockquote>, пока у вас не было необходимости в его применении, поскольку почти все рассматриваемые до сих пор функции полагали, что они работают на экране <blockquote>stdscr</blockquote>, и не требовалось передавать его как параметр.</p>     <p><blockquote>stdscr</blockquote> — это специальный случай структуры <blockquote>WINDOW</blockquote>, как stdout — специальный случай файлового потока. Обычно структура <blockquote>WINDOW</blockquote> объявляется в файле curses.h и, несмотря на то, что ее просмотр может быть очень поучителен, программы никогда не используют эту структуру напрямую, т.к. она может различаться в разных реализациях.</p>     <p>Вы можете создать и уничтожить окно с помощью вызовов функций newwin и delwin:</p>     <p><blockquote><b>#include &lt;curses.h&gt;</b></blockquote></p>     <p><blockquote><b>WINDOW *newwin(int num_of_lines, int num_of_cols, int start_y, int start_x);</b></blockquote></p>     <p><blockquote><b>int delwin(WINDOW *window_to_delete);</b></blockquote></p>     <p>Функция <blockquote>newwin</blockquote> создает новое окно в позиции экрана (<blockquote>start_y, int start_x</blockquote>) и с заданным. количеством строк и столбцов. Она возвращает указатель на новое окно или <blockquote>NULL</blockquote>, если создать окно невозможно. Если вы хотите, чтобы правый нижний угол нового окна совпадал с правым нижним углом экрана, можно задать нулевое количество строк и столбцов. Все окна должны располагаться в пределах экрана. Функция <blockquote>newwin</blockquote> завершится аварийно, если какая-либо часть окна окажется за пределами экрана. Новое окно, созданное <blockquote>newwin</blockquote>, абсолютно независимо от всех уже имеющихся окон. По умолчанию оно помещается поверх существующих окон, скрывая (но не изменяя) их содержимое.</p>     <p>Функция <blockquote>delwin</blockquote> удаляет окно, созданное ранее с помощью функции <blockquote>newwin</blockquote>. Поскольку при вызове <blockquote>newwin</blockquote>, по всей вероятности, выделяется память, следует всегда удалять окна, когда в них больше нет нужды.</p>     <blockquote>      <b>Примечание</b>      <p>Следите за тем, чтобы никогда не было попыток удалить собственные окна библиотеки curses: <blockquote>stdscr</blockquote> и <blockquote>curscr</blockquote>!</p>     </blockquote>     <p>Когда новое окно создано, как записать в него информацию? У всех уже рассмотренных функций есть универсальные версии, действующие в заданных окнах, и для удобства в них также включено перемещение курсора.</p>             <a name="metkadoc15"><h1>Универсальные функции</h1></a>     <p>Вы уже применяли функции <blockquote>addch</blockquote> и <blockquote>printw</blockquote> для вставки символов на экран. К этим функциям, как и ко многим другим, может быть добавлен префикс либо <blockquote>w</blockquote> для окна, либо <blockquote>mv</blockquote> для перемещения курсора, либо <blockquote>mvw</blockquote> для перемещения и окна. Если вы посмотрите заголовочный файл большинства версий библиотеки curses, то увидите, что многие функции, применявшиеся до сих пор, — простые макросы (<blockquote>#defines</blockquote>), вызывающие эти более универсальные функции.</p>     <p>Когда добавляется префикс <blockquote>w</blockquote>, в начало списка аргументов должен быть вставлен указатель типа <blockquote>WINDOW</blockquote>. Когда добавляется префикс <blockquote>mv</blockquote>, в начало списка нужно вставить два дополнительных параметра, координаты<i> y</i> и<i> х.</i> Они задают позицию на экране, в которой выполняется операция,<i> у</i> и <i>х</i> — относительные координаты окна, точка (0, 0) находится в левом верхнем углу<i> окна,</i> а не<i> экрана.</i></p>     <p>Когда добавляется префикс <blockquote>mvw</blockquote>, необходимо передавать в функцию три дополнительных параметра: указатель <blockquote>WINDOW</blockquote> и значения<i> у и х.</i> Как ни странно, указатель <blockquote>WINDOW</blockquote> всегда в списке предшествует экранным координатам, несмотря на то, что, судя по префиксу,<i> у</i> и <i>х</i> должны быть первыми.</p>     <p>Далее для примера приведен полный набор прототипов для семейств функций <blockquote>addch</blockquote> и <blockquote>printw</blockquote>.</p>     <p><blockquote><b>#include &lt;curses.h&gt;</b></blockquote></p>     <p><blockquote><b>int addch(const chtype char);</b></blockquote></p>     <p><blockquote><b>int waddch(WINDOW *window_pointer, const chtype char);</b></blockquote></p>     <p><blockquote><b>int mvaddch(int y, int x, const chtype char);</b></blockquote></p>     <p><blockquote><b>int mvwaddch(WINDOW *window_pointer, int y, int x, const chtype char);</b></blockquote></p>     <p><blockquote><b>int printw(char *format, ...);</b></blockquote></p>     <p><blockquote><b>int wprintw(WINDOW *window_pointer, char *format, ...);</b></blockquote></p>     <p><blockquote><b>int mvprintw(int y, int x, char *format, ...);</b></blockquote></p>     <p><blockquote><b>int mvwprintw(WINDOW *window_pointer, int y, int x, char *format, ...);</b></blockquote></p>     <p>У многих других функций, например <blockquote>inch</blockquote>, также есть варианты оконные и с перемещением курсора.</p>             <a name="metkadoc16"><h1>Перемещение и обновление окна</h1></a>     <p>Следующие команды позволят вам перемещать и перерисовывать окна:</p>     <p><blockquote><b>#include &lt;curses.h&gt;</b></blockquote></p>     <p><blockquote><b>int mvwin(WINDOW *window_to move, int new_y, int new x);</b></blockquote></p>     <p><blockquote><b>int wrefresh(WINDOW *window_ptr);</b></blockquote></p>     <p><blockquote><b>int wclear(WINDOW *window_ptr);</b></blockquote></p>     <p><blockquote><b>int werase(WINDOW *window_ptr);</b></blockquote></p>     <p><blockquote><b>int touchwin(WINDOW *window_ptr);</b></blockquote></p>     <p><blockquote><b>int scrollok(WINDOW *window_ptr, bool scroll_flag);</b></blockquote></p>     <p><blockquote><b>int scroll(WINDOW *window_ptr);</b></blockquote></p>     <p>Функция <blockquote>mvwin</blockquote> перемещает окно по экрану. Поскольку окно целиком должно располагаться в области экрана, функция <blockquote>mvwin</blockquote> завершится аварийно, если вы попытаетесь переместить окно так, что какая-то его часть выйдет за пределы экрана.</p>     <p>Функции <blockquote>wrefresh</blockquote>, <blockquote>wclear</blockquote> и <blockquote>werase</blockquote> — просто обобщения функций, с которыми вы встречались ранее; они только принимают указатель <blockquote>WINDOW</blockquote>, поэтому могут ссылаться на конкретное окно, а не на окно stdscr.</p>     <p>Функция <blockquote>touchwin</blockquote> довольно специальная. Она информирует библиотеку curses о том, что содержимое окна, на которое указывает ее параметр, было изменено. Это означает, что curses всегда будет перерисовывать такое окно при следующем вызове функции <blockquote>wrefresh</blockquote>, даже если вы на самом деле не меняли содержимое этого окна. Эта функция очень полезна для определения отображаемого окна при наличии нескольких перекрывающихся окон, загромождающих экран.</p>     <p>Две функции <blockquote>scroll</blockquote> управляют прокруткой окна. Функция <blockquote>scrollok</blockquote> при передаче логического значения true (обычно ненулевого) включает прокрутку окна. По умолчанию окна не прокручиваются. Функция <blockquote>scroll</blockquote> просто прокручивает окно на одну строку вверх. В некоторые реализации библиотеки curses входит и функция <blockquote>wsctl</blockquote>, которая также принимает количество строк для прокрутки, которое может быть и отрицательным числом. Мы вернемся к прокрутке немного позже в этой главе.</p>     <p>А теперь выполните упражнение 6.4.</p>     <b>Упражнение 6.4. Управление множественными окнами</b>     <p>Теперь, зная, как управлять несколькими окнами, вы можете включить эти новые функции в программу multiw1.c. Для краткости проверка ошибок не приводится.</p>     <p>1. Как обычно, вставьте первыми отсортированные объявления:</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;curses.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> WINDOW *new_window_ptr;</blockquote></p>     <p><blockquote> WINDOW *popup_windov_ptr;</blockquote></p>     <p><blockquote> int x loop;</blockquote></p>     <p><blockquote> int y_loop;</blockquote></p>     <p><blockquote> char a_letter = 'a';</blockquote></p>     <p><blockquote> initscr();</blockquote></p>     <p>2. Заполните базовое окно символами, обновляя физический экран, когда заполнен логический экран:</p>     <p><blockquote> move(5, 5);</blockquote></p>     <p><blockquote> printw("%s", "Testing multiple windows");</blockquote></p>     <p><blockquote> refresh();</blockquote></p>     <p><blockquote> for (y_loop = 0; y_loop &lt; LINES - 1; y_loop++) {</blockquote></p>     <p><blockquote>  for (x_loop = 0; x_loop &lt; COLS - 1; x_loop++) {</blockquote></p>     <p><blockquote>   mvwaddch(stdscr, y_loop, x_loop, a_letter);</blockquote></p>     <p><blockquote>   a_letter++;</blockquote></p>     <p><blockquote>   if (a_letter &gt; 'z') a_letter = 'a';</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> /* Обновление экрана */</blockquote></p>     <p><blockquote> refresh();</blockquote></p>     <p><blockquote> sleep(2);</blockquote></p>     <p>3. Теперь создайте окно 10&#215;20 и вставьте в него текст перед прорисовкой окна на экране:</p>     <p><blockquote> new_window_ptr = newwin(10, 20, 5, 5);</blockquote></p>     <p><blockquote> mvwprintw(new_window_ptr, 2, 2, "%s", "Hello World");</blockquote></p>     <p><blockquote> mwwprintw(new_window_ptr, 5, 2, "%s",</blockquote></p>     <p><blockquote>  "Notice how very long lines wrap inside the window");</blockquote></p>     <p><blockquote> wrefresh(new_window_ptr);</blockquote></p>     <p><blockquote> sleep(2);</blockquote></p>     <p>4. Измените содержимое фонового окна. Когда вы обновите экран, окно, на которое указывает <blockquote>new_window_ptr</blockquote>, будет затемнено:</p>     <p><blockquote> a_letter = '0';</blockquote></p>     <p><blockquote> for (y_lоор = 0; y_lоор &lt; LINES - 1; y_lоор++) {</blockquote></p>     <p><blockquote>  for (х_lоор = 0; xloop &lt; COLS - 1; х_lоор++) {</blockquote></p>     <p><blockquote>   mvwaddch(stdscr, y_loop, х_lоор, a_letter);</blockquote></p>     <p><blockquote>   a_letter++;</blockquote></p>     <p><blockquote>   if (a_letter &gt; '9') a_letter = '0';</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> refresh();</blockquote></p>     <p><blockquote> sleep(2);</blockquote></p>     <p>5. Если вы выполните вызов для обновления нового окна, ничего не изменится, поскольку вы не изменяли новое окно:</p>     <p><blockquote> wrefresh(new_window_ptr);</blockquote></p>     <p><blockquote> sleep(2);</blockquote></p>     <p>6. Но если вы сначала воспользуетесь функцией <blockquote>touchwin</blockquote> и заставите библиотеку curses думать, что окно было изменено, следующий вызов функции wrefresh снова отобразит новое окно на переднем плане.</p>     <p><blockquote> touchwin(new_window_ptr);</blockquote></p>     <p><blockquote> wrefresh(new_window_ptr);</blockquote></p>     <p><blockquote> sleep(2);</blockquote></p>     <p>7. Добавьте еще одно накладывающееся окно с рамкой вокруг него.</p>     <p><blockquote> popup_window_ptr = newwin(10, 20, 8, 8);</blockquote></p>     <p><blockquote> box(popup_window_ptr, '|', '-');</blockquote></p>     <p><blockquote> mvwprintw(popup_window_ptr, 5, 2, "%s", "Pop Up Window!");</blockquote></p>     <p><blockquote> wrefresh(popup_window_ptr);</blockquote></p>     <p><blockquote> sleep(2);</blockquote></p>     <p>8. Поиграйте с новыми всплывающими окнами перед их очисткой и удалением.</p>     <p><blockquote> touchwin(new_window_ptr);</blockquote></p>     <p><blockquote> wrefresh(new_window_ptr);</blockquote></p>     <p><blockquote> sleep(2);</blockquote></p>     <p><blockquote> wclear(new_window_ptr);</blockquote></p>     <p><blockquote> wrefresh(new_window_ptr);</blockquote></p>     <p><blockquote> sleep(2);</blockquote></p>     <p><blockquote> delwin(new_window_ptr);</blockquote></p>     <p><blockquote> touchwin(popup_window_ptr);</blockquote></p>     <p><blockquote> wrefresh(popup_window_ptr);</blockquote></p>     <p><blockquote> sleep(2);</blockquote></p>     <p><blockquote> delwin(popup_window_ptr);</blockquote></p>     <p><blockquote> touchwin(stdscr);</blockquote></p>     <p><blockquote> refresh();</blockquote></p>     <p><blockquote> sleep(2);</blockquote></p>     <p><blockquote> endwin();</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>К сожалению, нет возможности продемонстрировать выполнение этого фрагмента в книге, но на рис. 6.4 показан снимок экрана после отображения первого всплывающего окна.</p>     <img src="image015.jpg"/>     <p><b>Рис. 6.4</b></p>     <br>     <p>После того как будет изменен фон и появится новое всплывающее окно, вы увидите экран, показанный на рис. 6.5.</p>     <img src="image016.jpg"/>     <p><b>Рис. 6.5</b></p>     <br>     <p><b>Как это работает</b></p>     <p>После обычной инициализации программа заполняет стандартный экран цифрами, чтобы легче было увидеть новые окна, вставляемые на передний план. Далее показано, как можно наложить на фон новое окно с включенным в него текстом, разбитым на строки в соответствии с шириной окна. Далее вы видите, как с помощью функции <blockquote>touchwin</blockquote> заставить curses перерисовать окно, даже если в нем ничего не менялось.</p>     <p>Затем перед закрытием curses и завершением программы вставляется второе окно, перекрывающее первое, чтобы показать, как библиотека curses может управлять перекрывающимися окнами.</p>     <p>Как видно из программного кода примера, при обновлении окон следует быть очень внимательным, чтобы они отображались в нужной очередности. Библиотека curses не хранит никаких сведений об иерархии окон, поэтому если вы попросите curses обновить несколько окон, управлять их иерархией придется вам.</p>     <blockquote>      <b>Примечание</b>      <p>Для того чтобы библиотека curses отображала окна в нужном порядке, их следует обновлять в этом порядке. Один из способов добиться этого — сохранять все указатели ваших окон в массиве или списке, в которых поддерживается порядок их размещения, соответствующий порядку их появления на экране.</p>     </blockquote>             <a name="metkadoc17"><h1>Оптимизация обновлений экрана</h1></a>     <p>Как вы видели в примере из упражнения 6.4, обновление множественных окон требует некоторой ловкости, но не слишком обременительно. Но может возникнуть более серьезная проблема, если нуждающийся в обновлении терминал подключен через медленное сетевое соединение. К счастью, в наши дни с ней сталкиваются очень редко, но ее обработка настолько легка, что мы рассмотрим ее просто для полноты картины.</p>     <p>Задача состоит в минимизации количества символов, прорисовываемых на экране, поскольку при наличии медленных линий связи рисование на экране может оказаться утомительно долгим. Библиотека curses предлагает специальный метод обновления экрана с помощью пары функций <blockquote>wnoutrefresh</blockquote> и <blockquote>doupdate</blockquote>:</p>     <p><blockquote><b>#include &lt;curses.h&gt;</b></blockquote></p>     <p><blockquote><b>int wnoutrefresh(WINDOW *window_ptr);</b></blockquote></p>     <p><blockquote><b>int doupdate(void);</b></blockquote></p>     <p>Функция <blockquote>wnoutrefresh</blockquote> определяет, какие символы необходимо отправить на экран, но не отправляет их на самом деле. Функция <blockquote>doupdate</blockquote> действительно отправляет изменения на терминал. Если вы просто вызовите <blockquote>wnoutrefresh</blockquote>, а за ней тут же функцию <blockquote>doupdate</blockquote>, эффект будет такой же, как при вызове функции <blockquote>wrefresh</blockquote>. Однако если вы хотите перерисовать ряд окон, то можете вызвать функцию <blockquote>wnoutrefresh</blockquote> для каждого окна (конечно, в нужном порядке) и затем вызвать <blockquote>doupdate</blockquote> только после последнего вызова <blockquote>wnoutrefresh</blockquote>. Это позволит библиотеке curses выполнить расчеты, связанные с обновлением экрана, по очереди для каждого окна и только после этого вывести обновленный экран. Такой подход почти всегда позволяет curses минимизировать количество символов, нуждающихся в пересылке.</p>              <a name="metkadoc18"><h1>Вложенные окна</h1></a>    <p>Теперь, когда мы рассмотрели множественные окна, остановимся на специальном случае множественных окон, называемом <i>вложенными окнами</i> или<i> подокнами. </i>Создаются и уничтожаются вложенные окна с помощью следующих вызовов:</p>    <p><blockquote><b>#include &lt;curses.h&gt;</b></blockquote></p>    <p><blockquote><b>WINDOW *subwin(WINDOW *parent, int num_of_lines, int num_of_cols,</b></blockquote></p>    <p><blockquote><b> int start_y, int start_x);</b></blockquote></p>    <p><blockquote><b>int delwin(WINDOW *window_to_delete);</b></blockquote></p>    <p>У функции <blockquote>subwin</blockquote> почти такой же список параметров, как у функции <blockquote>newwin</blockquote>, и удаляются вложенные окна так же, как другие окна с помощью вызова <blockquote>delwin</blockquote>. Для записи во вложенные окна, как и в новые окна, вы можете применять ряд функций <blockquote>mvw</blockquote>. На самом деле большую часть времени вложенные окна ведут себя почти так же, как новые окна, но есть одно важное отличие: подокна самостоятельно не хранят отдельный набор экранных символов; они используют ту же область хранения символов, что и родительское окно, заданное при создании вложенного окна. Это означает, что любые изменения, сделанные во вложенном окне, вносятся и в лежащее в основании родительское окно, поэтому, когда подокно удаляется, экран не меняется.</p>    <p>На первый взгляд вложенные окна кажутся бесполезным экспериментом. Почему не изменять просто родительское окно? Основная сфера их применения — предоставление простого способа прокрутки другого окна. Потребность в прокрутке небольшой области экрана удивительно часто возникает при написании программ с использованием curses. Создав вложенное окно и прокручивая его, вы добьетесь желаемого результата.</p>    <blockquote>     <b>Примечание</b>     <p>Одно ограничение, накладываемое на применение вложенных окон, заключается в необходимости перед обновлением экрана вызвать в приложении функцию <blockquote>touchwin</blockquote> для родительского окна.</p>    </blockquote>    <p>Выполните упражнение 6.5.</p>    <b>Упражнение 6.5. Вложенные окна </b>    <p>Теперь, когда вы познакомились с новыми функциями, этот короткий пример покажет, как они действуют и чем отличаются от функций окна, применявшихся ранее.</p>    <p>1. Начальная секция кода программы subscl.c инициализирует отображение базового окна с некоторым текстом:</p>    <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>    <p><blockquote>#include &lt;curses.h&gt;</blockquote></p>    <br>    <p><blockquote>int main() {</blockquote></p>    <p><blockquote> WINDOW *sub_window_ptr;</blockquote></p>    <p><blockquote> int x_loop;</blockquote></p>    <p><blockquote> int y_loop;</blockquote></p>    <p><blockquote> int counter;</blockquote></p>    <p><blockquote> char a_letter = '1';</blockquote></p>    <p><blockquote> initscr();</blockquote></p>    <p><blockquote> for (y_loop = 0; y_loop &lt; LINES - 1; y_loop++) {</blockquote></p>    <p><blockquote>  for (x_loop = 0; x_loop &lt; COLS - 1; x_loop++) {</blockquote></p>    <p><blockquote>   mvwaddch(stdscr, y_loop, x_loop, a_letter);</blockquote></p>    <p><blockquote>   a_letter++;</blockquote></p>    <p><blockquote>   if (a_letter &gt; '9') a_letter = '1';</blockquote></p>    <p><blockquote>  }</blockquote></p>    <p><blockquote> }</blockquote></p>    <p>2. Теперь создайте новое подокно с прокруткой. Как рекомендовалось, вам следует перед обновлением экрана "коснуться" родительского окна:</p>    <p><blockquote> ub_window_ptr = subwin(stdscr, 10, 20, 10, 10);</blockquote></p>    <p><blockquote> scrollok(sub_window_ptr, 1);</blockquote></p>    <p><blockquote> touchwin(stdscr);</blockquote></p>    <p><blockquote> refresh();</blockquote></p>    <p><blockquote> sleep(1);</blockquote></p>    <p>3. Сотрите содержимое вложенного окна, выведите в нем текст и обновите его. Прокрутка текста обеспечивается циклом:</p>    <p><blockquote> werase(sub_window_ptr);</blockquote></p>    <p><blockquote> mvwprintw(sub_window_ptr, 2, 0, "%s", "This window will now scroll");</blockquote></p>    <p><blockquote> wrefresh(sub_window_ptr);</blockquote></p>    <p><blockquote> sleep(1);</blockquote></p>    <p><blockquote> for (counter = 1; counter &lt; 10; counter++) {</blockquote></p>    <p><blockquote>  wprintw(sub_window_ptr, "%s", "This text is both wrapping and \</blockquote></p>    <p><blockquote>   scrolling.");</blockquote></p>    <p><blockquote>  wrefresh(sub_window_ptr);</blockquote></p>    <p><blockquote>  sleep(1);</blockquote></p>    <p><blockquote> }</blockquote></p>    <p>4. Завершив цикл, удалите вложенное окно и обновите основной экран:</p>    <p><blockquote> delwin(sub_window_ptr);</blockquote></p>    <p><blockquote> touchwin(stdscr);</blockquote></p>    <p><blockquote> refresh();</blockquote></p>    <p><blockquote> sleep(1);</blockquote></p>    <p><blockquote> endwin();</blockquote></p>    <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>К концу программы вы увидите вывод, показанный на рис. 6.6.</p>    <img src="image017.jpg"/>    <p><b>Рис. 6.6</b> </p>    <br>    <p><b>Как это работает</b></p>    <p>После присвоения указателю <blockquote>sub_window_ptr</blockquote> результата вызова <blockquote>subwin</blockquote> вы включаете прокрутку вложенного окна. Даже после удаления вложенного окна и обновления базового окна (<blockquote>strdcr</blockquote>) текст на экране не меняется, поскольку вложенное окно на самом деле откорректировало символьные данные экрана <blockquote>strdcr</blockquote>.</p>          <a name="metkadoc19"><h1>Дополнительная клавиатура</h1></a>    <p>Вы уже познакомились с некоторыми средствами библиотеки curses для обработки клавиатурного ввода. У многих клавиатур, как минимум, есть клавиши управления курсором и функциональные клавиши. Кроме того, у многих клавиатур есть дополнительная клавиатура и другие клавиши, например, &lt;Insert&gt; и &lt;Home&gt;.</p>    <p>Для большинства терминалов расшифровка этих клавиш — серьезная проблема, потому что они посылают строку символов, начинающуюся с escape-символа. Дело не только в том, что приложению трудно отличить одиночное нажатие клавиши &lt;Esc&gt; от строки символов, появившейся в результате нажатия функциональной клавиши, оно еще должно справляться с терминалами разных типов, применяющими разные управляющие последовательности для одних и тех же логических клавиш.</p>    <p>К счастью, библиотека curses предоставляет элегантное решение для управления функциональными клавишами. Обычно в структуре <blockquote>terminfo</blockquote> для каждого терминала хранится последовательность, отправляемая каждой функциональной клавишей, и во включенном в программу файле curses.h для логических клавиш есть набор определений, начинающихся с префикса <blockquote>KEY_</blockquote>.</p>    <p>Когда curses стартует, преобразование последовательностей в логические клавиши отключено, и его следует включить вызовом функции <blockquote>keypad</blockquote>. Если вызов успешен, функция вернет <blockquote>OK</blockquote>, в противном случае <blockquote>ERR</blockquote>.</p>    <p><blockquote><b>#include &lt;curses.h&gt;</b></blockquote></p>    <p><blockquote><b>int keypad(WINDOW *window_ptr, bool keypad_on);</b></blockquote></p>    <p>Когда<i> режим дополнительной клавиатуры</i> включен с помощью вызова функции <blockquote>keypad</blockquote> с параметром <blockquote>keypad_on</blockquote>, равным <blockquote>true</blockquote>, библиотека curses принимает на себя обработку клавиатурных последовательностей, так что чтение с клавиатуры может вернуть не только нажатую клавишу, но и одно из определений вида <blockquote>KEY_</blockquote> для логических клавиш.</p>    <p>Отметьте три незначительных ограничения, налагаемых при использовании режима дополнительной клавиатуры.</p>    <p>&#9633; Распознавание escape-последовательностей требует разного времени, и многие сетевые протоколы сгруппируют символы в пакеты (что приведет к неверному распознаванию escape-последовательностей) или разделят их (что приведет к распознаванию последовательностей функциональных клавиш, как клавиши &lt;Esc&gt; и отдельных символов). Такое поведение чаще всего наблюдается в региональных сетях (Wide-Area Network, WAN) и других медленных линиях связи. Единственный выход — попытаться запрограммировать терминалы так, чтобы они отправляли единичные уникальные символы в ответ на нажатие каждой функциональной клавиши, используемой вами, хотя это ограничит количество управляющих символов.</p>    <p>&#9633; Для того чтобы библиотека curses могла отличить нажатие клавиши &lt;Esc&gt; от клавиатурной последовательности, начинающейся с символа <blockquote>Esc</blockquote>, ей требуется ожидание в течение короткого промежутка времени. Иногда при включенном режиме дополнительной клавиатуры можно заметить легкую задержку при обработке клавиши &lt;Esc&gt;.</p>    <p>&#9633; Библиотека curses не может обрабатывать неуникальные escape-последовательности. Если у вашего терминала есть две разные клавиши, отправляющие одну и ту же последовательность, библиотека просто не будет ее обрабатывать, поскольку не может решить, какую логическую клавишу следует вернуть.</p>    <p>Выполните упражнение 6.6.</p>    <b>Упражнение 6.6. Применение дополнительной клавиатуры</b>    <p>Далее приведена короткая программа keypad.c, демонстрирующая применение режима дополнительной клавиатуры. После запуска программы нажмите клавишу &lt;Esc&gt; и отметьте незначительную задержку, в течение которой программа пытается понять: Esc — это начало управляющей последовательности или просто нажатие одной клавиши,</p>    <p>1. Инициализировав программу и библиотеку curses, включите режим дополнительной клавиатуры:</p>    <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>    <p><blockquote>#include &lt;curses.h&gt;</blockquote></p>    <p><blockquote>#define LOCAL_ESCAPE_KEY 27</blockquote></p>    <br>    <p><blockquote>int main() {</blockquote></p>    <p><blockquote> int key;</blockquote></p>    <p><blockquote> initscr();</blockquote></p>    <p><blockquote> crmode();</blockquote></p>    <p><blockquote> keypad(stdscr, TRUE);</blockquote></p>    <p>2. Отключите отображение символов, чтобы помешать перемещению курсора при нажатии клавиш управления курсором. Экран очищается, и выводится некоторый текст. Программа ждет нажатия клавиши и до тех пор, пока не нажата клавиша &lt;Q&gt; или не возникла ошибка. Символ нажатой клавиши выводится на экран. Если нажатые клавиши соответствуют одной из последовательностей для дополнительной клавиатуры терминала, вместо символа выводится эта последовательность.</p>    <p><blockquote> noecho();</blockquote></p>    <p><blockquote> clear();</blockquote></p>    <p><blockquote> mvprintw(5, 5, "Key pad demonstration. Press 'q' to quit");</blockquote></p>    <p><blockquote> move(7, 5);</blockquote></p>    <p><blockquote> refresh();</blockquote></p>    <p><blockquote> key = getch();</blockquote></p>    <p><blockquote> while (key != ERR &amp;&amp; key i= 'q') {</blockquote></p>    <p><blockquote>  move(7, 5);</blockquote></p>    <p><blockquote>  clrtoeol();</blockquote></p>    <p><blockquote>  if ((key &gt;= 'A' &amp;&amp; key &lt;= 'Z') || (key &gt;= 'a' &amp;&amp; key &lt;= 'z')) {</blockquote></p>    <p><blockquote>   printw("Key was%c", (char)key);</blockquote></p>    <p><blockquote>  } else {</blockquote></p>    <p><blockquote>   switch(key) {</blockquote></p>    <p><blockquote>   case LOCAL_ESCAPE_KEY:</blockquote></p>    <p><blockquote>    printw("%s", "Escape key");</blockquote></p>    <p><blockquote>    break;</blockquote></p>    <p><blockquote>   case KEY_END:</blockquote></p>    <p><blockquote>    printw("%s", "END key");</blockquote></p>    <p><blockquote>    break;</blockquote></p>    <p><blockquote>   case KEY_BEG:</blockquote></p>    <p><blockquote>    printw("%s", "BEGINNING key");</blockquote></p>    <p><blockquote>    break;</blockquote></p>    <p><blockquote>   case KEY_RIGHT:</blockquote></p>    <p><blockquote>    printw("%s", "RIGHT key");</blockquote></p>    <p><blockquote>    break;</blockquote></p>    <p><blockquote>   case KEY_LEFT:</blockquote></p>    <p><blockquote>    printw("%s", "LEFT key");</blockquote></p>    <p><blockquote>    break;</blockquote></p>    <p><blockquote>   case KEY_UP:</blockquote></p>    <p><blockquote>    printw("%s", "UP key");</blockquote></p>    <p><blockquote>    break;</blockquote></p>    <p><blockquote>   case KEY_DOWN:</blockquote></p>    <p><blockquote>    printw("%s", "DOWN key");</blockquote></p>    <p><blockquote>    break;</blockquote></p>    <p><blockquote>   default:</blockquote></p>    <p><blockquote>    printw("Unmatched — %d", key);</blockquote></p>    <p><blockquote>    break;</blockquote></p>    <p><blockquote>   } /* switch */</blockquote></p>    <p><blockquote>  } /* else */</blockquote></p>    <p><blockquote>  refresh();</blockquote></p>    <p><blockquote>  key = getch();</blockquote></p>    <p><blockquote> } /* while */</blockquote></p>    <p><blockquote> endwin();</blockquote></p>    <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>    <p><blockquote>}</blockquote></p>    <p><b>Как это работает</b></p>    <p>Включив режим дополнительной клавиатуры, вы увидите, как можно распознать различные функциональные клавиши на дополнительной клавиатуре, генерирующие escape-последовательности. Вы, возможно, сумеете заметить, что распознавание клавиши &lt;Esc&gt; немного медленнее, чем других клавиш.</p>          <a name="metkadoc20"><h1>Применение цвета</h1></a>         <p>В прошлом очень немногие терминалы ввода/вывода поддерживали цвета, поэтому у большей части самых старых версий библиотеки curses не было поддержки цветов. Цвета появились в библиотеке ncurses и других современных реализациях curses. К сожалению, на "неинтеллектуальный экран", первооснову библиотеки curses, повлиял API, и curses используют цвета очень ограниченным способом, отражающим слабые характеристики старых цветных терминалов.</p>     <p>Каждая символьная ячейка на экране может быть записана одним цветом из набора разных цветов на фоне одного цвета из набора различных цветов фона. Например, можно вывести зеленый текст на красном фоне.</p>     <p>Цветовая поддержка в библиотеке curses немного необычна, в том смысле, что цвет символа не определяется независимо от цвета фона. Вы должны задать цвет переднего плана и фона как пару, именуемую, что неудивительно,<i> цветовой парой.</i></p>     <p>Прежде чем применять цвета в curses, нужно убедиться в том, что текущий терминал поддерживает цвета, и инициализировать подпрограммы управления цветом библиотеки curses. Для этого примените две функции: <blockquote>has_colors</blockquote> и <blockquote>start_color</blockquote>.</p>     <p><blockquote><b>#include &lt;curses.h&gt;</b></blockquote></p>     <p><blockquote><b>bool has_colors(void);</b></blockquote></p>     <p><blockquote><b>int start_color(void);</b></blockquote></p>     <p>Функция <blockquote>has_colors</blockquote> возвращает <blockquote>true</blockquote>, если терминал поддерживает цвета. Далее следует вызвать функцию <blockquote>start_color</blockquote>, которая вернет <blockquote>OK</blockquote>, если цветовая поддержка успешно инициализирована. После вызова <blockquote>start_color</blockquote> и инициализации цветов переменная <blockquote>COLOR_PAIRS</blockquote> принимает значение, равное максимальному количеству цветовых пар, которые может поддерживать терминал. Переменная <blockquote>COLORS</blockquote> определяет максимальное число доступных цветов, которых, как правило, восемь. Внутри компьютера числа от 0 до 63 действуют как уникальные ID для каждого из доступных цветов.</p>     <p>Прежде чем применять цвета как атрибуты, вы должны инициализировать цветовые пары, которые хотите использовать. Делается это с помощью функции <blockquote>init_pair</blockquote>. Обратиться к атрибутам, задающим цвет, можно с помощью функции <blockquote>COLOR_PAIR</blockquote>.</p>     <p><blockquote><b>#include &lt;curses.h&gt;</b></blockquote></p>     <p><blockquote><b>int init_pair(short pair_number, short foreground, short background);</b></blockquote></p>     <p><blockquote><b>int COLOR_PAIR(int pair_number);</b></blockquote></p>     <p><blockquote><b>int pair_content(short pair_number, short *foreground, short *background);</b></blockquote></p>     <p>В файле curses.h обычно определены некоторые базовые цвета, начинающиеся с префикса <blockquote>COLOR_</blockquote>. Дополнительная функция <blockquote>pair_content</blockquote> позволяет извлечь сведения о ранее определенной цветовой паре.</p>     <p>Для определения цветовой пары номер 1, как красный на зеленом, примените следующую строку:</p>     <p><blockquote>init_pair(1, COLOR_RED, COLOR_GREEN);</blockquote></p>     <p>Затем вы сможете получить доступ к этой цветовой паре, применив функцию <blockquote>COLOR_PAIR</blockquote> следующим образом:</p>     <p><blockquote>wattron(window_ptr, COLOR_PAIR(1));</blockquote></p>     <p>Она установит вывод в будущем на экран красных символов на зеленом фоне.</p>     <p>Поскольку <blockquote>COLOR_PAIR</blockquote> — это атрибут, вы можете комбинировать его с другими атрибутами. На ПК часто можно добиться на экране цветов повышенной яркости, объединив с помощью поразрядной операции <blockquote>OR</blockquote> атрибут <blockquote>COLOR_PAIR</blockquote> с дополнительным атрибутом <blockquote>A_BOLD</blockquote>:</p>     <p><blockquote>wattron(window_ptr, COLOR_PAIR(1) | A_BOLD);</blockquote></p>     <p>Давайте проверим эти функции в примере color.c (упражнение 6.7).</p>     <b>Упражнение 6.7. Цвета</b>     <p>1. Сначала проверьте, поддерживает ли цвета терминал, используемый программой. Если да, то инициализируйте отображение цветов:</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;curses.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int i;</blockquote></p>     <p><blockquote> initscr();</blockquote></p>     <p><blockquote> if (!has_colors()) {</blockquote></p>     <p><blockquote>  endwin();</blockquote></p>     <p><blockquote>  fprintf(stderr, "Error — no color support on this terminal\n");</blockquote></p>     <p><blockquote>  exit(1);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> if (start_color() != OK) {</blockquote></p>     <p><blockquote>  endwin();</blockquote></p>     <p><blockquote>  fprintf(stderr, "Error — could not initialize colors\n");</blockquote></p>     <p><blockquote>  exit(2);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p>2. Теперь можно вывести допустимое количество цветов и цветовые пары. Создайте семь цветовых пар и выведите их по очереди на экран:</p>     <p><blockquote> clear();</blockquote></p>     <p><blockquote> mvprintw(5, 5, "There are %d COLORS, and %d COLOR_PAIRS available", COLORS, COLOR_PAIRS);</blockquote></p>     <p><blockquote> refresh();</blockquote></p>     <p><blockquote> init_pair(1, COLOR_RED, COLOR_BLACK);</blockquote></p>     <p><blockquote> init_pair(2, COLOR_RED, COLOR_GREEN);</blockquote></p>     <p><blockquote> init_pair(3, COLOR_GREEN, COLOR_RED);</blockquote></p>     <p><blockquote> init_pair(4, COLOR_YELLOW, COLOR_BLUE);</blockquote></p>     <p><blockquote> init_pair(5, COLOR_BLACK, COLOR_WHITE);</blockquote></p>     <p><blockquote> init_pair(6, COLOR_MAGENTA, COLOR_BLUE);</blockquote></p>     <p><blockquote> init_pair(7, COLOR_CYAN, COLOR_WHITE);</blockquote></p>     <p><blockquote> for (i = 1; i &lt;= 7; i++) {</blockquote></p>     <p><blockquote>  attroff(A_BOLD);</blockquote></p>     <p><blockquote>  attrset(COLOR_PAIR(i));</blockquote></p>     <p><blockquote>  mvprintw(5 + i, 5, "Color pair %d", i);</blockquote></p>     <p><blockquote>  attrset(COLOR_PAIR(i) | A_BOLD);</blockquote></p>     <p><blockquote>  mwprintw(5 + i, 25, "Bold color pair %d", i);</blockquote></p>     <p><blockquote>  refresh();</blockquote></p>     <p><blockquote>  sleep(1);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> endwin();</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Выполнение примера приведет к выводу, показанному на рис. 6.7, за вычетом реальных цветов, которые не отображаются на черно-белом снимке экрана.</p>     <img src="image018.jpg"/>     <p><b>Рис. 6.7</b></p>     <br>     <p><b>Как это работает</b></p>     <p>После проверки того, что экран поддерживает управление цветами, программа инициализирует цветовую обработку и определяет ряд цветовых пар. Далее на экран выводится текст с использованием цветовых пар для того, чтобы продемонстрировать комбинации разных цветов на экране.</p>             <a name="metkadoc21"><h1>Переопределение цветов</h1></a>     <p>Как пережиток, оставшийся от старых неинтеллектуальных терминалов, которые могли отображать очень немного цветов в каждый момент времени, но позволяли настраивать текущую цветовую палитру, в библиотеке curses сохранилась возможность переопределения цветов с помощью функции <blockquote>init_color</blockquote>:</p>     <p><blockquote><b>#include &lt;curses.h&gt;</b></blockquote></p>     <p><blockquote><b>int init_color(short color_number, short red, short green, short blue);</b></blockquote></p>     <p>Она позволяет переопределить существующий цвет (в диапазоне от 0 до <blockquote>COLORS</blockquote>) новыми значениями яркости цвета из диапазона от 0 до 1000. Такой подход немного напоминает определение цветовых характеристик в графических файлах формата GIF.</p>              <a name="metkadoc22"><h1>Панели </h1></a>    <p>При написании более сложных программ с использованием curses порой бывает легче построить логический экран и затем позже вывести весь или часть экрана на физический экран. В некоторых случаях лучше иметь логический экран большего размера, чем физический экран и отображать только часть логического экрана в любой конкретный момент времени.</p>    <p>Это нелегко сделать с помощью функций библиотеки curses, с которыми вы познакомились к этому моменту, т.к. все окна должны быть не больше физического экрана. Библиотека curses предоставляет специальную структуру данных,<i> панель </i>(pad), для манипулирования данными логического экрана, которые не умещаются в стандартном окне.</p>    <p>Структура панели похожа на структуру <blockquote>WINDOW</blockquote>, и все функции библиотеки curses, написанные для работы с окнами, можно применять и к панелям. Но у панелей есть и собственные функции для создания и обновления.</p>    <p>Панели создаются во многом так же, как и обычные окна.</p>    <p><blockquote><b>#include &lt;curses.h&gt;</b></blockquote></p>    <p><blockquote><b>WINDOW *newpad(int number_of_lines, int number_of_columns);</b></blockquote></p>    <p>Обратите внимание на то, что возвращаемое значение — указатель на структуру типа <blockquote>WINDOW</blockquote>, такое же, как у функции <blockquote>newwin</blockquote>. Удаляются панели, как и окна, функцией <blockquote>delwin</blockquote>.</p>    <p>Но к панелям применяются другие подпрограммы обновления. Поскольку панель не привязана к конкретной точке экрана, вы должны задать область панели, которую хотите поместить на экран, и ее положение на экране. Делайте это с помощью функции prefresh.</p>    <p><blockquote><b>#include &lt;сurses.h&gt;</b></blockquote></p>    <p><blockquote><b>int prefresh(WINDOW *pad_ptr, int pad_row, int pad_column, int screen_row_min, int screen_col_min, int screen_row_max, int screen_соl_max);</b></blockquote></p>    <p>Функция выполняет запись области панели, начинающейся в точке (<blockquote>pad_row</blockquote>, <blockquote>pad_column</blockquote>), в область экрана, определенную от (<blockquote>screen_row_min</blockquote>, <blockquote>screen_col_min</blockquote>) до (<blockquote>screen_row_max</blockquote>, <blockquote>screen_col_max</blockquote>).</p>    <p>Есть и дополнительная подпрограмма <blockquote>pnoutrefresh</blockquote>. Она действует так же, как функция <blockquote>wnoutrefresh</blockquote>, обеспечивая более производительное обновление экрана.</p>    <p>Давайте проверим это на практике с помощью программы pad.с (упражнение 6.8).</p>    <b>Упражнение 6.8. Применение панели</b>    <p>1. В начале этой программы вы инициализируете структуру панели и затем формируете панель с помощью функции, которая возвращает указатель на нее. Вставьте символы, заполняющие структуру панели (панель на 50 символов шире и выше экрана терминала):</p>    <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>    <p><blockquote>#include &lt;curses.h&gt;</blockquote></p>    <br>    <p><blockquote>int main() {</blockquote></p>    <p><blockquote> WINDOW *pad_ptr;</blockquote></p>    <p><blockquote> int x, y;</blockquote></p>    <p><blockquote> int pad_lines;</blockquote></p>    <p><blockquote> int pad_cols;</blockquote></p>    <p><blockquote> char disp_char;</blockquote></p>    <p><blockquote> initscr();</blockquote></p>    <p><blockquote> pad_lines = LINES + 50;</blockquote></p>    <p><blockquote> pad_cols = COLS + 50;</blockquote></p>    <p><blockquote> pad_ptr = newpad(pad_lines, padcols);</blockquote></p>    <p><blockquote> disp_char = 'a';</blockquote></p>    <p><blockquote> for (x = 0; x &lt; pad_lines; x++) {</blockquote></p>    <p><blockquote>  for (у = 0; у &lt; pad_cols; y++) {</blockquote></p>    <p><blockquote>   mvwaddch(pad_ptr, x, y, disp_char);</blockquote></p>    <p><blockquote>   if (disp_char == 'z') disp_char = 'a';</blockquote></p>    <p><blockquote>   else disp_char++;</blockquote></p>    <p><blockquote>  }</blockquote></p>    <p><blockquote> }</blockquote></p>    <p>2. Теперь перед завершением программы нарисуйте разные области панели в разных местах экрана:</p>    <p><blockquote> prefresh(pad_ptr, 5, 7, 2, 2, 9, 9);</blockquote></p>    <p><blockquote> sleep(1);</blockquote></p>    <p><blockquote> prefresh(pad_ptr, LINES + 5, COLS + 7, -5, 5, 21, 19);</blockquote></p>    <p><blockquote> sleep(1);</blockquote></p>    <p><blockquote> delwin(pad_ptr);</blockquote></p>    <p><blockquote> endwin();</blockquote></p>    <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Выполнив эту программу, вы увидите нечто подобное показанному на рис. 6.8.</p>    <img src="image019.jpg"/>    <p><b>Рис. 6.8</b></p>    <br>          <a name="metkadoc23"><h1>Приложение, управляющее коллекцией компакт-дисков</h1></a>         <p>Теперь, когда вы узнали о средствах, которые предлагает библиотека curses, можно разработать типовое приложение. Далее приведена его версия, написанная на языке С и использующая библиотеку curses. К достоинствам приложения относятся более четкое отображение информации на экране и применение окна с прокруткой для просмотра списков.</p>     <p>Все приложение занимает восемь страниц, поэтому мы разделили его на секции и отдельные функции внутри секций. Исходный код программы curses_app.c можно получить на Web-сайте издательства Wrox <b>(http://www.wrox.com/WileyCDA/).</b> Как и все программы из этой книги, оно подчиняется требованиям Общедоступной лицензии проекта GNU.</p>     <blockquote>      <b>Примечание</b>      <p>Мы написали эту версию приложения для работы с базой данных компакт-дисков, используя информацию из предыдущих глав. Данное приложение — потомок оригинального сценария командной оболочки, приведенного в главе 2. Оно не перепроектировалось для написания на языке С, поэтому вы увидите в этой версии многие подходы, заимствованные из сценария. Учтите, что в этой реализации есть существенные ограничения, которые мы устраним в последующих модификациях.</p>     </blockquote>     <p>Мы разбили программный код этого приложения на несколько отдельных секций, которые обозначены заголовками последующих разделов. Соглашения, принятые для оформления этого программного кода, немного отличаются от оформления большинства программ в этой книге; здесь выделение цветом применяется только для обозначения вызовов других функций приложения.</p>             <a name="metkadoc24"><h1>Начало нового приложения для работы с коллекцией компакт-дисков</h1></a>     <p>Первая секция программного кода просто связана с объявлениями переменных и функций, которые вы будете применять позже, и инициализацией некоторых структур данных.</p>     <p>1. Включите в программу все приведенные заголовочные файлы и несколько глобальных переменных:</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <p><blockquote>#include &lt;curses.h&gt;</blockquote></p>     <p><blockquote>#define MAX_STRING 80 /* Самый длинный допустимый ответ */</blockquote></p>     <p><blockquote>#define MAX_ENTRY 1024 /* Самый длинный допустимый элемент БД */</blockquote></p>     <p><blockquote>#define MESSAGE_LINE 6 /* В этой строке разные сообщения */</blockquote></p>     <p><blockquote>#define ERROR LINE 22 /* Строка для вывода ошибок */</blockquote></p>     <p><blockquote>#define Q_LINE 20 /* Строка для вопросов */</blockquote></p>     <p><blockquote>#define PROMPT_LINE 18 /* Строка для вывода приглашения */</blockquote></p>     <p>2. Теперь вам нужны глобальные переменные. Переменная <blockquote>current_cdis</blockquote> применяется для хранения названия текущего компакт-диска, с которым вы работаете в данный момент. Она инициализируется так, что первый символ равен <blockquote>NULL</blockquote>, чтобы показать, что компакт-диск не выбран. Символ завершения <blockquote>\0</blockquote>, строго говоря, не обязателен, но он гарантирует инициализацию переменной, что само по себе хорошая вещь. Переменная <blockquote>current_cat</blockquote> применяется для записи номера текущего компакт-диска в каталоге:</p>     <p><blockquote>static char current_cd[MAX_STRING] = "\0";</blockquote></p>     <p><blockquote>static char current_cat[MAX_STRING];</blockquote></p>     <p>3. Теперь объявите имена файлов. Для простоты в этой версии имена файлов фиксированные, как и имя временного файла.</p>     <p>Это может вызвать проблемы, если программа выполняется двумя пользователями в одном и том же каталоге. Лучше получать имена файлов базы данных как аргументы программы или из переменных окружения. Нам также потребуется улучшенный метод генерации уникального имени временного файла, для чего мы могли бы использовать функцию <blockquote>tmpnam</blockquote> из стандарта POSIX. Мы обратимся к решению многих из этих проблем в<i> главе 8</i>, когда применим СУРБД MySQL для хранения данных.</p>     <p><blockquote>const char *title_file = "title.cdb";</blockquote></p>     <p><blockquote>const char *tracks_file = "tracks.cdb";</blockquote></p>     <p><blockquote>const char *temp_file = "cdb.tmp";</blockquote></p>     <p>4. И наконец, прототипы функций:</p>     <p><blockquote>void clear_all_screen(void);</blockquote></p>     <p><blockquote>void get_return(void);</blockquote></p>     <p><blockquote>int get_confirm(void);</blockquote></p>     <p><blockquote>int getchoice(char *greet, char *choices[]);</blockquote></p>     <p><blockquote>void draw_menu(char *options[], int highlight,</blockquote></p>     <p><blockquote> int start_row, int start_col);</blockquote></p>     <p><blockquote>void insert_title(char *cdtitle);</blockquote></p>     <p><blockquote>void get_string(char *string);</blockquote></p>     <p><blockquote>void add_record(void);</blockquote></p>     <p><blockquote>void count_cds(void);</blockquote></p>     <p><blockquote>void find_cd(void);</blockquote></p>     <p><blockquote>void list_tracks(void);</blockquote></p>     <p><blockquote>void remove_tracks(void);</blockquote></p>     <p><blockquote>void remove_cd(void);</blockquote></p>     <p><blockquote>void update_cd(void);</blockquote></p>     <p>5. Прежде чем рассматривать их реализацию, введем некоторые структуры (на самом деле массив пунктов меню) для хранения меню. Когда выбирается пункт меню, возвращается первый символ выбранного пункта. Например, если это пункт меню <b>add new</b> CD (добавить новый CD), при его выборе будет возвращен символ <blockquote>а</blockquote>. Когда компакт-диск выбран, будет отображаться расширенное меню.</p>     <p><blockquote>char *main_menu[] = {</blockquote></p>     <p><blockquote> "add new CD",</blockquote></p>     <p><blockquote> "find CD",</blockquote></p>     <p><blockquote> "count CDs and tracks in the catalog",</blockquote></p>     <p><blockquote> "quit",</blockquote></p>     <p><blockquote> 0,</blockquote></p>     <p><blockquote>};</blockquote></p>     <p><blockquote>char *extended_menu[] = {</blockquote></p>     <p><blockquote> "add new CD",</blockquote></p>     <p><blockquote> "find CD",</blockquote></p>     <p><blockquote> "count CDs and tracks in the catalog",</blockquote></p>     <p><blockquote> "list tracks on current CD";</blockquote></p>     <p><blockquote> "remove current CD",</blockquote></p>     <p><blockquote> "update track information",</blockquote></p>     <p><blockquote> "quit",</blockquote></p>     <p><blockquote> 0,</blockquote></p>     <p><blockquote>};</blockquote></p>     <p>На этом инициализация закончена. Теперь можно переходить к функциям программы, но сначала необходимо составить общее представление о взаимосвязях всех 16 функций. Функции разделены на три программных секции:</p>     <p>&#9633; отображение меню;</p>     <p>&#9633; добавление компакт-дисков в базу данных;</p>     <p>&#9633; извлечение и отображение данных компакт-диска.</p>     <p>Визуальное представление дано на рис. 6.9.</p>     <img src="image020.jpg"/>     <p><b>Рис. 6.9</b></p>             <a name="metkadoc25"><h1>Взгляд на функцию<i> main</i></h1></a>     <p>Функция <blockquote>main</blockquote> позволяет выбирать пункты меню, пока не выбран вариант выхода из меню (<b>quit</b>). Далее приведен соответствующий код.</p>     <p><blockquote><i>int main() {</i></blockquote></p>     <p><blockquote> int choice;</blockquote></p>     <p><blockquote> initscr();</blockquote></p>     <p><blockquote> do {</blockquote></p>     <p><blockquote>  choice = getchoice("Options:", current_cd[0] ? extended_menu : main_menu);</blockquote></p>     <p><blockquote>  switch (choice) {</blockquote></p>     <p><blockquote>  case 'q':</blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  case 'a':</blockquote></p>     <p><blockquote><i>   add_record();</i></blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  case 'c':</blockquote></p>     <p><blockquote><i>   count_cds();</i></blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  case 'f':</blockquote></p>     <p><blockquote><i>   find_cd();</i></blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  case 'l':</blockquote></p>     <p><blockquote><i>   list_tracks();</i></blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  case 'r':</blockquote></p>     <p><blockquote><i>   remove_cd();</i></blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  case 'u':</blockquote></p>     <p><blockquote><i>   update_cd();</i></blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> } while (choice != 'q');</blockquote></p>     <p><blockquote> endwin();</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Теперь давайте подробно рассмотрим функции, связанные с тремя секциями программы.</p>             <a name="metkadoc26"><h1>Формирование меню</h1></a>     <p>В этой секции рассматриваются три функции, относящиеся к пользовательскому интерфейсу программы.</p>     <p>1. Функция <blockquote>getchoice</blockquote>, вызываемая из функции <blockquote>main</blockquote>, — это основная функция данной секции. В функцию <blockquote>getchoice</blockquote> передается приглашение <blockquote>greet</blockquote> и указатель <blockquote>choices</blockquote> на базовое или расширенное меню (в зависимости от того, выбран ли компакт-диск). Вы также увидите, как <blockquote>main_menu</blockquote> или <blockquote>extended_menu</blockquote> передаются как параметры в описанную ранее функцию <blockquote>main</blockquote>.</p>     <p><blockquote><i>int get_choice(char *greet, char* choises[]) {</i></blockquote></p>     <p><blockquote> static int selected_row = 0;</blockquote></p>     <p><blockquote> int max_row = 0;</blockquote></p>     <p><blockquote> int start_screenrow = MESSAGE_LINE, start_screencol = 10;</blockquote></p>     <p><blockquote> char **option;</blockquote></p>     <p><blockquote> int selected;</blockquote></p>     <p><blockquote> int key = 0;</blockquote></p>     <p><blockquote> option = choices;</blockquote></p>     <p><blockquote> while (*option) {</blockquote></p>     <p><blockquote>  max_row++;</blockquote></p>     <p><blockquote>  option++;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> if (selected_row &gt;= max_row)</blockquote></p>     <p><blockquote>  selected_row = 0;</blockquote></p>     <p><blockquote><i> clear_all_screen();</i></blockquote></p>     <p><blockquote> mvprintw(start_screenrow - 2, start_screencol, greet);</blockquote></p>     <p><blockquote> keypad(stdscr, TRUE);</blockquote></p>     <p><blockquote> cbreak();</blockquote></p>     <p><blockquote> noecho();</blockquote></p>     <p><blockquote> key = 0;</blockquote></p>     <p><blockquote> while (key != 'q' &amp;&amp; key != KEY_ENTER &amp;&amp; key != '\n') {</blockquote></p>     <p><blockquote>  if (key == KEY_UP) {</blockquote></p>     <p><blockquote>   if (selected_row == 0) selected_row = max_row - 1;</blockquote></p>     <p><blockquote>   else selected_row--;</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  if (key == KEY_DOWN) {</blockquote></p>     <p><blockquote>   if (selected_row == (max_row - 1)) selected_row = 0;</blockquote></p>     <p><blockquote>   else selected_row++;</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  selected = *choices[selected_row];</blockquote></p>     <p><blockquote><i>  draw_menu(choices, selected_row, start_screen_row, start_screencol);</i></blockquote></p>     <p><blockquote>  key = getch();</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> keypad(stdscr, FALSE);</blockquote></p>     <p><blockquote> nocbreak();</blockquote></p>     <p><blockquote> echo();</blockquote></p>     <p><blockquote> if (key == 'q') selected = 'q';</blockquote></p>     <p><blockquote> return(selected);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>2. Обратите внимание на то, как две локальные функции <blockquote>clear_all_screen</blockquote> и <blockquote>draw_menu</blockquote> вызываются внутри функции <blockquote>getchoice</blockquote>. Первой рассмотрим функцию <blockquote>draw_menu</blockquote>:</p>     <p><i><blockquote>void draw_menu(char* options[], int current_highlight, int start_row, int start_col) {</blockquote></i></p>     <p><blockquote> int current_row = 0;</blockquote></p>     <p><blockquote> char **option_ptr;</blockquote></p>     <p><blockquote> char *txt_ptr;</blockquote></p>     <p><blockquote> option_ptr = options;</blockquote></p>     <p><blockquote> while (*option_ptr) {</blockquote></p>     <p><blockquote>  if (current_row == current_highlight) attron(A_STANDOUT);</blockquote></p>     <p><blockquote>  txt_ptr = options[current_row];</blockquote></p>     <p><blockquote>  txt_ptr++;</blockquote></p>     <p><blockquote>  mvprintw(start_row + current_row, start_col, "%s", txt_ptr);</blockquote></p>     <p><blockquote>  if (current_row == current_highlight) attroff(A_STANDOUT);</blockquote></p>     <p><blockquote>  current_row++;</blockquote></p>     <p><blockquote>  option_ptr++;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> mvprintw(start_row + current_row + 3, start_col,</blockquote></p>     <p><blockquote>  "Move highlight then press Return ");</blockquote></p>     <p><blockquote> refresh();</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>3. Далее рассмотрим функцию <blockquote>clear_all_screen</blockquote>, которая, как ни странно, очищает экран и перезаписывает заголовок. Если компакт-диск выбран, отображаются его данные:</p>     <p><blockquote><i>void clear all_screen() {</i></blockquote></p>     <p><blockquote> clear();</blockquote></p>     <p><blockquote> mvprintw(2, 20, "%s", "CD Database Application");</blockquote></p>     <p><blockquote> if (current_cd[0]) {</blockquote></p>     <p><blockquote>  mvprintw(ERROR_LINE, 0, "Current CD: %s: %s\n", current_cat, current_cd);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> refresh();</blockquote></p>     <p><blockquote>}</blockquote></p>             <a name="metkadoc27"><h1>Управление базой данных</h1></a>     <p>В этом разделе описаны функции пополнения или обновления базы данных компакт-дисков. Функции <blockquote>add_record</blockquote>, <blockquote>update_cd</blockquote> и <blockquote>remove_cd</blockquote> вызываются из функции <blockquote>main</blockquote>.</p>     <b>Добавление записей</b>     <p>1. Добавьте сведения о новом компакт-диске в базу данных.</p>     <p><blockquote><i>void add_record {</i></blockquote></p>     <p><blockquote> char catalog_number[MAX_STRING];</blockquote></p>     <p><blockquote> char cd_title[MAX_STRING];</blockquote></p>     <p><blockquote> char cd_type[MAX_STRING];</blockquote></p>     <p><blockquote> char cd_artist[MAX_STRING];</blockquote></p>     <p><blockquote> char cd_entry[MAX_STRING];</blockquote></p>     <p><blockquote> int screenrow = MESSAGE_LINE;</blockquote></p>     <p><blockquote> int screencol = 10;</blockquote></p>     <p><blockquote><i> clear_all_screen();</i></blockquote></p>     <p><blockquote> mvprintw(screenrow, screencol, "Enter new CD details");</blockquote></p>     <p><blockquote> screenrow += 2;</blockquote></p>     <p><blockquote> mvprintw(screenrow, screencol, "Catalog Number: " );</blockquote></p>     <p><blockquote><i> get_string(catalog_number);</i></blockquote></p>     <p><blockquote> screenrow++;</blockquote></p>     <p><blockquote> mvprintw(screenrow, screencol, " CD Title: ");</blockquote></p>     <p><blockquote><i> get_string(cd_title);</i></blockquote></p>     <p><blockquote> screenrow++;</blockquote></p>     <p><blockquote> mvprintw(screenrow, screencol, " CD Type: ");</blockquote></p>     <p><blockquote><i> get_string(cd_type);</i></blockquote></p>     <p><blockquote> screenrow++;</blockquote></p>     <p><blockquote> mvprintw(screenrow, screencol, " Artist: ");</blockquote></p>     <p><blockquote><i> get_string(cd_artist);</i></blockquote></p>     <p><blockquote> screenrow++;</blockquote></p>     <p><blockquote> mvprintw(PROMPT_LINE-2, 5, "About to add this new entry:");</blockquote></p>     <p><blockquote> sprintf(cd_entry, "%s, %s, %s, %s",</blockquote></p>     <p><blockquote>  catalog_number, cd_title, cd_type, cd_artist);</blockquote></p>     <p><blockquote> mvprintw(PROMPT_LINE, 5, "%s", cd_entry);</blockquote></p>     <p><blockquote> refresh();</blockquote></p>     <p><blockquote> move(PROMPT_LINE, 0);</blockquote></p>     <p><blockquote><i> if (get_confirm()) {</i></blockquote></p>     <p><blockquote><i>  insert_title(cd_entry);</i></blockquote></p>     <p><blockquote>  strcpy(current_cd, cd_title);</blockquote></p>     <p><blockquote>  strcpy(current_cat, catalog_number);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>2. Функция <blockquote>get_string</blockquote> приглашает к вводу и считывает строку из текущей позиции экрана. Она также удаляет завершающую новую пустую строку:</p>     <p><blockquote><i>void get_string(char* string) {</i></blockquote></p>     <p><blockquote> int len;</blockquote></p>     <p><blockquote> wgetnstr(stdscr, string, MAX_STRING);</blockquote></p>     <p><blockquote> len = strlen(string);</blockquote></p>     <p><blockquote> if (len &gt; 0 &amp;&amp; string[len - 1] == '\n') string[len - 1] = '\0';</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>3. Функция <blockquote>get_confirm</blockquote> запрашивает и считывает пользовательское подтверждение. Она читает введенную пользователем строку и проверяет, первый символ — <blockquote>Y</blockquote> или <blockquote>у</blockquote>. Если она обнаруживает другой символ, то не дает подтверждения.</p>     <p><blockquote><i>int get_confirm() {</i></blockquote></p>     <p><blockquote> int confirmed = 0;</blockquote></p>     <p><blockquote> char first_char;</blockquote></p>     <p><blockquote> mvprintw(Q_LINE, 5, "Are you sure? ");</blockquote></p>     <p><blockquote> clrtoeol();</blockquote></p>     <p><blockquote> refresh();</blockquote></p>     <p><blockquote> cbreak();</blockquote></p>     <p><blockquote> first_char = getch();</blockquote></p>     <p><blockquote> if (first_char == 'Y' || first_char == 'y') {</blockquote></p>     <p><blockquote>  confirmed = 1;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> nocbreak();</blockquote></p>     <p><blockquote> if (!confirmed) {</blockquote></p>     <p><blockquote>  mvprintw(Q_LINE, 1, " Cancelled");</blockquote></p>     <p><blockquote>  clrtoeol();</blockquote></p>     <p><blockquote>  refresh();</blockquote></p>     <p><blockquote>  sleep(1);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return confirmed;</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>4. Последней рассмотрим функцию <blockquote>insert_title</blockquote>. Она вставляет в базу данных компакт-дисков заголовок, добавляя строку с заголовком в конец файла заголовков:</p>     <p><blockquote><i>void insert_title(char* cdtitle) {</i></blockquote></p>     <p><blockquote> FILE *fp = fopen(title_file, "a");</blockquote></p>     <p><blockquote> if (!fp) {</blockquote></p>     <p><blockquote>  mvprintw(ERROR_LINE, 0, "cannot open CD titles database");</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  fprintf(fp, "%s\n", cdtitle);</blockquote></p>     <p><blockquote>  fclose(fp);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote>}</blockquote></p>     <b>Обновление записей</b>     <p>1. Продолжим рассмотрение других управляющих функций, вызываемых из функции <blockquote>main</blockquote>. Следующая из них — функция <blockquote>update_cd</blockquote>. Эта функция использует обведенное рамкой вложенное окно с прокруткой и нуждается в нескольких константах, которые объявляются как глобальные, поскольку они позже потребуются функции <blockquote>list_tracks</blockquote>.</p>     <p><blockquote><i>#define BOXED_LINES  11</i></blockquote></p>     <p><blockquote><i>#define BOXED_ROWS   60</i></blockquote></p>     <p><blockquote><i>#define BOX_LINE_POS 8</i></blockquote></p>     <p><blockquote><i>#define BOX_ROW_POS  2</i></blockquote></p>     <p>2. Функция <blockquote>update_cd</blockquote> позволяет пользователю заново ввести сведения о дорожках текущего компакт-диска. Удалив предыдущие записи о дорожках, она приглашает ввести новую информацию.</p>     <p><blockquote><i>void update_cd() {</i></blockquote></p>     <p><blockquote> FILE *tracks_fp;</blockquote></p>     <p><blockquote> char track_name[MAX_STRING];</blockquote></p>     <p><blockquote> int len;</blockquote></p>     <p><blockquote> int track = 1;</blockquote></p>     <p><blockquote> int screen_line = 1;</blockquote></p>     <p><blockquote> WINDOW *box_window_ptr;</blockquote></p>     <p><blockquote> WINDOW *sub_window_ptr;</blockquote></p>     <p><blockquote><i> clear_all_screen();</i></blockquote></p>     <p><blockquote> mvprintw(PROMPT_LINE, 0, "Re-entering tracks for CD. ");</blockquote></p>     <p><blockquote><i> if (!get_confirm())</i></blockquote></p>     <p><i><blockquote>return;</blockquote></i></p>     <p><blockquote> move(PROMP_TLINE, 0);</blockquote></p>     <p><blockquote> clrtoeol();</blockquote></p>     <p><blockquote><i> remove_tracks();</i></blockquote></p>     <p><blockquote> mvprintw(MESSAGE_LINE, 0, "Enter a blank line to finish");</blockquote></p>     <p><blockquote> tracks_fp = fopen(tracks_file, "a");</blockquote></p>     <blockquote>      <b>Примечание</b>      <p>Листинг будет продолжен через минуту; мы хотим сделать краткую паузу, чтобы обратить ваше внимание на ввод данных в обрамленное окно с прокруткой. Хитрость заключается в формировании вложенного окна, рисовании рамки по его краю и создании внутри этого окна нового вложенного окна с прокруткой.</p>     </blockquote>     <p><blockquote> box_window_ptr = subwin(stdscr, BOXED_LINES + 2, BOXED_ROWS + 2,</blockquote></p>     <p><blockquote>  BOX_LINE_POS - 1, BOX_ROW_POS - 1);</blockquote></p>     <p><blockquote> if (!box_window_ptr) return;</blockquote></p>     <p><blockquote> box(box_window_ptr, ACS_VLINE, ACS_HLINE);</blockquote></p>     <p><blockquote> sub_window_ptr = subwin(stdscr, BOXED_LINES, BOXED_ROWS,</blockquote></p>     <p><blockquote>  BOX_LINE_POS, BOX_ROW_POS);</blockquote></p>     <p><blockquote> if (!sub_window_ptr) return;</blockquote></p>     <p><blockquote> scrollok(sub_window_ptr, TRUE);</blockquote></p>     <p><blockquote> werase(sub_window_ptr);</blockquote></p>     <p><blockquote> touchwin(stdscr);</blockquote></p>     <p><blockquote> do {</blockquote></p>     <p><blockquote>  mvwprintw(sub_window_ptr, screen_line++, BOX_ROW_POS + 2,</blockquote></p>     <p><blockquote>   "Track %d: ", track);</blockquote></p>     <p><blockquote>  clrtoeol();</blockquote></p>     <p><blockquote>  refresh();</blockquote></p>     <p><blockquote>  wgetnstr(sub_window_ptr, track_name, MAX_STRING);</blockquote></p>     <p><blockquote>  len = strlen(track_name);</blockquote></p>     <p><blockquote>  if (len &gt; 0 &amp;&amp; track_name[len - 1] = '\n')</blockquote></p>     <p><blockquote>   track_name[len - 1] = '\0';</blockquote></p>     <p><blockquote>  if (*track_name)</blockquote></p>     <p><blockquote>   fprintf(tracks_fp, "%s, %d, %s\n", current_cat, track, track_name);</blockquote></p>     <p><blockquote>  track++;</blockquote></p>     <p><blockquote>  if (screen_line &gt; BOXED__LINES - 1) {</blockquote></p>     <p><blockquote>   /* время начать прокрутку */</blockquote></p>     <p><blockquote>   scroll(sub_window_ptr);</blockquote></p>     <p><blockquote>   screen_line--;</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> } while (*track_name);</blockquote></p>     <p><blockquote> delwin(sub_window_ptr);</blockquote></p>     <p><blockquote> fclose(tracks_fp);</blockquote></p>     <p><blockquote>}</blockquote></p>     <b>Удаление записей</b>     <p>1. <blockquote>remove_cd</blockquote> — последняя функция, вызываемая из функции <blockquote>main</blockquote>.</p>     <p><blockquote><i>void remove_cd() {</i></blockquote></p>     <p><blockquote> FILE *titles_fp, *temp_fp;</blockquote></p>     <p><blockquote> char entry[MAX_ENTRY];</blockquote></p>     <p><blockquote> int cat_length;</blockquote></p>     <p><blockquote> if (current_cd[0] == '\0') return;</blockquote></p>     <p><blockquote><i> clear_all_screen();</i></blockquote></p>     <p><blockquote> mvprintw(PROMPT_LINE, 0, "About to remove CD %s: %s. ", current_cat, current_cd);</blockquote></p>     <p><blockquote><i> if (!get_confirm())</i></blockquote></p>     <p><blockquote>  return;</blockquote></p>     <p><blockquote> cat_length = strlen(current_cat);</blockquote></p>     <p><blockquote> /* Файл заголовков копируется во временный, игнорируя данный CD */</blockquote></p>     <p><blockquote> titles_fp = fopen(title_file, "r");</blockquote></p>     <p><blockquote> temp_fp = fopen(temp_flie, "w");</blockquote></p>     <p><blockquote> while(fgets(entry, MAX_ENTRY, titles_fp)) {</blockquote></p>     <p><blockquote>  /* Сравнивает номер в каталоге и копирует элемент, если не</blockquote></p>     <p><blockquote>     найдено совпадение */</blockquote></p>     <p><blockquote>  if (strncmp(current_cat, entry, cat_length) != 0)</blockquote></p>     <p><blockquote>   fputs(entry, temp_fp);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> fclose(titles_fp);</blockquote></p>     <p><blockquote> fclose(temp_fp);</blockquote></p>     <p><blockquote> /* Удаляет файл заголовков и переименовывает временный файл */</blockquote></p>     <p><blockquote> unlink(title_file);</blockquote></p>     <p><blockquote> rename(temp_file, title_file);</blockquote></p>     <p><blockquote> /* Теперь делает то же самое для файла дорожек */</blockquote></p>     <p><blockquote> remove_tracks();</blockquote></p>     <p><blockquote> /* Устанавливает 'None' для текущего CD */</blockquote></p>     <p><blockquote> current_cd[0] = '\0';</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>2. Теперь вам только нужен программный код функции <blockquote>remove_tracks</blockquote>, удаляющей дорожки текущего компакт-диска. Она вызывается двумя функциями — <blockquote>update_cd</blockquote> и <blockquote>remove_cd</blockquote>.</p>     <p><blockquote><i>void remove_tracks() {</i></blockquote></p>     <p><blockquote> FILE *tracks_fp, *temp_fp;</blockquote></p>     <p><blockquote> char entry[MAX_ENTRY];</blockquote></p>     <p><blockquote> int cat_length;</blockquote></p>     <p><blockquote> if (current_cd[0] == '\0') return;</blockquote></p>     <p><blockquote> cat_length = strlen(current_cat);</blockquote></p>     <p><blockquote> tracks_fp = fopen(tracks_file, "r");</blockquote></p>     <p><blockquote> if (tracks_fp == (FILE *)NULL) return;</blockquote></p>     <p><blockquote> temp_fp = fopen(temp_file, "w");</blockquote></p>     <p><blockquote> while (fgets(entry, MAX_ENTRY, tracks_fp)) {</blockquote></p>     <p><blockquote>  /* Сравнивает номер в каталоге и копирует элемент, если не</blockquote></p>     <p><blockquote>     найдено совпадение */</blockquote></p>     <p><blockquote>  if (strncmp(current_cat, entry, cat_length) != 0)</blockquote></p>     <p><blockquote>   fputs(entry, temp_fp);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> fclose(tracks_fp);</blockquote></p>     <p><blockquote> fclose(temp_fp);</blockquote></p>     <p><blockquote> /* Удаляет файл дорожек<i> и</i> переименовывает временный файл */</blockquote></p>     <p><blockquote> unlink(tracks_file);</blockquote></p>     <p><blockquote> rename(temp_file, tracks_file);</blockquote></p>     <p><blockquote>}</blockquote></p>             <a name="metkadoc28"><h1>Запросы к базе данных компакт-дисков</h1></a>     <p>Теперь рассмотрим функции для доступа к данным, которые для упрощения доступа хранятся в паре простых файлов как поля, разделенные запятыми.</p>     <p>1. Страстным коллекционерам важно знать, каким богатством они обладают или сколько собрано. Следующая функция делает это превосходно; она просматривает базу данных, подсчитывая заголовки и дорожки.</p>     <p><blockquote><i>void count_cds() {</i></blockquote></p>     <p><blockquote> FILE *titles_fp, *tracks_fp;</blockquote></p>     <p><blockquote> char entry[MAX_ENTRY];</blockquote></p>     <p><blockquote> int titles = 0;</blockquote></p>     <p><blockquote> int tracks = 0;</blockquote></p>     <p><blockquote> titles_fp = fopen(title_file, "r");</blockquote></p>     <p><blockquote> if (titles_fp) {</blockquote></p>     <p><blockquote>  while (fgets(entry, MAX_ENTRY, titles_fp))</blockquote></p>     <p><blockquote>   titles++;</blockquote></p>     <p><blockquote>  fclose(titles_fp);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> tracks_fp = fopen(tracks_file, "r");</blockquote></p>     <p><blockquote> if (tracks_fp) {</blockquote></p>     <p><blockquote>  while (fgets(entry, MAX_ENTRY, tracks_fp))</blockquote></p>     <p><blockquote>   tracks++;</blockquote></p>     <p><blockquote>  fclose(tracks_fp);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> mvprintw(ERROR_LINE, 0,</blockquote></p>     <p><blockquote>  "Database contains %d titles, with a total of %d tracks.", titles, tracks);</blockquote></p>     <p><blockquote> get_return();</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>2. Вы потеряли аннотацию к вашему любимому компакт-диску? Не волнуйтесь! Если вы аккуратно ввели подробную информацию в базу данных, теперь можно найти перечень дорожек с помощью функции <blockquote>find_cd</blockquote>. Она предлагает ввести подстроку, совпадение с которой нужно искать в базе данных, и устанавливает в глобальную переменную <blockquote>current_cd</blockquote> заголовок найденного компакт-диска.</p>     <p><blockquote><i>void find_cd() {</i></blockquote></p>     <p><blockquote> char match[MAX_STRING], entry[MAX_ENTRY];</blockquote></p>     <p><blockquote> FILE *titles_fp;</blockquote></p>     <p><blockquote> int count = 0;</blockquote></p>     <p><blockquote> char *found, *title, *catalog;</blockquote></p>     <p><blockquote> mvprintw(Q_LINE, 0, "Enter a string to search for in CD titles: ");</blockquote></p>     <p><blockquote><i> get_string(match);</i></blockquote></p>     <p><blockquote> titles_fp = fopen(title_file, "r");</blockquote></p>     <p><blockquote> if (titles_fp) {</blockquote></p>     <p><blockquote>  while (fgets(entry, MAX_ENTRY, titles_fp)) {</blockquote></p>     <p><blockquote>   /* Пропускает прежний номер в каталоге */</blockquote></p>     <p><blockquote>   catalog = entry;</blockquote></p>     <p><blockquote>   if (found == strstr(catalog, ", ")) {</blockquote></p>     <p><blockquote>    *found = '\0';</blockquote></p>     <p><blockquote>    title = found + 1;</blockquote></p>     <p><blockquote>    /* Стирает следующую запятую в элементе, укорачивая его</blockquote></p>     <p><blockquote>       только до заголовка */</blockquote></p>     <p><blockquote>    if (found == strstr(title, ", ")) {</blockquote></p>     <p><blockquote>     *found = '\0';</blockquote></p>     <p><blockquote>     /* Теперь проверяет, есть ли совпадающая строка */</blockquote></p>     <p><blockquote>     if (found == strstr(title, match)) {</blockquote></p>     <p><blockquote>      count++;</blockquote></p>     <p><blockquote>      strcpy(current_cd, title);</blockquote></p>     <p><blockquote>      strcpy(current_cat, catalog);</blockquote></p>     <p><blockquote>     }</blockquote></p>     <p><blockquote>    }</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  fclose(titles_fp);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> if (count != 1) {</blockquote></p>     <p><blockquote>  if (count == 0) {</blockquote></p>     <p><blockquote>   mvprintw(ERROR_LINE, 0, "Sorry, no matching CD found. ");</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  if (count &gt; 1) {</blockquote></p>     <p><blockquote>   mvprintw(ERROR_LINE, 0,</blockquote></p>     <p><blockquote>    "Sorry, match is ambiguous: CDs found. ", count);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  current_cd[0] = '\0';</blockquote></p>     <p><blockquote><i>  get_return();</i></blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Хотя переменная <blockquote>catalog</blockquote> указывает на массив, больший чем <blockquote>current_cat</blockquote>, и могла бы переписать память, проверка в функции <blockquote>fgets</blockquote> препятствует этому.</p>     <p>3. Вам также нужно иметь возможность перечислить на экране дорожки выбранного компакт-диска. Для вложенных окон можно использовать директивы <blockquote>#define</blockquote>, применявшиеся в функции <blockquote>update_cd</blockquote> в предыдущем разделе.</p>     <p><blockquote><i>void list_tracks() {</i></blockquote></p>     <p><blockquote> FILE *tracks_fp;</blockquote></p>     <p><blockquote> char entry[MAX_ENTRY];</blockquote></p>     <p><blockquote> int cat_length;</blockquote></p>     <p><blockquote> int lines_op = 0;</blockquote></p>     <p><blockquote> WINDOW *track_pad_ptr;</blockquote></p>     <p><blockquote> int tracks = 0;</blockquote></p>     <p><blockquote> int key;</blockquote></p>     <p><blockquote> int first_line = 0;</blockquote></p>     <p><blockquote> if (current_cd[0] == '\0') {</blockquote></p>     <p><blockquote>  mvprintw(ERROR_LINE, 0, "You must select a CD first. ");</blockquote></p>     <p><blockquote><i>  get_return();</i></blockquote></p>     <p><blockquote>  return;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote><i> clear_all_screen();</i></blockquote></p>     <p><blockquote> cat_length = strlen(current_cat);</blockquote></p>     <p><blockquote> /* Сначала считает количество дорожек у текущего CD */</blockquote></p>     <p><blockquote> tracks_fp = fopen(tracks_file, "r");</blockquote></p>     <p><blockquote> if (!tracks_fp) return;</blockquote></p>     <p><blockquote> while (fgets(entry, MAX_ENTRY, tracks_fp)) {</blockquote></p>     <p><blockquote>  if (strncmp(current_cat, entry, cat_length) == 0) tracks++;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> fclose(tracks_fp);</blockquote></p>     <p><blockquote> /* Создает новую панель, гарантируя, что даже при наличии одной</blockquote></p>     <p><blockquote>    дорожки панель достаточна большая, поэтому последующий вызов</blockquote></p>     <p><blockquote>    prefresh() всегда будет допустим. */</blockquote></p>     <p><blockquote> track_pad_ptr = newpad(tracks + 1 + ВОХЕD_LINES, BOXED_ROWS + 1);</blockquote></p>     <p><blockquote> if (!track_pad_ptr) return;</blockquote></p>     <p><blockquote> tracks_fp = fopen(tracks_file, "r");</blockquote></p>     <p><blockquote> if (!tracks_fp) return;</blockquote></p>     <p><blockquote> mvprintw(4, 0, "CD Track Listing\n");</blockquote></p>     <p><blockquote> /* Записывает сведения о дорожке на панель */</blockquote></p>     <p><blockquote> while (fgets(entry, MAX_ENTRY, tracks_fp)) {</blockquote></p>     <p><blockquote>  /* Сравнивает номер каталога и оставшийся вывод элемента */</blockquote></p>     <p><blockquote>  if (strncmp(current_cat, entry, cat_length) == 0) {</blockquote></p>     <p><blockquote>   mvwprintw(track_pad_ptr, lines_op++, 0, "%s", entry + cat_length + 1);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> fclose(tracks_fp);</blockquote></p>     <p><blockquote> if (lines_op &gt; BOXED_LINES) {</blockquote></p>     <p><blockquote>  mvprintw(MESSAGE_LINE, 0,</blockquote></p>     <p><blockquote>   "Cursor keys to scroll, RETURN or q to exit");</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  mvprintw(MESSAGE_LINE, 0, "RETURN or q to exit");</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> wrefresh(stdscr);</blockquote></p>     <p><blockquote> keypad(stdscr, TRUE);</blockquote></p>     <p><blockquote> cbreak();</blockquote></p>     <p><blockquote> noecho();</blockquote></p>     <p><blockquote> key = 0;</blockquote></p>     <p><blockquote> while (key != "q" &amp;&amp; key != KEY_ENTER &amp;&amp; key != '\n') {</blockquote></p>     <p><blockquote>  if (key == KEY_UP) {</blockquote></p>     <p><blockquote>   if (first_line &gt; 0) first_line--;</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  if (key == KEY_DOWN) {</blockquote></p>     <p><blockquote>   if (first_line + BOXED_LINES + 1 &lt; tracks) first_line++;</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  /* Теперь рисует соответствующую часть панели на экране */</blockquote></p>     <p><blockquote>  prefresh(track_pad_ptr, first_line, 0, BOX_LINE_POS, BOX_ROW_POS,</blockquote></p>     <p><blockquote>   BOX_LINE_POS + BOXED_LINES, BOX_ROW_POS + BOXED_ROWS);</blockquote></p>     <p><blockquote>  key = getch();</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> delwin(track_pad_ptr);</blockquote></p>     <p><blockquote> keypad(stdsсr, FALSE);</blockquote></p>     <p><blockquote> nocbreak();</blockquote></p>     <p><blockquote> echo();</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>4. В последних двух функциях вызывается функция <blockquote>get_return</blockquote>, которая приглашает к вводу и считывает символ возврата каретки, игнорируя другие символы.</p>     <p><blockquote><i>void get_return() {</i></blockquote></p>     <p><blockquote> int ch;</blockquote></p>     <p><blockquote> mvprintw(23, 0, "is", " Press return ");</blockquote></p>     <p><blockquote> refresh();</blockquote></p>     <p><blockquote> while ((ch = getchar()) != '\n' &amp;&amp; ch != EOF);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Если вы выполните эту программу, то увидите на экране нечто похожее на рис. 6.10.</p>     <img src="image021.jpg"/>     <p><b>Рис. 6.10</b> </p>              <a name="metkadoc29"><h1>Резюме </h1></a>    <p>В этой главе вы изучили библиотеку curses. Она предлагает текстовым программам удобный способ управления экраном и считывания данных с клавиатуры. Хотя библиотека curses не обеспечивает такого уровня управления, как общий терминальный интерфейс (GTI) и прямой доступ к структуре <blockquote>terminfo</blockquote>, ею гораздо легче пользоваться. Если вы пишете полноэкранное текстовое приложение, стоит рассмотреть возможность применения в нем библиотеки curses для управления экраном и чтения данных с клавиатуры.</p>     <br><br>
<center><div align="center"><a href="index.php.html">Оглавление</a></div></center>




<br>
<script type="text/javascript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="https://www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script><br>

<noindex>
<div align="center">
<center>

<!-- SAPE RTB DIV 600x340 -->
<div id="SRTB_507029"></div>
<!-- SAPE RTB END -->

</center>
</div>
</noindex>

</td>
<td width="240" valign="top">

<br>

<div id="menu3">
<ul>
<li><a href="../../alternativnaja_medicina/index.html"><span>Альтернативная медицина</span></a></li>
<li><a href="../../astronomija_i_kosmos/index.html"><span>Астрономия и Космос</span></a></li>
<li><a href="../../biologija/index.html"><span>Биология</span></a></li>
<li><a href="../../voennaja_istorija/index.html"><span>Военная история</span></a></li>
<li><a href="../../geologija_i_geografija/index.html"><span>Геология и география</span></a></li>
<li><a href="../../gosudarstvo_i_pravo/index.html"><span>Государство и право</span></a></li>
<li><a href="../../delovaja_literatura/index.html"><span>Деловая литература</span></a></li>
<li><a href="../../domashnie_zhivotnye/index.html"><span>Домашние животные</span></a></li>
<li><a href="../../domovodstvo/index.html"><span>Домоводство</span></a></li>
<li><a href="../../zdorove/index.html"><span>Здоровье</span></a></li>
<li><a href="../../istorija/index.html"><span>История</span></a></li>
<li><a href="../index.html"><span>Компьютеры и Интернет</span></a></li>
<li><a href="../../kulinarija/index.html"><span>Кулинария</span></a></li>
<li><a href="../../kulturologija/index.html"><span>Культурология</span></a></li>
<li><a href="../../literaturovedenie/index.html"><span>Литературоведение</span></a></li>
<li><a href="../../matematika/index.html"><span>Математика</span></a></li>
<li><a href="../../medicina/index.html"><span>Медицина</span></a></li>
<li><a href="../../nauchnaja_literatura_prochee/index.html"><span>Науч. литер. - прочее</span></a></li>
<li><a href="../../pedagogika/index.html"><span>Педагогика</span></a></li>
<li><a href="../../politika/index.html"><span>Политика</span></a></li>
<li><a href="../../psihologija/index.html"><span>Психология</span></a></li>
<li><a href="../../religiovedenie/index.html"><span>Религиоведение</span></a></li>
<li><a href="../../sad_i_ogorod/index.html"><span>Сад и огород</span></a></li>
<li><a href="../../samosovershenstvovanie/index.html"><span>Самосовершенствование</span></a></li>
<li><a href="../../sdelai_sam/index.html"><span>Сделай сам</span></a></li>
<li><a href="../../sport/index.html"><span>Спорт</span></a></li>
<li><a href="../../tehnicheskie_nauki/index.html"><span>Технические науки</span></a></li>
<li><a href="../../transport_i_aviacija/index.html"><span>Транспорт и авиация</span></a></li>
<li><a href="../../uchebniki/index.html"><span>Учебники</span></a></li>
<li><a href="../../fizika/index.html"><span>Физика</span></a></li>
<li><a href="../../filosofija/index.html"><span>Философия</span></a></li>
<li><a href="../../himija/index.html"><span>Химия</span></a></li>
<li><a href="../../hobbi_i_remesla/index.html"><span>Хобби и ремесла</span></a></li>
<li><a href="../../shpargalki/index.html"><span>Шпаргалки</span></a></li>
<li><a href="../../yezoterika/index.html"><span>Эзотерика</span></a></li>
<li><a href="../../yurisprudencija/index.html"><span>Юриспруденция</span></a></li>
<li><a href="../../jazykoznanie/index.html"><span>Языкознание</span></a></li>
</ul>
</div>

<br>
<div align="center">
<center>
<noindex>

<!-- SAPE RTB DIV 240x400 -->
<div id="SRTB_507028"></div>
<!-- SAPE RTB END -->

</noindex>
</center>
</div>

</td>
</tr>
<tr>
<td colspan="3" align="center">


<hr>
<a href="../../index.html"><span>Главная</span></a> | 
<a rel="sidebar" href="p10.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a> | 
<a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a> | 
<a href="p10.php.html#" onClick="scroll(0,0); return false" title="наверх">Наверх</a>
</td>
</tr>
<tr>
<td colspan="3" valign="top" align="left">
<br>

 



</td>
</tr>
</table>

<noindex>
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter21717787 = new Ya.Metrika({id:21717787,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="http://mc.yandex.ru/watch/21717787" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

</noindex>
</center>
</div></body>
</html>