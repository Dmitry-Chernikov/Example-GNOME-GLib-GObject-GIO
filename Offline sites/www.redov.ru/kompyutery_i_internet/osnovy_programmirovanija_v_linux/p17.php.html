<html>
<head>
<meta http-equiv="Content-Language" content="ru">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<link href="../../0img/style.css" rel="stylesheet" type="text/css" />
<link rel="SHORTCUT ICON" href="http://www.redov.ru/0img/favicon.ico" type="image/x-icon"> 
<title>Глава 13 Связь между процессами: каналы / Основы программирования в Linux</title>
</head>
<body>
<div align="center">
<center>
<table border="0" cellpadding="0" cellspacing="0" width="1260">
<tr>
<td colspan="3" valign="top" align="left" height="100">
<table border="0" cellpadding="0" cellspacing="0" width="1260" height="100">
<tr>
<td valign="middle" align="center" width="350">
<a href="../../index.html"><img src="../../0img/logo.jpg" width="350" height="100" title="Онлайн библиотека redov.ru"/></a>
</td>
<td valign="middle" align="center" width="910">

<noindex>

<!-- SAPE RTB JS -->
<script
    async="async"
    src="http://cdn-rtb.sape.ru/rtb-b/js/393/2/106393.js"
    type="text/javascript">
</script>
<!-- SAPE RTB END -->

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507025"></div>
<!-- SAPE RTB END -->

</noindex>

</td>
</tr>
</table>
</td>
</tr>
<tr>
<td colspan="3" valign="middle" align="left">

<div id="menu">
<ul>
		<li><a href="../../index.html"><span>Главная</span></a></li>
		<li><a rel="sidebar" href="p17.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a></li>
		<li><a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a></li>
		<li><a href="p17.php.html#" onClick="scroll(0,9999999); return false"><span>Вниз</span></a></li>
</ul>
</div>


</td>
</tr>
<tr>
<td width="240" valign="top" align="center">

<br>
<noindex>
<!-- SAPE RTB DIV 160x600 -->
<div id="SRTB_733378"></div>
<!-- SAPE RTB END -->
</noindex>



</td>
<td valign="top" align="left" style="padding-left: 5; padding-right: 5" width="780">
<br>
<noindex>
<div align="center">

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507027"></div>
<!-- SAPE RTB END -->

</div>
</noindex>
<br>



<li><a href="p17.php.html#metkadoc2">     Что такое канал?     </a></li>
<li><a href="p17.php.html#metkadoc3">     Каналы процессов     </a></li>
<li><a href="p17.php.html#metkadoc4">      <i>popen</i>      </a></li>
<li><a href="p17.php.html#metkadoc5">      <i>pclose</i>      </a></li>
<li><a href="p17.php.html#metkadoc6">     Отправка вывода в <i>popen</i>     </a></li>
<li><a href="p17.php.html#metkadoc7">      Передача данных большого объема      </a></li>
<li><a href="p17.php.html#metkadoc8">      Как реализован вызов <i>popen</i>      </a></li>
<li><a href="p17.php.html#metkadoc9">     Вызов <i>pipe</i>     </a></li>
<li><a href="p17.php.html#metkadoc10">     Родительский и дочерний процессы     </a></li>
<li><a href="p17.php.html#metkadoc11">      Чтение закрытых каналов      </a></li>
<li><a href="p17.php.html#metkadoc12">      Каналы, применяемые как стандартные ввод и вывод      </a></li>
<li><a href="p17.php.html#metkadoc13">     Именованные каналы: FIFO     </a></li>
<li><a href="p17.php.html#metkadoc14">      Доступ к FIFO      </a></li>
<li><a href="p17.php.html#metkadoc15">      Более сложная тема: применение каналов FIFO в клиент-серверных приложениях      </a></li>
<li><a href="p17.php.html#metkadoc16">     Приложение для работы с базой данных компакт-дисков     </a></li>
<li><a href="p17.php.html#metkadoc17">      Цели      </a></li>
<li><a href="p17.php.html#metkadoc18">      Реализация      </a></li>
<li><a href="p17.php.html#metkadoc19">      Функции интерфейса клиента      </a></li>
<li><a href="p17.php.html#metkadoc20">      Интерфейс сервера server.c      </a></li>
<li><a href="p17.php.html#metkadoc21">      Канал      </a></li>
<li><a href="p17.php.html#metkadoc22">      Резюме, касающееся приложения      </a></li>
<li><a href="p17.php.html#metkadoc23">     Резюме      </a></li>
<a name="metkadoc1"><h1>Глава 13</p>    <p>Связь между процессами: каналы</h1></a>       <p>В<i> главе 11</i> вы видели очень простой способ пересылки сообщений между процессами с помощью сигналов. Вы формировали уведомляющие события, которые могли бы применяться для вызова ответа, но передаваемая информация была ограничена номером сигнала.</p>    <p>В этой главе вы познакомитесь с каналами, которые позволяют процессам обмениваться более полезной информацией. В конце этой главы вы примените свои вновь приобретенные знания для новой реализации программы, управляющей базой данных компакт-дисков, в виде клиент-серверного приложения.</p>    <p>В данной главе мы обсудим следующие темы:</p>    <p>&#9633; определение канала;</p>    <p>&#9633; каналы процессов;</p>    <p>&#9633; вызовы каналов;</p>    <p>&#9633; родительские и дочерние процессы;</p>    <p>&#9633; именованные каналы — FIFO;</p>    <p>&#9633; замечания, касающиеся клиент-серверных приложений.</p>          <a name="metkadoc2"><h1>Что такое канал?</h1></a>    <p>Мы применяем термин<i> "канал"</i> для обозначения соединения потока данных одного процесса с другим. Обычно вы присоединяете или связываете каналом вывод одного процесса с вводом другого.</p>    <p>Большинство пользователей Linux уже знакомы с идеей конвейера, связывающего вместе команды оболочки так, что вывод одного процесса поставляет данные прямо во ввод другого. В случае команд оболочки это делается с помощью символа конвейера или канала, соединяющего команды следующим образом:</p>    <p><blockquote>cmd1 | cmd2</blockquote></p>    <p>Командная оболочка организует стандартный ввод и вывод двух команд так, что:</p>    <p>&#9633; стандартный ввод <blockquote>cmd1</blockquote> поступает с клавиатуры терминала;</p>    <p>&#9633; стандартный вывод <blockquote>cmd1</blockquote> поставляется <blockquote>cmd2</blockquote> как ее стандартный ввод;</p>    <p>&#9633; стандартный вывод <blockquote>cmd2</blockquote> подсоединен к экрану терминала.</p>    <p>На самом деле командная оболочка заново соединила потоки стандартных ввода и вывода так, что потоки данных проходят с клавиатурного ввода через две команды и выводятся на экран. На рис. 13.1 приведено визуальное представление этого процесса.</p>    <img src="image039.jpg"/>    <p><b>Рис. 13.1</b> </p>    <br>    <p>В этой главе вы увидите, как достичь этого эффекта в программе и как можно использовать каналы для связи многих процессов, что позволит создать простую клиент-серверную систему.</p>          <a name="metkadoc3"><h1>Каналы процессов</h1></a>         <p>Возможно, простейший способ передачи данных между программами — применение функций <blockquote>popen</blockquote> и <blockquote>pclose</blockquote>. У них следующие прототипы:</p>     <p><blockquote><b>#include &lt;stdio.h&gt;</b></blockquote></p>     <p><blockquote><b>FILE *popen(const char *command, const char *open_mode);</b></blockquote></p>     <p><blockquote><b>int pclose(FILE *stream_to_close);</b></blockquote></p>             <a name="metkadoc4"><h1><i>popen</i></h1></a>     <p>Функция popen позволяет программе запустить другую программу как новый процесс и либо передать ей данные, либо получить их из нее. Строка <blockquote>command</blockquote> — это имя программы для выполнения вместе с любыми параметрами, параметр <blockquote>open_mode</blockquote> должен быть <blockquote>"r"</blockquote> или <blockquote>"w"</blockquote>.</p>     <p>Если <blockquote>open_mode</blockquote> — <blockquote>"r"</blockquote>, вывод вызванной программы становится доступен вызывающей программе и может быть считан из возвращаемого функцией <blockquote>popen</blockquote> файлового потока <blockquote>FILE*</blockquote> с помощью обычных функций библиотеки stdio, предназначенных для чтения (например, <blockquote>fread</blockquote>). Но если <blockquote>open_mode</blockquote> — <blockquote>"w"</blockquote>, программа может отправить данные вызванной команде с помощью вызова функции <blockquote>fwrite</blockquote>. Далее вызванная программа сможет читать данные из своего стандартного ввода. Обычно вызванная программа не знает, что она считывает данные из другого процесса; она просто читает свой поток стандартного ввода и воздействует на него.</p>     <p>Вызов функции <blockquote>popen</blockquote> должен задавать <blockquote>"r"</blockquote> или <blockquote>"w"</blockquote>; никакого другого значения стандартной реализацией popen не поддерживается. Это означает, что вы не можете вызвать другую программу и одновременно читать из нее и писать в нее. В случае сбоя <blockquote>popen</blockquote> возвращает пустой указатель. Если вы хотите создать двунаправленную связь с помощью каналов, стандартное решение — применить два канала: по одному для потока данных каждого направления.</p>             <a name="metkadoc5"><h1><i>pclose</i></h1></a>     <p>Когда процесс, стартовавший с помощью <blockquote>popen</blockquote>, закончится, вы можете закрыть файловый поток, связанный с ним, с помощью функции <blockquote>pclose</blockquote>. Вызов <blockquote>pclose</blockquote> вернет управление, только когда процесс, запущенный с помощью <blockquote>popen</blockquote>, завершится. Если он все еще выполняется во время вызова <blockquote>pclose</blockquote>, вызов <blockquote>pclose</blockquote> будет ждать окончания процесса.</p>     <p>Функция <blockquote>pclose</blockquote> обычно возвращает код завершения процесса, чей файловый поток она закрывает. Если вызывающий процесс уже выполнил оператор <blockquote>wait</blockquote> перед вызовом <blockquote>pclose</blockquote>, статус завершения будет потерян, поскольку вызванный процесс закончен, и функция <blockquote>pclose</blockquote> вернет -1 с переменной <blockquote>errno</blockquote>, получившей значение <blockquote>ECHILD</blockquote>.</p>     <p>Выполните упражнение 13.1.</p>     <b>Упражнение 13.1. Чтение вывода внешней программы</b>     <p>Давайте опробуем простой пример popen1.c с функциями <blockquote>popen</blockquote> и <blockquote>pclose</blockquote>. Вы будете применять в программе <blockquote>popen</blockquote> для доступа к информации из <blockquote>uname</blockquote>. <blockquote>uname</blockquote> — это команда, выводящая системную информацию, включая тип компьютера, имя ОС, версию и выпуск, а также сетевое имя машины.</p>     <p>Запустив программу, вы откроете канал к <blockquote>uname</blockquote>; сделаете его читаемым и зададите <blockquote>read_fp</blockquote>, как указатель на вывод. В конце канал, на который указывает <blockquote>read_fp</blockquote>, закрывается.</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> FILE *read_fp;</blockquote></p>     <p><blockquote> char buffer[BUFSIZ +1];</blockquote></p>     <p><blockquote> int chars_read;</blockquote></p>     <p><blockquote> memset(buffer, '\0', sizeof(buffer));</blockquote></p>     <p><blockquote> read_fp = popen("uname -a", "r");</blockquote></p>     <p><blockquote> if (read_fp ! = NULL) {</blockquote></p>     <p><blockquote>  chars_read = fread(buffer, sizeof(char), BUFSIZ, read_fp);</blockquote></p>     <p><blockquote>  if (chars_read &gt; 0) {</blockquote></p>     <p><blockquote>   printf("Output was:-\n%s\n", buffer);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  pclose(read_fp);</blockquote></p>     <p><blockquote>  exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Когда вы выполните программу, то должны получить вывод, похожий на следующий (полученный на одной из машин авторов):</p>     <p><blockquote>$ ./popen1</blockquote></p>     <p><blockquote>Output was:-</blockquote></p>     <p><blockquote>Linux suse103 2.6.20.2-2-default #1 SMP Fri Mar 9 21:54:10 UTC 2001 i686 i686 i386 GNU/Linux</blockquote></p>     <p><b>Как это работает</b></p>     <p>Программа применяет функцию <blockquote>popen</blockquote> для вызова команды <blockquote>uname</blockquote> с параметром <blockquote>-а</blockquote>. Затем она использует возвращенный файловый поток для чтения данных, до <blockquote>BUFSIZ</blockquote> символов (как задано в директиве <blockquote>#define</blockquote> из файла stdio.h), и затем выводит их на экран. Поскольку вы перехватываете вывод команды uname внутри программы, его можно обрабатывать.</p>              <a name="metkadoc6"><h1>Отправка вывода в <i>popen</i></h1></a>         <p>Теперь, когда вы рассмотрели пример захвата вывода из внешней программы, давайте познакомимся с отправкой вывода во внешнюю программу. В упражнении 13.2 показана программа popen2.c, передающая по каналу данные другой программе. В этом примере будет использована команда od (от англ. <i>octal dump — </i>восьмеричный дамп).</p>     <b>Упражнение 13.2. Пересылка вывода в другую программу</b>     <p>Взглянув на следующий программный код, вы увидите, что он очень похож на предыдущий пример, за исключением того, что вы пишете данные в канал вместо чтения данных из него. Далее приведена программа popen2.c.</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> FILE *write_fp;</blockquote></p>     <p><blockquote> char buffer[BUFSIZ + 1];</blockquote></p>     <p><blockquote> sprintf(buffer, "Once upon a time, there was...\n");</blockquote></p>     <p><blockquote> write_fp = popen("od -c", "w");</blockquote></p>     <p><blockquote> if (write_fp != NULL) {</blockquote></p>     <p><blockquote>  fwrite(buffer, sizeof(char), strlen(buffer), write_fp);</blockquote></p>     <p><blockquote>  pclose(write_fp);</blockquote></p>     <p><blockquote>  exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>После выполнения этой программы вы должны получить следующий вывод:</p>     <p><blockquote>$ <b>./popen2</b></blockquote></p>     <p><blockquote>0000000  O n c e   u p o n   a   t i m e</blockquote></p>     <p><blockquote>0000020  ,   t h e r e   w a s . . . \n</blockquote></p>     <p><blockquote>0000037</blockquote></p>     <p><b>Как это работает</b></p>     <p>Программа применяет <blockquote>popen</blockquote> с параметром "w" для запуска команды <blockquote>od -с</blockquote> таким образом, что может отправить данные этой команде. Затем она отправляет строку, которую команда <blockquote>od -с</blockquote> получает и обрабатывает; далее команда <blockquote>od -с</blockquote> выводит результат обработки в своем стандартном выводе.</p>     <p>Такой же вывод можно получить из командной строки с помощью следующей команды:</p>     <p><blockquote>$ <b>echo "Once upon a time, there was..." | od -c</b></blockquote></p>             <a name="metkadoc7"><h1>Передача данных большого объема</h1></a>     <p>Механизм, применявшийся до сих пор, просто отправляет и получает все данные в одном вызове <blockquote>fread</blockquote> или <blockquote>fwrite</blockquote>. Порой вам может понадобиться отправлять данные меньшими порциями или вы не будете знать размера вывода. Для того чтобы не объявлять слишком большой буфер, можно просто применить множественные вызовы <blockquote>fread</blockquote> или <blockquote>fwrite</blockquote> и обрабатывать данные порциями.</p>     <p>В упражнении 13.3 приведена программа popen3.c, читающая все данные из канала.</p>     <b>Упражнение 13.3. Чтение из канала данных большого объема</b>     <p>В этой программе вы читаете данные из вызванного процесса <blockquote>ps ах</blockquote>. У вас нет возможности узнать заранее, какой величины будет вывод, поэтому вы должны разрешить множественные операции чтения из канала.</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> FILE * read_fp;</blockquote></p>     <p><blockquote> char buffer[BUFSIZ + 1];</blockquote></p>     <p><blockquote> int chars_read;</blockquote></p>     <p><blockquote> memset(buffer, '\0' , sizeof(buffer));</blockquote></p>     <p><blockquote> read_fp = popen("ps ax", "r");</blockquote></p>     <p><blockquote> if(read_fp != NULL) {</blockquote></p>     <p><blockquote>  chars_read = fread(buffer, sizeof(char), BUFSIZ, read_fp);</blockquote></p>     <p><blockquote>  while (chars_read &gt; 0) {</blockquote></p>     <p><blockquote>   buffer[chars_read - 1] = '\0';</blockquote></p>     <p><blockquote>   printf("Reading %d:-\n %s\n", BUFSIZ, buffer);</blockquote></p>     <p><blockquote>   chars_read = fread(buffer, sizeof(char), BUFSIZ, read_fp);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  pclose(read_fp);</blockquote></p>     <p><blockquote>  exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Вывод, отредактированный для краткости, подобен приведенному далее:</p>     <p><blockquote>$ <b>./popen3</b></blockquote></p>     <p><blockquote>Reading 1024:-</blockquote></p>     <p><blockquote>PID TTY  STAT TIME COMMAND</blockquote></p>     <p><blockquote>  1 ?    Ss   0:03 init [5]</blockquote></p>     <p><blockquote>  2 ?    SW   0:00 [kflushd]</blockquote></p>     <p><blockquote>  3 ?    SW   0:00 [kpiod]</blockquote></p>     <p><blockquote>  4 ?    SW   0:00 [kswapd]</blockquote></p>     <p><blockquote>  5 ?    SW&lt;  0:00 [mdrecoveryd]</blockquote></p>     <p><blockquote>...</blockquote></p>     <p><blockquote>240 tty2 S    0:02 emacs draft1.txt</blockquote></p>     <p><blockquote>Reading 1024:-</blockquote></p>     <p><blockquote>368 tty1 S    0:00 ./popen 3</blockquote></p>     <p><blockquote>369 tty1 R    0:00 ps -ax</blockquote></p>     <p><blockquote>370 ...</blockquote></p>     <p><b>Как это работает</b></p>     <p>Программа применяет функцию <blockquote>popen</blockquote> с параметром <blockquote>"r"</blockquote> аналогично программе popen1.c. В этот раз она продолжает чтение из файлового потока до тех пор, пока в нем есть данные. Учтите, что, хотя программе <blockquote>ps</blockquote> нужно некоторое время для выполнения, Linux так организует планирование процессов, что обе программы выполняются, когда могут. Если у читающего процесса popen3 нет входных данных, он приостанавливается до появления доступных данных. Если записывающий процесс <blockquote>ps</blockquote> формирует вывод, больший по объему, чем может вместить буфер, он приостанавливается до тех пор, пока считывающий процесс не обработает какой-то объем данных.</p>     <p>В этом примере строка <blockquote>Reading:-</blockquote> может не появиться второй раз. Это означает, что <blockquote>BUFSIZ</blockquote> больше объема вывода команды <blockquote>ps</blockquote>. В некоторых (самых современных) системах Linux установлен размер буфера <blockquote>BUFSIZ</blockquote>, равный 8192 байт или даже больше. Для того чтобы проверить корректность работы программы при считывании нескольких порций вывода, попробуйте считывать за один раз меньше символов, чем <blockquote>BUFSIZ</blockquote>, может быть <blockquote>BUFSIZ/10</blockquote>.</p>             <a name="metkadoc8"><h1>Как реализован вызов <i>popen</i></h1></a>     <p>Вызов <blockquote>popen</blockquote> выполняет программу, которую вы запросили, прежде всего, вызывая командную оболочку <blockquote>sh</blockquote> и передавая ей командную строку как аргумент. У этого процесса две стороны: приятная и не очень.</p>     <p>В ОС Linux (как и во всех UNIX-подобных системах) подстановка всех параметров выполняется командной оболочкой, поэтому вызов оболочки для синтаксического анализа командной строки перед вызовом программы дает возможность командной оболочке выполнить любую подстановку, например, определить реальные файлы, на которые ссылается строка *.с до того, как программа начнет выполняться. Часто это очень полезно и позволяет запускать с помощью <blockquote>popen</blockquote> сложные команды оболочки. Другие функции создания процесса, например <blockquote>execl</blockquote>, гораздо сложнее применять для вызова, поскольку вызывающий процесс должен самостоятельно выполнять подстановки параметров командной оболочки.</p>     <p>Нежелательный эффект применения командной оболочки состоит в том, что для каждого вызова <blockquote>popen</blockquote> вместе с требуемой программой вызывается командная оболочка. Далее каждый вызов <blockquote>popen</blockquote> порождает запуск двух дополнительных процессов, что делает функцию <blockquote>popen</blockquote> немного расточительной с точки зрения расходования системных ресурсов и вызов нужной команды выполняется медленнее, чем было бы в противном случае.</p>     <p>В упражнении 13.4 приведена программа popen4.c, которую можно использовать для демонстрации поведения <blockquote>popen</blockquote>. Вы можете сосчитать количество строк во всех файлах с исходным текстом примеров семейства <blockquote>popen</blockquote>, применив команду <blockquote>cat</blockquote> к файлам и затем пересылая по каналу вывод в команду <blockquote>wc -l</blockquote>, которая считает количество строк. В командной строке эквивалентная команда выглядит следующим образом:</p>     <p><blockquote>$ <b>cat popen*.c | wc -l</b></blockquote></p>     <blockquote>      <b>Примечание</b>      <p>На самом деле <blockquote>wc -l popen*.c</blockquote> легче и гораздо эффективнее ввести с клавиатуры, но пример иллюстрирует основные принципы использования каналов.</p>     </blockquote>     <b>Упражнение 13.4. Вызов <blockquote>popen</blockquote> запускает командную оболочку</b>     <p>Эта программа применяет в точности предыдущую команду, но с помощью <blockquote>popen</blockquote>, так что она может читать результат.</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> FILE *read_fp;</blockquote></p>     <p><blockquote> char buffer[BUFSIZ +1];</blockquote></p>     <p><blockquote> int chars_read;</blockquote></p>     <p><blockquote> memset(buffer, '\0', sizeof(buffer));</blockquote></p>     <p><blockquote> read_fp = popen("cat popen*.с | wc -l", "r");</blockquote></p>     <p><blockquote> if (read_fp != NULL) {</blockquote></p>     <p><blockquote>  chars_read = fread(buffer, sizeof(char), BUFSIZ, read_fp);</blockquote></p>     <p><blockquote>  while (chars_read &gt; 0) {</blockquote></p>     <p><blockquote>   buffer[chars_read - 1] = '\0';</blockquote></p>     <p><blockquote>   printf("Reading:-\n %s\n", buffer);</blockquote></p>     <p><blockquote>   chars_read = fread(buffer, sizeof(char), BUFSIZ, read_fp);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  pclose(read_fp);</blockquote></p>     <p><blockquote>  exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Выполнив эту программу, вы получите следующий вывод:</p>     <p><blockquote>$ <b>./popen4</b></blockquote></p>     <p><blockquote>Reading:-</blockquote></p>     <p><blockquote>94</blockquote></p>     <p><b>Как это работает</b></p>     <p>Программа показывает, что вызывается командная оболочка для того, чтобы развернуть <blockquote>popen*.с</blockquote> в список всех файлов, начинающихся с <blockquote>popen</blockquote> и заканчивающихся <blockquote>.с</blockquote>, а также для обработки символа канала (<blockquote>|</blockquote>) и отправки вывода команды <blockquote>cat</blockquote> в команду <blockquote>wс</blockquote>. Вы вызываете командную оболочку, программы <blockquote>cat</blockquote> <blockquote>и</blockquote> <blockquote>wc</blockquote> и задаете перенаправление — все в одном вызове <blockquote>popen</blockquote>. Программа, вызвавшая команду, видит только заключительный вывод.</p>              <a name="metkadoc9"><h1>Вызов <i>pipe</i></h1></a>    <p>Вы познакомились с высокоуровневой функцией <blockquote>popen</blockquote>, а теперь пойдем дальше и рассмотрим низкоуровневую функцию <blockquote>pipe</blockquote>. Она предоставляет средства передачи данных между двумя программами без накладных расходов на вызов командной оболочки для интерпретации запрашиваемой команды. Эта функция также позволит вам лучше управлять чтением и записью данных.</p>    <p>У функции <blockquote>pipe</blockquote> следующее объявление:</p>    <p><blockquote><b>#include &lt;unistd.h&gt;</b></blockquote></p>    <p><blockquote><b>int pipe(int file_descriptor[2]);</b></blockquote></p>    <p>Функции <blockquote>pipe</blockquote> передается указатель на массив из двух целочисленных файловых дескрипторов. Она заполняет массив двумя новыми файловыми дескрипторами и возвращает 0. В случае неудачи она вернет -1 и установит переменную <blockquote>errno</blockquote> для указания причины сбоя. В интерактивном справочном руководстве Linux на странице, посвященной функций <blockquote>pipe</blockquote> (в разделе 2 руководства), определены следующие ошибки:</p>    <p>&#9633; <blockquote>EMFILE</blockquote> — процесс использует слишком много файловых дескрипторов;</p>    <p>&#9633; <blockquote>ENFILE</blockquote> — системная таблица файлов полна;</p>    <p>&#9633; <blockquote>EFAULT</blockquote> — некорректный файловый дескриптор.</p>    <p>Два возвращаемых файловых дескриптора подсоединяются специальным образом. Любые данные, записанные в <blockquote>file_descriptor[1]</blockquote>, могут быть считаны обратно из <blockquote>file_descriptor[0]</blockquote>. Данные обрабатываются по алгоритму<i> "первым пришел, первым обслужен", </i>обычно обозначаемому как <i>FIFO. </i>Это означает, что если вы записываете байты <blockquote>1</blockquote>, <blockquote>2</blockquote>, <blockquote>3</blockquote> в <blockquote>file_descriptor[1]</blockquote>, чтение из <blockquote>file_descriptor[0]</blockquote> выполняется в следующем порядке: <blockquote>1</blockquote>, <blockquote>2</blockquote>, <blockquote>3</blockquote>. Этот способ отличается от стека, который функционирует по алгоритму<i> "последним пришел, первым обслужен", </i>который обычно называют сокращенно <i>LIFO.</i></p>    <blockquote>     <b>Примечание</b>     <p>Важно уяснить, что речь идет о файловых дескрипторах, а не о файловых потоках, поэтому для доступа к данным вы должны применять низкоуровневые системные вызовы <blockquote>read</blockquote> и <blockquote>write</blockquote> вместо библиотечных функций потоков <blockquote>fread</blockquote> и <blockquote>fwrite</blockquote>.</p>    </blockquote>    <p>В упражнении 13.5 приведена программа pipe1.с, которая использует вызов <blockquote>pipe</blockquote> для создания канала.</p>    <b>Упражнение 13.5 Функция <blockquote>pipe</blockquote></b>    <p>Следующий пример — программа pipe1.c. Обратите внимание на массив <blockquote>file_pipes</blockquote>, который передается функции <blockquote>pipe</blockquote> как параметр.</p>    <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>    <p><blockquote>#include &lt;string.h&gt;</blockquote></p>    <br>    <p><blockquote>int main() {</blockquote></p>    <p><blockquote> int data_processed;</blockquote></p>    <p><blockquote> int filepipes[2];</blockquote></p>    <p><blockquote> const char some_data[] = "123";</blockquote></p>    <p><blockquote> char buffer[BUFSIZ + 1];</blockquote></p>    <p><blockquote> memset(buffer, '\0', sizeof(buffer));</blockquote></p>    <p><blockquote> if (pipe(file_pipes) == 0) {</blockquote></p>    <p><blockquote>  data_processed = write(file_pipes[1], some_data, strlen(somedata));</blockquote></p>    <p><blockquote>  printf("Wrote %d bytes\n", data_processed);</blockquote></p>    <p><blockquote>  data_processed = read(file_pipes[0], buffer, BUFSIZ);</blockquote></p>    <p><blockquote>  printf("Read %d bytes: %s\n", data_processed, buffer);</blockquote></p>    <p><blockquote>  exit(EXIT_SUCCESS);</blockquote></p>    <p><blockquote> }</blockquote></p>    <p><blockquote> exit(EXIT_FAILURE);</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Если вы выполните программу, то получите следующий вывод:</p>    <p><blockquote>$ <b>./pipe1</b></blockquote></p>    <p><blockquote>Wrote 3 bytes</blockquote></p>    <p><blockquote>Read 3 bytes: 123</blockquote></p>    <p><b>Как это работает</b></p>    <p>Программа создает канал с помощью двух файловых дескрипторов из массива <blockquote>file_pipes[]</blockquote>. Далее она записывает данные в канал, используя файловый дескриптор <blockquote>file_pipes[1]</blockquote>, и считывает их обратно из <blockquote>file_pipes[0]</blockquote>. Учтите, что у канала есть внутренняя буферизация, позволяющая хранить данные между вызовами функций <blockquote>write</blockquote> и <blockquote>read</blockquote>.</p>    <p>Следует знать, что реакция на попытку писать с помощью дескриптора <blockquote>file_descriptor[0]</blockquote> или читать с помощью дескриптора <blockquote>file_descriptor[1]</blockquote> не определена, поэтому поведение программы может быть очень странным и меняться без каких-либо предупреждений. В системах авторов такие вызовы заканчивались аварийно и возвращали -1, что, по крайней мере, гарантирует легкость обнаружения такой ошибки.</p>    <p>На первый взгляд этот пример использования канала ничего не предлагает такого, чего мы не могли бы сделать с помощью простого файла. Действительные преимущества каналов проявятся, когда вам нужно будет передавать данные между двумя процессами. Как вы видели в<i> главе 11,</i> когда программа создает новый процесс с помощью вызова <blockquote>fork</blockquote>, уже открытые к этому моменту файловые дескрипторы так и остаются открытыми. Создав канал в исходном процессе и затем сформировав с помощью <blockquote>fork</blockquote> новый процесс, вы сможете передать данные из одного процесса в другой через канал (упражнение 13.6).</p>    <b>Упражнение 13.6. Каналы через вызов <blockquote>fork</blockquote></b>    <p>1. Это пример pipe2.c. Он выполняется также как первый до того момента, пока вы не вызовете функцию <blockquote>fork</blockquote>.</p>    <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>    <p><blockquote>#include &lt;string.h&gt;</blockquote></p>    <br>    <p><blockquote>int main() {</blockquote></p>    <p><blockquote> int data_processed;</blockquote></p>    <p><blockquote> int file_pipes[2];</blockquote></p>    <p><blockquote> const char some_data[] = "123";</blockquote></p>    <p><blockquote> char buffer[BUFSIZ + 1];</blockquote></p>    <p><blockquote> pid_t fork_result;</blockquote></p>    <p><blockquote> memset(buffer, '0', sizeof(buffer));</blockquote></p>    <p><blockquote> if (pipe(file_pipes) == 0) {</blockquote></p>    <p><blockquote>  fork_result = fork();</blockquote></p>    <p><blockquote>  if (fork_result == -1) {</blockquote></p>    <p><blockquote>   fprintf(stderr, "Fork failure");</blockquote></p>    <p><blockquote>   exit(EXIT_FAILURE);</blockquote></p>    <p><blockquote>  }</blockquote></p>    <p>2. Вы убедились, что вызов <blockquote>fork</blockquote> отработал, поэтому, если его результат равен нулю, вы находитесь в дочернем процессе:</p>    <p><blockquote>  if (fork_result == 0) {</blockquote></p>    <p><blockquote>   data_processed = read(file_pipes[0], buffer, BUFSIZ);</blockquote></p>    <p><blockquote>   printf("Read %d bytes: %s\n", data_processed, buffer);</blockquote></p>    <p><blockquote>   exit(EXIT_SUCCESS);</blockquote></p>    <p><blockquote>  }</blockquote></p>    <p>3. В противном случае вы должны быть в родительском процессе:</p>    <p><blockquote>  else {</blockquote></p>    <p><blockquote>   data_processed = write(file_pipes[1], some_data,</blockquote></p>    <p><blockquote>    strlen(some_data));</blockquote></p>    <p><blockquote>   printf("Wrote %d bytes\n", data_processed);</blockquote></p>    <p><blockquote>  }</blockquote></p>    <p><blockquote> }</blockquote></p>    <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>После выполнения этой программы вы получите вывод, аналогичный предыдущему:</p>    <p><blockquote>$ <b>./pipe2</b></blockquote></p>    <p><blockquote>Wrote 3 bytes</blockquote></p>    <p><blockquote>Read 3 bytes: 123</blockquote></p>    <p>Вы можете столкнуться с повторным выводом строки приглашения для ввода команды перед завершающим фрагментом вывода, поскольку родительский процесс завершится раньше дочернего, поэтому мы подчистили вывод, чтобы его легче было читать.</p>    <p><b>Как это работает</b></p>    <p>Сначала программа создает канал с помощью вызова <blockquote>pipe</blockquote>. Далее она применяет вызов <blockquote>fork</blockquote> для создания нового процесса. Если <blockquote>fork</blockquote> завершился успешно, родительский процесс пишет данные в канал, в то время как дочерний считывает данные из канала. Оба процесса, и родительский, и дочерний, завершаются после одного вызова <blockquote>write</blockquote> и <blockquote>read</blockquote>. Если родительский процесс завершается раньше дочернего, вы можете увидеть между двумя выводами строку приглашения командной оболочки.</p>    <p>Несмотря на то, что программа внешне похожа на первый пример <blockquote>pipe</blockquote>, мы сделали большой шаг вперед, получив возможность использовать разные процессы для чтения и записи (рис. 13.2).</p>    <img src="image040.jpg"/>    <p><b>Рис. 13.2</b> </p>          <a name="metkadoc10"><h1>Родительский и дочерний процессы</h1></a>         <p>Следующий логический шаг в нашем изучении вызова <blockquote>pipe</blockquote> — разрешить дочернему процессу быть другой программой, отличной от своего родителя, а не просто другим процессом, выполняющим ту же самую программу. Сделать это можно с помощью вызова <blockquote>exec</blockquote>. Единственная сложность заключается в том, что новому процессу, созданному <blockquote>exec</blockquote>, нужно знать, какой файловый дескриптор применять для доступа. В предыдущем примере этой проблемы не возникло, потому что дочерний процесс обращался к своей копии данных <blockquote>file_pipes</blockquote>. После вызова <blockquote>exec</blockquote> возникает другая ситуация, поскольку старый процесс заменен новым дочерним процессом. Эту проблему можно обойти, если передать файловый дескриптор (который, в конце концов, просто число) как параметр программе, вновь созданной с помощью вызова <blockquote>exec</blockquote>.</p>     <p>Для того чтобы посмотреть, как это работает, вам понадобятся две программы (упражнение 13.7). Первая —<i> поставщик данных.</i> Она создает канал и затем вызывает дочерний процесс,<i> потребитель данных.</i></p>     <b>Упражнение 13.7. Каналы и <blockquote>exec</blockquote></b>     <p>1. Для получения первой программы исправьте pipe2.c, превратив ее в pipe3.c. Измененные строки затенены.</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int data_processed;</blockquote></p>     <p><blockquote> int file_pipes[2];</blockquote></p>     <p><blockquote> const char somedata[] = "123";</blockquote></p>     <p><blockquote> char buffer[BUFSIZ + 1];</blockquote></p>     <p><blockquote> pid_t fork_result;</blockquote></p>     <p><blockquote> memset(buffer, '\0', sizeof(buffer));</blockquote></p>     <p><blockquote> if (pipe(file_pipes) == 0) {</blockquote></p>     <p><blockquote>  fork_result = fork();</blockquote></p>     <p><blockquote>  if (fork_result == (pid_t)-1) {</blockquote></p>     <p><blockquote>   fprintf(stderr, "Fork failure");</blockquote></p>     <p><blockquote>   exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  if (fork_result == 0) {</blockquote></p>     <p><blockquote><i>   sprintf(buffer, "%d", file_pipes[0]);</i></blockquote></p>     <p><blockquote><i>   (void)execl("pipe4", "pipe4", buffer, (char*)0);</i></blockquote></p>     <p><blockquote><i>   exit(EXIT_FAILURE);</i></blockquote></p>     <p><blockquote>  } else {</blockquote></p>     <p><blockquote>   data_processed = write(file_pipes[1], some_data, strlen(some_data));</blockquote></p>     <p><blockquote><i>   printf ("%d - wrote %d bytes\n", getpid(), data_processed);</i></blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>2. Программа-потребитель pipe4.c, читающая данные, гораздо проще:</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <br>     <p><blockquote>int main(int argc, char *argv[]) {</blockquote></p>     <p><blockquote> int data_processed;</blockquote></p>     <p><blockquote> char buffer[BUFSIZ + 1];</blockquote></p>     <p><blockquote> int file_descriptor;</blockquote></p>     <p><blockquote> memset(buffer, '\0', sizeof(buffer));</blockquote></p>     <p><blockquote> sscanf(argv[1], "%d", &amp;file_descriptor);</blockquote></p>     <p><blockquote> data_processed = read(file_descriptor, buffer, BUFSIZ);</blockquote></p>     <p><blockquote> printf("%d — read %d bytes: %s\n", getpid(), data_processed,</blockquote></p>     <p><blockquote>  buffer);</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Выполнив pipe3 и помня о том, что она вызывает программу pipe4, вы получите вывод, аналогичный приведенному далее:</p>     <p><blockquote>$ <b>./pipe3</b></blockquote></p>     <p><blockquote>22460 - wrote 3 bytes</blockquote></p>     <p><blockquote>22461 - read 3 bytes: 123</blockquote></p>     <p><b>Как это работает</b></p>     <p>Программа pipe3 начинается как предыдущий пример, используя вызов <blockquote>pipe</blockquote> для создания канала и затем вызов <blockquote>fork</blockquote> для создания нового процесса. Далее она применяет функцию <blockquote>sprintf</blockquote> для сохранения в буфере номера файлового дескриптора чтения из канала, который формирует аргумент программы pipe4.</p>     <p>Вызов <blockquote>execl</blockquote> применен для вызова программы pipe4. В нем использованы следующие аргументы:</p>     <p>&#9633; вызванная программа;</p>     <p>&#9633; <blockquote>argv[0]</blockquote>, принимающий имя программы;</p>     <p>&#9633; <blockquote>argv[1]</blockquote>, содержащий номер файлового дескриптора, из которого программа должна читать;</p>     <p>&#9633; <blockquote>(char *)0</blockquote>, завершающий список параметров.</p>     <p>Программа pipe4 извлекает номер файлового дескриптора из строки аргументов и затем читает из него данные.</p>             <a name="metkadoc11"><h1>Чтение закрытых каналов</h1></a>     <p>Прежде чем двигаться дальше, необходимо более внимательно рассмотреть файловые дескрипторы, которые открыты. До этого момента вы разрешали читающему процессу просто читать какие-то данные и завершаться, полагая, что ОС Linux уберет файлы в ходе завершения процесса.</p>     <p>В большинстве программ, читающих данные из стандартного ввода, это делается несколько иначе, чем в виденных вами до сих пор примерах. Обычно программы не знают, сколько данных они должны считать, поэтому они, как правило, выполняют цикл — чтение данных, их обработка и затем снова чтение данных и так до тех пор, пока не останется данных для чтения.</p>     <p>Вызов <blockquote>read</blockquote> обычно будет задерживать выполнение процесса, т.е. он заставит процесс ждать до тех пор, пока не появятся данные. Если другой конец канала был закрыт, следовательно, нет ни одного процесса, имеющего канал для записи, и вызов <blockquote>read</blockquote> блокируется. Поскольку это не очень полезно, вызов <blockquote>read</blockquote>, пытающийся читать из канала, не открытого для записи, возвращает 0 вместо блокирования. Это позволит читающему процессу обнаружить канальный эквивалент метки "конец файла" и действовать соответствующим образом. Учтите, что это не то же самое, что чтение некорректного дескриптора файла, которое вызов read считает ошибкой и обозначает возвратом -1.</p>     <p>Если вы применяете канал с вызовом <blockquote>fork</blockquote>, есть два файловых дескриптора, которые можно использовать для записи в канал: один в родительском, а другой в дочернем процессах. Вы должны закрыть файловые дескрипторы записи в канал в обоих этих процессах, прежде чем канал будет считаться закрытым и вызов <blockquote>read</blockquote> для чтения из канала завершится аварийно. Мы рассмотрим пример этого позже, когда вернемся к данной теме, для того чтобы подробно обсудить флаг <blockquote>O_NONBLOCK</blockquote> и каналы FIFO.</p>             <a name="metkadoc12"><h1>Каналы, применяемые как стандартные ввод и вывод</h1></a>     <p>Теперь, когда вы знаете, как заставить вызов <blockquote>read</blockquote>, примененный к пустому каналу, завершиться аварийно, можно рассмотреть более простой метод соединения каналом двух процессов. Вы устраиваете так, что у одного из файловых дескрипторов канала будет известное значение, обычно стандартный ввод, 0, или стандартный вывод, 1. Его немного сложнее установить в родительском процессе, но при этом значительно упрощается программа дочернего процесса.</p>     <p>Одно неоспоримое достоинство заключается в том, что вы можете вызывать стандартные программы, которым не нужен файловый дескриптор как параметр. Для этого вам следует применить функцию <blockquote>dup</blockquote>, с которой вы встречались в<i> главе 3. </i>Существуют две тесно связанные версии функции <blockquote>dup</blockquote>, которые объявляются следующим образом:</p>     <p><blockquote><b>#include &lt;unistd.h&gt;</b></blockquote></p>     <p><blockquote><b>int dup(int file_descriptor);</b></blockquote></p>     <p><blockquote><b>int dup2(int file_descriptor_one, int file_descriptor_two);</b></blockquote></p>     <p>Назначение вызова <blockquote>dup</blockquote> — открыть новый дескриптор файла, немного похоже на то, как это делает вызов <blockquote>open</blockquote>. Разница в том, что файловый дескриптор, созданный <blockquote>dup</blockquote>, ссылается на тот же файл (или канал), что и существующий файловый дескриптор. В случае вызова <blockquote>dup</blockquote> новый файловый дескриптор всегда имеет самый маленький доступный номер, а в случае <blockquote>dup2</blockquote> — первый доступный дескриптор, больший чем значение параметра <blockquote>file_descriptor_two</blockquote>.</p>     <blockquote>      <b>Примечание</b>      <p>Того же эффекта, что и применение вызовов <blockquote>dup</blockquote> и <blockquote>dup2</blockquote> можно добиться, применяя более общий вызов <blockquote>fcntl</blockquote> с командой <blockquote>F_DUPFD</blockquote>. Как говорилось, вызов <blockquote>dup</blockquote> легче использовать, поскольку он разработан специально для создания дубликатов файловых дескрипторов. Он также очень широко применяется, поэтому вы встретите его гораздо чаще в существующих программах, чем вызов <blockquote>fcntl</blockquote> и команду <blockquote>F_DUPFD</blockquote>.</p>     </blockquote>     <p>Итак, как же <blockquote>dup</blockquote> помогает в обмене данными между процессами? Хитрость кроется в знании того, что дескриптор стандартного файла ввода всегда 0 и что <blockquote>dup</blockquote> всегда возвращает новый файловый дескриптор, применяя наименьший доступный номер. Сначала закрыв дескриптор 0, а затем вызвав <blockquote>dup</blockquote>, вы получите новый файловый дескриптор с номером 0. Поскольку новый файловый дескриптор — это дубликат существующего, стандартный ввод изменится и получит доступ к файлу или каналу, файловый дескриптор которого вы передали в функцию <blockquote>dup</blockquote>. В результате вы создадите два файловых дескриптора, которые ссылаются на один и тот же файл или канал и один из них будет стандартным вводом.</p>     <b>Управление файловым дескриптором с помощью <i>close</i> и<i> dup</i></b>     <p>Легче всего понять, что происходит, когда вы закрываете файловый дескриптор 0 и затем вызываете <blockquote>dup</blockquote>, если рассмотреть состояние первых четырех файловых дескрипторов, изменяющихся последовательно друг за другом (табл. 13.1).</p>     <br>     <p><b><i>Таблица 13.1</i></b></p>     <table>      <tr>       <th valign="top">Номер файлового дескриптора</th>       <th valign="top">Первоначально</th>       <th valign="top">После закрытия файлового дескриптора 0</th>       <th valign="top">После вызова <blockquote>dup</blockquote></th>      </tr>      <tr>       <td valign="top">0</td>       <td valign="top">Стандартный ввод</td>       <td valign="top">{closed}</td>       <td valign="top">Файловый дескриптор канала</td>      </tr>      <tr>       <td valign="top">1</td>       <td valign="top">Стандартный вывод</td>       <td valign="top">Стандартный вывод</td>       <td valign="top">Стандартный вывод</td>      </tr>      <tr>       <td valign="top">2</td>       <td valign="top">Стандартный поток ошибок</td>       <td valign="top">Стандартный поток ошибок</td>       <td valign="top">Стандартный поток ошибок</td>      </tr>      <tr>       <td valign="top">3</td>       <td valign="top">Файловый дескриптор канала</td>       <td valign="top">Файловый дескриптор канала</td>       <td valign="top">Файловый дескриптор канала</td>      </tr>     </table>     <p>А теперь выполните упражнение 13.8.</p>     <b>Упражнение 13.3. Каналы и <blockquote>dup</blockquote></b>     <p>Давайте вернемся к предыдущему примеру, но на этот раз вы измените дочернюю программу, заменив в ней файловый дескриптор stdin концом считывания <blockquote>read</blockquote> созданного вами канала. Вы также выполните некоторую реорганизацию файловых дескрипторов, чтобы дочерняя программа могла правильно определить конец данных в канале. Как обычно, мы пропустили некоторые проверки ошибок для краткости.</p>     <p>Превратите программу pipe3.c в pipe5.c с помощью следующего программного кода:</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int data_processed;</blockquote></p>     <p><blockquote> int file pipes[2];</blockquote></p>     <p><blockquote> const char some_data[] = "123";</blockquote></p>     <p><blockquote> pid_t fork_result;</blockquote></p>     <p><blockquote> if (pipe(file_pipes) == 0) {</blockquote></p>     <p><blockquote>  fork_result = fork();</blockquote></p>     <p><blockquote>  if (fork_result == (pid_t)-1) {</blockquote></p>     <p><blockquote>   fprintf(stderr, "Fork failure");</blockquote></p>     <p><blockquote>   exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  if (fork_result == (pid_t)0) {</blockquote></p>     <p><blockquote><i>   close(0);</i></blockquote></p>     <p><blockquote><i>   dup(file_pipes[0];</i></blockquote></p>     <p><blockquote><i>   close(file_pipes[0]);</i></blockquote></p>     <p><blockquote><i>   close(file_pipes[1]);</i></blockquote></p>     <p><blockquote><i>   execlp("od", "od", "-c", (char*)0);</i></blockquote></p>     <p><blockquote>   exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote>  } else {</blockquote></p>     <p><blockquote><i>   close(file_pipes[0]);</i></blockquote></p>     <p><blockquote>   data_processed = write(file_pipes[1], some_data,</blockquote></p>     <p><blockquote>    strlen(some_data));</blockquote></p>     <p><blockquote>   close(file_pipes[1]);</blockquote></p>     <p><blockquote>   printf("%d — wrote %d bytes\n", (int)getpid(), data_processed);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>У этой программы следующий вывод:</p>     <p><blockquote>$ <b>./pipe5</b></blockquote></p>     <p><blockquote>22495 - wrote 3 bytes</blockquote></p>     <p><blockquote>0000000 1 2 3</blockquote></p>     <p><blockquote>0000003</blockquote></p>     <p><b>Как это работает</b></p>     <p>Как и прежде, программа создает канал, затем выполняет вызов <blockquote>fork</blockquote>, создавая дочерний процесс. В этот моменту обоих процессов, родительского и дочернего, есть файловые дескрипторы для доступа к каналу, по одному для чтения и записи, т.е. всего четыре открытых файловых дескриптора.</p>     <p>Давайте первым рассмотрим дочерний процесс. Он закрывает свой стандартный ввод с помощью <blockquote>close(0)</blockquote> и затем вызывает <blockquote>dup(file_pipes[0])</blockquote>. Этот вызов дублирует файловый дескриптор, связанный с концом <blockquote>read</blockquote> канала, как файловый дескриптор 0, стандартный ввод. Далее дочерний процесс закрывает исходный файловый дескриптор для чтения из канала, <blockquote>file_pipes[0]</blockquote>. Поскольку этот процесс никогда не будет писать в канал, он также закрывает файловый дескриптор для записи в канал, <blockquote>file_pipes[1]</blockquote>. Теперь у дочернего процесса единственный файловый дескриптор, связанный с каналом, файловый дескриптор 0, его стандартный ввод.</p>     <p>Далее дочерний процесс может применить <blockquote>exec</blockquote> для вызова любой программы, которая читает стандартный ввод. В данном случае мы используем команду <blockquote>od</blockquote>. Команда <blockquote>od</blockquote> будет ждать, когда данные станут ей доступны, как если бы она ждала ввода с терминала пользователя. В действительности без специального программного кода, позволяющего непосредственно выяснить разницу, она не будет знать, что ввод приходит из канала, а не с терминала.</p>     <p>Родительский процесс начинает с закрытия конца чтения канала, <blockquote>file_pipes[0]</blockquote>, потому что он никогда не будет читать из канала. Затем он пишет данные в канал. Когда все данные записаны, родительский процесс закрывает конец записи в канал и завершается. Поскольку теперь нет файловых дескрипторов, открытых для записи в канал, программа <blockquote>od</blockquote> сможет считать три байта, записанных в канал, но последующие операции чтения далее будут возвращать 0 байтов, указывая на конец файла. Когда <blockquote>read</blockquote> вернет 0, программа <blockquote>od</blockquote> завершится. Это аналогично выполнению команды <blockquote>od</blockquote>, введенной с терминала, и последующему нажатию комбинации клавиш &lt;Ctrl&gt;+&lt;D&gt; для отправки признака конца файла команде <blockquote>od</blockquote>.</p>     <p>На рис. 13.3 показан результат вызова <blockquote>pipe</blockquote>, на рис. 13.4 — результат вызова <blockquote>fork</blockquote>, а на рис. 13.5 представлена программа, когда она готова к передаче данных.</p>     <img src="image041.jpg"/>     <p><b>Рис. 13.3</b></p>     <br>     <br>     <img src="image042.jpg"/>     <p><b>Рис. 13.4</b></p>     <br>     <br>     <img src="image043.jpg"/>     <p><b>Рис. 13.5</b></p>              <a name="metkadoc13"><h1>Именованные каналы: FIFO</h1></a>         <p>До сих пор вы могли передавать данные только между связанными программами, т.е. программами, которые стартовали из общего процесса-предка. Часто это очень неудобно, хотелось бы, чтобы и у несвязанных процессов была возможность обмениваться данными.</p>     <p>Вы можете сделать это с помощью каналов FIFO, часто называемых<i> именованными каналами.</i> Именованный канал — это файл специального типа (помните, что в ОС Linux все, что угодно, — файл!), существующий в виде имени в файловой системе, но ведущий себя как неименованные каналы, которые вы уже встречали.</p>     <p>Вы можете создавать именованные каналы из командной строки и внутри программы. С давних времен программой создания их в командной строке была команда <blockquote>mknod</blockquote>:</p>     <p><blockquote>$ <b>mknod <i>имя_файла</i> p</b></blockquote></p>     <p>Однако команды <blockquote>mknod</blockquote> нет в списке команд X/Open, поэтому она включена не во все UNIX-подобные системы. Предпочтительнее применять в командной строке</p>     <p><blockquote>$ <b>mkfifo <i>имя_файла</i></b></blockquote></p>     <blockquote>      <b>Примечание</b>      <p>У некоторых более старых версий UNIX была только команда <blockquote>mknod</blockquote>. В стандарте X/Open issue 4 Version 2 есть вызов функции <blockquote>mknod</blockquote>, но не программа командной строки. ОС Linux, как всегда настроенная дружелюбно, предлагает оба варианта: <blockquote>mknod</blockquote> и <blockquote>mkfifo</blockquote>.</p>     </blockquote>     <p>Внутри программы можете применять два разных вызова:</p>     <p><blockquote><b>#include &lt;sys/types.h&gt;</b></blockquote></p>     <p><blockquote><b>#include &lt;sys/stat.h&gt;</b></blockquote></p>     <p><blockquote><b>int mkfifo(const char *filename, mode_t mode);</b></blockquote></p>     <p><blockquote><b>int mknod(const char* filename, mode_t mode | S_IFIFO, (dev_t)0);</b></blockquote></p>     <p>Помимо команды <blockquote>mknod</blockquote> вы можете использовать функцию <blockquote>mknod</blockquote> для создания файлов специальных типов. Единственный переносимый вариант применения этой функции, создающий именованный канал, — использование значения 0 типа <blockquote>dev_t </blockquote>и объединений с помощью операции or режима доступа к файлу и <blockquote>S_IFIFO</blockquote>. В примерах мы будем применять более простую функцию <blockquote>mkfifo</blockquote>.</p>     <p>Итак, выполните упражнение 13.9.</p>     <b>Упражнение 13.9. Создание именованного канала</b>     <p>Далее приведен исходный текст примера fifo1.c.</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/types.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/stat.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int res = mkfifo("/tmp/my_fifo", 0777);</blockquote></p>     <p><blockquote> if (res == 0) printf ("FIFO created\n");</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Вы можете создать канал и заглянуть в него:</p>     <p><blockquote>$ <b>./fifo1</b></blockquote></p>     <p><blockquote>FIFO created</blockquote></p>     <p><blockquote>$ <b>ls -lF /tmp/my_fifo</b></blockquote></p>     <p><blockquote>prwxr-xr-x 1 rick users 0 2007-06-16 17:18 /tmp/my_fifo|</blockquote></p>     <p>Обратите внимание на то, что первый символ вывода — <blockquote>р</blockquote>, обозначающий канал. Символ <blockquote>|</blockquote> в конце добавлен опцией <blockquote>-F</blockquote> команды <blockquote>ls</blockquote> и тоже обозначает канал.</p>     <p><b>Как это работает</b></p>     <p>Программа применяет функцию <blockquote>mkfifo</blockquote> для создания специального файла. Несмотря на то, что запрашиваете режим <blockquote>0777</blockquote>, он заменяется пользовательской маской (<blockquote>umask</blockquote>), устанавливаемой (в данном случае <blockquote>022</blockquote>) точно так же, как при создании обычного файла, поэтому у результирующего файла режим <blockquote>755</blockquote>. Если ваша <blockquote>umask</blockquote> установлена иначе, например, ее значение <blockquote>0002</blockquote>, вы увидите другие права доступа у созданного файла.</p>     <p>Удалить FIFO можно как традиционный файл с помощью команды <blockquote>rm</blockquote> или внутри программы посредством системного вызова <blockquote>unlink</blockquote>.</p>             <a name="metkadoc14"><h1>Доступ к FIFO</h1></a>     <p>У именованных каналов есть одно очень полезное свойство: поскольку они появляются в файловой системе, их можно применять в командах на месте обычного имени файла. Прежде чем вы продолжите программирование с использованием созданного вами файла FIFO, давайте исследуем поведение такого файла с помощью обычных команд для работы с файлом (упражнение 13.10).</p>     <b>Упражнение 13.10. Организации доступа к файлу FIFO</b>     <p>1. Сначала попробуйте прочесть (пустой) файл FIFO:</p>     <p><blockquote>$ <b>cat &lt; /tmp/my_fifo</b></blockquote></p>     <p>2. Теперь попытайтесь записать в FIFO. Вам придется использовать другой терминал, поскольку первая команда в данный момент "зависла" в ожидании появления каких-нибудь данных в FIFO:</p>     <p><blockquote>$ <b>echo "Hello World" &gt; /tmp/my_fifo</b></blockquote></p>     <p>Вы увидите вывод команды <blockquote>cat</blockquote>. Если не посылать никаких данных в канал FIFO, команда <blockquote>cat</blockquote> будет ждать до тех пор, пока вы не прервете ее выполнение, традиционно комбинацией клавиш &lt;Ctrl&gt;+&lt;C&gt;.</p>     <p>3. Можно выполнить обе команды одновременно, переведя первую в фоновый режим:</p>     <p><blockquote>$ <b>cat &lt; /tmp/my_fifo &amp;</b></blockquote></p>     <p><blockquote>[1] 1316</blockquote></p>     <p><blockquote>$ <b>echo "Hello World" &gt; /tmp/my_fifo</b></blockquote></p>     <p><blockquote>Hello World</blockquote></p>     <br>     <p><blockquote>[1]+ Done   cat &lt;/tmp/my_fifo</blockquote></p>     <p><blockquote>$</blockquote></p>     <p><b>Как это работает</b></p>     <p>Поскольку в канале FIFO не было данных, обе команды, <blockquote>cat</blockquote> и <blockquote>echo</blockquote>, приостанавливают выполнение, ожидая, соответственно, поступления каких-нибудь данных и какого-либо процесса для их чтения.</p>     <p>На третьем шаге процесс <blockquote>cat</blockquote> с самого начала заблокирован в фоновом режиме. Когда <blockquote>echo</blockquote> делает доступными некоторые данные, команда <blockquote>cat</blockquote> читает их и выводит в стандартный вывод. Обратите внимание на то, что она затем завершается, не дожидаясь дополнительных данных. Программа <blockquote>cat</blockquote> не блокируется, т.к. канал уже закрылся, когда завершилась вторая команда, поместившая данные в FIFO, поэтому вызовы <blockquote>read</blockquote> в программе <blockquote>cat</blockquote> вернут 0 байтов, обозначая этим конец файла.</p>     <p>Теперь, когда вы посмотрели, как ведут себя каналы FIFO при обращении к ним с помощью программ командной строки, давайте рассмотрим более подробно программный интерфейс, предоставляющий больше возможностей управления операциями чтения и записи при организации доступа к FIFO.</p>     <blockquote>      <b>Примечание</b>      <p>В отличие от канала, созданного вызовом <blockquote>pipe</blockquote>, FIFO существует как именованный файл, но не как открытый файловый дескриптор, и должен быть открыт перед тем, как можно будет из него читать данные или в него записывать их. Открывается и закрывается канал FIFO с помощью функций <blockquote>open</blockquote> и <blockquote>close</blockquote>, которые вы ранее применяли к файлам, но с дополнительными функциональными возможностями. Вызову <blockquote>open</blockquote> передается полное имя FIFO вместо полного имени обычного файла.</p>     </blockquote>     <b>Открытие FIFO с помощью <i>open</i></b>     <p>Основное ограничение при открытии канала FIFO состоит в том, что программа не может открыть FIFO для чтения и записи с режимом <blockquote>O_RDWR</blockquote>. Если программа нарушит это ограничение, результат будет непредсказуемым. Это очень разумное ограничение, т.к., обычно канал FIFO применяется для передачи данных в одном направлении, поэтому нет нужды в режиме <blockquote>O_RDWR</blockquote>. Процесс стал бы считывать обратно свой вывод, если бы канал был открыт для чтения/записи.</p>     <p>Если вы действительно хотите передавать данные между программами в обоих направлениях, гораздо лучше использовать пару FIFO или неименованных каналов, по одному для каждого направления передачи, или (что нетипично) явно изменить направление потока данных, закрыв и снова открыв канал FIFO. Мы вернемся к двунаправленному обмену данными с помощью каналов FIFO чуть позже в этой главе.</p>     <p>Другое различие между открытием канала FIFO и обычного файла заключается в использовании флага <blockquote>open_flag</blockquote> (второй параметр функции <blockquote>open</blockquote>) со значением <blockquote>O_NONBLOCK</blockquote>. Применение этого режима <blockquote>open</blockquote> изменяет способ обработки не только вызова <blockquote>open</blockquote>, но и запросов <blockquote>read</blockquote> и <blockquote>write</blockquote> для возвращаемого файлового дескриптора.</p>     <p>Существует четыре допустимых комбинации значений <blockquote>O_RDONLY</blockquote>, <blockquote>O_WRONLY</blockquote> и <blockquote>O_NONBLOCK</blockquote> флага. Рассмотрим их все по очереди.</p>     <p><blockquote>open(const char *path, O_RDONLY);</blockquote></p>     <p>В этом случае вызов <blockquote>open</blockquote> блокируется, он не вернет управление программе до тех пор, пока процесс не откроет этот FIFO для записи. Это похоже на первый пример с командой <blockquote>cat</blockquote>.</p>     <p><blockquote>open(const char *path, O_RDONLY | O_NONBLOCK);</blockquote></p>     <p>Теперь вызов <blockquote>open</blockquote> завершится успешно и вернет управление сразу, даже если канал FIFO не был открыт для записи каким-либо процессом.</p>     <p><blockquote>open(const char *path, O_WRONLY);</blockquote></p>     <p>В данном случае вызов <blockquote>open</blockquote> будет заблокирован до тех пор, пока процесс не откроет тот же канал FIFO для чтения.</p>     <p><blockquote>open(const char *path, O_WRONLY | O_NONBLOCK);</blockquote></p>     <p>Этот вариант вызова всегда будет возвращать управление немедленно, но если ни один процесс не открыл этот канал FIFO для чтения, <blockquote>open</blockquote> вернет ошибку, -1, и FIFO не будет открыт. Если есть процесс, открывший FIFO для чтения, возвращенный файловый дескриптор может использоваться для записи в канал FIFO.</p>     <blockquote>      <b>Примечание</b>      <p>Обратите внимание на асимметрию в использовании <blockquote>O_NONBLOCK</blockquote> с <blockquote>O_RDONLY</blockquote> и <blockquote>O_WRONLY</blockquote>, заключающуюся в том, что неблокирующий вызов <blockquote>open</blockquote> для записи завершается аварийно, если ни один процесс не открыл канал для чтения, а неблокирующий вызов <blockquote>open</blockquote> для чтения не возвращает ошибку. На поведение вызова <blockquote>close</blockquote> флаг <blockquote>O_NONBLOCK</blockquote> влияния не оказывает.</p>     </blockquote>     <p>Выполните упражнение 13.11.</p>     <b>Упражнение 13.11. Открытие файлов FIFO</b>     <p>Теперь рассмотрим, как можно использовать поведение вызова <blockquote>open</blockquote> с флагом, содержащим <blockquote>O_NONBLOCK</blockquote>, для синхронизации двух процессов. Вместо применения нескольких программ-примеров вы напишите одну тестовую программу fifo2.c, которая позволит исследовать поведение каналов FIFO при передаче ей разных параметров.</p>     <p>1. Начните с заголовочных файлов, директивы <blockquote>#define</blockquote> и проверки правильности количества предоставленных аргументов командной строки:</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <p><blockquote>#include &lt;fcntl.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/types.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/stat.h&gt;</blockquote></p>     <p><blockquote>#define FIFO_NAME "/tmp/my_fifo"</blockquote></p>     <br>     <p><blockquote>int main(int argc, char *argv[]) {</blockquote></p>     <p><blockquote> int res;</blockquote></p>     <p><blockquote> int open_mode = 0;</blockquote></p>     <p><blockquote> int i;</blockquote></p>     <p><blockquote> if (argc &lt; 2) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Usage: %s &lt;some combination of\</blockquote></p>     <p><blockquote>   O_RDONLY O_WRONLY O_NONBLOCK&gt;\n", *argv);</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p>2. Полагая, что программа передает тестовые данные, вы задаете параметр <blockquote>open_mode</blockquote> из следующих аргументов:</p>     <p><blockquote> for(i = 1; i &lt;argc; i++) {</blockquote></p>     <p><blockquote>  if (strncmp(*++argv, "O_RDONLY", 8) == 0) open_mode |= O_RDONLY;</blockquote></p>     <p><blockquote>  if (strncmp(*argv, "O_WRONLY", 8) == 0) open_mode |= O_WRONLY;</blockquote></p>     <p><blockquote>  if (strncmp(*argv, "O_NONBLOCK", 10) == 0) open_mode |= O_NONBLOCK;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p>3. Далее проверьте, существует ли канал FIFO, и при необходимости создайте его. Затем FIFO открывается, и пока программа засыпает на короткое время, выполняется результирующий вывод. В заключение FIFO закрывается.</p>     <p><blockquote> if (access(FIFO_NAME, F_OK) == -1) {</blockquote></p>     <p><blockquote>  res = mkfifo(FIFO_NAME, 0777);</blockquote></p>     <p><blockquote>  if (res != 0) {</blockquote></p>     <p><blockquote>   fprintf(stderr, "Gould not create fifo %s\n", FIFO_NAME);</blockquote></p>     <p><blockquote>   exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> printf("Process %d opening FIF0\n", getpid());</blockquote></p>     <p><blockquote> res = open(FIFO_NAME, open_mode);</blockquote></p>     <p><blockquote> printf("Process %d result %d\n", getpid(), res);</blockquote></p>     <p><blockquote> sleep(5);</blockquote></p>     <p><blockquote> if (res != -1) (void)close(res);</blockquote></p>     <p><blockquote> printf("Process %d finished\n", getpid());</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p><b>Как это работает</b></p>     <p>Эта программа позволяет задать в командной строке комбинации значений <blockquote>O_RDONLY</blockquote>, <blockquote>O_WRONLY</blockquote> и <blockquote>O_NONBLOCK</blockquote>, которые вы хотите применить. Делается это сравнением известных строк с параметрами командной строки и установкой (с помощью <blockquote>|=</blockquote>) соответствующего флага при совпадении строки. В программе используется функция <blockquote>access</blockquote>, проверяющая, существует ли уже файл FIFO, и создающая его при необходимости.</p>     <p>Никогда не уничтожайте FIFO, т.к. у вас нет способа узнать, не использует ли FIFO другая программа.</p>     <b><i>O_RDONLY </i>и <i>O_WRONLY </i>без <i>O_NONBLOCK</i></b>     <p>Теперь у вас есть тестовая программа, и вы можете проверить комбинации пар. Обратите внимание на то, что первая программа, считыватель, помещена в фоновый режим.</p>     <p><blockquote>$ <b>./fifo2 O_RDONLY &amp;</b></blockquote></p>     <p><blockquote>[1] 152</blockquote></p>     <p><blockquote>Process 152 opening FIFO</blockquote></p>     <p><blockquote>$ <b>./fifo2 O_WRONLY</b></blockquote></p>     <p><blockquote>Process 153 opening FIFO</blockquote></p>     <p><blockquote>Process 152 result 3</blockquote></p>     <p><blockquote>Process 153 result 3</blockquote></p>     <p><blockquote>Process 152 finished</blockquote></p>     <p><blockquote>Process 153 finished</blockquote></p>     <p>Это, наверное, самое распространенное применение именованных каналов. Оно позволяет читающему процессу стартовать и ждать в вызове <blockquote>open</blockquote>, а затем разрешает обеим программам продолжить выполнение, когда вторая программа откроет канал FIFO. Обратите внимание на то, что и читающий, и пишущий процессы были синхронизированы вызовом <blockquote>open</blockquote>.</p>     <blockquote>      <b>Примечание</b>      <p>Когда процесс в ОС Linux заблокирован, он не потребляет ресурсы ЦП, поэтому этот метод синхронизации очень эффективен с точки зрения использования ЦП.</p>     </blockquote>     <b><i>O_RDONLY </i>с <i>O_NONBLOCK </i>и <i>O_WRONLY</i></b>     <p>В следующем примере читающий процесс выполняет вызов <blockquote>open</blockquote> и немедленно продолжается, даже если нет ни одного пишущего процесса. Пишущий процесс тоже немедленно продолжает выполняться после вызова <blockquote>open</blockquote>, потому что канал FIFO уже открыт для чтения.</p>     <p><blockquote>$ <b>./fifо2 O_RDONLY O_NONBLOCK &amp;</b></blockquote></p>     <p><blockquote>[1] 160</blockquote></p>     <p><blockquote>Process 160 opening fifo</blockquote></p>     <p><blockquote>$ <b>./fifo2 O_WRONLY</b></blockquote></p>     <p><blockquote>Process 161 opening FIFO</blockquote></p>     <p><blockquote>Process 160 result 3</blockquote></p>     <p><blockquote>Process 161 result 3</blockquote></p>     <p><blockquote>Process 160 finished</blockquote></p>     <p><blockquote>Process 161 finished</blockquote></p>     <p><blockquote>[1]+ Done   ./fifo2 O_RDONLY O_NONBLOCK</blockquote></p>     <p>Эти два примера — вероятно, самые распространенные комбинации режимов <blockquote>open</blockquote>. Не стесняйтесь использовать программу-пример для экспериментов с другими возможными комбинациями.</p>     <b>Чтение из каналов FIFO и запись в них</b>     <p>Применение режима <blockquote>O_NONBLOCK</blockquote> влияет на поведение вызовов <blockquote>read</blockquote> и <blockquote>write</blockquote> в каналах FIFO.</p>     <p>Вызов <blockquote>read</blockquote>, применяемый для чтения из пустого блокирующего FIFO (открытого без флага <blockquote>O_NONBLOCK</blockquote>), будет ждать до тех пор, пока не появятся данные, которые можно прочесть. Вызов <blockquote>read</blockquote>, применяемый в неблокирующем FIFO, напротив, при отсутствии данных вернет 0 байтов.</p>     <p>Вызов <blockquote>write</blockquote> для записи в полностью блокирующий канал FIFO будет ждать до тех пор, пока данные не смогут быть записаны. Вызов <blockquote>write</blockquote>, применяемый к FIFO, который не может принять все байты, предназначенные для записи, либо:</p>     <p>&#9633; будет аварийно завершен, если был запрос на запись <blockquote>PIPE_BUF</blockquote> байтов или меньше и данные не могут быть записаны;</p>     <p>&#9633; запишет часть данных, если был запрос на запись более чем <blockquote>PIPE_BUF</blockquote> байтов, и вернет количество реально записанных байтов, которое может быть и 0.</p>     <p>Размер FIFO — очень важная характеристика. Существует накладываемый системой предел объема данных, которые могут быть в FIFO в любой момент времени. Он задается директивой <blockquote>#define PIPE_BUF</blockquote>, обычно находящейся в файле limits.h. В ОС Linux и многих других UNIX-подобных системах он обычно равен 4096 байт, но в некоторых системах может быть и 512 байт. Система гарантирует, что операции записи PIPE_BUF или меньшего количества байтов в канал FIFO, который был открыт <blockquote>O_WRONLY</blockquote> (т.е. блокирующий), запишут или все байты, или ни одного.</p>     <p>Несмотря на то, что этот предел не слишком важен в простом случае с одним записывающим каналом FIFO и одним читающим FIFO, очень распространено использование одного канала FIFO, позволяющего разным программам отправлять запросы к этому единственному каналу FIFO. Если несколько разных программ попытаются писать в FIFO в одно и то же время, жизненно важно, чтобы блоки данных из разных программ не перемежались друг с другом, т. е. каждая операция write должна быть "атомарной". Как это сделать?</p>     <p>Если вы ручаетесь, что все ваши запросы <blockquote>write</blockquote> адресованы блокирующему каналу FIFO и их размер меньше <blockquote>PIPE_BUF</blockquote> байтов, система гарантирует, что данные никогда не будут разделены. Вообще это неплохая идея — ограничить объем данных, передаваемых через FIFO блоком в <blockquote>PIPE_BUF</blockquote> байтов, если вы не используете единственный пишущий и единственный читающий процессы.</p>     <p>Выполните упражнение 13.12.</p>     <b>Упражнение 13.12. Связь процессов с помощью каналов FIFO</b>     <p>Для того чтобы увидеть, как несвязанные процессы могут общаться с помощью именованных каналов, вам понадобятся две отдельные программы fifo3.c и fifo4.c.</p>     <p>1. Первая программа — поставщик. Она создает канал, если требуется, и затем записывает в него данные как можно быстрее.</p>     <blockquote>      <b>Примечание</b>      <p>Поскольку пример иллюстративный, нас не интересуют конкретные данные, и мы не беспокоимся об инициализации буфера, В обоих листингах затененные строки содержат изменения, внесенные в программу fifo2.c помимо удаления кода со всеми аргументами командной строки.</p>     </blockquote>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <p><blockquote>#include &lt;fcntl.h&gt;</blockquote></p>     <p><blockquote><i>#include &lt;limits.h&gt;</i></blockquote></p>     <p><blockquote>#include &lt;sys/types.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/stat.h&gt;</blockquote></p>     <br>     <p><blockquote>#define FIFO_NAME "/tmp/my_fifo"</blockquote></p>     <p><blockquote><i>#define BUFFER_SIZE PIPE_BUF</i></blockquote></p>     <p><blockquote><i>#define TEN_MEG (1024 * 1024 * 10)</i></blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote><i> int pipe_fd;</i></blockquote></p>     <p><blockquote> int res;</blockquote></p>     <p><blockquote> int open_mode = O_WRONLY;</blockquote></p>     <p><blockquote><i> int bytes_sent = 0;</i></blockquote></p>     <p><blockquote><i> char buffer[BUFFER_SIZE + 1];</i></blockquote></p>     <p><blockquote> if (access(FIFO_NAME, F_OK) == -1) {</blockquote></p>     <p><blockquote>  res = mkfifo(FIFO_NAME, 0777);</blockquote></p>     <p><blockquote>  if (res != 0) {</blockquote></p>     <p><blockquote>   fprintf(stderr, "Could not create fifo %s\n", FIFO_NAME);</blockquote></p>     <p><blockquote>   exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote><i> printf("Process %d opening FIFO O_WRONLY\n", getpid());</i></blockquote></p>     <p><blockquote><i> pipe_fd = open(FIFO_NAME, open_name);</i></blockquote></p>     <p><blockquote><i> printf("Process %d result %d\n", getpid(), pipe_fd);</i></blockquote></p>     <p><blockquote><i> if (pipe_fd != -1) {</i></blockquote></p>     <p><blockquote><i>  while (bytes_sent &lt; TEN_MEG) {</i></blockquote></p>     <p><blockquote><i>   res = write(pipe_fd, buffer, BUFFER_SIZE);</i></blockquote></p>     <p><blockquote><i>   if (res == -1) {</i></blockquote></p>     <p><blockquote><i>    fprintf(stderr, "Write error on pipe\n);</i></blockquote></p>     <p><blockquote><i>    exit(EXIT_FAILURE);</i></blockquote></p>     <p><blockquote><i>   }</i></blockquote></p>     <p><blockquote><i>   bytes_sent += res;</i></blockquote></p>     <p><blockquote><i>  }</i></blockquote></p>     <p><blockquote><i>  (void)close(pipe_fd);</i></blockquote></p>     <p><blockquote><i> } else { </i></blockquote></p>     <p><blockquote><i>  exit(EXIT_FAILURE);</i></blockquote></p>     <p><blockquote><i> }</i></blockquote></p>     <p><blockquote> printf("Process %d finished\n", getpid());</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>2. Вторая программа, потребитель, гораздо проще. Она читает и выбрасывает данные из канала FIFO.</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <p><blockquote>#include &lt;fcntl.h&gt;</blockquote></p>     <p><blockquote><i>#include &lt;limits.h&gt;</i></blockquote></p>     <p><blockquote>#include &lt;sys/types.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/stat.h&gt;</blockquote></p>     <br>     <p><blockquote>#define FIFO_NAME "/tmp/my_fifo"</blockquote></p>     <p><blockquote><i>#define BUFFER_SIZE PIPE_BUF</i></blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote><i> int pipe_fd;</i></blockquote></p>     <p><blockquote> int res;</blockquote></p>     <p><blockquote><i> int open_mode = O_RDONLY;</i></blockquote></p>     <p><blockquote><i> char buffer[BUFFER_SIZE - 1];</i></blockquote></p>     <p><blockquote><i> int bytes_read = 0;</i></blockquote></p>     <p><blockquote><i> memset(buffer, '\0', sizeof(buffer));</i></blockquote></p>     <p><blockquote><i> printf("Process %d opening FIFO O_RDONLY\n", getpid());</i></blockquote></p>     <p><blockquote><i> pipe_fd = open(FIFO_NAME, open_mode); </i></blockquote></p>     <p><blockquote><i> printf("Prосеss %d result %d\n", getpid(), pipe_fd);</i></blockquote></p>     <p><blockquote><i> if (pipe_fd != -1) {</i></blockquote></p>     <p><blockquote><i>  do {</i></blockquote></p>     <p><blockquote><i>   res = read(pipe_fd, buffer,BUFFER_SIZE);</i></blockquote></p>     <p><blockquote><i>   bytes_read += res;</i></blockquote></p>     <p><blockquote><i>  } while (res &gt; 0);</i></blockquote></p>     <p><blockquote><i>  (void)close(pipe_fd);</i></blockquote></p>     <p><blockquote><i> } else {</i></blockquote></p>     <p><blockquote><i>  exit(EXIT_FAILURE);</i></blockquote></p>     <p><blockquote><i> }</i></blockquote></p>     <p><blockquote><i> printf("Process %d finished, %d bytes read\n", getpid(), bytes_read);</i></blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Когда вы выполните эти программы одновременно, с использованием команды <blockquote>time</blockquote> для хронометража читающего процесса, то получите следующий (с некоторыми пропусками для краткости) вывод:</p>     <p><blockquote>$ <b>./fifo3 &amp;</b></blockquote></p>     <p><blockquote>[1] 375</blockquote></p>     <p><blockquote>Process 375 opening FIFO O_WRONLY</blockquote></p>     <p><blockquote>$ <b>time ./fifo4</b></blockquote></p>     <p><blockquote>Process 377 opening FIFO O_RDONLY</blockquote></p>     <p><blockquote>Process 375 result 3</blockquote></p>     <p><blockquote>Process 377 result 3</blockquote></p>     <p><blockquote>Process 375 finished</blockquote></p>     <p><blockquote>Process 377 finished, 10485760 bytes read</blockquote></p>     <br>     <p><blockquote>real 0m0.053s</blockquote></p>     <p><blockquote>user 0m0.020s</blockquote></p>     <p><blockquote>sys  0m0.040s</blockquote></p>     <br>     <p><blockquote>[1]+ Done   ./fifo3</blockquote></p>     <p><b>Как это работает</b></p>     <p>Обе программы применяют FIFO в режиме блокировки. Вы запускаете первой программу fifo3 (пишущий процесс/поставщик), которая блокируется, ожидая, когда читающий процесс откроет канал FIFO. Когда программа fifo4 (потребитель) запускается, пишущий процесс разблокируется и начинает записывать данные в канал. В это же время читающий процесс начинает считывать данные из канала.</p>     <blockquote>      <b>Примечание</b>      <p>ОС Linux так организует планирование двух процессов, что они оба выполняются, когда могут, и заблокированы в противном случае. Следовательно, пишущий процесс блокируется, когда канал полон, а читающий — когда канал пуст.</p>     </blockquote>     <p>Вывод команды <blockquote>time</blockquote> показывает, что читающему процессу потребовалось гораздо меньше одной десятой секунды для считывания 10 Мбайт данных в процесс. Это свидетельствует о том, что каналы, по крайней мере, их реализация в современных версиях Linux, могут быть эффективным средством обмена данными между программами.</p>             <a name="metkadoc15"><h1>Более сложная тема: применение каналов FIFO в клиент-серверных приложениях</h1></a>     <p>Заканчивая обсуждение каналов FIFO, давайте рассмотрим возможность построения очень простого клиент-серверного приложения, применяющего именованные каналы. Вы хотите, чтобы один серверный процесс принимал запросы, обрабатывал их и возвращал результирующие данные запрашивающей стороне — клиенту.</p>     <p>Вам нужно разрешить множественным клиентским процессам отправлять данные серверу. Для простоты предположим, что данные, которые нужно обработать, можно разбить на блоки, каждый из которых меньше <blockquote>PIPE_BUF</blockquote> байтов. Конечно, реализовать такую систему можно разными способами, но мы рассмотрим только один, как иллюстрацию применения именованных каналов.</p>     <p>Поскольку сервер будет обрабатывать только один блок данных в каждый момент времени, кажется логичным создать один канал FIFO, который читается сервером и в который записывают всё клиенты. Если открыть FIFO в блокирующем режиме, сервер и клиенты будут при необходимости блокироваться.</p>     <p>Возвращать обработанные данные клиентам немного сложнее. Вам придется организовать второй канал для возвращаемых данных, один для каждого клиента. Если передавать идентификатор (PID) процесса-клиента в исходных данных, отправляемых на сервер, обе стороны смогут использовать его для генерации уникального имени канала с возвращаемыми данными.</p>     <p>Выполните упражнение 13.13.</p>     <b>Упражнение 13.13. Пример клиент-серверного приложения</b>     <p>1. Прежде всего, вам нужен заголовочный файл client.h, в котором определены данные, общие для серверных и клиентских программ. В приложение также для удобства включены требуемые системные заголовочные файлы.</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <p><blockquote>#include &lt;fcntl.h&gt;</blockquote></p>     <p><blockquote>#include &lt;limits.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/types.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/stat.h&gt;</blockquote></p>     <br>     <p><blockquote>#define SERVER_FIFO_NAME "/tmp/serv_fifo"</blockquote></p>     <p><blockquote>#define CLIENT_FIFO_NAME "/tmp/cli_%d_fifo"</blockquote></p>     <p><blockquote>#define BUFFER_SIZE 20</blockquote></p>     <br>     <p><blockquote>struct data_to_pass_st {</blockquote></p>     <p><blockquote> pid_t client_pid;</blockquote></p>     <p><blockquote> char some_data[BUFFER_SIZE - 1];</blockquote></p>     <p><blockquote>};</blockquote></p>     <p>2. Теперь займемся серверной программой server.c. В этом разделе вы создаете и затем открываете канал сервера. Он задается в режиме "только для чтения" и с блокировкой. После засыпания (из демонстрационных соображений) сервер читает данные от клиента, у которого есть структура типа <blockquote>data_to_pass_st</blockquote>.</p>     <p><blockquote>#include "client.h"</blockquote></p>     <p><blockquote>#include &lt;ctype.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int server_fifo_fd, client fifo_fd;</blockquote></p>     <p><blockquote> struct data_to_pass_st my_data;</blockquote></p>     <p><blockquote> int read_res;</blockquote></p>     <p><blockquote> char client_fifo[256];</blockquote></p>     <p><blockquote> char *tmp_char_ptr;</blockquote></p>     <p><blockquote> mkfifo(SERVER_FIFO_NAME, 0777);</blockquote></p>     <p><blockquote> server_fifo_fd = open(SERVER_FIFO_NAME, O_RDONLY);</blockquote></p>     <p><blockquote> if (server_fifo_fd == -1) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Server fifo failure\n");</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> sleep(10); /* для целей демонстрации разрешает клиентам создать очередь */</blockquote></p>     <p><blockquote> do {</blockquote></p>     <p><blockquote>  read_res = read(server_fifo_fd, &amp;my_data, sizeof(my_data));</blockquote></p>     <p><blockquote>  if (read res &gt; 0) {</blockquote></p>     <p>3. На следующем этапе вы выполняете некоторую обработку данных, только что полученных от клиента: преобразуете все символы в некоторых данных в прописные и соединяете <blockquote>CLIENT_FIFO_NAME</blockquote> с полученным идентификатором <blockquote>client_pid</blockquote>.</p>     <p><blockquote>   tmp_char_ptr = my_data.some_data;</blockquote></p>     <p><blockquote>   while (*tmp_char_ptr) {</blockquote></p>     <p><blockquote>    *tmp_char_ptr = toupper(* tmp_char_ptr);</blockquote></p>     <p><blockquote>    tmp_char_ptr++;</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>   sprintf(client_fifo, CLIENT_FIFO_NAME, my_data.client_pid);</blockquote></p>     <p>4. Далее отправьте обработанные данные назад, открыв канал клиентской программы в режиме "только для записи" и с блокировкой. В заключение закройте серверный FIFO с помощью закрытия файла и отсоединения FIFO.</p>     <p><blockquote>   client_fifo_fd = open(client_fifo, O_WRONLY);</blockquote></p>     <p><blockquote>   if (client_fifo_fd ! = -1) {</blockquote></p>     <p><blockquote>    write(client_fifo_fd, &amp;my_data, sizeof(my_data));</blockquote></p>     <p><blockquote>    close(client_fifo_fd);</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> } while (read_res &gt; 0);</blockquote></p>     <p><blockquote> close(server_fifo_fd);</blockquote></p>     <p><blockquote> unlink(SERVER_FIFO_NAME);</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>5. Далее приведена клиентская программа client.с. В первой части этой программы FIFO сервера, если он уже существует, открывается как файл. Далее программа получает идентификатор собственного процесса, который формирует некие данные, которые будут отправляться на сервер. Создается FIFO клиента, подготовленный для следующего раздела.</p>     <p><blockquote>#include "client.h"</blockquote></p>     <p><blockquote>#include &lt;ctype.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int server_fifo_fd, client_fifo_fd;</blockquote></p>     <p><blockquote> struct data_to_pass_st my_data;</blockquote></p>     <p><blockquote> int times_to_send;</blockquote></p>     <p><blockquote> char client_fifo[256];</blockquote></p>     <p><blockquote> server_fifo_fd = open(SERVER_FIFO_NAME, O_WRONLY);</blockquote></p>     <p><blockquote> if (server_fifo_fd == -1) {</blockquote></p>     <p><blockquote>  fprintf (stderr, "Sorry, no server\n");</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> my_data.client_pid = getpid();</blockquote></p>     <p><blockquote> sprintf(client_fifo, CLIENT_FIFO_NAME, my_data.client_pid);</blockquote></p>     <p><blockquote> if (mkfifo(client_fifo, 0777) == -1) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Sorry, can't make %s\n", client_fifo);</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p>6. В каждом из пяти проходов цикла клиентские данные отправляются на сервер. Далее клиентский FIFO открывается (в режиме "только для чтения" с блокировкой) и данные считываются обратно. В конце серверный FIFO закрывается, а клиентский FIFO удаляется из файловой системы.</p>     <p><blockquote> for (times_to_send = 0; times_to_send &lt; 5; times_to_send++) {</blockquote></p>     <p><blockquote>  sprintf(my_data.some_data, "Hello from %d", my_data.client_pid);</blockquote></p>     <p><blockquote>  printf("%d sent %s, ", my_data.client_pid, my_data.some_data);</blockquote></p>     <p><blockquote>  write(server_fifo_fd, &amp;my_data, sizeof(my_data));</blockquote></p>     <p><blockquote>  client_fifo_fd = open(client_fifo, O_RDONLY);</blockquote></p>     <p><blockquote>  if (client_fifo_fd != -1) {</blockquote></p>     <p><blockquote>   if (read(client_fifo_fd, &amp;my_data, sizeof(my_data)) &gt; 0) {</blockquote></p>     <p><blockquote>    printf("received: %s\n", my_data.some_data);</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>   close(client_fifo_fd);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> close(server_fifo_fd);</blockquote></p>     <p><blockquote> unlink(client_fifo);</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Для тестирования этого приложения вам необходимо запустить единственную копию сервера и несколько клиентов. Для того чтобы запустить их приблизительно в одно и то же время, примените следующие команды командной оболочки.</p>     <p><blockquote>$ <b>./server &amp;</b></blockquote></p>     <p><blockquote>$ <b>for i in 1 2 3 4 5</b></blockquote></p>     <p><blockquote><b>do</b></blockquote></p>     <p><blockquote><b>./client &amp;</b></blockquote></p>     <p><blockquote><b>done</b></blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Они запускают один серверный процесс и пять клиентских. Вывод клиентских программ, отредактированный для краткости, выглядит следующим образом:</p>     <p><blockquote>531 sent Hello from 531, received: HELLO FROM 531</blockquote></p>     <p><blockquote>532 sent Hello from 532, received: HELLO FROM 532</blockquote></p>     <p><blockquote>529 sent Hello from 529, received: HELLO FROM 529</blockquote></p>     <p><blockquote>530 sent Hello from 530, received: HELLO FROM 530</blockquote></p>     <p><blockquote>531 sent Hello from 531, received: HELLO FROM 531</blockquote></p>     <p><blockquote>532 sent Hello from 532, received: HELLO FROM 532</blockquote></p>     <p>Как видно из данного вывода, запросы разных клиентов перемежаются, но каждый клиент получает соответствующим образом обработанные и возвращаемые ему данные. Имейте в виду, что вы можете увидеть или не увидеть чередование запросов, т.к. порядок получения клиентских запросов может меняться от машины к машине и даже в разных сеансах работы приложения на одной машине.</p>     <p><b>Как это работает</b></p>     <p>Теперь мы обсудим последовательность клиентских и серверных операций во взаимодействии, чего не делали до сих пор.</p>     <p>Сервер создает свой канал FIFO в режиме "только чтение" и блокируется. Он делает это до тех пор, пока первый клиентский процесс не подсоединится, открыв тот же FIFO для записи. В этот момент серверный процесс разблокируется и выполняется вызов <blockquote>sleep</blockquote>, поэтому вызовы <blockquote>write</blockquote> клиентов образуют очередь. (В реальном приложении вызов <blockquote>sleep</blockquote> может быть удален, мы применяем его только чтобы продемонстрировать корректное функционирование программы с множественными одновременно действующими клиентами.)</p>     <p>Между тем, после того как клиентский процесс открыл серверный канал FIFO, он создает собственный FIFO с уникальным именем для считывания данных с сервера. Только после этого клиент записывает данные на сервер (причем, если канал полон или сервер все еще спит, клиентская программа блокируется) и затем блокирует для вызова <blockquote>read</blockquote> свой собственный канал FIFO, ожидая ответа.</p>     <p>Получив данные от клиента, сервер обрабатывает их, открывает клиентский канал для записи и записывает в него данные, что снимает блокировку клиентского процесса. Когда клиент разблокирован, он может читать из своего канала данные, записанные туда сервером.</p>     <p>Процесс повторяется полностью до тех пор, пока последний клиент не закроет канал сервера, вызывая аварийное завершение серверного вызова read (возвращение 0), поскольку ни у одного процесса нет серверного канала, открытого для записи. Если бы это был реальный серверный процесс, вынужденный ожидать будущих клиентов, возможно, вам пришлось бы изменить его, выбрав одно из двух:</p>     <p>&#9633; открыть файловый дескриптор собственного серверного канала, чтобы вызов <blockquote>read</blockquote> всегда его блокировал, а не возвращал 0;</p>     <p>&#9633; закрыть и повторно открыть серверный канал, когда <blockquote>read</blockquote> вернет 0 байтов, чтобы серверный процесс блокировался вызовом <blockquote>open</blockquote>, ожидая клиента, так, как он это делал, стартуя первый раз.</p>     <p>Оба эти метода проиллюстрированы в новом варианте приложения для работы с базой данных компакт-дисков, использующем именованные каналы.</p>              <a name="metkadoc16"><h1>Приложение для работы с базой данных компакт-дисков</h1></a>         <p>Теперь, зная, как применять именованные каналы для реализации простой клиент-серверной системы, вы можете пересмотреть приложение для работы с базой данных компакт-дисков и соответствующим образом переработать его. Вы включите в него также некоторую обработку сигналов, позволяющую выполнить кое-какие действия по наведению порядка при прерывании процесса. Будет использоваться более ранняя версия приложения с dbm и интерфейсом командной строки, чтобы исходный текст программы был максимально простым и понятным.</p>     <p>Прежде чем подробно рассматривать эту новую версию, необходимо откомпилировать приложение. Если вы взяли исходный код с Web-сайта, примените make-файл для его компиляции и получения серверной и клиентской программ.</p>     <blockquote>      <b>Примечание</b>      <p>Как было показано ранее в<i> главе</i> 7, в различных дистрибутивах файлы dbm именуются и устанавливаются немного по-разному. Если предоставленные файлы не компилируются в вашем дистрибутиве, вернитесь к<i> главе</i> 7 и поищите сведения об именах и местонахождении файлов dbm.</p>     </blockquote>     <p>Выполнение команды <blockquote>server -i</blockquote> позволяет программе инициализировать новую базу данных компакт-дисков.</p>     <p>Нет нужды говорить о том, что клиент не выполнится, пока сервер не установится и не запустится. Далее приведен make-файл, показывающий, как совмещаются программы:</p>     <p><blockquote>all: server client</blockquote></p>     <p><blockquote>CC=cc</blockquote></p>     <p><blockquote>CFLAGS= -pedantic -Wall</blockquote></p>     <p><blockquote># Для отладки удалите знак комментария в следующей строке</blockquote></p>     <p><blockquote># DFLAGS=-DDEBUG_TRACE=1 -g</blockquote></p>     <p><blockquote># Где и какую версию dbm мы применяем.</blockquote></p>     <p><blockquote># Предполагается, что gdbm предустановлена в стандартном месте, но мы</blockquote></p>     <p><blockquote># собираемся применять подпрограммы, совместимые с gdbrn, которые</blockquote></p>     <p><blockquote># заставляют ее эмулировать ndbm. Делается это потому, что ndbm — 'самая</blockquote></p>     <p><blockquote># стандартная' из версий dbm. Возможно, вам потребуется внести изменения</blockquote></p>     <p><blockquote># в соответствии с вашим дистрибутивом.</blockquote></p>     <p><blockquote>DBM_INC_PATH=/usr/include/gdbm</blockquote></p>     <p><blockquote>DBM_LIB_PATH=/usr/lib</blockquote></p>     <p><blockquote>DBM_LIB_FILE=-lgdbm</blockquote></p>     <p><blockquote># В некоторых дистрибутивах может понадобиться изменить предыдущую</blockquote></p>     <p><blockquote># строку, чтобы включить библиотеку совместимости, как показано далее.</blockquote></p>     <p><blockquote># DBM_LIB_FILE=-lgdbm_compat -lgdbm</blockquote></p>     <br>     <p><blockquote>.с.о:</blockquote></p>     <p><blockquote> $(CC) $(CFLAGS) -I$(DBM_INC_PATH) $(DFLAGS) -с $&lt;</blockquote></p>     <br>     <p><blockquote>app_ui.o: app_ui.c cd_data.h</blockquote></p>     <p><blockquote>cd_dbm.o: cd_dbm.c cd_data.h</blockquote></p>     <p><blockquote>client_f.o: client_f.c cd_data.h cliserv.h</blockquote></p>     <p><blockquote>pipe_imp.o: pipe_imp.c cd_data.h cliserv.h</blockquote></p>     <p><blockquote>server.о: server.с cd_data.h cliserv.h</blockquote></p>     <p><blockquote>client: app_ui.o clientif.o pipe_imp.o</blockquote></p>     <p><blockquote> $(CC) -o client $(DFLAGS) app_ui.о clientif.o pipe_imp.o</blockquote></p>     <br>     <p><blockquote>server: server.о cd_dbm.o pipe_imp.o</blockquote></p>     <p><blockquote> $(CC) -o server -L$(DBM_LIB_PATH) $(DFLAGS) server.о cd_dbm.o pipe_imp.o -l$(DBM_LIB_FILE)</blockquote></p>     <br>     <p><blockquote>clean:</blockquote></p>     <p><blockquote> rm -f server client_app *.o *~</blockquote></p>             <a name="metkadoc17"><h1>Цели</h1></a>     <p>Наша задача — отделить часть приложения, работающую с базой данных, от пользовательского интерфейса приложения. Вам также необходимо выполнять один серверный процесс, но разрешить одновременное выполнение множества клиентских процессов и при этом сократить до минимума изменения, вносимые в существующий программный код. Везде, где это возможно, вы сохраните исходный текст приложения неизменным.</p>     <p>Для простоты у вас должна быть возможность создавать (и удалять) каналы внутри приложения, не заставляя администратора системы создавать именованные каналы перед тем, как вы сможете их применять.</p>     <p>Важно также не использовать состояние "активного ожидания", чтобы не тратить времени ЦП на ожидание события. Как вы видели, ОС Linux позволяет приостанавливать выполнение в ожидании событий без потребления значительных ресурсов. Следует применять блокирующие свойства каналов для гарантии эффективного использования ЦП. В конце концов, теоретически сервер может ждать в течение многих часов поступления запроса.</p>             <a name="metkadoc18"><h1>Реализация</h1></a>     <p>В предыдущей версии приложения, реализованного в виде единого процесса, с которой вы познакомились в<i> главе</i> 7, для управления данными применялся набор подпрограмм доступа к данным. К ним относились следующие подпрограммы:</p>     <p><blockquote>int database_initialize(const int new_database);</blockquote></p>     <p><blockquote>void database_close(void);</blockquote></p>     <p><blockquote>cdc_entry get_cdc_entry(const char *cd_catalog_ptr);</blockquote></p>     <p><blockquote>cdt_entry get_cdt_entry(const char *cd_catalog_ptr, const int track_no);</blockquote></p>     <p><blockquote>int add_cdc_entry(const cdc_entry entry_to_add);</blockquote></p>     <p><blockquote>int add_cdt_entry(const cdt_entry entry_to_add);</blockquote></p>     <p><blockquote>int del_cdc_entry(const char *cd_catalog_ptr);</blockquote></p>     <p><blockquote>int del_cdt_entry(const char *cd_catalog_ptr, const int track_no);</blockquote></p>     <p><blockquote>cdc_entry search_cdc_entry(const char *cd_catalog_ptr,</blockquote></p>     <p><blockquote> int *first_call_ptr);</blockquote></p>     <p>В этих функциях очень удобно провести резкую границу между клиентом и сервером.</p>     <p>В реализации в виде единого процесса вы можете разделить приложение на две части (рис. 13.6), несмотря на то, что оно компилировалось как единая программа.</p>     <img src="image044.jpg"/>     <p><b>Рис. 13.6</b> </p>     <br>     <p>В клиент-серверную версию приложения вы хотите включить несколько именованных каналов и сопроводительный программный код для связи двух основных частей приложения. На рис. 13.7 показана необходимая структура.</p>     <img src="image045.jpg"/>     <p><b>Рис. 13.7</b> </p>     <br>     <p>В данной реализации подпрограммы интерфейса и клиента, и сервера помещены в один файл pipe_imp.c. Это сохраняет в едином файле весь программный код, зависящий от применения именованных каналов в клиент-серверной реализации. Форматирование и упаковка передаваемых данных хранятся отдельно от подпрограмм, реализующих именованные каналы. В результате у вас появятся дополнительные файлы исходного текста программы, но с более логичным разделением. Структура вызовов в приложении показана на рис. 13.8.</p>     <img src="image046.jpg"/>     <p><b>Рис. 13.8</b> </p>     <br>     <p>Файлы арр_ui.c, client_if.c и pipe_imp.c компилируются и компонуются вместе для получения клиентской программы. Файлы cd_dbm.c, server.c и pipe_imp.c компилируются и компонуются вместе для создания серверной программы. Заголовочный файл cliserv.h действует как заголовочный файл общих определений для связывания обеих программ.</p>     <p>В файлы app_ui.c и cd_dbm.c внесены очень незначительные изменения, в принципе позволяющие разделить приложение на две программы. Поскольку теперь приложение очень большое и существенная часть программного кода не изменилась по сравнению с предыдущей версией, здесь мы покажем только файлы cliserv.h, сlient_if.c и pipe_imp.c.</p>     <b>Заголовочный файл <i>cliserv.h</i></b>     <p>Сначала рассмотрим cliserv.h. Этот файл определяет клиент-серверный интерфейс. Он необходим и клиентской, и серверной программам.</p>     <p>1. Далее приведены необходимые директивы <blockquote>#include</blockquote>.</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;fcntl.h&gt;</blockquote></p>     <p><blockquote>#include &lt;limits.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/types.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/stat.h&gt;</blockquote></p>     <p>2. Затем вы определяете именованные каналы. Используйте один канал для сервера и по одному каналу для каждого клиента. Поскольку клиентов может быть несколько, клиентская программа включает идентификатор процесса в имя, таким образом, обеспечивая уникальность канала.</p>     <p><blockquote>#define SERVER_PIPE "/tmp/server_pipe"</blockquote></p>     <p><blockquote>#define CLIENT_PIPE "/tmp/client_%d_pipe"</blockquote></p>     <p><blockquote>#define ERR_TEXT_LEN 80</blockquote></p>     <p>3. Реализуйте команды как перечислимые типы, а не как директивы <blockquote>#define</blockquote>.</p>     <blockquote>      <b>Примечание</b>      <p>Это хорошая возможность для компилятора выполнить дополнительную проверку типов и помочь в отладке приложения, т.к. многие отладчики могут показывать имена перечислимых констант, но не имена, определенные директивой <blockquote>#define</blockquote>.</p>     </blockquote>     <p>Первый оператор <blockquote>typedef</blockquote> задает тип запроса, отправляемого на сервер; второй описывает тип серверного ответа клиенту.</p>     <p><blockquote>typedef enum {</blockquote></p>     <p><blockquote> s_create_new_database = 0,</blockquote></p>     <p><blockquote> s_get_cdc_entry,</blockquote></p>     <p><blockquote> s_get_cdt_entry,</blockquote></p>     <p><blockquote> s_add_cdc_entry,</blockquote></p>     <p><blockquote> s_add_cdt_entry,</blockquote></p>     <p><blockquote> s_del_cdc_entry,</blockquote></p>     <p><blockquote> s_del_cdt_entry,</blockquote></p>     <p><blockquote> s_fmd_cdc_entry</blockquote></p>     <p><blockquote>} client_request_e;</blockquote></p>     <br>     <p><blockquote>typedef enum {</blockquote></p>     <p><blockquote> r_success = 0,</blockquote></p>     <p><blockquote> r_failure,</blockquote></p>     <p><blockquote> r_find_no_more</blockquote></p>     <p><blockquote>} server_response_e;</blockquote></p>     <p>4. Далее объявите структуру, которая будет формировать сообщение, передаваемое между двумя процессами в обоих направлениях.</p>     <blockquote>      <b>Примечание</b>      <p>Поскольку на самом деле вам не нужно возвращать <blockquote>cdc_entry</blockquote> и <blockquote>cdt_entry</blockquote> в одном ответе, вы могли бы сделать их объединением (union). Но для простоты можно оставить их отдельными элементами, кроме того, в этом случае легче поддерживать программный код.</p>     </blockquote>     <p><blockquote>typedef struct {</blockquote></p>     <p><blockquote> pid_t client_pid;</blockquote></p>     <p><blockquote> client_request_e request;</blockquote></p>     <p><blockquote> server_response_e response;</blockquote></p>     <p><blockquote> cdc_entry cdc_entry_data;</blockquote></p>     <p><blockquote> cdt_entry cdt_entry_data;</blockquote></p>     <p><blockquote> char error_text[ERR_TEXT_LEN + 1];</blockquote></p>     <p><blockquote>} message_db_t;</blockquote></p>     <p>5. В заключение приведены функции интерфейса канала, выполняющие передачу данных и содержащиеся в файле pipe_imp.c. Они делятся на функции серверной и клиентской стороны, в первом и втором блоках соответственно.</p>     <p><blockquote>int server_starting(void);</blockquote></p>     <p><blockquote>void server_ending(void);</blockquote></p>     <p><blockquote>int read_request_from_client(message_db_t *rec_ptr);</blockquote></p>     <p><blockquote>int start_resp_to_client(const message_db_t mess_to_send);</blockquote></p>     <p><blockquote>int send_resp_to_client(const message_db_t mess_to_send);</blockquote></p>     <p><blockquote>void end_resp_to_client(void);</blockquote></p>     <p><blockquote>int client_starting(void);</blockquote></p>     <p><blockquote>void client_ending(void);</blockquote></p>     <p><blockquote>int send_mess_to_server(message_db_t mess_to_send);</blockquote></p>     <p><blockquote>int start_resp_from_server(void);</blockquote></p>     <p><blockquote>int read_resp_from_server(message_db_t *rec_ptr);</blockquote></p>     <p><blockquote>void end_resp_from_server(void);</blockquote></p>     <p>Мы разделим последующее обсуждение на функции клиентского интерфейса и детали серверных и клиентских функций, хранящихся в файле pipe_imp.c, и при необходимости будем обращаться к исходному программному коду.</p>             <a name="metkadoc19"><h1>Функции интерфейса клиента</h1></a>     <p>Рассмотрим файл clientif.c. Он предоставляет "поддельные" версии подпрограмм доступа к базе данных. Они кодируют запрос в структуре <blockquote>message_db_t</blockquote> и затем применяют подпрограммы из файла pipe_imp.c для передачи запроса серверу. Такой подход позволит вам внести минимальные изменения в первоначальный файл app_ui.c.</p>     <b>Интерпретатор клиента</b>     <p>1. В этом файле реализовано девять функций для работы с базой данных, объявленных в файле cd_data.h. Делает он это передачей запросов серверу и затем возвратом ответа сервера из функции, действуя как посредник. Файл начинается с файлов <blockquote>#include</blockquote> и констант.</p>     <p><blockquote>#define _POSIX_SOURCE</blockquote></p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;fcntl.h&gt;</blockquote></p>     <p><blockquote>#include &lt;limits.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/types.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/stat.h&gt;</blockquote></p>     <p><blockquote>#include "cd_data.h"</blockquote></p>     <p><blockquote>#include "cliserv.h"</blockquote></p>     <p>2. Статическая переменная <blockquote>mypid</blockquote> уменьшает количество вызовов <blockquote>getpid</blockquote>, требуемых в противном случае. Мы применяем локальную функцию <blockquote>read_one_response</blockquote> для устранения дублирующегося программного кода.</p>     <p><blockquote>static pid_t mypid;</blockquote></p>     <p><blockquote>static int read_one_response(message_db_t *rec_ptr);</blockquote></p>     <p>3. Подпрограммы <blockquote>database_initialize</blockquote> и <blockquote>close</blockquote> все еще вызываются, но теперь используются, соответственно, для инициализации клиентского интерфейса каналов и удаления лишних именованных каналов, когда клиент завершил выполнение.</p>     <p><blockquote>int database_initialize(const int new_database) {</blockquote></p>     <p><blockquote> if (!client_starting()) return(0);</blockquote></p>     <p><blockquote> mypid = getpid();</blockquote></p>     <p><blockquote> return(1);</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote>/* инициализация базы данных */</blockquote></p>     <p><blockquote>void database_close(void) {</blockquote></p>     <p><blockquote> client_ending();</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>4. Подпрограмма <blockquote>get_cdc_entry</blockquote> вызывается для получения элемента каталога из базы данных по заданному названию компакт-диска в каталоге. В ней вы кодируете запрос в структуре <blockquote>message_db_t</blockquote> и передаете его на сервер. Далее вы считываете обратно ответ в другую структуру типа <blockquote>message_db_t</blockquote>. Если элемент найден, он включается в структуру <blockquote>message_db_t</blockquote> как структура типа <blockquote>cdc_entry</blockquote>, поэтому вы можете передать соответствующую часть структуры.</p>     <p><blockquote>cdc_entry get_cdc_entry(const char *cd_catalog_ptr) {</blockquote></p>     <p><blockquote> cdc_entry ret_val;</blockquote></p>     <p><blockquote> message_db_t mess_send;</blockquote></p>     <p><blockquote> message_db_t mess_ret;</blockquote></p>     <p><blockquote> ret_val.catalog[0] = '\0';</blockquote></p>     <p><blockquote> mess_send.client_pid = mypid;</blockquote></p>     <p><blockquote> mess_send.request = s_get_cdc_entry;</blockquote></p>     <p><blockquote> strcpy(mess_send.cdc_entry_data.catalog, cd_catalog_ptr);</blockquote></p>     <p><blockquote> if (send_mess_to_server(mess_send)) {</blockquote></p>     <p><blockquote>  if (read_one_response(&amp;mess_ret)) {</blockquote></p>     <p><blockquote>   if (mess_ret.response == r_success) {</blockquote></p>     <p><blockquote>    ret_val = mess_ret.cdc_entry_data;</blockquote></p>     <p><blockquote>   } else {</blockquote></p>     <p><blockquote>    fprintf(stderr, "%s", mess_ret.error_text);</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>  } else {</blockquote></p>     <p><blockquote>   fprintf(stderr, "Server failed to respond\n");</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Server not accepting requests\n");</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return(ret_val);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>5. Далее приведен исходный текст функции <blockquote>read_one_response</blockquote>, которая используется для устранения дублирующегося программного кода.</p>     <p><blockquote>static int read_one_response(message_db_t *rec_ptr) {</blockquote></p>     <p><blockquote> int return_code = 0;</blockquote></p>     <p><blockquote> if (!rec_ptr) return(0);</blockquote></p>     <p><blockquote> if (start_resp_from_server()) {</blockquote></p>     <p><blockquote>  if (read_resp_from_server(rec_ptr)) {</blockquote></p>     <p><blockquote>   return_code = 1;</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  end_resp_from_server();</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return(return_code);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>6. Остальные подпрограммы <blockquote>get_xxx</blockquote>, <blockquote>del_xxx</blockquote> и <blockquote>add_xxx</blockquote> реализованы аналогично функции <blockquote>get_cdc_entry</blockquote> и приводятся здесь для полноты картины. Сначала функция для извлечения дорожек компакт-диска.</p>     <p><blockquote>cdt_entry get_cdt_entry(const char *cd_catalog_ptr,</blockquote></p>     <p><blockquote> const int track no) {</blockquote></p>     <p><blockquote> cdt_entry ret_val;</blockquote></p>     <p><blockquote> message_db_t mess_send;</blockquote></p>     <p><blockquote> message_db_t mess_ret;</blockquote></p>     <p><blockquote> ret_val.catalog[0] = '\0';</blockquote></p>     <p><blockquote> mess_send.client_pid = mypid; mess_send.request = s_get_cdt_entry;</blockquote></p>     <p><blockquote> strcpy(mess_send.cdt_entry_data.catalog, cd_catalog_ptr);</blockquote></p>     <p><blockquote> mess_send.cdt_entry_data.track_no = track_no;</blockquote></p>     <p><blockquote> if (send_mess_to_server(mess_send)) {</blockquote></p>     <p><blockquote>  if (read_one_response(&amp;mess_ret)) {</blockquote></p>     <p><blockquote>   if (mess_ret.response == r_success) {</blockquote></p>     <p><blockquote>    ret_val = mess_ret.cdt_entry_data;</blockquote></p>     <p><blockquote>   } else {</blockquote></p>     <p><blockquote>    fprintf(stderr, "%s", mess_ret.error_text);</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>  } else {</blockquote></p>     <p><blockquote>   fprintf(stderr, "Server failed to respond\n");</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Server not accepting requests\n");</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return(ret_val);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>7. Далее две функции для вставки данных, первая для добавления элемента каталога, а вторая — дорожек в базу данных.</p>     <p><blockquote>int add_cdc_entry(const cdc_entry entry_to_add) {</blockquote></p>     <p><blockquote> message_db_t mess_send;</blockquote></p>     <p><blockquote> message_db_t mess_ret;</blockquote></p>     <p><blockquote> mess_send.client_pid = mypid;</blockquote></p>     <p><blockquote> mess_send.request = s_add_cdc_entry;</blockquote></p>     <p><blockquote> mess_send.cdc_entry_data = entry_to_add;</blockquote></p>     <p><blockquote> if (send_mess_to_server(mess_send)) {</blockquote></p>     <p><blockquote>  if (read_one_response(&amp;mess_ret)) {</blockquote></p>     <p><blockquote>   if (mess_ret.response == r_success) {</blockquote></p>     <p><blockquote>    return(1);</blockquote></p>     <p><blockquote>   } else {</blockquote></p>     <p><blockquote>    fprintf(stderr, "%s", mess_ret.error_text);</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>  } else {</blockquote></p>     <p><blockquote>   fprintf(stderr, "Server failed to respond\n");</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Server not accepting requests\n");</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote>int add_cdt_entry(const cdt_entry entry_to_add) {</blockquote></p>     <p><blockquote> message_db_t mess_send;</blockquote></p>     <p><blockquote> message_db_t mess_ret;</blockquote></p>     <p><blockquote> mess_send.client_pid = mypid;</blockquote></p>     <p><blockquote> mess_send.request = s_add_cdt_entry;</blockquote></p>     <p><blockquote> mess send.cdt_entry data = entry_to_add;</blockquote></p>     <p><blockquote> if (send_mess_to_server(mess_send)) {</blockquote></p>     <p><blockquote>  if (read_one_response(&amp;mess_ret)) {</blockquote></p>     <p><blockquote>   if (mess_ret.response == r_success) {</blockquote></p>     <p><blockquote>    return(1);</blockquote></p>     <p><blockquote>   } else {</blockquote></p>     <p><blockquote>    fprintf(stderr, "%s", mess_ret.error_text);</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>  } else {</blockquote></p>     <p><blockquote>   fprintf(stderr, "Server failed to respond\n");</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Server not accepting requests\n");</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>8. В заключение две функции для удаления данных.</p>     <p><blockquote>int del_cdc_entry(const char *cd_catalog_ptr) {</blockquote></p>     <p><blockquote> message_db_t mess_send;</blockquote></p>     <p><blockquote> message_db_t mess_ret;</blockquote></p>     <p><blockquote> mess_send.client_pid = mypid;</blockquote></p>     <p><blockquote> mess_send.request = s_del_cdc_entry;</blockquote></p>     <p><blockquote> strcpy(mess_send.cdc_entry_data.catalog, cd_catalog_ptr);</blockquote></p>     <p><blockquote> if (send_mess_to_server(mess_send)) {</blockquote></p>     <p><blockquote>  if (read_one_response(&amp;mess_ret)) {</blockquote></p>     <p><blockquote>   if (mess_ret.response == r_success) {</blockquote></p>     <p><blockquote>    return(1);</blockquote></p>     <p><blockquote>   } else {</blockquote></p>     <p><blockquote>    fprintf(stderr, "%s", mess_ret.error_text);</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>  } else {</blockquote></p>     <p><blockquote>   fprintf(stderr, "Server failed to respond\n");</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Server not accepting requests\n");</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote>int del_cdt_entry(const char *cd_catalog_ptr, const int track no) {</blockquote></p>     <p><blockquote> message_db_t mess_send;</blockquote></p>     <p><blockquote> message_db_t mess_ret;</blockquote></p>     <p><blockquote> mess_send.client_pid = mypid;</blockquote></p>     <p><blockquote> mess_send.request = s_del_cdt_entry;</blockquote></p>     <p><blockquote> strcpy(mess_send.cdt_entry_data.catalog, cd_catalog_ptr);</blockquote></p>     <p><blockquote> mess_send.cdt_entry_data.track_no = track_no;</blockquote></p>     <p><blockquote> if (send_mess_to_server(mess_send)) {</blockquote></p>     <p><blockquote>  if (read_one_response(&amp;mess_ret)) {</blockquote></p>     <p><blockquote>   if (mess_ret.response == r_success) {</blockquote></p>     <p><blockquote>    return(1);</blockquote></p>     <p><blockquote>   } else {</blockquote></p>     <p><blockquote>    fprintf(stderr, "%s", mess_ret.error_text);</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>  } else {</blockquote></p>     <p><blockquote>   fprintf(stderr, "Server failed to respond\n");</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Server not accepting requests\n");</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <b>Поиск в базе данных</b>     <p>Функция поиска по ключу компакт-диска сложнее. Пользователь этой функции рассчитывает вызвать ее один раз для начала поиска. Мы удовлетворили его ожидания в<i> главе</i> 7, задавая параметр <blockquote>*first_call_ptr</blockquote> равным <blockquote>true</blockquote> при первом вызове функции, и функция в этом случае возвращает первое найденное совпадение. При последующих вызовах функции поиска указатель <blockquote>*first_call_ptr</blockquote> равен <blockquote>false</blockquote> и возвращаются дальнейшие совпадения, по одному на каждый вызов.</p>     <p>Теперь, когда вы разделили приложение на два процесса, нельзя разрешать поиску обрабатывать по одному элементу на сервере, потому что другой клиент может запросить у сервера иной поиск, когда выполняется ваш поиск. Вы не можете заставить серверную часть хранить отдельно содержимое (как далеко продвинулся поиск) для поиска каждого клиента, т.к. клиент может просто остановить поиск на полпути, когда найден нужный компакт-диск или клиент "упал".</p>     <p>Можно либо изменить алгоритм поиска, либо, как показано в приведенном далее программном коде, спрятать сложность в подпрограмме интерфейса. Данный код вынуждает сервер возвращать все возможные совпадения с искомым значением и затем сохраняет их во временном файле до тех пор, пока клиент не запросит их.</p>     <p>1. Эта функция не так сложна, как кажется, просто в ней вызываются три функции канала <blockquote>send_mess_to_server</blockquote>, <blockquote>start_resp_from_server</blockquote> и <blockquote>read_resp_fromserver</blockquote>, которые будут рассмотрены в следующем разделе.</p>     <p><blockquote>cdc_entry search_cdc_entry(const char *cd_catalog_ptr,</blockquote></p>     <p><blockquote> int *first_call_ptr) {</blockquote></p>     <p><blockquote> message_db_t mess_send;</blockquote></p>     <p><blockquote> message_db_t mess_ret;</blockquote></p>     <p><blockquote> static FILE *work_file = (FILE *)0;</blockquote></p>     <p><blockquote> static int entries_matching = 0;</blockquote></p>     <p><blockquote> cdc_entry ret_val;</blockquote></p>     <p><blockquote> ret_val.catalog[0] = '\0';</blockquote></p>     <p><blockquote> if (!work_file &amp;&amp; (*first_call_ptr == 0)) return(ret_val);</blockquote></p>     <p>2. Далее показан первый вызов для поиска с указателем <blockquote>*first_call_ptr</blockquote>, равным <blockquote>true</blockquote>. Он немедленно приравнивается <blockquote>false</blockquote>, на случай, если вы забыли. Создается временный файл <blockquote>work_file</blockquote> и инициализируется структура сообщения клиенту.</p>     <p><blockquote>if (*first_call_ptr) {</blockquote></p>     <p><blockquote> *first_call_ptr = 0;</blockquote></p>     <p><blockquote> if (work_file) fclose(work_file);</blockquote></p>     <p><blockquote> work_file = tmpfile();</blockquote></p>     <p><blockquote> if (!work_file) return(ret_val);</blockquote></p>     <p><blockquote> mess_send.client_pid = mypid;</blockquote></p>     <p><blockquote> mess_send.request = s_find_cdc_entry;</blockquote></p>     <p><blockquote> strcpy(mess_send.cdc_entry_data.catalog, cd_catalog_ptr);</blockquote></p>     <p>3. Теперь приводится проверка условий с тремя уровнями вложенности, заставляющая вызывать функции из файла pipe_imp.c. Если сообщение успешно отправлено на сервер, клиент ждет ответа от сервера. Пока считывания с сервера успешны, совпадения с искомой величиной возвращаются в <blockquote>work_file</blockquote> клиента и наращивается счетчик entries_matching.</p>     <p><blockquote> if (send_mess_to_server(mess_send)) {</blockquote></p>     <p><blockquote>  if (start_resp_from_server()) {</blockquote></p>     <p><blockquote>   while (read_resp_from_server(&amp;mess_ret)) {</blockquote></p>     <p><blockquote>    if (mess_ret.response == r_success) {</blockquote></p>     <p><blockquote>     fwrite(&amp;mess_ret.cdc_entry_data, sizeof(cdc_entry), 1, work_file);</blockquote></p>     <p><blockquote>     entries_matching++;</blockquote></p>     <p><blockquote>    } else {</blockquote></p>     <p><blockquote>     break;</blockquote></p>     <p><blockquote>    }</blockquote></p>     <p><blockquote>   } /* while */</blockquote></p>     <p><blockquote>  } else {</blockquote></p>     <p><blockquote>   fprintf(stderr, "Server not responding\n");</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  fprintf (stderr, "Server not accepting requests\n");</blockquote></p>     <p><blockquote> }</blockquote></p>     <p>4. Следующая проверка ищет, есть ли совпадения с заданным значением. Далее вызов <blockquote>fseek</blockquote> переводит указатель в файле <blockquote>work_file</blockquote> на место записи следующей порции данных.</p>     <p><blockquote> if (entries_matching == 0) {</blockquote></p>     <p><blockquote>  fclose(work_file);</blockquote></p>     <p><blockquote>  work_file = (FILE *)0;</blockquote></p>     <p><blockquote>  return(ret_val);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> (void)fseek(work_file, 0L, SEEK_SET);</blockquote></p>     <p>5. Если это не первый вызов функции поиска для данного конкретного элемента, программа проверяет, были ли уже найдены совпадения. В заключение в структуру <blockquote>ret_val</blockquote> читается следующий совпадающий элемент. Предшествующие проверки гарантируют наличие совпадающего элемента.</p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  /* не *first_call_ptr */</blockquote></p>     <p><blockquote>  if (entries_matching == 0) {</blockquote></p>     <p><blockquote>   fclose(work_file);</blockquote></p>     <p><blockquote>   work_file = (FILE *)0;</blockquote></p>     <p><blockquote>   return(ret_val);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> fread(&amp;ret_val, sizeof(cdc_entry), 1, work_file);</blockquote></p>     <p><blockquote> entries_matching--;</blockquote></p>     <p><blockquote> return(ret_val);</blockquote></p>     <p><blockquote>}</blockquote></p>             <a name="metkadoc20"><h1>Интерфейс сервера server.c</h1></a>     <p>Если у клиента есть интерфейс для обращения к программе app_ui.c, серверу также нужна программа для управления (переименованной) программой cd_access.c, теперь cd_dbm.c. Далее приведена функция main сервера.</p>     <p>1. Начните с объявления нескольких глобальных переменных, прототипа функции <blockquote>process_command</blockquote> и функции перехвата сигнала для обеспечения чистого завершения.</p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;fcntl.h&gt;</blockquote></p>     <p><blockquote>#include &lt;limits.h&gt;</blockquote></p>     <p><blockquote>#include &lt;signal.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <p><blockquote>#include &lt;errno.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/types.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/stat.h&gt;</blockquote></p>     <p><blockquote>#include "cd_data.h"</blockquote></p>     <p><blockquote>#include "cliserv.h"</blockquote></p>     <br>     <p><blockquote>int save errno;</blockquote></p>     <p><blockquote>static int server_running = 1;</blockquote></p>     <br>     <p><blockquote>static void process_command(const message_db_t mess_command);</blockquote></p>     <br>     <p><blockquote>void catch_signals() {</blockquote></p>     <p><blockquote> server_running = 0;</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>2. Теперь переходите к функции <blockquote>main</blockquote>. После проверки успешного завершения подпрограмм захвата сигнала программа проверяет, передали ли вы <blockquote>-i</blockquote> в командной строке. Если да, она создаст новую базу данных. Если вызов подпрограммы <blockquote>database_initialize</blockquote> в файле cd_dbm.c завершится аварийно, будет выведено сообщение об ошибке. Если все хорошо и сервер работает, любые запросы от клиента направляются функции <blockquote>process_command</blockquote>, которую вы вскоре увидите.</p>     <p><blockquote>int main(int argc, char *argv[]) {</blockquote></p>     <p><blockquote> struct sigaction new_action, old_action;</blockquote></p>     <p><blockquote> message_db_t mess command;</blockquote></p>     <p><blockquote> int database_init_type = 0;</blockquote></p>     <p><blockquote> new_action.sa_handler = catch_signals;</blockquote></p>     <p><blockquote> sigemptyset(&amp;new_action.sa_mask);</blockquote></p>     <p><blockquote> new_action.sa_flags = 0;</blockquote></p>     <p><blockquote> if ((sigaction(SIGINT, &amp;new_action, &amp;old_action) != 0) ||</blockquote></p>     <p><blockquote>  (sigaction(SIGHUP, &amp;new_action, &amp;old_action) != 0) ||</blockquote></p>     <p><blockquote>  (sigaction(SIGTERM, &amp;new_action, &amp;old_action) != 0)) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Server startup error, signal catching failed\n");</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> if (argc &gt; 1) {</blockquote></p>     <p><blockquote>  argv++;</blockquote></p>     <p><blockquote>  if (strncmp("-i", *argv, 2) == 0) database_init_type = 1;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> if (!database_initialize(database_init_type)) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Server error :-\</blockquote></p>     <p><blockquote>   could not initialize database\n");</blockquote></p>     <p><blockquote>  exit (EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> if (!server starting()) exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> while(server_running) {</blockquote></p>     <p><blockquote>  if (read_request_from_client(&amp;mess_command)) {</blockquote></p>     <p><blockquote>   process_command(mess_command);</blockquote></p>     <p><blockquote>  } else {</blockquote></p>     <p><blockquote>   if (server_running) fprintf(stderr,</blockquote></p>     <p><blockquote>    "Server ended — can not read pipe\n");</blockquote></p>     <p><blockquote>   server_running = 0;</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> } /* while */</blockquote></p>     <p><blockquote> server_ending();</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>3. Любые сообщения клиентов направляются в функцию <blockquote>process_command</blockquote>, где они обрабатываются в операторе <blockquote>case</blockquote>, который выполняет соответствующие вызовы из файла cd_dbm.c.</p>     <p><blockquote>static void process_command(const message_db_t comm) {</blockquote></p>     <p><blockquote> message_db_t resp;</blockquote></p>     <p><blockquote> int first_time = 1;</blockquote></p>     <p><blockquote> resp = comm; /* копирует команду обратно,</blockquote></p>     <p><blockquote>                 затем изменяет resp, как требовалось */</blockquote></p>     <p><blockquote> if (!start_resp_to_client(resp)) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Server Warning:</blockquote></p>     <p><blockquote>   start_resp_to_client %d failed\n", resp.client_pid);</blockquote></p>     <p><blockquote>  return;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> resp.response = r_success;</blockquote></p>     <p><blockquote> memset(resp.error_text, '\0', sizeof(resp.error_text));</blockquote></p>     <p><blockquote> save_errno = 0;</blockquote></p>     <p><blockquote> switch(resp.request) {</blockquote></p>     <p><blockquote> case s_create_new_database:</blockquote></p>     <p><blockquote>  if (!database initialize(1))</blockquote></p>     <p><blockquote>   resp.response = r_failure;</blockquote></p>     <p><blockquote>  break;</blockquote></p>     <p><blockquote> case s_get_cdc_entry:</blockquote></p>     <p><blockquote>  resp.cdc_entry_data =</blockquote></p>     <p><blockquote>   get_cdc_entry(comm.cdc_entry_data.catalog);</blockquote></p>     <p><blockquote>  break;</blockquote></p>     <p><blockquote> case s_get_cdt_entry:</blockquote></p>     <p><blockquote>  resp.cdt_entry_data =</blockquote></p>     <p><blockquote>   get_cdt_entry(comm.cdt_entry_data.catalog,</blockquote></p>     <p><blockquote>   comm.cdt_entry_data.track_no);</blockquote></p>     <p><blockquote>  break;</blockquote></p>     <p><blockquote> case s_add_cdc_entry:</blockquote></p>     <p><blockquote>  if (!add_cdc_entry(comm.cdc_entry_data))</blockquote></p>     <p><blockquote>   resp.response = r_failure;</blockquote></p>     <p><blockquote>  break;</blockquote></p>     <p><blockquote> case s_add_cdt_entry:</blockquote></p>     <p><blockquote>  if (!add_cdt_entry(comm.cdt_entry_data))</blockquote></p>     <p><blockquote>   resp.response = r_failure;</blockquote></p>     <p><blockquote>  break;</blockquote></p>     <p><blockquote> case s_del_cdc_entry:</blockquote></p>     <p><blockquote>  if (!del_cdc_entry(comm.cdc_entry_data.catalog))</blockquote></p>     <p><blockquote>   resp.response = r_failure;</blockquote></p>     <p><blockquote>  break;</blockquote></p>     <p><blockquote> case s_del_cdt_entry:</blockquote></p>     <p><blockquote>  if (!del_cdt_entry(comm.cdt_entry_data.catalog,</blockquote></p>     <p><blockquote>   comm.cdt_entry_data.track_no)) resp.response = r_failure;</blockquote></p>     <p><blockquote>  break;</blockquote></p>     <p><blockquote> case s_find_cdc_entry:</blockquote></p>     <p><blockquote>  do {</blockquote></p>     <p><blockquote>   resp.cdc_entry_data =</blockquote></p>     <p><blockquote>    search_cdc_entry(comm.cdc_entry_data.catalog, &amp;first_time);</blockquote></p>     <p><blockquote>   if (resp.cdc_entry_data.catalog[0] != 0) {</blockquote></p>     <p><blockquote>    resp.response = r_success;</blockquote></p>     <p><blockquote>    if (!send_resp_to_client(resp)) {</blockquote></p>     <p><blockquote>     fprintf(stderr,</blockquote></p>     <p><blockquote>      "Server Warning:- failed to respond to %d\n", resp.client_pid);</blockquote></p>     <p><blockquote>     break;</blockquote></p>     <p><blockquote>    }</blockquote></p>     <p><blockquote>   } else {</blockquote></p>     <p><blockquote>    resp.response = r_find_no_more;</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>  } while (resp.response == r_success);</blockquote></p>     <p><blockquote>  break;</blockquote></p>     <p><blockquote> default:</blockquote></p>     <p><blockquote>  resp.response = r_failure;</blockquote></p>     <p><blockquote>  break;</blockquote></p>     <p><blockquote> } /* switch */</blockquote></p>     <p><blockquote> sprintf(resp.error_text, </blockquote></p>     <p><blockquote>  "Command failed:\n\t%s\n", strerror(save_errno));</blockquote></p>     <p><blockquote> if (!send_resp_to_client(resp)) {</blockquote></p>     <p><blockquote>  fprintf(stderr,</blockquote></p>     <p><blockquote>   "Server Warning:- failed to respond to %d\n", resp.client_pid);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> end_resp_to_client();</blockquote></p>     <p><blockquote> return;</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Прежде чем рассматривать действующую реализацию канала, давайте обсудим последовательность событий, которые должны произойти для передачи данных между клиентским и серверным процессами. На рис. 13.9 показан запуск обоих, и клиентского, и серверного, процессов, а также то, как они образуют петлю во время обработки команд и ответов.</p>     <p>В этой реализации ситуация немного сложнее, т.к. в запросе на поиск клиент передает серверу одну команду и затем ждет один или несколько ответов от сервера. Это усложняет программу, особенно клиентскую часть.</p>     <img src="image047.jpg"/>     <p><b>Рис. 13.9</b> </p>             <a name="metkadoc21"><h1>Канал</h1></a>     <p>Далее показан файл реализации канала pipe_imp.с, в котором содержатся клиентские и серверные функции.</p>     <blockquote>      <b>Примечание</b>      <p>Как вы видели в<i> главе 10,</i> может быть определено символическое имя DEBUG_TRACE для того, чтобы показать последовательность вызовов, в которых клиентский и серверный процессы передают друг другу сообщения.</p>     </blockquote>     <b>Заголовочный файл для реализации канала</b>     <p>1. Прежде всего, директивы <blockquote>#include</blockquote>:</p>     <p><blockquote>#include "cd_data.h"</blockquote></p>     <p><blockquote>#include "cliserv.h"</blockquote></p>     <p>2. Вы также определяете в файле программы несколько значений, нужных вам в разных функциях:</p>     <p><blockquote>static int server_fd = -1;</blockquote></p>     <p><blockquote>static pid_t mypid = 0;</blockquote></p>     <p><blockquote>static char client_pipe_name[PATH_MAX + 1] = {'\0'};</blockquote></p>     <p><blockquote>static int client_fd = -1;</blockquote></p>     <p><blockquote>static int client_write_fd = -1;</blockquote></p>     <b>Функции серверной стороны</b>     <p>Далее нужно рассмотреть функции серверной стороны. В следующем разделе показаны функции, открывающие и закрывающие именованный канал и читающие сообщения от клиентов. В следующем за ним разделе приведен программный код, который открывает и закрывает клиентские каналы и пересылает по ним сообщения, основываясь на идентификаторе процесса, который клиент включает в свое сообщение.</p>     <b>Функции сервера</b>     <p>1. Подпрограмма <blockquote>server_starting</blockquote> создает именованный канал, из которого сервер будет считывать команды. Далее она открывает канал для чтения. Этот вызов <blockquote>open</blockquote> будет блокировать выполнение, пока клиент не откроет канал для записи. Используйте режим блокировки для того, чтобы сервер мог выполнить блокировку вызовов <blockquote>read</blockquote> в канале в ожидании отправляемых ему команд.</p>     <p><blockquote>int server_starting(void) {</blockquote></p>     <p><blockquote>#if DEBUG_TRACE</blockquote></p>     <p><blockquote> printf("%d server_starting()\n", getpid());</blockquote></p>     <p><blockquote>#endif</blockquote></p>     <p><blockquote> unlink(SERVER_PIPE);</blockquote></p>     <p><blockquote> if (mkfifo(SERVER_PIPE, 0777) == -1) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Server startup error, no FIFO created\n");</blockquote></p>     <p><blockquote>  return(0);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> if ((server_fd = open(SERVER_PIPE, O_RDONLY)) == -1) {</blockquote></p>     <p><blockquote>  if (errno == EINTR) return(0);</blockquote></p>     <p><blockquote>  fprintf(stderr, "Server startup error, no FIFO opened\n");</blockquote></p>     <p><blockquote>  return(0);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return(1);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>2. Когда сервер завершает работу, он удаляет именованный канал, для того чтобы клиенты могли установить, что нет действующего сервера.</p>     <p><blockquote>void server_ending(void) {</blockquote></p>     <p><blockquote>#if DEBUG_TRACE</blockquote></p>     <p><blockquote> printf("%d:- server_ending()\n", getpid());</blockquote></p>     <p><blockquote>#endif</blockquote></p>     <p><blockquote> (void)close(server_fd);</blockquote></p>     <p><blockquote> (void)unlink(SERVER_PIPE);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>3. Функция <blockquote>read_request_from_client</blockquote> будет блокировать чтение в серверном канале до тех пор, пока клиент не запишет в него сообщение.</p>     <p><blockquote>int read_request_from_client(message_db_t *rec_ptr) {</blockquote></p>     <p><blockquote> int return_code = 0;</blockquote></p>     <p><blockquote> int read_bytes;</blockquote></p>     <p><blockquote>#if DEBUG_TRACE</blockquote></p>     <p><blockquote> printf("%d :- read_request_from_client()\n", getpid());</blockquote></p>     <p><blockquote>#endif</blockquote></p>     <p><blockquote> if (server_fd != -1) {</blockquote></p>     <p><blockquote>  read_bytes = read(server_fd, rec_ptr, sizeof(*rec_ptr));</blockquote></p>     <p><blockquote>  ...</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return(return_code);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>4. В особом случае, когда ни у одного клиента нет канала, открытого для записи, вызов <blockquote>read</blockquote> вернет 0, т.е. он обнаружит EOF (метку конца файла). Затем сервер закроет канал и откроет его снова так, что канал блокируется до тех пор, пока клиент также не откроет канал. Выполняется то же, что и при первом запуске сервера; вы инициализировали сервер повторно. Вставьте этот программный код в предыдущую функцию. </p>     <p><blockquote>if (read_bytes == 0) {</blockquote></p>     <p><blockquote> (void)close(server_fd);</blockquote></p>     <p><blockquote> if ((server_fd = open(SERVER_PIPE, O_RDONLY)) == -1) {</blockquote></p>     <p><blockquote>  if (errno != EINTR) {</blockquote></p>     <p><blockquote>   fprintf(stderr, "Server error, FIFO open failed\n");</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote>  return(0);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> read_bytes = read(server_fd, rec_ptr, sizeof(*rec_ptr));</blockquote></p>     <p><blockquote>}</blockquote></p>     <p><blockquote>if (read_bytes == sizeof(*rec_ptr)) return_code = 1;</blockquote></p>     <p>Сервер — это единственный процесс, способный одновременно обслуживать множество клиентов. Поскольку каждый клиент применяет свой канал для получения ответов, адресованных ему, сервер, для того чтобы отправить ответы разным клиентам, должен писать в разные каналы. Поскольку файловые дескрипторы — это ограниченный ресурс, сервер открывает клиентский канал для записи только тогда, когда у него есть данные для отправки.</p>     <p>В программном коде открытие клиентского канала, запись в него и закрытие канала разделены на три отдельные функции. Когда вы возвращаете многочисленные результаты поиска, такой подход необходим, для того чтобы можно было открыть канал один раз, записать в него множество ответов и затем снова закрыть канал.</p>     <b>Прокладка каналов</b>     <p>1. Сначала откройте канал клиента.</p>     <p><blockquote>int start_resp_to_client(const message_db_t mess_to_send) {</blockquote></p>     <p><blockquote>#if DEBUG_TRACE</blockquote></p>     <p><blockquote> printf("%d :- start_resp_to_client()\n", getpid());</blockquote></p>     <p><blockquote>#endif</blockquote></p>     <p><blockquote> (void)sprintf(client_pipe_name, CLIENT_PIPE,</blockquote></p>     <p><blockquote>  mess_to_send.client_pid);</blockquote></p>     <p><blockquote> if ((client_fd = open(client_pipe_name, O_WRONLY)) == -1) return(0);</blockquote></p>     <p><blockquote> return(1);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>2. Все сообщения отправляются с помощью данной функции. Соответствующие клиентские функции, которые принимают сообщение, вы увидите позже.</p>     <p><blockquote>int send_resp_to_client(const message_db_t mess_to_send) {</blockquote></p>     <p><blockquote> int write_bytes;</blockquote></p>     <p><blockquote>#if DEBUG_TRACE</blockquote></p>     <p><blockquote> printf("%d :- send_resp_to_client()\n", getpid());</blockquote></p>     <p><blockquote>#endif</blockquote></p>     <p><blockquote> if (client_fd == -1) return(0);</blockquote></p>     <p><blockquote> write_bytes = write(client_fd, &amp;mess_to_send, sizeof(mess_to_send));</blockquote></p>     <p><blockquote> if (write_bytes != sizeof(mess_to_send)) return(0);</blockquote></p>     <p><blockquote> return(1);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>3. В заключение закройте клиентский канал.</p>     <p><blockquote>void end resp_to_client(void) {</blockquote></p>     <p><blockquote>#if DEBUG_TFACE</blockquote></p>     <p><blockquote> printf("%d :- end_resp_to_client()\n", getpid());</blockquote></p>     <p><blockquote>#endif</blockquote></p>     <p><blockquote> if (client_fd != -1) {</blockquote></p>     <p><blockquote>  (void)close(сlient_fd);</blockquote></p>     <p><blockquote>  client_fd = -1;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote>}</blockquote></p>     <b>Функции на стороне клиента</b>     <p>Дополнение к серверу — клиентские функции в файле pipe_imp.c. Они очень похожи на серверные функции за исключением функции с интригующим именем <blockquote>send_mess_to_server</blockquote>.</p>     <b>Клиентские функции</b>     <p>1. После проверки доступности сервера функция <blockquote>client_starting</blockquote> инициализирует канал клиентской стороны.</p>     <p><blockquote>int client_starting(void) {</blockquote></p>     <p><blockquote>#if DEBUG_TFACE</blockquote></p>     <p><blockquote> printf("%d client_starting\n", getpid());</blockquote></p>     <p><blockquote>#endif</blockquote></p>     <p><blockquote> mypid = getpid();</blockquote></p>     <p><blockquote> if ((server_fd = open(SERVER_PIPE, O_WRONLY)) == -1) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Server not running\n");</blockquote></p>     <p><blockquote>  return(0);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> (void)sprintf(client pipe name, CLIENT_PIPE, mypid);</blockquote></p>     <p><blockquote> (void)unlink(client_pipe_name);</blockquote></p>     <p><blockquote> if (mkfifo(client_pipe_name, 0777) == -1) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "Unable to create client pipe %s\n", client_pipe_name);</blockquote></p>     <p><blockquote>  return(0);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return(1);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>2. Функция <blockquote>client_ending</blockquote> закрывает файловые дескрипторы и удаляет ненужный теперь именованный канал.</p>     <p><blockquote>void client_ending(void) {</blockquote></p>     <p><blockquote>#if DEBUG_TRACE</blockquote></p>     <p><blockquote> printf("%d client_ending()\n", getpid());</blockquote></p>     <p><blockquote>#endif</blockquote></p>     <p><blockquote> if (client_write_fd != -1) (void)close(client_write_fd);</blockquote></p>     <p><blockquote> if (client_fd != -1) (void)close(client_fd);</blockquote></p>     <p><blockquote> if (server_fd != -1) (void)close(server_fd);</blockquote></p>     <p><blockquote> (void)unlink(client_pipe_name);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>3. Функция <blockquote>send_mess_to_server</blockquote> передает запрос через канал сервера.</p>     <p><blockquote>int send_mess_to_server(message_db_t mess_to_send) {</blockquote></p>     <p><blockquote> int write_bytes;</blockquote></p>     <p><blockquote>#if DEBUG_TRACE</blockquote></p>     <p><blockquote> printf("%d send_mess_to_server()\n", getpid());</blockquote></p>     <p><blockquote>#endif</blockquote></p>     <p><blockquote> if (server_fd == -1) return(0);</blockquote></p>     <p><blockquote> mess_to_send.client_pid = mypid;</blockquote></p>     <p><blockquote> write_bytes = write(server_fd, &amp;mess_to_send, sizeof(mess_to_send));</blockquote></p>     <p><blockquote> if (write_bytes != sizeof(mess_to_send)) return(0);</blockquote></p>     <p><blockquote> return(1);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Как и в серверных функциях, клиент получает назад результаты от сервера с помощью трех функций, обслуживающих множественные результаты поисков.</p>     <b>Получение результатов с сервера</b>     <p>1. Данная клиентская функция запускается для ожидания ответа сервера. Она открывает канал клиента только для чтения и затем повторно открывает файл канала только для записи. Чуть позже в этом разделе вы поймете почему.</p>     <p><blockquote>int start_resp_from_server(void) {</blockquote></p>     <p><blockquote>#if DEBUG_TRACE</blockquote></p>     <p><blockquote> printf("%d :- start_resp_from_server()\n", getpid());</blockquote></p>     <p><blockquote>#endif</blockquote></p>     <p><blockquote> if (client_pipe_name[0] == '\0') return(0);</blockquote></p>     <p><blockquote> if (client_fd != -1) return(1);</blockquote></p>     <p><blockquote> client_fd = open(client_pipe_name, O_RDONLY);</blockquote></p>     <p><blockquote> if (client_fd != -1) {</blockquote></p>     <p><blockquote>  client_write_fd = open(client_pipe_name, O_WRONLY);</blockquote></p>     <p><blockquote>  if (client_write_fd != -1) return(1);</blockquote></p>     <p><blockquote>  (void)close(client_fd);</blockquote></p>     <p><blockquote>  client_fd = -1;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> return(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>2. Далее приведена основная операция <blockquote>read</blockquote>, которая получает с сервера совпадающие элементы базы данных.</p>     <p><blockquote>int read_resp_from_server(message_db_t *rec_ptr) {</blockquote></p>     <p><blockquote> int read_bytes;</blockquote></p>     <p><blockquote> int return_code = 0;</blockquote></p>     <p><blockquote>#if DEBUG_TRACE</blockquote></p>     <p><blockquote> printf("%d :- reader_resp_from_server()\n", getpid());</blockquote></p>     <p><blockquote> #endif</blockquote></p>     <p><blockquote> if (!rec_ptr) return(0);</blockquote></p>     <p><blockquote> if (client_fd = -1) return(0);</blockquote></p>     <p><blockquote> read_bytes = read(client_fd, rec_ptr, sizeof(*rec_ptr));</blockquote></p>     <p><blockquote> if (read_bytes = sizeof(*rec_ptr)) return_code = 1;</blockquote></p>     <p><blockquote> return(return_code);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>3. И в заключение приведена клиентская функция, помечающая конец ответа сервера.</p>     <p><blockquote>void end_resp_from_server(void) {</blockquote></p>     <p><blockquote>#if DEBUG_TRACE</blockquote></p>     <p><blockquote> printf("%d :- end_resp_from_server()\n", getpid());</blockquote></p>     <p><blockquote>#endif</blockquote></p>     <p><blockquote> /* В реализации канала эта функция пустая */</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Второй дополнительный вызов <blockquote>open</blockquote> канала клиента для записи в <blockquote>start_resp_from_server</blockquote></p>     <p><blockquote>client_write_fd = open(client_pipe_name, O_WRONLY);</blockquote></p>     <p>применяется для защиты от ситуации гонок, когда серверу необходимо быстро откликаться на несколько запросов клиента,</p>     <p>Для того чтобы стало понятнее, рассмотрим такую последовательность событий:</p>     <p>1. Клиент пишет запрос к серверу.</p>     <p>2. Сервер читает запрос, открывает канал клиента и отправляет обратно ответ, но приостанавливает выполнение до того, как успеет закрыть канал клиента.</p>     <p>3. Клиент открывает канал для чтения, читает первый ответ и закрывает свой канал.</p>     <p>4. Далее клиент посылает новую команду и открывает клиентский канал для чтения.</p>     <p>5. Сервер возобновляет работу, закрывая свой конец клиентского канала.</p>     <p>К сожалению, в этот момент клиент пытается считать из канала ответ на свой следующий запрос, но <blockquote>read</blockquote> вернет 0 байтов, поскольку ни один процесс не открыл клиентский канал для записи.</p>     <p>Разрешив клиенту открыть канал как для чтения, так и для записи, и устранив тем самым необходимость повторного открытия канала, вы избежите подобной ситуации гонок. Учтите, что клиент никогда не пишет в канал, поэтому нет опасности считывания ошибочных данных.</p>             <a name="metkadoc22"><h1>Резюме, касающееся приложения</h1></a>     <p>Вы разделили приложение, управляющее базой данных компакт-дисков, на клиентскую и серверную части, что позволило разрабатывать независимо пользовательский интерфейс и внутреннюю технологию работы с базой данных. Как видите, четко определенный интерфейс базы данных дает возможность каждому важному элементу приложения наилучшим образом использовать машинные ресурсы. Если пойти чуть дальше, можно было бы заменить реализацию с помощью каналов на сетевой вариант и применить выделенный компьютер для сервера базы данных. В<i> главе 15</i> вы узнаете больше об организации сети.</p>              <a name="metkadoc23"><h1>Резюме </h1></a>    <p>В этой главе вы рассмотрели передачу данных между процессами с помощью каналов. Сначала вы познакомились с неименованными каналами, которые создаются вызовом <blockquote>popen</blockquote> или <blockquote>pipe</blockquote>, и посмотрели, как, применяя канал и вызов <blockquote>dup</blockquote>, можно передать данные из одной программы в стандартный ввод другой. Далее вы перешли к именованным каналам и узнали, как можно передавать данные между несвязанными программами. В заключение вы реализовали простой пример клиент- серверного приложения, используя каналы FIFO для обеспечения не только синхронизации процессов, но и организации двунаправленного потока данных. </p>     <br><br>
<center><div align="center"><a href="index.php.html">Оглавление</a></div></center>




<br>
<script type="text/javascript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="https://www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script><br>

<noindex>
<div align="center">
<center>

<!-- SAPE RTB DIV 600x340 -->
<div id="SRTB_507029"></div>
<!-- SAPE RTB END -->

</center>
</div>
</noindex>

</td>
<td width="240" valign="top">

<br>

<div id="menu3">
<ul>
<li><a href="../../alternativnaja_medicina/index.html"><span>Альтернативная медицина</span></a></li>
<li><a href="../../astronomija_i_kosmos/index.html"><span>Астрономия и Космос</span></a></li>
<li><a href="../../biologija/index.html"><span>Биология</span></a></li>
<li><a href="../../voennaja_istorija/index.html"><span>Военная история</span></a></li>
<li><a href="../../geologija_i_geografija/index.html"><span>Геология и география</span></a></li>
<li><a href="../../gosudarstvo_i_pravo/index.html"><span>Государство и право</span></a></li>
<li><a href="../../delovaja_literatura/index.html"><span>Деловая литература</span></a></li>
<li><a href="../../domashnie_zhivotnye/index.html"><span>Домашние животные</span></a></li>
<li><a href="../../domovodstvo/index.html"><span>Домоводство</span></a></li>
<li><a href="../../zdorove/index.html"><span>Здоровье</span></a></li>
<li><a href="../../istorija/index.html"><span>История</span></a></li>
<li><a href="../index.html"><span>Компьютеры и Интернет</span></a></li>
<li><a href="../../kulinarija/index.html"><span>Кулинария</span></a></li>
<li><a href="../../kulturologija/index.html"><span>Культурология</span></a></li>
<li><a href="../../literaturovedenie/index.html"><span>Литературоведение</span></a></li>
<li><a href="../../matematika/index.html"><span>Математика</span></a></li>
<li><a href="../../medicina/index.html"><span>Медицина</span></a></li>
<li><a href="../../nauchnaja_literatura_prochee/index.html"><span>Науч. литер. - прочее</span></a></li>
<li><a href="../../pedagogika/index.html"><span>Педагогика</span></a></li>
<li><a href="../../politika/index.html"><span>Политика</span></a></li>
<li><a href="../../psihologija/index.html"><span>Психология</span></a></li>
<li><a href="../../religiovedenie/index.html"><span>Религиоведение</span></a></li>
<li><a href="../../sad_i_ogorod/index.html"><span>Сад и огород</span></a></li>
<li><a href="../../samosovershenstvovanie/index.html"><span>Самосовершенствование</span></a></li>
<li><a href="../../sdelai_sam/index.html"><span>Сделай сам</span></a></li>
<li><a href="../../sport/index.html"><span>Спорт</span></a></li>
<li><a href="../../tehnicheskie_nauki/index.html"><span>Технические науки</span></a></li>
<li><a href="../../transport_i_aviacija/index.html"><span>Транспорт и авиация</span></a></li>
<li><a href="../../uchebniki/index.html"><span>Учебники</span></a></li>
<li><a href="../../fizika/index.html"><span>Физика</span></a></li>
<li><a href="../../filosofija/index.html"><span>Философия</span></a></li>
<li><a href="../../himija/index.html"><span>Химия</span></a></li>
<li><a href="../../hobbi_i_remesla/index.html"><span>Хобби и ремесла</span></a></li>
<li><a href="../../shpargalki/index.html"><span>Шпаргалки</span></a></li>
<li><a href="../../yezoterika/index.html"><span>Эзотерика</span></a></li>
<li><a href="../../yurisprudencija/index.html"><span>Юриспруденция</span></a></li>
<li><a href="../../jazykoznanie/index.html"><span>Языкознание</span></a></li>
</ul>
</div>

<br>
<div align="center">
<center>
<noindex>

<!-- SAPE RTB DIV 240x400 -->
<div id="SRTB_507028"></div>
<!-- SAPE RTB END -->

</noindex>
</center>
</div>

</td>
</tr>
<tr>
<td colspan="3" align="center">


<hr>
<a href="../../index.html"><span>Главная</span></a> | 
<a rel="sidebar" href="p17.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a> | 
<a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a> | 
<a href="p17.php.html#" onClick="scroll(0,0); return false" title="наверх">Наверх</a>
</td>
</tr>
<tr>
<td colspan="3" valign="top" align="left">
<br>

 



</td>
</tr>
</table>

<noindex>
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter21717787 = new Ya.Metrika({id:21717787,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="http://mc.yandex.ru/watch/21717787" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

</noindex>
</center>
</div></body>
</html>