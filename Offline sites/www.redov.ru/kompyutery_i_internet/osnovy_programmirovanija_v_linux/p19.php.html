<html>
<head>
<meta http-equiv="Content-Language" content="ru">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<link href="../../0img/style.css" rel="stylesheet" type="text/css" />
<link rel="SHORTCUT ICON" href="http://www.redov.ru/0img/favicon.ico" type="image/x-icon"> 
<title>Глава 15 Сокеты / Основы программирования в Linux</title>
</head>
<body>
<div align="center">
<center>
<table border="0" cellpadding="0" cellspacing="0" width="1260">
<tr>
<td colspan="3" valign="top" align="left" height="100">
<table border="0" cellpadding="0" cellspacing="0" width="1260" height="100">
<tr>
<td valign="middle" align="center" width="350">
<a href="../../index.html"><img src="../../0img/logo.jpg" width="350" height="100" title="Онлайн библиотека redov.ru"/></a>
</td>
<td valign="middle" align="center" width="910">

<noindex>

<!-- SAPE RTB JS -->
<script
    async="async"
    src="http://cdn-rtb.sape.ru/rtb-b/js/393/2/106393.js"
    type="text/javascript">
</script>
<!-- SAPE RTB END -->

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507025"></div>
<!-- SAPE RTB END -->

</noindex>

</td>
</tr>
</table>
</td>
</tr>
<tr>
<td colspan="3" valign="middle" align="left">

<div id="menu">
<ul>
		<li><a href="../../index.html"><span>Главная</span></a></li>
		<li><a rel="sidebar" href="p19.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a></li>
		<li><a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a></li>
		<li><a href="p19.php.html#" onClick="scroll(0,9999999); return false"><span>Вниз</span></a></li>
</ul>
</div>


</td>
</tr>
<tr>
<td width="240" valign="top" align="center">

<br>
<noindex>
<!-- SAPE RTB DIV 160x600 -->
<div id="SRTB_733378"></div>
<!-- SAPE RTB END -->
</noindex>



</td>
<td valign="top" align="left" style="padding-left: 5; padding-right: 5" width="780">
<br>
<noindex>
<div align="center">

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507027"></div>
<!-- SAPE RTB END -->

</div>
</noindex>
<br>



<li><a href="p19.php.html#metkadoc2">     Что такое сокет?     </a></li>
<li><a href="p19.php.html#metkadoc3">     Соединения на базе сокетов     </a></li>
<li><a href="p19.php.html#metkadoc4">      Атрибуты сокета      </a></li>
<li><a href="p19.php.html#metkadoc5">      Создание сокета      </a></li>
<li><a href="p19.php.html#metkadoc6">      Адреса сокетов      </a></li>
<li><a href="p19.php.html#metkadoc7">      Именование сокета      </a></li>
<li><a href="p19.php.html#metkadoc8">      Создание очереди сокетов      </a></li>
<li><a href="p19.php.html#metkadoc9">      Прием запросов на соединение      </a></li>
<li><a href="p19.php.html#metkadoc10">      Запросы соединений      </a></li>
<li><a href="p19.php.html#metkadoc11">      Закрытие сокета      </a></li>
<li><a href="p19.php.html#metkadoc12">      Обмен данными с помощью сокетов      </a></li>
<li><a href="p19.php.html#metkadoc13">      Порядок байтов на компьютере и в сети      </a></li>
<li><a href="p19.php.html#metkadoc14">     Сетевая информация     </a></li>
<li><a href="p19.php.html#metkadoc15">      Интернет-демон (xinetd/inetd)      </a></li>
<li><a href="p19.php.html#metkadoc16">      Параметры сокета      </a></li>
<li><a href="p19.php.html#metkadoc17">     Множественные клиенты     </a></li>
<li><a href="p19.php.html#metkadoc18">      <i>select</i>      </a></li>
<li><a href="p19.php.html#metkadoc19">      Множественные клиенты      </a></li>
<li><a href="p19.php.html#metkadoc20">     Дейтаграммы     </a></li>
<li><a href="p19.php.html#metkadoc21">     Резюме      </a></li>
<a name="metkadoc1"><h1>Глава 15</p>    <p>Сокеты</h1></a>       <p>В этой главе вы познакомитесь с еще одним способом взаимодействия процессов, существенно отличающимся от тех, которые мы обсуждали в<i> главах 13</i> и<i> 14.</i> До настоящего момента все рассматриваемые нами средства основывались на совместно используемых ресурсах одного компьютера. Ресурсы могли быть разными: областью файловой системы, сегментами совместно используемой памяти или очередями сообщений, но использовать их могли только процессы, выполняющиеся на одной машине.</p>    <p>В версию ОС Berkeley UNIX было включено новое средство коммуникации — интерфейс сокетов, — являющееся расширением концепции канала, обсуждавшейся в <i>главе 13.</i> В системах Linux также есть интерфейсы сокетов.</p>    <p>Вы можете применять сокеты во многом так же, как каналы, но они поддерживают взаимодействие в пределах компьютерной сети. Процесс на одной машине может использовать сокеты для взаимосвязи с процессом на другом компьютере, что делает возможным существование клиент-серверных систем, распределенных в сети. Процессы, выполняющиеся на одной машине, также могут применять сокеты.</p>    <p>Кроме того, интерфейс сокетов стал доступен в ОС Windows благодаря общедоступной спецификации Windows Sockets или WinSock. Сервисы сокетов в ОС Windows предоставляются системным файлом Winsock.dll. Стало быть, программы под управлением Windows могут взаимодействовать по сети с компьютерами под управлением Linux и UNIX и наоборот, реализуя, таким образом, клиент-серверные системы. Несмотря на то, что программный интерфейс для WinSock не совпадает полностью с интерфейсом сокетов в UNIX, в основе его лежат те же сокеты.</p>    <p>В одной-единственной главе мы не сможем дать исчерпывающее описание всех многообразных сетевых возможностей Linux, поэтому вы найдете здесь лишь основные программные сетевые интерфейсы, которые позволят вам писать собственные программы, работающие в сети.</p>    <p>Более подробно мы рассмотрим следующие темы:</p>    <p>&#9633; как действует соединение с помощью сокетов;</p>    <p>&#9633; атрибуты сокетов, адреса и обмен информацией;</p>    <p>&#9633; сетевая информация и интернет-демон (inetd/xinetd);</p>    <p>&#9633; клиенты и серверы.</p>          <a name="metkadoc2"><h1>Что такое сокет?</h1></a>    <p>Сокет — это средство связи, позволяющее разрабатывать клиент-серверные системы для локального, на одной машине, или сетевого использования. Функции ОС Linux, такие как вывод, подключение к базам данных и обслуживание Web-страниц, равно как и сетевые утилиты, например <blockquote>rlogin</blockquote>, предназначенная для удаленной регистрации, и <blockquote>ftp</blockquote>, применяемая для передачи файлов, обычно используют сокеты для обмена данными.</p>    <p>Сокеты создаются и используются не так, как каналы, потому что они подчеркивают явное отличие между клиентом и сервером. Механизм сокетов позволяет создавать множество клиентов, присоединенных к единственному серверу.</p>          <a name="metkadoc3"><h1>Соединения на базе сокетов</h1></a>         <p>Соединения на базе сокетов можно рассматривать как телефонные звонки в учреждение. Телефонный звонок поступает в организацию, и на него отвечает секретарь приемной, направляющий вызов в соответствующий отдел (серверный процесс) и оттуда к нужному сотруднику (сокет сервера). Каждый входящий телефонный звонок (клиент) направляется к соответствующей конечной точке, и промежуточные операторы могут заниматься последующими телефонными звонками. Прежде чем рассматривать установку соединений с помощью сокетов в системах Linux, нужно понять, как они ведут себя в приложениях сокетов, поддерживающих соединения.</p>     <p>Сначала серверное приложение создает сокет, который как файловый дескриптор представляет собой ресурс, присваиваемый единственному серверному процессу. Сервер создает его с помощью системного вызова <blockquote>socket</blockquote>, и этот сокет не может использоваться совместно с другими процессами.</p>     <p>Далее сервер присваивает сокету имя. Локальные сокеты с заданными именами файлов в файловой системе Linux часто размещаются в каталоге /tmp или /usr/tmp. У сетевых сокетов имя файла будет идентификатором сервиса (номер порта/точка доступа), относящегося к конкретной сети, к которой могут подключаться клиенты. Этот идентификатор, задавая определенный номер порта, соответствующий корректному серверному процессу, позволяет Linux направлять входящие подключения по определенному маршруту. Например, Web-сервер обычно создает сокет для порта 80, идентификатор, зарезервированный для этой цели. Web-обозреватели знают о необходимости применять порт 80 для своих HTTP-подключений к Web- сайтам, которые пользователь хочет читать. Именуется сокет с помощью системного вызова <blockquote>bind</blockquote>. Далее серверный процесс ждет подключения клиента к именованному сокету. Системный вызов <blockquote>listen</blockquote> формирует очередь входящих подключений. Сервер может принять их с помощью системного вызова <blockquote>accept</blockquote>.</p>     <p>Когда сервер вызывает <blockquote>accept</blockquote>, создается новый сокет, отличающийся от именованного сокета. Этот новый сокет применяется только для взаимодействия с данным конкретным клиентом. Именованный сокет сохраняется для дальнейших подключений других клиентов. Если сервер написан корректно, он может извлечь выгоду из многочисленных подключений. Web-сервер добивается этого за счет одновременного предоставления страниц многих клиентам. В случае простого сервера все последующие клиенты ждут в очереди до тех пор, пока сервер не будет готов снова.</p>     <p>Клиентская сторона системы с применением сокетов гораздо проще. Клиент создает неименованный сокет с помощью вызова <blockquote>socket</blockquote>. Затем он вызывает <blockquote>connect</blockquote> для подключения к серверу, используя в качестве адреса именованный сокет сервера.</p>     <p>Будучи установлены, сокеты могут применяться как низкоуровневые файловые дескрипторы, обеспечивая двунаправленный обмен данными.</p>     <p>Выполните упражнения 15.1 и 15.2.</p>     <b>Упражнение 15.1. Простой локальный клиент</b>     <p>Далее приведен пример очень простой клиентской программы client1.с. В ней неименованный сокет создается и затем подключается к сокету сервера, названному <blockquote>server_socket</blockquote>. Системный вызов <blockquote>socket</blockquote> мы подробно рассмотрим чуть позже, когда будем обсуждать некоторые проблемы адресации.</p>     <p>1. Включите нужные заголовочные файлы и задайте переменные:</p>     <p><blockquote>#include &lt;sys/types.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/socket.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/un.h&gt;</blockquote></p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int sockfd;</blockquote></p>     <p><blockquote> int len;</blockquote></p>     <p><blockquote> struct sockaddr_un address;</blockquote></p>     <p><blockquote> int result;</blockquote></p>     <p><blockquote> char ch = 'A';</blockquote></p>     <p>2. Создайте сокет для клиента:</p>     <p><blockquote> sockfd = socket(AF_UNIX, SOCK_STREAM, 0);</blockquote></p>     <p>3. Назовите сокет по согласованию с сервером:</p>     <p><blockquote> address.sun_family = AF_UNIX;</blockquote></p>     <p><blockquote> strcpy(address.sun_path, "server_socket");</blockquote></p>     <p><blockquote> len = sizeof(address);</blockquote></p>     <p>4. Соедините ваш сокет с сокетом сервера:</p>     <p><blockquote> result = connect(sockfd, (struct sockaddr *)&amp;address, len);</blockquote></p>     <p><blockquote> if (result == -1) {</blockquote></p>     <p><blockquote>  perror("oops : client1");</blockquote></p>     <p><blockquote>  exit(1);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p>5. Теперь вы можете читать и писать через <blockquote>sockfd</blockquote>:</p>     <p><blockquote> write(sockfd, &amp;ch, 1);</blockquote></p>     <p><blockquote> read(sockfd, &amp;ch, 1);</blockquote></p>     <p><blockquote> printf("char from server = %c\n", ch);</blockquote></p>     <p><blockquote> close(sockfd);</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Эта программа завершится аварийно, если вы попытаетесь выполнить ее, потому что еще не создан именованный сокет сервера, (Точное сообщение об ошибке может отличаться в разных системах.)</p>     <p><blockquote>$ <b>./client1</b></blockquote></p>     <p><blockquote>oops: client1: No such file or directory</blockquote></p>     <p><blockquote>$</blockquote></p>     <b>Упражнение 15.2. Простой локальный сервер</b>     <p>Далее приведена программа простого сервера server1.с, которая принимает запрос на соединение от клиента. Она создает сокет сервера, присваивает ему имя, создает очередь ожидания и принимает запросы на соединения.</p>     <p>1. Включите необходимые заголовочные файлы и задайте переменные:</p>     <p><blockquote>#include &lt;sys/types.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/socket.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/un.h&gt;</blockquote></p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int server_sockfd, client_sockfd;</blockquote></p>     <p><blockquote> int server_len, client_len;</blockquote></p>     <p><blockquote> struct sockaddr_un server_address;</blockquote></p>     <p><blockquote> struct sockaddr_un client_address;</blockquote></p>     <p>2. Удалите все старые сокеты и создайте неименованный сокет для сервера:</p>     <p><blockquote> unlink("server_socket"); </blockquote></p>     <p><blockquote> server_sockfd = socket(AF_UNIX, SOCK_STREAM, 0); </blockquote></p>     <p>3. Присвойте имя сокету:</p>     <p><blockquote> server_address.sun_family = AF_UNIX;</blockquote></p>     <p><blockquote> strcpy(server_address.sun_path, "server_socket");</blockquote></p>     <p><blockquote> server_len = sizeof(server_address);</blockquote></p>     <p><blockquote> bind(server_sockfd, (struct sockaddr *)&amp;server_address, server_len);</blockquote></p>     <p>4. Создайте очередь запросов на соединение и ждите запроса клиента:</p>     <p><blockquote> listen(server_sockfd, 5);</blockquote></p>     <p><blockquote> while(1) {</blockquote></p>     <p><blockquote>  char ch;</blockquote></p>     <p><blockquote>  printf("server waiting\n");</blockquote></p>     <p>5. Примите запрос на соединение:</p>     <p><blockquote>  client_len = sizeof(client_address);</blockquote></p>     <p><blockquote>  client_sockfd = accept(server_sockfd,</blockquote></p>     <p><blockquote>   (struct sockaddr *)&amp;client_address, &amp;client_len);</blockquote></p>     <p>6. Читайте и записывайте данные клиента с помощью <blockquote>client_sockfd</blockquote>:</p>     <p><blockquote>  read(client_sockfd, &amp;ch, 1);</blockquote></p>     <p><blockquote>  ch++;</blockquote></p>     <p><blockquote>  write(client_sockfd, &amp;ch, 1);</blockquote></p>     <p><blockquote>  close(client_sockfd);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote>}</blockquote></p>     <p><b>Как это работает</b></p>     <p>В этом примере серверная программа в каждый момент времени может обслуживать только одного клиента. Она просто читает символ, поступивший от клиента, увеличивает его и записывает обратно. В более сложных системах, где сервер должен выполнять больше работы по поручению клиента, такой подход будет неприемлемым, потому что другие клиенты не смогут подключиться до тех пор, пока сервер не завершит работу. Позже вы увидите пару методов, позволяющих подключаться многочисленным клиентам.</p>     <p>Когда вы выполняете серверную программу, она создает сокет и ждет запросов на соединение. Если вы запустите ее в фоновом режиме, т.е. она будет выполняться независимо, вы сможете затем запускать клиентов как высокоприоритетные задачи.</p>     <p><blockquote>$ <b>./server1 &amp;</b></blockquote></p>     <p><blockquote>[1] 1094</blockquote></p>     <p><blockquote>$ server waiting</blockquote></p>     <p>Ожидая запросы на соединения, сервер выводит сообщение. В приведенном примере сервер ждет запрос с сокета файловой системы, и вы сможете увидеть его с помощью обычной команды <blockquote>ls</blockquote>.</p>     <p>Хорошо взять за правило удалять сокет после окончания работы с ним, даже в случае аварийного завершения программы из-за получения сигнала. Это убережет файловую систему от загромождения неиспользуемыми файлами.</p>     <p><blockquote>$ <b>ls -lF server socket</b></blockquote></p>     <p><blockquote>srwxr-xr-x 1 neil users 0 2007-06-23 11:41 server_socket=</blockquote></p>     <p>Здесь тип устройства — сокет, на что указывает символ <blockquote>s</blockquote> перед правами доступа и символ <blockquote>=</blockquote> в конце имени. Сокет был создан как обычный файл с правами доступа, модифицированными текущей <blockquote>umask</blockquote>. Если применить команду <blockquote>ps</blockquote>, то можно увидеть сервер, выполняющийся в фоновом режиме. Он показан спящим (параметр <blockquote>STAT</blockquote> равен <blockquote>s</blockquote>) и, следовательно, не потребляющим ресурсы ЦП.</p>     <p><blockquote>$ <b>ps lх</b></blockquote></p>     <p><blockquote>F  UID   PID  PPID PRI NI  VSZ RSS WCHAN  STAT TTY   TIME COMMAND</blockquote></p>     <p><blockquote>0 1000 23385 10689  17  0 1424 312 361800 S    pts/1 0:00 ./server1</blockquote></p>     <p>Теперь, когда вы запустите программу, то успешно подключитесь к серверу. Поскольку сокет сервера существует, вы можете соединиться с ним и обмениваться данными.</p>     <p><blockquote>$ <b>./client1</b></blockquote></p>     <p><blockquote>server waiting char from server = В</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>На терминале вывод сервера и клиента перемешаны, но можно увидеть, что сервер получил символ от клиента, увеличил его и вернул. Далее сервер продолжает выполняться и ждет следующего клиента. Если вы запустите несколько клиентов вместе, они будут обслуживаться по очереди, хотя полученный вывод может оказаться еще более перемешанным.</p>     <p><blockquote>$ <b>./client1 &amp; ./client1 &amp; ./client1 &amp;</b></blockquote></p>     <p><blockquote>[2] 23412</blockquote></p>     <p><blockquote>[3] 23413</blockquote></p>     <p><blockquote>[4] 23414</blockquote></p>     <p><blockquote>server waiting</blockquote></p>     <p><blockquote>char from server = В</blockquote></p>     <p><blockquote>server waiting</blockquote></p>     <p><blockquote>char from server = В</blockquote></p>     <p><blockquote>server waiting</blockquote></p>     <p><blockquote>char from server = В</blockquote></p>     <p><blockquote>server waiting</blockquote></p>     <p><blockquote>[2]  Done client1</blockquote></p>     <p><blockquote>[3]- Done client1</blockquote></p>     <p><blockquote>[4]+ Done client1</blockquote></p>     <p><blockquote>$</blockquote></p>             <a name="metkadoc4"><h1>Атрибуты сокета</h1></a>     <p>Для того чтобы до конца понять системные вызовы, применявшиеся в рассмотренном примере, необходимо узнать кое-что об организации сети в системах UNIX.</p>     <p>Сокеты характеризуются тремя атрибутами:<i> доменом, типом</i> и<i> протоколом.</i> У них также есть адрес, используемый как имя сокета. Форматы адресов меняются в зависимости от домена, также называемого семейством протоколов (protocol family). Каждое семейство протоколов может применять одно или несколько семейств адресов, определяющих формат адреса.</p>     <b>Домены сокетов</b>     <p>Домены задают сетевую рабочую среду, которую будет использовать соединение сокетов. Самый популярный домен сокетов — <blockquote>AF_INET</blockquote>, ссылающийся на сеть Интернет и применяемый во многих локальных сетях Linux и, конечно, в самом Интернете. Низкоуровневый протокол Internet Protocol (IP), у которого только одно адресное семейство, накладывает определенный способ задания компьютеров, входящих в сеть. Он называется <i>IP-адресом.</i></p>     <blockquote>      <b>Примечание</b>      <p>Для преодоления некоторых проблем стандартного протокола IP существенно ограниченного количества доступных адресов был разработан интернет-протокол нового поколения IPv6. Он использует другой домен сокетов <blockquote>AF_INET6</blockquote> и иной формат адресов. Ожидается, что со временем IPv6 заменит IP, но для этого потребуется много лет. Несмотря на то, что уже есть реализации IPv6 для Linux, их обсуждение выходит за рамки этой книги.</p>     </blockquote>     <p>Несмотря на то, что у машин в Интернете почти всегда есть имена, их преобразуют в IP-адреса. Пример IP-адреса — 192.168.1.99. Все IP-адреса представлены четырьмя числами, каждое из которых меньше 256, и образуют так называемые<i> четверки с точками.</i> Когда клиент подключается по сети с помощью сокетов, ему нужен IP- адрес компьютера сервера.</p>     <p>На компьютере сервера может быть доступно несколько сервисов. Клиент может обратиться к конкретному сервису на компьютере, включенном в сеть, с помощью IP-порта. Внутри системы порт идентифицируется уникальным 16-разрядным целым числом, а за пределами системы — комбинацией IP-адреса и номера порта. Сокеты — это коммуникационные конечные точки, которые должны быть связаны с портами, прежде чем передача данных станет возможна.</p>     <p>Серверы ожидают запросов на соединения от определенных клиентов. У хорошо известных сервисов есть выделенные номера портов, которые используются всеми машинами под управлением ОС Linux и UNIX. Обычно, но не всегда, эти номера меньше 1024. Примерами могут служить буфер печати принтера (515), <blockquote>rlogin</blockquote> (513), <blockquote>ftp</blockquote> (21) и <blockquote>httpd</blockquote> (80). Последний из названных — стандартный порт для Web-серверов. Обычно номера портов, меньшие 1024, зарезервированы для системных сервисов и могут обслуживаться процессами с правами суперпользователя. Стандарт X/Open определяет в заголовочном файле netdb.h константу <blockquote>IPPORT_RESERVED</blockquote> для указания наибольшего номера зарезервированных портов.</p>     <p>Поскольку для стандартных сервисов есть стандартный набор номеров портов, компьютеры могут легко соединяться друг с другом, не угадывая правильный номер порта. Локальный сервисы могут применять адреса нестандартных портов.</p>     <p>Домен в первом упражнении, <blockquote>AF_UNIX</blockquote>, — это домен файловой системы UNIX, который может использоваться сокетами, находящимися на единственном компьютере, возможно, даже не входящем в сеть. Если это так, то низкоуровневый протокол — это файловый ввод/вывод, а адреса — имена файлов. Для сокета сервера применялся адрес <blockquote>server_socket</blockquote>, который, как вы видели, появлялся в текущем каталоге, когда вы выполняли серверное приложение.</p>     <p>Кроме того, могут применяться и другие домены: <blockquote>AF_ISO</blockquote> для сетей на основе стандартных протоколов ISO и <blockquote>AF_XNS</blockquote> для Xerox Network System (сетевая система Xerox). В этой книге мы их не будем обсуждать.</p>     <b>Типы сокетов</b>     <p>У домена сокетов может быть несколько способов обмена данными, у каждого из которых могут быть разные характеристики. В случае сокетов домена <blockquote>AF_UNIX</blockquote> проблемы не возникают, т.к, они обеспечивают надежный двунаправленный обмен данными. В сетевых доменах необходимо знать характеристики базовой сети и их влияние на различные механизмы передачи данных.</p>     <p>Интернет-протоколы предоставляют два механизма передачи данных с разными уровнями обслуживания:<i> потоки</i> и<i> дейтаграммы.</i></p>     <b>Потоковые сокеты</b>     <p>Потоковые сокеты (в чем-то подобные стандартным потокам ввода/вывода) обеспечивают соединение, представляющее собой последовательный и надежный двунаправленный поток байтов. Следовательно, гарантируется, что без указания возникшей ошибки данные не будут потеряны, продублированы или переупорядочены. Сообщения большого объема фрагментируются, передаются и снова собираются воедино. Это напоминает файловый поток, который принимает большие объемы данных и делит их на меньшие блоки для записи на физический диск. У потоковых сокетов предсказуемое поведение.</p>     <p>Потоковые сокеты, описываемые типом <blockquote>SOCK_STREAM</blockquote>, реализованы в домене <blockquote>AF_INET</blockquote> соединениями на базе протоколов TCP/IP. Кроме того, это обычный тип сокетов и в домене <blockquote>AF_UNIX</blockquote>. В этой главе мы сосредоточимся на сокетах типа <blockquote>SOCK_STREAM</blockquote>, поскольку они чаще всего применяются при программировании сетевых приложений.</p>     <blockquote>      <b>Примечание</b>      <p>TCP/IP — сокращение для протоколов Transmission Control Protocol/Internet Protocol. Протокол IP — низкоуровневый протокол передачи пакетов, обеспечивающий выбор маршрута при пересылке данных в сети от одного компьютера к другому. Протокол TCP обеспечивает упорядочивание, управление потоком и ретрансляцию, гарантирующие полную и корректную передачу больших объемов данных или же сообщение о соответствующей ошибочной ситуации.</p>     </blockquote>     <b>Дейтаграммные сокеты</b>     <p>В отличие от потоковых дейтаграммные сокеты, описываемые типом <blockquote>SOCK_DGRAM</blockquote>, не устанавливают и не поддерживают соединение. Кроме того, существует ограничение для размера дейтаграммы, которая может отправляться. Она передается как единое сетевое сообщение, которое может быть потеряно, продублировано или прибыть несвоевременно, т.е. перед дейтаграммами, посланными после нее.</p>     <p>Дейтаграммные сокеты реализованы в домене <blockquote>AF_INET</blockquote> с помощью соединений UDP/IP и предоставляют неупорядоченный ненадежный сервис. (UDP сокращенное название протокола User Datagram Protocol.) Однако они относительно экономичны с точки зрения расходования ресурсов, поскольку не нуждаются в поддержке сетевых соединений. Они быстры, т.к. не тратится время на установку сетевого соединения.</p>     <p>Дейтаграммы полезны для однократных запросов к информационным сервисам, для предоставления обычных сведений о состоянии или для выполнения низкоприоритетной регистрации данных. Их преимущество в том, что остановка сервера не причинит чрезмерных неудобств клиенту и не потребует перезапуска клиента. Поскольку серверы на базе дейтаграмм обычно сохраняют данные без соединения, их можно останавливать и запускать снова, не мешая их клиентам.</p>     <p>На этом мы закончим обсуждение дейтаграмм, дополнительную информацию см. в <i>разд. "Дейтаграммы" в конце данной главы.</i></p>     <b>Протоколы сокетов</b>     <p>Если низкоуровневый механизм передачи данных позволяет применять несколько протоколов, предоставляющих сокет требуемого типа, можно выбрать конкретный протокол или сокет. В этой главе мы сосредоточимся на сокетах сети UNIX и ее файловой системы, которые не требуют от вас выбора протокола, отличного от заданного по умолчанию.</p>             <a name="metkadoc5"><h1>Создание сокета</h1></a>     <p>Системный вызов socket создает сокет и возвращает дескриптор, который может применяться для доступа к сокету:</p>     <p><blockquote><b>#include &lt;sys/types.h&gt;</b></blockquote></p>     <p><blockquote><b>#include &lt;sys/socket.h&gt;</b></blockquote></p>     <p><blockquote><b>int socket(int domain, int type, int protocol);</b></blockquote></p>     <p>Созданный сокет — это одна конечная точка линии передачи. Параметр <blockquote>domain</blockquote> задает семейство адресов, параметр <blockquote>type</blockquote> определяет тип используемого с этим сокетом обмена данными, a <blockquote>protocol</blockquote> — применяемый протокол.</p>     <p>В табл. 15.1 приведены имена доменов.</p>     <br>     <p><b><i>Таблица 15.1</i></b></p>     <table>      <tr>       <th valign="top">Домен</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>AF_UNIX</blockquote></td>       <td valign="top">Внутренние для UNIX (сокеты файловой системы)</td>      </tr>      <tr>       <td valign="top"><blockquote>AF_INET</blockquote></td>       <td valign="top">Интернет-протоколы ARPA (Advanced Research Projects Agency, управление перспективных исследований и разработок) (сокеты сети UNIX)</td>      </tr>      <tr>       <td valign="top"><blockquote>AF_ISO</blockquote></td>       <td valign="top">Протоколы стандарта ISO (International Standards Organization, Международная организация по стандартизации)</td>      </tr>      <tr>       <td valign="top"><blockquote>AF_NS</blockquote></td>       <td valign="top">Протоколы сетевых систем Xerox</td>      </tr>      <tr>       <td valign="top"><blockquote>AF_IPX</blockquote></td>       <td valign="top">Novell-протокол IPX</td>      </tr>      <tr>       <td valign="top"><blockquote>AF_APPLETALK</blockquote></td>       <td valign="top">Appletalk DDS (Appletalk Digital Data Service)</td>      </tr>     </table>     <p>К наиболее популярным доменам сокетов относятся <blockquote>AF_UNIX</blockquote>, применяемый для локальных сокетов, реализуемых средствами файловых систем UNIX и Linux, и <blockquote>AF_INET</blockquote>, используемый для сетевых сокетов UNIX. Сокеты домена <blockquote>AF_INET</blockquote> могут применяться программами, взаимодействующими в сетях на базе протоколов TCP/IP, включая Интернет. Интерфейс ОС Windows Winsock также предоставляет доступ к этому домену сокетов.</p>     <p>Параметр сокета type задает характеристики обмена данными, применяемые для нового сокета. Возможными значениями могут быть <blockquote>SOCK_STREAM</blockquote> и <blockquote>SOCK_DGRAM</blockquote>.</p>     <p>&#9633; <blockquote>SOCK_STREAM</blockquote> — это упорядоченный, надежный, основанный на соединении, двунаправленный поток байтов. В случае домена сокетов <blockquote>AF_INET</blockquote> этот тип обмена данными по умолчанию обеспечивается TCP-соединением, которое устанавливается между двумя конечными точками потоковых сокетов при подключении. Данные могут передаваться в двух направлениях по линии связи сокетов. Протоколы TCP включают в себя средства фрагментации и последующей повторной сборки сообщений больших объемов и повторной передачи любых их частей, которые могли быть потеряны в сети.</p>     <p>&#9633; <blockquote>SOCK_DGRAM</blockquote> — дейтаграммный сервис. Вы можете использовать такой сокет для отправки сообщений с фиксированным (обычно небольшим) максимальным объемом, но при этом нет гарантии, что сообщение будет доставлено или что сообщения не будут переупорядочены в сети. В случае сокетов домена <blockquote>AF_INET</blockquote> этот тип передачи данных обеспечивается дейтаграммами UDP (User Datagram Protocol, пользовательский протокол дейтаграмм).</p>     <p>Протокол, применяемый для обмена данными, обычно определяется типом сокета и доменом. Как правило, выбора нет. Параметр <blockquote>protocol</blockquote> применяется в тех случаях, когда выбор все же предоставляется. Задание 0 позволяет выбрать стандартный протокол, используемый во всех примерах данной главы.</p>     <p>Системный вызов <blockquote>socket</blockquote> возвращает дескриптор, во многом похожий на низкоуровневый файловый дескриптор. Когда сокет подключен к концевой точке другого сокета, для отправки и получения данных с помощью сокетов можно применять системные вызовы <blockquote>read</blockquote> и <blockquote>write</blockquote> с дескриптором сокета. Системный вызов <blockquote>close</blockquote> используется для удаления сокетного соединения.</p>             <a name="metkadoc6"><h1>Адреса сокетов</h1></a>     <p>Каждый домен сокетов требует своего формата адресов. В домене <blockquote>AF_UNIX</blockquote> адрес описывается структурой <blockquote>sockaddr_un</blockquote>, объявленной в заголовочном файле sys/un.h: </p>     <p><blockquote><b>struct sockaddr_un {</b></blockquote></p>     <p><blockquote><b> sa_family_t sun_family; /* AF_UNIX */</b></blockquote></p>     <p><blockquote><b> char sun_path[];        /* Путь к файлу */</b></blockquote></p>     <p><blockquote><b>};</b></blockquote></p>     <p>Для того чтобы адреса разных типов могли передаваться в системные вызовы для обработки сокетов, все адресные форматы описываются похожей структурой, которая начинается с поля (в данном случае <blockquote>sun_family</blockquote>), задающего тип адреса (домен сокета). В домене <blockquote>AF_UNIX</blockquote> адрес задается именем файла в поле структуры <blockquote>sun_path</blockquote>.</p>     <p>В современных системах Linux тип <blockquote>sa_family_t</blockquote>, описанный в стандарте X/Open как объявляемый в заголовочном файле sys/un.h, интерпретируется как тип <blockquote>short</blockquote>. Кроме того, размер <blockquote>pathname</blockquote>, задаваемого в поле <blockquote>sun_path</blockquote>, ограничен (в Linux указывается 108 символов; в других системах может применяться именованная константа, например, <blockquote>UNIX_MAX_PATH</blockquote>). Поскольку размер адресной структуры может меняться, многие системные вызовы сокетов требуют или предоставляют на выходе длину, которая будет использоваться для копирования конкретной адресной структуры.</p>     <p>В домене <blockquote>AF_INET</blockquote> адрес задается с помощью структуры с именем <blockquote>sockaddr_in</blockquote>, определенной в файле netinet/in.h, которая содержит как минимум следующие элементы:</p>     <p><blockquote><b>struct sockaddr_in {</b></blockquote></p>     <p><blockquote><b> short int sin_family;        /* AF_INET */</b></blockquote></p>     <p><blockquote><b> unsigned short int sin_port; /* Номер порта */</b></blockquote></p>     <p><blockquote><b> struct in_addr sin_addr;     /* Интернет-адрес */</b></blockquote></p>     <p><blockquote><b>};</b></blockquote></p>     <p>Структура IP-адреса типа in_addr определена следующим образом:</p>     <p><blockquote><b>struct in_addr {</b></blockquote></p>     <p><blockquote><b> unsigned long int s_addr;</b></blockquote></p>     <p><blockquote><b>};</b></blockquote></p>     <p>Четыре байта IP-адреса образуют одно 32-разрядное значение. Сокет домена <blockquote>AF_INET</blockquote> полностью описывается IP-адресом и номером порта. С точки зрения приложения все сокеты действуют как файловые дескрипторы, и их адреса задаются уникальными целочисленными значениями.</p>             <a name="metkadoc7"><h1>Именование сокета</h1></a>     <p>Для того чтобы сделать сокет (созданный с помощью вызова <blockquote>socket</blockquote>) доступным для других процессов, серверная программа должна присвоить сокету имя. Сокеты домена <blockquote>AF_UNIX</blockquote> связаны с полным именем файла в файловой системе, как вы видели в программе-примере server1. Сокеты домена <blockquote>AF_INET</blockquote> связаны с номером IP-порта.</p>     <p><blockquote><b>#include &lt;sys/socket.h&gt;</b></blockquote></p>     <p><blockquote><b>int bind(int socket, const struct sockaddr *address, size_t address len);</b></blockquote></p>     <p>Системный вызов <blockquote>bind</blockquote> присваивает адрес, заданный в параметре <blockquote>address</blockquote>, неименованному сокету, связанному с дескриптором сокета <blockquote>socket</blockquote>. Длина адресной структуры передается в параметре <blockquote>address_len</blockquote>:</p>     <p>Длина и формат адреса зависят от адресного семейства. В системном вызове <blockquote>bind</blockquote> указатель конкретной адресной структуры должен быть приведен к обобщенному адресному типу <blockquote>(struct sockaddr*)</blockquote>.</p>     <p>В случае успешного завершения <blockquote>bind</blockquote> возвращает 0. Если он завершается аварийно, возвращается -1, и переменной <blockquote>errno</blockquote> присваивается одно из значений, перечисленных в табл. 15.2.</p>     <br>     <p><b><i>Таблица 15.2</i></b></p>     <table>      <tr>       <th valign="top">Значение <blockquote>errno</blockquote></th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>EBADF</blockquote></td>       <td valign="top">Неверный файловый дескриптор</td>      </tr>      <tr>       <td valign="top"><blockquote>ENOTSOCK</blockquote></td>       <td valign="top">Файловый дескриптор не ссылается на сокет</td>      </tr>      <tr>       <td valign="top"><blockquote>EINVAL</blockquote></td>       <td valign="top">Файловый дескриптор ссылается на сокет, уже получивший имя</td>      </tr>      <tr>       <td valign="top"><blockquote>EADDRNOTAVAIL</blockquote></td>       <td valign="top">Недопустимый адрес</td>      </tr>      <tr>       <td valign="top"><blockquote>EADDINUSE</blockquote></td>       <td valign="top">У адреса уже есть связанный с ним сокет</td>      </tr>      <tr>       <td colspan="2" valign="top">Для сокетов домена <blockquote>AF_UNIX</blockquote> есть несколько дополнительных значений</td>      </tr>      <tr>       <td valign="top"><blockquote>EACCESS</blockquote></td>       <td valign="top">Невозможно создать имя в файловой системе из-за прав доступа</td>      </tr>      <tr>       <td valign="top"><blockquote>ENOTDIR</blockquote>, <blockquote>ENAMETOOLONG</blockquote></td>       <td valign="top">Означает недопустимое имя файла</td>      </tr>     </table>             <a name="metkadoc8"><h1>Создание очереди сокетов</h1></a>     <p>Для приема запросов на входящие соединения на базе сокетов серверная программа должна создать очередь для хранения ждущих обработки запросов. Формируется она с помощью системного вызова <blockquote>listen</blockquote>.</p>     <p><blockquote><b>#include &lt;sys/socket.h&gt;</b></blockquote></p>     <p><blockquote><b>int listen(int socket, int backlog);</b></blockquote></p>     <p>Система Linux может ограничить количество ждущих обработки соединений, которые могут храниться в очереди. В соответствии с этим максимумом вызов <blockquote>listen</blockquote> задает длину очереди, равной <blockquote>backlog</blockquote>. Входящие соединения, не превышающие максимальной длины очереди, сохраняются в ожидании сокета; последующим запросам на соединение будет отказано, и клиентская попытка соединения завершится аварийно. Этот механизм реализуется вызовом <blockquote>listen</blockquote> для того, чтобы можно было сохранить ждущие соединения запросы, пока серверная программа занята обработкой запроса предыдущего клиента. Очень часто параметр <blockquote>backlog</blockquote> равен 5.</p>     <p>Функция <blockquote>listen</blockquote> вернет 0 в случае успешного завершения и -1 в случае ошибки. Как и для системного вызова <blockquote>bind</blockquote>, ошибки могут обозначаться константами <blockquote>EBADF</blockquote>, <blockquote>EINVAL</blockquote> И <blockquote>ENOTSOCK</blockquote>.</p>             <a name="metkadoc9"><h1>Прием запросов на соединение</h1></a>     <p>После создания и именования сокета серверная программа может ждать запросы на выполнение соединения с сокетом с помощью системного вызова <blockquote>accept</blockquote>:</p>     <p><blockquote><b>#include &lt;sys/socket.h&gt;</b></blockquote></p>     <p><blockquote><b>int accept(int socket, struct sockaddr *address, size_t *address_len);</b></blockquote></p>     <p>Системный вызов <blockquote>accept</blockquote> возвращает управление, когда клиентская программа пытается подключиться к сокету, заданному в параметре <blockquote>socket</blockquote>. Этот клиент — первый из ждущих соединения в очереди данного сокета. Функция <blockquote>accept</blockquote> создает новый сокет для обмена данными с клиентом и возвращает его дескриптор. У нового сокета будет тот же тип, что и у сокета сервера, ждущего запросы на соединения.</p>     <p>Предварительно сокету должно быть присвоено имя с помощью системного вызова <blockquote>bind</blockquote> и у него должна быть очередь запросов на соединение, место для которой выделил системный вызов <blockquote>listen</blockquote>. Адрес вызывающего клиента будет помещен в структуру <blockquote>sockaddr</blockquote>, на которую указывает параметр <blockquote>address</blockquote>. Если адрес клиента не представляет интереса, в этом параметре может задать пустой указатель.</p>     <p>Параметр <blockquote>address_len</blockquote> задает длину адресной структуры клиента. Если адрес клиента длиннее, чем это значение, он будет урезан. Перед вызовом <blockquote>accept</blockquote> в параметре <blockquote>address_len</blockquote> должна быть задана ожидаемая длина адреса. По возвращении из вызова в <blockquote>address_len</blockquote> будет установлена реальная длина адресной структуры запрашивающего соединение клиента.</p>     <p>Если нет запросов на соединение, ждущих в очереди сокета, вызов accept будет заблокирован (так что программа не сможет продолжить выполнение) до тех пор, пока клиент не сделает запрос на соединение. Вы можете изменить это поведение, применив флаг <blockquote>O_NONBLOCK</blockquote> в файловом дескрипторе сокета с помощью вызова <blockquote>fcntl</blockquote> в вашей программе следующим образом:</p>     <p><blockquote>int flags = fcntl(socket, F_GETFL, 0);</blockquote></p>     <p><blockquote>fcntl(socket, F_SETFL, O_NONBLOCK | flags);</blockquote></p>     <p>Функция <blockquote>accept</blockquote> возвращает файловый дескриптор нового сокета, если есть запрос клиента, ожидающего соединения, и -1 в случае ошибки. Возможные значения ошибок такие же, как у вызовов <blockquote>bind</blockquote> и <blockquote>listen</blockquote> плюс дополнительная константа <blockquote>EWOULDBLOCK</blockquote> в случае, когда задан флаг <blockquote>O_NONBLOCK</blockquote> и нет ждущих запросов на соединение. Ошибка <blockquote>EINTR</blockquote> возникнет, если процесс прерван во время блокировки в функции <blockquote>accept</blockquote>.</p>             <a name="metkadoc10"><h1>Запросы соединений</h1></a>     <p>Клиентские программы подключаются к серверам, устанавливая соединение между неименованным сокетом и сокетом сервера, ждущим подключений. Делают они это с помощью вызова <blockquote>connect</blockquote>:</p>     <p><blockquote><b>#include &lt;sys/socket.h&gt;</b></blockquote></p>     <p><blockquote><b>int connect(int socket, const struct sockaddr *address, size_t address_len);</b></blockquote></p>     <p>Сокет, заданный в параметре <blockquote>socket</blockquote>, соединяется с сокетом сервера, заданным в параметре <blockquote>address</blockquote>, длина которого равна <blockquote>address_len</blockquote>. Сокет должен задаваться корректным файловым дескриптором, полученным из системного вызова <blockquote>socket</blockquote>.</p>     <p>Если функция <blockquote>connect</blockquote> завершается успешно, она возвращает 0, в случае ошибки вернется -1. Возможные ошибки на этот раз включают значения, перечисленные в табл. 15.3.</p>     <br>     <p><b><i>Таблица 15.3</i></b></p>     <table>      <tr>       <th valign="top">Значение <blockquote>errno</blockquote></th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>EBADF</blockquote></td>       <td valign="top">В параметре <blockquote>socket</blockquote> задан неверный файловый дескриптор</td>      </tr>      <tr>       <td valign="top"><blockquote>EALREADY</blockquote></td>       <td valign="top">Для этого сокета соединение уже обрабатывается</td>      </tr>      <tr>       <td valign="top"><blockquote>ETIMEDOUT</blockquote></td>       <td valign="top">Допустимое время ожидания соединения превышено</td>      </tr>      <tr>       <td valign="top"><blockquote>ECONNREFUSED</blockquote></td>       <td valign="top">Запрос на соединение отвергнут сервером</td>      </tr>     </table>     <p>Если соединение не может быть установлено немедленно, вызов <blockquote>connect</blockquote> будет заблокирован на неопределенный период ожидания. Когда допустимое время ожидания будет превышено, соединение разорвется и вызов <blockquote>connect</blockquote> завершится аварийно. Однако, если вызов прерван сигналом, который обрабатывается, connect завершится аварийно (со значением errno, равным <blockquote>EINTR</blockquote>), но попытка соединения не будет прервана — соединение будет установлено асинхронно и программа должна будет позже проверить, успешно ли оно установлено.</p>     <p>Как и в случае вызова <blockquote>accept</blockquote>, возможность блокировки в вызове <blockquote>connect</blockquote> можно исключить установкой в файловом дескрипторе флага <blockquote>O_NONBLOCK</blockquote>. В этом случае, если соединение не может быть установлено немедленно, вызов <blockquote>connect</blockquote> завершится аварийно с переменной <blockquote>errno</blockquote>, равной <blockquote>EINPROGRESS</blockquote>, и соединение будет выполнено асинхронно.</p>     <p>Хотя асинхронные соединения трудно обрабатывать, вы можете применить вызов <blockquote>select</blockquote> к файловому дескриптору сокета, чтобы убедиться в том, что сокет готов к записи. Мы обсудим вызов <blockquote>select</blockquote> чуть позже в этой главе.</p>             <a name="metkadoc11"><h1>Закрытие сокета</h1></a>     <p>Вы можете разорвать сокетное соединение в серверной или клиентской программах, вызвав функцию <blockquote>close</blockquote>, так же как в случае низкоуровневых файловых дескрипторов. Сокеты следует закрывать на обоих концах. На сервере это нужно делать, когда <blockquote>read</blockquote> вернет ноль. Имейте в виду, что вызов <blockquote>close</blockquote> может быть заблокирован, если сокет, у которого есть непереданные данные, обладает типом, ориентированным на соединение, и установленным параметром <blockquote>SOCK_LINGER</blockquote>. Дополнительную информацию об установке параметров сокета вы узнаете позже в этой главе.</p>             <a name="metkadoc12"><h1>Обмен данными с помощью сокетов</h1></a>     <p>Теперь, когда мы описали основные системные вызовы, связанные с сокетами, давайте повнимательнее рассмотрим программы-примеры. Вы попытаетесь переработать их, заменив сокет файловой системы сетевым сокетом. Недостаток сокета файловой системы состоит в том, что если автор не использует полное имя файла, он создается в текущем каталоге серверной программы. Для того чтобы сделать его полезным в большинстве случаев, следует создать сокет в общедоступном каталоге (например, /tmp), подходящем для сервера и его клиентов. В случае сетевых серверов достаточно выбрать неиспользуемый номер порта.</p>     <p>Для примера выберите номер порта 9734. Это произвольный выбор, позволяющий избежать использования портов стандартных сервисов (вы не должны применять номера портов, меньшие 1024, поскольку они зарезервированы для системного использования). Другие номера портов с обеспечиваемыми ими сервисами часто приводятся в системном файле /etc/services. При написании программ, использующих сокеты, всегда выбирайте номер порта, которого нет в этом файле конфигурации.</p>     <blockquote>      <b>Примечание</b>      <p>Вам следует знать, что в программах client2.c и server2.c умышленно допущена ошибка, которую вы устраните в программах client3.c и server3.c. Пожалуйста, не используйте текст примеров client2.c и server2.c в собственных программах.</p>     </blockquote>     <p>Вы будете выполнять ваши серверную и клиентскую программы в локальной сети, но сетевые сокеты полезны не только в локальной сети, любая машина с подключением к Интернету (даже по модемной линии связи) может применять сетевые сокеты для обмена данными с другими компьютерами. Программу, основанную на сетевых подключениях, можно применять даже на изолированном компьютере с ОС UNIX, т. к. такой компьютер обычно настроен на использование виртуальной сети или внутренней петли (loopback network), включающей только его самого. Для демонстрационных целей данный пример использует виртуальную сеть, которая может быть также полезна для отладки сетевых приложений, поскольку она устраняет любые внешние сетевые проблемы.</p>     <p>Виртуальная сеть состоит из единственного компьютера, традиционно именуемого <blockquote>localhost</blockquote>, со стандартным IP-адресом 127.0.0.1. Это локальная машина. Ее адрес вы сможете найти в файле сетевых узлов etc/hosts наряду с именами и адресами других узлов, входящих в совместно используемые сети.</p>     <p>У каждой сети, с которой компьютер обменивается данными, есть связанный с ней аппаратный интерфейс. У компьютера в каждой сети может быть свое имя и конечно будут разные IP-адреса. Например, у машины Нейла с именем tilde три сетевых интерфейса и, следовательно, три адреса. Они записаны в файле /etc/hosts следующим образом.</p>     <p><blockquote>127.0.0.1    localhost         # Петля</blockquote></p>     <p><blockquote>192.168.1.1  tilde.localnet    # Локальная частная сеть Ethernet</blockquote></p>     <p><blockquote>158.152.X.X  tilde.demon.co.uk # Модемная линия связи</blockquote></p>     <p>Первая строка — пример виртуальной сети, ко второй сети доступ осуществляется с помощью адаптера Ethernet, а третья — модемная линия связи с провайдером интернет-сервисов. Вы можете написать программу, применяющую сетевые сокеты, для связи с серверами с помощью любого из приведенных интерфейсов без каких-либо корректировок.</p>     <p>Выполните упражнения 15.3 и 15.4.</p>     <b>Упражнение 15.3. Сетевой клиент</b>     <p>Далее приведена измененная программа-клиент client2.c, предназначенная для использования сетевого соединения на базе сокета в виртуальной сети. Она содержит незначительную ошибку, связанную с аппаратной зависимостью, но мы обсудим ее чуть позже в этой главе.</p>     <p>1. Включите необходимые директивы <blockquote>#include</blockquote> и задайте переменные:</p>     <p><blockquote>#include &lt;sys/types.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/socket.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote><i>#include &lt;netinet/in.h&gt;</i></blockquote></p>     <p><blockquote><i>#include &lt;arpa/inet.h&gt;</i></blockquote></p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int sockfd;</blockquote></p>     <p><blockquote> int len;</blockquote></p>     <p><blockquote><i> struct sockaddr_in address;</i></blockquote></p>     <p><blockquote> int result;</blockquote></p>     <p><blockquote> char ch = 'A';</blockquote></p>     <p>2. Создайте сокет клиента:</p>     <p><blockquote><i> sockfd = socket(AF_INET, SOCK_STREAM, 0);</i></blockquote></p>     <p>3. Присвойте имя сокету по согласованию с сервером:</p>     <p><blockquote><i> address.sin_family = AF_INET;</i></blockquote></p>     <p><blockquote><i> address.sin_addr.s_addr = inet_addr("127.0.0.1");</i></blockquote></p>     <p><blockquote><i> address.sin_port = 9734;</i></blockquote></p>     <p><blockquote> len = sizeof(address);</blockquote></p>     <p>Оставшаяся часть программы такая же, как в приведенном ранее в этой главе примере. Когда вы выполните эту версию, она завершится аварийно, потому что на данном компьютере нет сервера, выполняющегося на порте 9734.</p>     <p><blockquote>$ <b>./client2</b></blockquote></p>     <p><blockquote>oops: client2: Connection refused</blockquote></p>     <p><blockquote>$</blockquote></p>     <p><b>Как это работает</b></p>     <p>Клиентская программа использует структуру <blockquote>sockaddr_in</blockquote> из заголовочного файла netinet/in.h для задания адреса <blockquote>AF_INET</blockquote>. Она пытается подключиться к серверу, размещенному на узле с IP-адресом 127.0.0.1. Программа применяет функцию <blockquote>inet_addr</blockquote> для преобразования текстового представления IP-адреса в форму, подходящую для адресации сокетов. На страницах интерактивного справочного руководства для inet вы найдете дополнительную информацию о других функциях, преобразующих адреса.</p>     <b>Упражнение 15.4. Сетевой сервер</b>     <p>Вам также нужно модифицировать серверную программу, ждущую подключений на выбранном вами номере порта. Далее приведена откорректированная программа сервера server2.c.</p>     <p>1. Вставьте необходимые заголовочные файлы и задайте переменные:</p>     <p><blockquote>#include &lt;sys/types.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/socket.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote><i>#include &lt;netinet/in.h&gt;</i></blockquote></p>     <p><blockquote><i>#include &lt;arpa/inet.h&gt;</i></blockquote></p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int server_sockfd, client_sockfd;</blockquote></p>     <p><blockquote> int server_len, client_len;</blockquote></p>     <p><blockquote><i> struct sockaddr_in server_address;</i></blockquote></p>     <p><blockquote><i> struct sockaddr_in client_address;</i></blockquote></p>     <p>2. Создайте неименованный сокет для сервера:</p>     <p><blockquote><i> server_sockfd = socket(AF_INET, SOCK_STREAM, 0);</i></blockquote></p>     <p>3. Дайте имя сокету:</p>     <p><blockquote><i> server_address.sin_family = AF_INET;</i></blockquote></p>     <p><blockquote><i> server_address.sin_port.s_addr = inet_addr("127.0.0.1");</i></blockquote></p>     <p><blockquote><i> server_address.sin_port = 9734;</i></blockquote></p>     <p><blockquote> server_len = sizeof(server_address);</blockquote></p>     <p><blockquote> bind(server_sockfd, (struct sockaddr *)&amp;server_address, server_len);</blockquote></p>     <p>С этой строки и далее текст примера точно совпадает с программным кодом в файле server1.c. Выполнение client2 и server2 продемонстрирует то же поведение, что и при запуске программ client1 и server1.</p>     <p><b>Как это работает</b></p>     <p>Серверная программа создает сокет домена <blockquote>AF_INET</blockquote> и выполняет необходимые действия для приема запросов на подключение к нему. Сокет связывается с выбранным вами портом. Заданный адрес определяет, каким машинам разрешено подсоединяться. Задавая такой же адрес виртуальной сети, как в клиентской программе, вы ограничиваете соединения только локальной машиной.</p>     <p>Если вы хотите разрешить серверу устанавливать соединения с удаленными клиентами, необходимо задать набор IP-адресов, которые разрешены. Можно применить специальное значение <blockquote>INADDR_ANY</blockquote> для того, чтобы показать, что будете принимать запросы на подключение от всех интерфейсов, имеющихся на вашем компьютере. Если необходимо, вы можете разграничить интерфейсы разных сетей, чтобы отделить соединения локальной сети от соединений глобальной сети. Константа <blockquote>INADDR_ANY</blockquote> — 32-разрядное целое число, которое можно использовать в поле <blockquote>sin_addr.s_addr</blockquote> адресной структуры. Но прежде вам нужно решить проблему.</p>             <a name="metkadoc13"><h1>Порядок байтов на компьютере и в сети</h1></a>     <p>Если запустить приведенные версии серверной и клиентской программ на машине на базе процессора Intel под управлением Linux, то с помощью команды <blockquote>netstat</blockquote> можно увидеть сетевые соединения. Эта команда есть в большинство систем UNIX, настроенных на работу в сети. Она отображает клиент-серверное соединение, ожидающее закрытия. Соединение закрывается после небольшой задержки. (Повторяем, что вывод в разных версиях Linux может отличаться.)</p>     <p><blockquote>$ <b>./server2 &amp; ./client2</b></blockquote></p>     <p><blockquote>[3] 23770</blockquote></p>     <p><blockquote>server waiting</blockquote></p>     <p><blockquote>server waiting</blockquote></p>     <p><blockquote>char from server = В</blockquote></p>     <p><blockquote>$ <b>netstat -A inet</b></blockquote></p>     <p><blockquote>Active Internet connections (w/o servers)</blockquote></p>     <p><blockquote>Proto Recv-Q Send-Q Local Address  Foreign Address (State)   User</blockquote></p>     <p><blockquote>tcp        1      0 localhost:1574 localhost:1174  TIME_WAIT root</blockquote></p>     <blockquote>      <b>Примечание</b>      <p>Прежде чем испытывать последующие примеры этой главы, убедитесь в том, что завершено выполнение серверных программ-примеров, поскольку они будут конкурировать при приеме соединений клиентов, и вы увидите вводящие в заблуждение результаты. Удалить их все (включая те, что будут приведены позже в этой главе) можно с помощью следующей команды:</p>      <p><blockquote>killall server1 server2 server3 server4 server5</blockquote></p>     </blockquote>     <p>Вы сможете увидеть номера портов, присвоенные соединению сервера с клиентом. Локальный адрес отображает сервер, а внешний адрес — удаленного клиента. (Даже если клиент размещен на той же машине, он все равно подключается через сеть.) Для четкого разделения всех сокетов порты клиентов обычно отличаются от сокета сервера, ожидающего запросы на соединения, и уникальны в пределах компьютера.</p>     <p>Отображается локальный адрес (сокет сервера) 1574 (или может выводиться имя сервиса <blockquote>mvel-lm</blockquote>) и выбранный в примере порт 9734. Почему они отличаются? Дело в том, что номера портов и адреса передаются через интерфейсы сокета как двоичные числа. В разных компьютерах применяется различный порядок байтов для представления целых чисел. Например, процессор Intel хранит 32-разрядное целое в виде четырех последовательных байтов памяти в следующем порядке 1-2-3-4, где 1-й байт — самый старший. Процессоры IBM PowerPC будут хранить целое со следующим порядком следования байтов: 4-3-2-1. Если используемую для хранения целых память просто побайтно копировать, два компьютера не придут к согласию относительно целочисленных значений.</p>     <p>Для того чтобы компьютеры разных типов могли согласовать значения многобайтовых целых чисел, передаваемых по сети, необходимо определить сетевой порядок передачи байтов. Перед передачей данных клиентские и серверные программы должны преобразовать собственное внутреннее представление целых чисел в соответствии с принятым в сети порядком следования байтов. Делается это с помощью функций, определенных в заголовочном файле netinet/in.h. К ним относятся следующие:</p>     <p><blockquote><b>#include &lt;netinet/in.h&gt;</b></blockquote></p>     <p><blockquote><b>unsigned long int htonl(unsigned long int hostlong);</b></blockquote></p>     <p><blockquote><b>unsigned short int htons(unsigned short int hostshort);</b></blockquote></p>     <p><blockquote><b>unsigned long int ntohl(unsigned long int netlong);</b></blockquote></p>     <p><blockquote><b>unsigned short int ntohs(unsigned short int netshort);</b></blockquote></p>     <p>Эти функции преобразуют 16- и 32-разрядные целые из внутреннего формата в сетевой порядок следования байтов и обратно. Их имена соответствуют сокращенному названию выполняемых преобразований, например "host to network, long" (htonl, компьютерный в сетевой, длинные целые) и "host to network, short" (htons, компьютерный в сетевой, короткие целые). Компьютерам, у которых порядок следования байтов соответствует сетевому, эти функции предоставляют пустые операции.</p>     <p>Для обеспечения корректного порядка следования при передаче 16-разрядного целого числа ваши сервер и клиент должны применить эти функции к адресу порта. В программу server3.c следует внести следующие изменения:</p>     <p><blockquote><i>server_address.sin_addr_s_addr = htonl(INADDR_ANY);</i></blockquote></p>     <p><blockquote><i>server_address.sin_port = htons(9734);</i></blockquote></p>     <p>Результат, возвращаемый функцией <blockquote>inet_addr("127.0.0.1")</blockquote>, преобразовывать не нужно, потому что в соответствии со своим определением она возвращает результат с сетевым порядком следования байтов. В программу client3.c необходимо внести следующее изменение:</p>     <p><blockquote><i>address.sin_port = htons(9734);</i></blockquote></p>     <p>В сервер, благодаря применению константы <blockquote>INADDR_ANY</blockquote>, внесено изменение, позволяющее принимать запросы на соединение от любых IP-адресов.</p>     <p>Теперь, выполнив программы server3 и client3, вы увидите корректный номер порта, используемый для локального соединения:</p>     <p><blockquote>$ <b>netstat</b></blockquote></p>     <p><blockquote>Active Internet connections</blockquote></p>     <p><blockquote>Proto Recv-Q Send-Q Local Address  Foreign Address (State)   User</blockquote></p>     <p><blockquote>tcp        1      0 localhost:9734 localhost:1175  TIME_WAIT root</blockquote></p>     <blockquote>      <b>Примечание</b>      <p>Если вы пользуетесь компьютером, у которого собственный формат представления целых совпадает с сетевым порядком следования байтов, вы не увидите никакой разницы. Но для обеспечения корректного взаимодействия клиентов и серверов с разной архитектурой важно всегда применять функции преобразования.</p>     </blockquote>              <a name="metkadoc14"><h1>Сетевая информация</h1></a>         <p>До сих пор у клиентских и серверных программ были адреса и номера портов, компилируемые в них. В более универсальных серверных и клиентских программах для определения применяемых адресов и портов вы можете использовать данные сети.</p>     <p>Если у вас есть на это право, можно добавить свой сервер к списку известных сервисов в файл /etc/services, который назначает имена номерам портов, так что клиенты могут использовать вместо номеров символические имена сервисов.</p>     <p>Точно так же зная имя компьютера, можно определить IP-адрес, вызвав функции базы данных сетевых узлов (host database), которые найдут эти адреса. Делают они это, обращаясь за справкой к конфигурационным файлам, например, etc/hosts или к сетевым информационным сервисам, таким как NIS (Network Information Services (сервисы сетевой информации), ранее известным как Yellow Pages (желтые страницы)) и DNS (Domain Name Service, служба доменных имен).</p>     <p>Функции базы данных сетевых узлов или хостов (Host database) объявлены в заголовочном файле интерфейса netdb.h:</p>     <p><blockquote><b>#include &lt;netdb.h&gt;</b></blockquote></p>     <p><blockquote><b>struct hostent *gethostbyaddr(const void* addr, size_t len, int type);</b></blockquote></p>     <p><blockquote><b>struct hostent* gethostbyname(const char* name);</b></blockquote></p>     <p>Структура, возвращаемая этими функциями, должна как минимум содержать следующие элементы.</p>     <p><blockquote><b>struct hostent {</b></blockquote></p>     <p><blockquote><b> char *h_name;      /* Имя узла */</b></blockquote></p>     <p><blockquote><b> char **h_aliases;  /* Перечень псевдонимов (nicknames) */</b></blockquote></p>     <p><blockquote><b> int h_addrtype;    /* Тип адреса */</b></blockquote></p>     <p><blockquote><b> int h_length;      /* Длина адреса в байтах */</b></blockquote></p>     <p><blockquote><b> char **h_addr_list /* Перечень адреса (сетевой порядок байтов) */</b></blockquote></p>     <p><blockquote><b>};</b></blockquote></p>     <p>Если в базе данных нет элемента, соответствующего заданному узлу или адресу, информационные функции вернут пустой указатель.</p>     <p>Аналогично информацию, касающуюся сервисов и связанных номеров портов, можно получить с помощью информационных функций сервисов:</p>     <p><blockquote><b>#include &lt;netdb.h&gt;</b></blockquote></p>     <p><blockquote><b>struct servent *getservbyname(const char *name, const char *proto);</b></blockquote></p>     <p><blockquote><b>struct servent *getservbyport(int port, const char *proto);</b></blockquote></p>     <p>Параметр <blockquote>proto</blockquote> задает протокол, который будет применяться для подключения к сервису, либо "tcp" для TCP-соединений типа <blockquote>SOCK_STREAM</blockquote>, либо "udp" для UDP-дейтаграмм типа <blockquote>SOCK_DGRAM</blockquote>.</p>     <p>Структура <blockquote>servent</blockquote> содержит как минимум следующие элементы:</p>     <p><blockquote><b>struct servent {</b></blockquote></p>     <p><blockquote><b> char *s_name;     /* Имя сервиса */</b></blockquote></p>     <p><blockquote><b> char **s_aliases; /* Список псевдонимов (дополнительных имен) */</b></blockquote></p>     <p><blockquote><b> int s_port;       /* Номер IP-порта */</b></blockquote></p>     <p><blockquote><b> char *s_proto;    /* Тип сервиса, обычно "tcp" или "udp" */</b></blockquote></p>     <p><blockquote><b>}</b></blockquote></p>     <p>Вы можете собрать воедино информацию о компьютере из базы данных сетевых узлов, вызвав функцию <blockquote>gethostbyname</blockquote> и выведя ее результаты. Учтите, что адрес необходимо преобразовать в соответствующий тип и перейти от сетевого упорядочивания к пригодной для вывода строке с помощью преобразования <blockquote>inet_ntoa</blockquote>, определенного следующим образом:</p>     <p><blockquote><b>#include &lt;arpa/inet.h&gt;</b></blockquote></p>     <p><blockquote><b>char *inet_ntoa(struct in_addr in);</b></blockquote></p>     <p>Функция преобразует адрес интернет-узла в строку формата четверки чисел с точками. В случае ошибки она возвращает -1, но в стандарте POSIX не определены конкретные ошибки. Еще одна новая функция, которую вы примените, — <blockquote>gethostname</blockquote>:</p>     <p><blockquote><b>#include &lt;unistd.h&gt;</b></blockquote></p>     <p><blockquote><b>int gethostname(char *name, int name length);</b></blockquote></p>     <p>Эта функция записывает имя текущего узла в строку, заданную параметром <blockquote>name</blockquote>. Имя узла будет нуль-терминированной строкой. Аргумент <blockquote>namelength</blockquote> содержит длину строкового имени и, если возвращаемое имя узла превысит эту длину, оно будет обрезано. Функция <blockquote>gethostname</blockquote> возвращает 0 в случае успешного завершения и -1 в случае ошибки. И снова ошибки в стандарте POSIX не определены.</p>     <p>Выполните упражнение 15.5.</p>     <b>Упражнение 15.5. Сетевая информация</b>     <p>Данная программа getname.c получает сведения о компьютере.</p>     <p>1. Как обычно, вставьте соответствующие заголовочные файлы и объявите переменные:</p>     <p><blockquote>#include &lt;netinet/in.h&gt;</blockquote></p>     <p><blockquote>#include &lt;arpa/inet.h&gt;</blockquote></p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;netdb.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <br>     <p><blockquote>int main(int argc, char *argv[]) {</blockquote></p>     <p><blockquote> char *host, **names, **addrs;</blockquote></p>     <p><blockquote> struct hostent *hostinfo;</blockquote></p>     <p>2. Присвойте переменной <blockquote>host</blockquote> значение аргумента, предоставляемого при вызове программы <blockquote>getname</blockquote>, или по умолчанию имя машины пользователя:</p>     <p><blockquote> if (argc == 1) {</blockquote></p>     <p><blockquote>  char myname[256];</blockquote></p>     <p><blockquote>  gethostname(myname, 255);</blockquote></p>     <p><blockquote>  host = myname;</blockquote></p>     <p><blockquote> } else host = argv[1];</blockquote></p>     <p>3. Вызовите функцию gethostbyname и сообщите об ошибке, если никакая информация не найдена:</p>     <p><blockquote> hostinfo = gethostbyname(host);</blockquote></p>     <p><blockquote> if (!hostinfo) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "cannot get info for host: %s\n", host);</blockquote></p>     <p><blockquote>  exit(1);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p>4. Отобразите имя узла и любые псевдонимы, которые у него могут быть:</p>     <p><blockquote> printf("results for host %s:\n", host);</blockquote></p>     <p><blockquote> printf("Name : %s\n", hostinfo-&gt;h_name);</blockquote></p>     <p><blockquote> printf("Aliases: ");</blockquote></p>     <p><blockquote> names = hostinfo-&gt;h_aliases;</blockquote></p>     <p><blockquote> while (*names) {</blockquote></p>     <p><blockquote>  printf(" %s", *names); names++;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> printf("\n");</blockquote></p>     <p>5. Если запрашиваемый узел не является IP-узлом, сообщите об этом и завершите выполнение:</p>     <p><blockquote> if (hostinfo-&gt;h_addrtype != AF_INET) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "not an IP host!\n");</blockquote></p>     <p><blockquote>  exit(1);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p>6. В противном случае выведите IP-адрес (адреса):</p>     <p><blockquote> addrs = hostinfo-&gt;h_addr_list;</blockquote></p>     <p><blockquote> while (*addrs) {</blockquote></p>     <p><blockquote>  printf(" %s", inet_ntoa(*(struct in_addr*)*addrs));</blockquote></p>     <p><blockquote>  addrs++;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> printf("\n");</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Для определения узла по заданному IP-адресу можно применить функцию <blockquote>gethostbyaddr</blockquote>. Вы можете использовать ее на сервере для того, чтобы выяснить, откуда клиент запрашивает соединение.</p>     <p><b>Как это работает</b></p>     <p>Программа getname вызывает функцию gethostbyname для извлечения сведений об узле из базы данных сетевых узлов. Она выводит имя компьютера, его псевдонимы (другие имена, под которыми известен компьютер) и IP-адреса, которые он использует в своих сетевых интерфейсах. На одной из машин авторов выполнение примера и указание в качестве аргумента имени tilde привело к выводу двух интерфейсов: сети Ethernet и модемной линии связи.</p>     <p><blockquote>$ <b>./getname tilde</b></blockquote></p>     <p><blockquote>results for host tilde:</blockquote></p>     <p><blockquote>Name: tilde.localnet</blockquote></p>     <p><blockquote>Aliases: tilde</blockquote></p>     <p><blockquote>192.168.1.1 158.152.x.x</blockquote></p>     <p>Когда используется имя узла <blockquote>localhost</blockquote>, задается виртуальная сеть:</p>     <p><blockquote>$ <b>./getname localhost</b></blockquote></p>     <p><blockquote>results for host localhost:</blockquote></p>     <p><blockquote>Name: localhost</blockquote></p>     <p><blockquote>Aliases: 127.0.0.1</blockquote></p>     <p>Теперь вы можете изменить свою программу-клиента для соединения с любым именованным узлом сети. Вместо подключения к серверу из вашего примера, вы соединитесь со стандартным сервисом и сможете извлечь номер порта.</p>     <p>Большинство систем UNIX и некоторые ОС Linux делают доступными свои системные время и дату в виде стандартного сервиса с именем <blockquote>daytime</blockquote>. Клиенты могут подключаться к этому сервису для выяснения мнения сервера о текущих времени и дате. В упражнении 15:6 приведена программа-клиент getdate.c, именно это и делающая.</p>     <b>Упражнение 15.6. Подключение к стандартному сервису</b>     <p>1. Начните с обычных директив <blockquote>#include</blockquote> и объявлений:</p>     <p><blockquote>#include &lt;sys/socket.h&gt;</blockquote></p>     <p><blockquote>#include &lt;netinet/in.h&gt;</blockquote></p>     <p><blockquote>#include &lt;netdb.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <br>     <p><blockquote>int main(int argc, char *argv[]) {</blockquote></p>     <p><blockquote> char *host;</blockquote></p>     <p><blockquote> int sockfd;</blockquote></p>     <p><blockquote> int len, result;</blockquote></p>     <p><blockquote> struct sockaddr_in address;</blockquote></p>     <p><blockquote> struct hostent *hostinfo;</blockquote></p>     <p><blockquote> struct servent *servinfo;</blockquote></p>     <p><blockquote> char buffer[128];</blockquote></p>     <p><blockquote> if (argc == 1) host = "localhost";</blockquote></p>     <p><blockquote> else host = argv[1];</blockquote></p>     <p>2. Найдите адрес узла и сообщите об ошибке, если адрес не найден:</p>     <p><blockquote> hostinfo = gethostbyname(host);</blockquote></p>     <p><blockquote> if (!host info) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "no host: %s\n", host);</blockquote></p>     <p><blockquote>  exit(1);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p>3. Убедитесь, что на компьютере есть сервис <blockquote>daytime</blockquote>:</p>     <p><blockquote> servinfo = getservbyname("daytime", "tcp");</blockquote></p>     <p><blockquote> if (!servinfo) {</blockquote></p>     <p><blockquote>  fprintf(stderr, "no daytime service\n");</blockquote></p>     <p><blockquote>  exit(1);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> printf("daytime port is %d\n", ntohs(servinfo-&gt;s_port));</blockquote></p>     <p>4. Создайте сокет:</p>     <p><blockquote> sockfd = socket(AF_INET, SOCK_STREAM, 0);</blockquote></p>     <p>5. Сформируйте адрес для соединения:</p>     <p><blockquote> address.sin_family = AF_INET;</blockquote></p>     <p><blockquote> address.sin_port = servinfo-&gt;s_port;</blockquote></p>     <p><blockquote> address.sin_addr = *(struct in_addr *)*hostinfo-&gt;h_addr_list;</blockquote></p>     <p><blockquote> len = sizeof(address);</blockquote></p>     <p>6. Затем подключитесь и получите информацию:</p>     <p><blockquote> result = connect(sockfd, (struct sockaddr *)&amp;address, len);</blockquote></p>     <p><blockquote> if (result == -1) {</blockquote></p>     <p><blockquote>  perror("oops: getdate");</blockquote></p>     <p><blockquote>  exit(1);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> result = read(sockfd, buffer, sizeof(buffer));</blockquote></p>     <p><blockquote> buffer[result] = '\0';</blockquote></p>     <p><blockquote> printf("read %d bytes: %s", result, buffer);</blockquote></p>     <p><blockquote> close(sockfd);</blockquote></p>     <p><blockquote> exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Вы можете применять программу <blockquote>getdate</blockquote> для получения времени суток с любого известного узла сети.</p>     <p><blockquote>$ <b>./getdate localhost</b></blockquote></p>     <p><blockquote>daytime port is 13</blockquote></p>     <p><blockquote>read 26 bytes: 24 JUN 2007 06:03:03 BST</blockquote></p>     <p><blockquote>$</blockquote></p>     <p>Если вы получаете сообщение об ошибке, такое как</p>     <p><blockquote>oops: getdate: Connection refused</blockquote></p>     <p>или</p>     <p><blockquote>oops: getdate: No such file or directory</blockquote></p>     <p>причина может быть в том, что на компьютере, к которому вы подключаетесь, не включен сервис <blockquote>daytime</blockquote>. Такое поведение стало стандартным для большинства современных систем Linux. В следующем разделе вы увидите, как включать этот и другие сервисы.</p>     <p><b>Как это работает</b></p>     <p>При выполнении данной программы можно задать узел, к которому следует подключиться. Номер порта сервиса <blockquote>daytime</blockquote> определяется функцией сетевой базы данных <blockquote>getservbyname</blockquote>, которая возвращает сведения о сетевых сервисах таким же способом, как и при получении информации об узле сети. Программа <blockquote>getdate</blockquote> пытается соединиться с адресом, который указан первым в списке дополнительных адресов заданного узла. Если соединение успешно, программа считывает сведения, возвращаемые сервисом daytime, символьную строку, содержащую системные дату и время.</p>             <a name="metkadoc15"><h1>Интернет-демон (xinetd/inetd)</h1></a>     <p>Системы UNIX, предоставляющие ряд сетевых сервисов, зачастую делают это с помощью суперсервера. Эта программа (интернет-демон xinetd или inetd) ожидает одновременно запросы на соединения с множеством адресов портов. Когда клиент подключается к сервису, программа-демон запускает соответствующий сервер. При таком подходе серверам не нужно работать постоянно, они могут запускаться по требованию.</p>     <blockquote>      <b>Примечание</b>      <p>В современных системах Linux роль интернет-демона исполняет программа xinetd. Она заменила оригинальную UNIX-программу inetd, которую вы все еще можете встретить в более ранних системах Linux и других UNIX-подобных системах.</p>     </blockquote>     <p>Программа xinetd обычно настраивается с помощью пользовательского графического интерфейса для управления сетевыми сервисами, но вы можете изменять и непосредственно файлы конфигурации программы. К ним относятся файл /etc/xinetd.conf и файлы в каталоге /etc/xinetd.d.</p>     <p>У каждого сервиса, предоставляемого программой xinetd, есть файл конфигурации в каталоге /etc/xinetd.d. Программа xinetd считает все эти файлы конфигурации во время запуска и повторно при получении соответствующей команды.</p>     <p>Далее приведена пара примеров файлов конфигурации xinetd, первый из них для сервиса <blockquote>daytime</blockquote>.</p>     <p><blockquote># По умолчанию: отключен</blockquote></p>     <p><blockquote># Описание: сервер daytime. Это версия tcp.</blockquote></p>     <p><blockquote>service daytime</blockquote></p>     <p><blockquote>{</blockquote></p>     <p><blockquote> socket_type = stream</blockquote></p>     <p><blockquote> protocol    = tcp</blockquote></p>     <p><blockquote> wait        = no</blockquote></p>     <p><blockquote> user        = root</blockquote></p>     <p><blockquote> type        = INTERNAL</blockquote></p>     <p><blockquote> id          = daytime-stream</blockquote></p>     <p><blockquote> FLAGS       = IPv6 IPv4</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Следующий файл конфигурации предназначен для сервиса передачи файлов.</p>     <p><blockquote># По умолчанию: отключен</blockquote></p>     <p><blockquote># Описание:</blockquote></p>     <p><blockquote># FTP-сервер vsftpd обслуживает FTP-соединения. Он использует</blockquote></p>     <p><blockquote># для аутентификации обычные, незашифрованные имена пользователей и</blockquote></p>     <p><blockquote># пароли, vsftpd спроектирован для безопасной работы.</blockquote></p>     <p><blockquote># </blockquote></p>     <p><blockquote># Примечание: этот файл содержит конфигурацию запуска vsftpd для xinetd.</blockquote></p>     <p><blockquote># Файл конфигурации самой программы vsftpd находится в</blockquote></p>     <p><blockquote># /etc/vsftpd.conf</blockquote></p>     <p><blockquote>service ftp {</blockquote></p>     <p><blockquote># server_args =</blockquote></p>     <p><blockquote># log_on_success += DURATION USERID</blockquote></p>     <p><blockquote># log_on_failure += USERID</blockquote></p>     <p><blockquote># nice = 10</blockquote></p>     <p><blockquote> socket_type = stream</blockquote></p>     <p><blockquote> protocol    = tcp</blockquote></p>     <p><blockquote> wait        = no</blockquote></p>     <p><blockquote> user        = root</blockquote></p>     <p><blockquote> server      = /usr/sbin/vsftpd</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Сервис <blockquote>daytime</blockquote>, к которому подключается программа <blockquote>getdate</blockquote>, обычно обрабатывается самой программой xinetd (он помечен как внутренний) и может включаться с помощью как сокетов типа <blockquote>SOCK_STREAM</blockquote> (tcp), так и сокетов типа <blockquote>SOCK_DGRAM</blockquote> (udp).</p>     <p>Сервис передачи файлов <blockquote>ftp</blockquote> подключается только сокетами типа <blockquote>SOCK_STREAM</blockquote> и предоставляется внешней программой, в данном случае vsftpd. Демон будет запускать эту внешнюю программу, когда клиент подключится к порту <blockquote>ftp</blockquote>.</p>     <p>Для активизации конфигурационных изменений сервиса можно отредактировать конфигурацию xinetd и отправить сигнал отбоя (hang-up) процессу-демону, но мы рекомендуем использовать более дружелюбный способ настройки сервисов. Для того чтобы разрешить вашему клиенту подключаться к сервису <blockquote>daytime</blockquote>, включите этот сервис с помощью средств, предоставляемых системой Linux. В системах SUSE и openSUSE сервисы можно настраивать из SUSE Control Center (Центр управления SUSE), как показано на рис. 15.1. У версий Red Hat (и Enterprise Linux, и Fedora) есть похожий интерфейс настройки. В нем сервис <blockquote>daytime</blockquote> включается для TCP- и UDP-запросов.</p>     <img src="image050.jpg"/>     <p><b>Рис. 15.1</b> </p>     <br>     <p>Для систем, применяющих программу inetd вместо xinetd, далее приведено эквивалентное извлечение из файла конфигурации inetd, /etc/inetd.conf, которое программа inetd использует для принятия решения о запуске серверов:</p>     <p><blockquote>#</blockquote></p>     <p><blockquote># &lt;service_name&gt; &lt;sock_type&gt; &lt;proto&gt; &lt;flags&gt; &lt;user&gt; &lt;server_path&gt; &lt;args&gt;</blockquote></p>     <p><blockquote>#</blockquote></p>     <p><blockquote># Echo, discard, daytime и chargen используются в основном для</blockquote></p>     <p><blockquote># тестирования.</blockquote></p>     <p><blockquote>#</blockquote></p>     <p><blockquote>daytime stream tcp nowait root internal</blockquote></p>     <p><blockquote>daytime dgram udp wait root internal</blockquote></p>     <p><blockquote>#</blockquote></p>     <p><blockquote># Это стандартные сервисы.</blockquote></p>     <p><blockquote>#</blockquote></p>     <p><blockquote>ftp stream tcp-nowait root /usr/sbin/tcpd /usr/sbin/wu.ftpd</blockquote></p>     <p><blockquote>telnet stream tcp nowait root /usr/sbin/tcpd /usr/sbin/in.telnetd</blockquote></p>     <p><blockquote>#</blockquote></p>     <p><blockquote># Конец файла inetd.conf.</blockquote></p>     <p>Обратите внимание на то, что в нашем примере сервис ftp предоставляется внешней программой wu.ftpd. Если в вашей системе выполняется демон inetd, вы можете изменить набор предоставляемых сервисов, отредактировав файл /etc/inetd.conf (знак # в начале строки указывает на то, что это строка комментария) и перезапустив процесс inetd. Сделать это можно, отправив сигнал отбоя (hang-up) с помощью команды <blockquote>kill</blockquote>. Для облегчения этого процесса некоторые системы настроены так, что программа inetd записывает свой ID в файл. В противном случае можно применить команду <blockquote>killall</blockquote>:</p>     <p><blockquote># <b>killall -HUP inetd</b></blockquote></p>             <a name="metkadoc16"><h1>Параметры сокета</h1></a>     <p>Существует много параметров, которые можно применять для управления поведением соединений на базе сокетов — слишком много для подробного описания в этой главе. Для манипулирования параметрами используют функцию <blockquote>setsockopt</blockquote>:</p>     <p><blockquote><b>#include &lt;sys/socket.h&gt;</b></blockquote></p>     <p><blockquote><b>int setsockopt(int socket, int level, int option_name,</b></blockquote></p>     <p><blockquote><b> const void *option value, size_t option len);</b></blockquote></p>     <p>Задавать параметры можно на разных уровнях иерархии протоколов. Для установки параметров на уровне сокета вы должны задать <blockquote>level</blockquote> равным <blockquote>SOL_SOCKET</blockquote>. Для задания параметров на более низком уровне протоколов (TCP, UDP и т.д.) приравняйте параметр level номеру протокола (полученному либо из заголовочного файла netinet/in.h, либо из функции <blockquote>getprotobyname</blockquote>).</p>     <p>В аргументе <blockquote>option_name</blockquote> указывается имя задаваемого параметра, аргумент <blockquote>option_value</blockquote> содержит произвольное значение длиной <blockquote>option_len</blockquote> байтов, передаваемое без изменений обработчику низкоуровневого протокола.</p>     <p>Параметры уровня сокета определены в заголовочном файле sys/socket.h и включают приведенные в табл. 15.4 значения.</p>     <br>     <p><b><i>Таблица 15.5</i></b></p>     <table>      <tr>       <th valign="top">Параметр</th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>SO_DEBUG</blockquote></td>       <td valign="top">Включает отладочную информацию</td>      </tr>      <tr>       <td valign="top"><blockquote>SO_KEEPALIVE</blockquote></td>       <td valign="top">Сохраняет активными соединения при периодических передачах</td>      </tr>      <tr>       <td valign="top"><blockquote>SO_LINGER</blockquote></td>       <td valign="top">Завершает передачу перед закрытием</td>      </tr>     </table>     <p>Параметры <blockquote>SO_DEBUG</blockquote> и <blockquote>SO_KEEPALIVE</blockquote> принимают целое значение <blockquote>option_value</blockquote> для установки или включения (1) и сброса или выключения (0). Для параметра <blockquote>SO_LINGER</blockquote> нужна структура типа <blockquote>linger</blockquote>, определенная в файле sys/socket.h и задающая состояние параметра и величину интервала задержки.</p>     <p>Функция <blockquote>setsockopt</blockquote> возвращает 0 в случае успеха и -1 в противном случае. На страницах интерактивного справочного руководства описаны дополнительные параметры и ошибки.</p>              <a name="metkadoc17"><h1>Множественные клиенты</h1></a>         <p>До сих пор в этой главе вы видели, как применяются сокеты для реализации клиент-серверных систем, как локальных, так действующих, в сети. После установки соединения на базе сокетов они ведут себя как низкоуровневые открытые файловые дескрипторы и во многом как двунаправленные каналы.</p>     <p>Теперь необходимо рассмотреть случай множественных клиентов, одновременно подключающихся к серверу. Вы видели, что, когда серверная программа принимает от клиента запрос на соединение, создается новый сокет, а исходный сокет, ожидающий запросы на соединение, остается доступен для последующих запросов. Если сервер не сможет немедленно принять поступившие позже запросы на соединения, они сохранятся в очереди ожидания.</p>     <p>Тот факт, что исходный сокет все еще доступен, и что сокеты ведут себя как файловые дескрипторы, дает нам метод одновременного обслуживания многих клиентов. Если сервер вызовет функцию <blockquote>fork</blockquote> для создания своей второй копии, открытый сокет будет унаследован новым дочерним процессом. Далее он сможет обмениваться данными с подключившимся клиентом, в то время как основной сервер продолжит прием последующих запросов на соединение. В действительности в вашу программу сервера нужно внести очень простое изменение, показанное в упражнении 15.7.</p>     <p>Поскольку вы создаете дочерние процессы, но не ждете их завершения, следует сделать так, чтобы сервер игнорировал сигналы <blockquote>SIGCHLD</blockquote>, препятствуя возникновению процессов-зомби.</p>     <b>Упражнение 15.7. Сервер для многочисленных клиентов</b>     <p>1. Программа server4.c начинается так же, как последний рассмотренный сервер с важным добавлением директивы <blockquote>include</blockquote> для заголовочного файла signal.h. Переменные и процедуры создания и именования сокета остались прежними: </p>     <p><blockquote>#include &lt;sys/types.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/socket.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;netinet/in.h&gt;</blockquote></p>     <p><blockquote><i>#include &lt;signal.h&gt;</i></blockquote></p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int server_sockfd, client_sockfd;</blockquote></p>     <p><blockquote> int server_len, client_len;</blockquote></p>     <p><blockquote> struct sockaddr_in server_address;</blockquote></p>     <p><blockquote> struct sockaddr_in client_address;</blockquote></p>     <p><blockquote> server_sockfd = socket(AF_INET, SOCK_STREAM, 0);</blockquote></p>     <p><blockquote> server_address.sin_family = AF_INET;</blockquote></p>     <p><blockquote> server_address.sin_addr.s_addr = htonl(INADDR_ANY);</blockquote></p>     <p><blockquote> server_address.sin_port = htons(9734);</blockquote></p>     <p><blockquote> server_len = sizeof(server_address);</blockquote></p>     <p><blockquote> bind(server_sockfd, (struct sockaddr *)&amp;server_address, server_len);</blockquote></p>     <p>2. Создайте очередь соединений, игнорируйте подробности завершения дочернего процесса и ждите запросов клиентов:</p>     <p><blockquote><i> listen(server_sockfd, 5);</i></blockquote></p>     <p><blockquote><i> signal(SIGCHLD, SIG_IGN);</i></blockquote></p>     <p><blockquote><i> while(1) {</i></blockquote></p>     <p><blockquote><i>  char ch;</i></blockquote></p>     <p><blockquote><i>  printf("server waiting\n");</i></blockquote></p>     <p>3. Примите запрос на соединение:</p>     <p><blockquote><i>  client_len = sizeof(client_address);</i></blockquote></p>     <p><blockquote><i>  client_sockfd = accept(server_sockfd,</i></blockquote></p>     <p><blockquote><i>   (struct_sockaddr*)&amp;client_address, &amp;client_len);</i></blockquote></p>     <p>4. Вызовите <blockquote>fork</blockquote> с целью создания процесса для данного клиента и выполните проверку, чтобы определить, родитель вы или потомок:</p>     <p><blockquote><i>  if (fork() == 0) {</i></blockquote></p>     <p>5. Если вы потомок, то можете читать/писать в программе-клиенте на сокете <blockquote>client_sockfd</blockquote>. Пятисекундная задержка нужна для того, чтобы это продемонстрировать:</p>     <p><blockquote><i>   read(client_sockfd, &amp;ch, 1);</i></blockquote></p>     <p><blockquote><i>   sleep(5);</i></blockquote></p>     <p><blockquote><i>   ch++;</i></blockquote></p>     <p><blockquote><i>   write(client_sockfd, &amp;ch, 1);</i></blockquote></p>     <p><blockquote><i>   close(client_sockfd);</i></blockquote></p>     <p><blockquote><i>   exit(0);</i></blockquote></p>     <p><blockquote><i>  }</i></blockquote></p>     <p>6. В противном случае вы должны быть родителем и ваша работа с данным клиентом закончена:</p>     <p><blockquote><i>  else {</i></blockquote></p>     <p><blockquote><i>   close(client_socket);</i></blockquote></p>     <p><blockquote><i>  }</i></blockquote></p>     <p><blockquote><i> }</i></blockquote></p>     <p><blockquote><i>}</i></blockquote></p>     <p>Код включает пятисекундную задержку при обработке запроса клиента для имитации вычислений сервера или обращения к базе данных. Если бы вы проделали это в предыдущем сервере, каждое выполнение программы client3 заняло бы пять секунд. С новым сервером вы сможете обрабатывать множественные клиентские программы client3 параллельно с общим затраченным временем, чуть превышающим пять секунд.</p>     <p><blockquote>$ <b>./server4 &amp;</b></blockquote></p>     <p><blockquote>[1] 26566 server waiting</blockquote></p>     <p><blockquote>$ <b>./client3 &amp; ./client3 &amp; ./client3 &amp; ps x</b></blockquote></p>     <p><blockquote>[2] 26581</blockquote></p>     <p><blockquote>[3] 26582</blockquote></p>     <p><blockquote>[4] 26583</blockquote></p>     <p><blockquote>server waiting</blockquote></p>     <p><blockquote>server waiting</blockquote></p>     <p><blockquote>server waiting</blockquote></p>     <p><blockquote>PID   TTY   STAT TIME COMMAND</blockquote></p>     <p><blockquote>26566 pts/1 S    0:00 ./server4</blockquote></p>     <p><blockquote>26581 pts/1 S    0:00 ./client3</blockquote></p>     <p><blockquote>26582 pts/1 S    0:00 ./client3</blockquote></p>     <p><blockquote>26583 pts/1 S    0:00 ./client3</blockquote></p>     <p><blockquote>26584 pts/1 R+   0:00 ps x</blockquote></p>     <p><blockquote>26585 pts/1 S    0:00 ./server4</blockquote></p>     <p><blockquote>26586 pts/1 S    0:00 ./server4</blockquote></p>     <p><blockquote>26587 pts/1 S    0:00 ./server4</blockquote></p>     <p><blockquote>$ char from server = В</blockquote></p>     <p><blockquote>char from server = В</blockquote></p>     <p><blockquote>char from server = В</blockquote></p>     <p><blockquote><b>ps x</b></blockquote></p>     <p><blockquote>PID  TTY    STAT TIME COMMAND</blockquote></p>     <p><blockquote>26566 pts/1 S    0:00 ./server4</blockquote></p>     <p><blockquote>26590 pts/1 R+   0:00 ps x</blockquote></p>     <p><blockquote>[2] Done   ./client3</blockquote></p>     <p><blockquote>[3]- Done  ./client3</blockquote></p>     <p><blockquote>[4]+ Done  ./client3</blockquote></p>     <p><blockquote>$</blockquote></p>     <p><b>Как это работает</b></p>     <p>Теперь серверная программа создает новый дочерний процесс для обработки каждого клиента, поэтому вы можете видеть несколько сообщений об ожидании сервера, поскольку основная программа продолжает ждать новые запросы на подключения. В выводе команды <blockquote>ps</blockquote> (отредактированном) показан главный процесс server4 с PID, равным 26 566, который ожидает новых клиентов, в то время, как три клиентских процесса client3 обслуживаются тремя потомками сервера. После пятисекундной паузы все клиенты получают свои результаты и завершаются. Дочерние серверные процессы тоже завершаются, оставляя только один главный серверный процесс.</p>     <p>Серверная программа применяет вызов <blockquote>fork</blockquote> для обработки множественных клиентов. В приложении для работы с базой данных это может быть не самым удачным решением, т.к. серверная программа может быть довольно большой, и, кроме того, существует проблема координации обращений к базе данных множественных копий сервера. На самом деле, все, что вам нужно, — это способ обработки множественных клиентов единственным сервером без блокировки и ожидания доставки клиентских запросов. Решение этой задачи включает одновременную обработку множественных открытых файловых дескрипторов и не ограничено только приложениями с применением сокетов. Рассмотрим функцию <blockquote>select</blockquote>.</p>             <a name="metkadoc18"><h1><i>select</i></h1></a>     <p>Очень часто при разработке приложений Linux вам может понадобиться проверка состояния ряда вводов для того, чтобы определить следующее предпринимаемое действие. Например, программа обмена данными, такая как эмулятор терминала, нуждается в эффективном способе одновременного чтения с клавиатуры и с последовательного порта. В однопользовательской системе подойдет цикл "активного ожидания", многократно просматривающий ввод в поиске данных и читающий их, как только они появятся. Такое поведение очень расточительно в отношении времени ЦП.</p>     <p>Системный вызов <blockquote>select</blockquote> позволяет программе ждать прибытия данных (или завершения вывода) одновременно на нескольких низкоуровневых файловых дескрипторах. Это означает, что программа эмулятора терминала может блокироваться до тех пор, пока у нее не появится работа. Аналогичным образом сервер может иметь дело с многочисленными клиентами, ожидая запросы одновременно на многих открытых сокетах.</p>     <p>Функция <blockquote>select</blockquote> оперирует структурами данных <blockquote>fd_set</blockquote>, представляющими собой множества открытых файловых дескрипторов. Для обработки этих множеств определен набор макросов:</p>     <p><blockquote><b>#include &lt;sys/types.h&gt; #include &lt;sys/time.h&gt;</b></blockquote></p>     <p><blockquote><b>void FD_ZERO(fd_set *fdset);</b></blockquote></p>     <p><blockquote><b>void FD_CLR(int fd, fd_set *fdset);</b></blockquote></p>     <p><blockquote><b>void FD_SET(int fd, fd_set *fdset);</b></blockquote></p>     <p><blockquote><b>int FD_ISSET(int fd, fd_set *fdset);</b></blockquote></p>     <p>Как и предполагается в соответствии с их именами, макрос <blockquote>FD_ZERO</blockquote> инициализирует структуру <blockquote>fd_set</blockquote> пустым множеством, <blockquote>FD_SET</blockquote> и <blockquote>FD_CLR</blockquote> задают и очищают элементы множества, соответствующего файловому дескриптору, переданному как параметр <blockquote>fd</blockquote>, а макрос <blockquote>FD_ISSET</blockquote> возвращает ненулевое значение, если файловый дескриптор, на который ссылается <blockquote>fd</blockquote>, является элементом структуры <blockquote>fd_set</blockquote>, на которую указывает параметр <blockquote>fdset</blockquote>. Максимальное количество файловых дескрипторов в структуре типа <blockquote>fd_set</blockquote> задается константой <blockquote>FD_SETDIZE</blockquote>.</p>     <p>Функция <blockquote>select</blockquote> может также использовать значение для времени ожидания, чтобы помешать бесконечной блокировке. Это значение задается с помощью структуры <blockquote>struct timeval</blockquote>. Она определена в файле sys/time.h и содержит следующие элементы:</p>     <p><blockquote><b>struct timeval {</b></blockquote></p>     <p><blockquote><b> time_t tv_sec; /* Секунды */</b></blockquote></p>     <p><blockquote><b> long tv_usec;  /* Микросекунды */</b></blockquote></p>     <p><blockquote><b>}</b></blockquote></p>     <p>Тип <blockquote>time_t</blockquote>, определенный в файле sys/types.h, — целочисленный. Системный вызов <blockquote>select</blockquote> объявляется следующим образом:</p>     <p><blockquote><b>#include &lt;sys/types.h&gt;</b></blockquote></p>     <p><blockquote><b>#include &lt;sys/time.h&gt;</b></blockquote></p>     <p><blockquote><b>int select(int nfds, fd_set *readfds, fd_set *writefds,</b></blockquote></p>     <p><blockquote><b> fd_set *errorfds, struct timeval *timeout);</b></blockquote></p>     <p>Вызов <blockquote>select</blockquote> позволяет проверить, не готов ли хотя бы один из множества файловых дескрипторов к чтению или записи, или находится ли в ожидании из-за состояния ошибки и может быть заблокирован до момента готовности одного из дескрипторов.</p>     <p>Аргумент <blockquote>nfds</blockquote> задает количество проверяемых файловых дескрипторов, имеются в виду дескрипторы от 0 до <blockquote>nfds-1</blockquote>. Каждое из трех множеств дескрипторов может оказаться пустым указателем, тогда связанный с ним тест не выполняется.</p>     <p>Функция <blockquote>select</blockquote> вернет управление, если какой-либо из дескрипторов в множестве <blockquote>readfds</blockquote> готов к чтению, какой-нибудь дескриптор из множества <blockquote>writefds</blockquote> готов к записи или у одного из дескрипторов множества <blockquote>errorfd</blockquote> есть состояние ошибки. Если ни одно из условий не соблюдается, <blockquote>select</blockquote> вернет управление после промежутка времени, заданного <blockquote>timeout</blockquote>. Если параметр <blockquote>timeout</blockquote> — пустой указатель и нет активности на сокетах, вызов может быть заблокирован на неопределенное время.</p>     <p>Когда <blockquote>select</blockquote> возвращает управление программе, множества дескрипторов будут модифицированы для того, чтобы указать на готовые к чтению или записи или имеющие ошибки дескрипторы. Для их проверки следует использовать макрос <blockquote>FD_ISSET</blockquote>, позволяющий определить, какие дескрипторы требуют внимания. Можно изменить значение timeout для того, чтобы показать время, остающееся до следующего превышения времени ожидания, но такое поведение не задано стандартом X/Open. При превышении времени ожидания все множества дескрипторов будут очищены.</p>     <p>Вызов select возвращает общее количество дескрипторов в модифицированных множествах. В случае сбоя он вернет -1 и установит значение переменной <blockquote>errno</blockquote>, описывающее ошибку. Возможные ошибки — <blockquote>EBADF</blockquote> для неверных дескрипторов, <blockquote>EINTR</blockquote> для возврата из-за прерывания и <blockquote>EINVAL</blockquote> для некорректных значений параметров <blockquote>nfds</blockquote> или <blockquote>timeout</blockquote>.</p>     <b>Примечание</b>     <p>Несмотря на то, что Linux модифицирует структуру, на которую указывает <blockquote>timeout</blockquote>, фиксируя оставшееся неиспользованное время, большинство версий UNIX этого не делают. Большая часть существующего программного кода, применяющего функцию <blockquote>select</blockquote>, инициализирует структуру типа <blockquote>timeval</blockquote> и затем продолжает использовать ее без обновления содержимого. В системе Linux этот код может выполняться некорректно, поскольку ОС Linux изменяет структуру <blockquote>timeval</blockquote> при каждом истечении отведенного времени ожидания. Если вы пишете или переносите программный код, использующий функцию <blockquote>select</blockquote>, следует учитывать эту разницу и всегда повторно инициализировать время ожидания. Имейте в виду, что оба подхода корректны, они просто разные!</p>     <p>Выполните упражнение 15.8.</p>     <b>Упражнение 15.8. Функция <blockquote>select</blockquote></b>     <p>Далее для демонстрации применения функции select приведена программа select.c. Более сложный пример вы увидите чуть позже. Программа читает данные с клавиатуры (стандартный ввод — дескриптор 0) со временем ожидания 2,5 секунды. Данные читаются только тогда, когда ввод готов. Естественно расширить программу, включив в зависимости от характера приложения другие дескрипторы, такие как последовательные каналы (serial lines) и сокеты.</p>     <p>1. Начните как обычно с директив <blockquote>include</blockquote> и объявлений, а затем инициализируйте <blockquote>inputs</blockquote> для обработки ввода с клавиатуры:</p>     <p><blockquote>#include &lt;sys/types.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/time.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;fcntl.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/ioctl.h&gt;</blockquote></p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> char buffer[128];</blockquote></p>     <p><blockquote> int result, nread;</blockquote></p>     <p><blockquote> fd_set inputs, testfds;</blockquote></p>     <p><blockquote> struct timeval timeout;</blockquote></p>     <p><blockquote> FD_ZERO(&amp;inputs);</blockquote></p>     <p><blockquote> FD_SET(0, &amp;inputs);</blockquote></p>     <p>2. Подождите ввод из файла stdin в течение максимум 2,5 секунд:</p>     <p><blockquote> while(1) {</blockquote></p>     <p><blockquote>  testfds = inputs;</blockquote></p>     <p><blockquote>  timeout.tv_sec = 2;</blockquote></p>     <p><blockquote>  timeout.tv_usec = 500000;</blockquote></p>     <p><blockquote>  result = select(FD_SETSIZE, &amp;testfds, (fd_set *)NULL,</blockquote></p>     <p><blockquote>   (fd_set*)NULL, &amp;timeout);</blockquote></p>     <p>3. Спустя это время проверьте <blockquote>result</blockquote>. Если ввода не было, программа выполнит цикл еще раз. Если в нем возникла ошибка, программа завершается:</p>     <p><blockquote>  switch(result) {</blockquote></p>     <p><blockquote>  case 0:</blockquote></p>     <p><blockquote>   printf("timeout\n");</blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  case -1:</blockquote></p>     <p><blockquote>   perror("select");</blockquote></p>     <p><blockquote>   exit(1);</blockquote></p>     <p>4. Если во время ожидания у вас наблюдаются некоторые действия, связанные с файловым дескриптором, читайте ввод из stdin и выводите его при каждом получении символа EOL (конец строки), до нажатой комбинации клавиш &lt;Ctrl&gt;+&lt;D&gt;:</p>     <p><blockquote>  default:</blockquote></p>     <p><blockquote>   if (FD_ISSET(0, &amp;testfds)) {</blockquote></p>     <p><blockquote>    ioctl(0, FIONREAD, &amp;nread);</blockquote></p>     <p><blockquote>    if (nread == 0) {</blockquote></p>     <p><blockquote>     printf("keyboard done\n");</blockquote></p>     <p><blockquote>     exit(0);</blockquote></p>     <p><blockquote>    }</blockquote></p>     <p><blockquote>    nread = read(0, buffer, nread);</blockquote></p>     <p><blockquote>    buffer[nread] = 0;</blockquote></p>     <p><blockquote>    printf("read %d from keyboard: %s", nread, buffer);</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Во время выполнения эта программа каждые две с половиной секунды выводит строку <blockquote>timeout</blockquote>. Если вы набираете данные на клавиатуре, она читает файл стандартного ввода и отображает то, что было набрано. В большинстве командных оболочек ввод направляется в программу при нажатии пользователем клавиши &lt;Enter&gt; (или &lt;Return&gt;) или клавиш управляющей последовательности, поэтому программа будет отображать ввод каждый раз, когда вы нажимаете клавишу &lt;Enter&gt;. Учтите, что сама клавиша &lt;Enter&gt; тоже читается и обрабатывается как любой другой символ (попробуйте выполнить ввод без нажатия клавиши, введя ряд символов, за которыми следует комбинация &lt;Ctrl&gt;+&lt;D&gt;).</p>     <p><blockquote>$ <b>./select</b></blockquote></p>     <p><blockquote>timeout</blockquote></p>     <p><blockquote><b>hello</b></blockquote></p>     <p><blockquote>read 6 from keyboard: hello</blockquote></p>     <p><blockquote><b>fred</b></blockquote></p>     <p><blockquote>read 5 from keyboard: fred</blockquote></p>     <p><blockquote>timeout</blockquote></p>     <p><blockquote><b>^D</b></blockquote></p>     <p><blockquote>keyboard done</blockquote></p>     <p><blockquote>$</blockquote></p>     <p><b>Как это работает</b></p>     <p>Программа применяет вызов <blockquote>select</blockquote> для проверки состояния стандартного ввода. За счет корректировки значения времени ожидания программа каждые 2,5 секунды выводит сообщение об истечении времени ожидания. О нем свидетельствует возвращение 0 функцией <blockquote>select</blockquote>. При достижении конца файла дескриптор стандартного ввода помечается флагом как готовый к вводу, но при этом нет символов, предназначенных для считывания.</p>             <a name="metkadoc19"><h1>Множественные клиенты</h1></a>     <p>Ваша простая серверная программа может выиграть от применения <blockquote>select</blockquote> для одновременной обработки множественных клиентов, не прибегая к помощи дочерних процессов. Используя этот метод в реальных приложениях, вы должны следить за тем, чтобы другие клиенты не ждали слишком долго, пока вы обрабатываете первого подключившегося клиента.</p>     <p>Сервер может применять функцию <blockquote>select</blockquote> одновременно к сокету, ожидающему запросы на подключение, и к сокетам клиентских соединений. Как только активность зафиксирована, можно использовать макрос <blockquote>FD_ISSET</blockquote> для проверки в цикле всех возможных файловых дескрипторов и выявления активных среди них.</p>     <p>Если сокет, ожидающий запросов на подключение, готов к вводу, это означает, что клиент пытается подсоединиться, и вы можете вызывать функцию <blockquote>accept</blockquote> без риска блокировки. Если клиентский дескриптор указывает на готовность, это означает, что есть запрос клиента, ждущий, что вы сможете прочесть и обработать его. Чтение 0 байтов означает, что клиентский процесс завершился, и вы можете закрыть сокет и удалить его из множества своих дескрипторов.</p>     <p>Выполните упражнение 15.9.</p>     <b>Упражнение 15.9. Улучшенное клиент-серверное приложение</b>     <p>1. В финальный пример программы server5.с вы включите заголовочные файлы sys/time.h и sys/ioctl.h вместо signal.h, использованного в предыдущей программе, и объявите несколько дополнительных переменных для работы с вызовом <blockquote>select</blockquote>:</p>     <p><blockquote>#include &lt;sys/types.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/socket.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;netinet/in.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/time.h&gt;</blockquote></p>     <p><blockquote>#include &lt;sys/ioctl.h&gt;</blockquote></p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int server_sockfd, client_sockfd;</blockquote></p>     <p><blockquote> int server_len, client_len;</blockquote></p>     <p><blockquote> struct sockaddr_in server_address;</blockquote></p>     <p><blockquote> struct sockaddr_in client_address;</blockquote></p>     <p><blockquote> int result;</blockquote></p>     <p><blockquote> fd_set readfds, testfds;</blockquote></p>     <p>2. Создайте сокет для сервера и присвойте ему имя:</p>     <p><blockquote> server_sockfd = socket(AF_INET, SOCK_STREAM, 0);</blockquote></p>     <p><blockquote> server_address.sin_family = AF_INET;</blockquote></p>     <p><blockquote> server_address.sin_addr.s_addr = htonl(INADDR_ANY);</blockquote></p>     <p><blockquote> server_address.sin_port = htons(9734);</blockquote></p>     <p><blockquote> server_len = sizeof(server_address);</blockquote></p>     <p><blockquote> bind(serversockfd, (struct sockaddr *)&amp;server_address, server_len);</blockquote></p>     <p>3. Создайте очередь запросов на соединение и инициализируйте множество <blockquote>readfds</blockquote> для обработки ввода с сокета <blockquote>server_sockfd</blockquote>:</p>     <p><blockquote> listen(server_sockfd, 5);</blockquote></p>     <p><blockquote> FD_ZERO(&amp;readfds);</blockquote></p>     <p><blockquote> FD_SET(server_sockfd, &amp;readfds);</blockquote></p>     <p>4. Теперь ждите запросы от клиентов. Поскольку вы передали пустой указатель как параметр <blockquote>timeout</blockquote>, не будет наступать истечения времени ожидания. Программа завершится и сообщит об ошибке, если <blockquote>select</blockquote> возвращает значение, меньшее 1.</p>     <p><blockquote> while(1) {</blockquote></p>     <p><blockquote>  char ch;</blockquote></p>     <p><blockquote>  int fd;</blockquote></p>     <p><blockquote>  int nread;</blockquote></p>     <p><blockquote>  testfds = readfds;</blockquote></p>     <p><blockquote>  printf("server waiting\n");</blockquote></p>     <p><blockquote>  result = select(FD_SETSIZE, &amp;testfds, (fd_set *)0,</blockquote></p>     <p><blockquote>   (fd_set *)0, (struct timeval *)0);</blockquote></p>     <p><blockquote>  if (result &lt; 1) {</blockquote></p>     <p><blockquote>   perror("server5");</blockquote></p>     <p><blockquote>   exit(1);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p>5. После того как вы определили, что есть активность, можно выяснить, какой из дескрипторов активен, проверяя каждый из них по очереди с помощью макроса <blockquote>FD_ISSET</blockquote>:</p>     <p><blockquote>  for (fd = 0; fd &lt; FD_SETSIZE; fd++) {</blockquote></p>     <p><blockquote>   if (FD_ISSET(fd, &amp;testfds)) {</blockquote></p>     <p>6. Если зафиксирована активность на <blockquote>server_sockfd</blockquote>, это может быть запрос на новое соединение, и вы добавляете в множество дескрипторов соответствующий <blockquote>client_sockfd</blockquote>:</p>     <p><blockquote>    if (fd == server_sockfd) {</blockquote></p>     <p><blockquote>     client_len = sizeof(client_address);</blockquote></p>     <p><blockquote>     client_sockfd = accept(server_sockfd,</blockquote></p>     <p><blockquote>      (struct sockaddr*)&amp;client_address, &amp;client_len);</blockquote></p>     <p><blockquote>     FD_SET(client_sockfd, &amp;readfds);</blockquote></p>     <p><blockquote>     printf("adding client on fd %d\n", client_sockfd);</blockquote></p>     <p><blockquote>    }</blockquote></p>     <p>Если активен не сервер, значит, активность проявляет клиент. Если получен <blockquote>close</blockquote>, клиент исчезает, и можно удалить его из множества дескрипторов. В противном случае вы "обслуживаете" клиента, как и в предыдущих примерах.</p>     <p><blockquote>    else {</blockquote></p>     <p><blockquote>     ioctl(fd, FIONREAD, &amp;nread);</blockquote></p>     <p><blockquote>     if (nread == 0) {</blockquote></p>     <p><blockquote>      close(fd);</blockquote></p>     <p><blockquote>      FD_CLR(fd, &amp;readfds);</blockquote></p>     <p><blockquote>      printf("removing client on fd %d\n", fd);</blockquote></p>     <p><blockquote>     } else {</blockquote></p>     <p><blockquote>      read(fd, &amp;ch, 1);</blockquote></p>     <p><blockquote>      sleep(5);</blockquote></p>     <p><blockquote>      printf("serving client on fd %d\n", fd);</blockquote></p>     <p><blockquote>      ch++;</blockquote></p>     <p><blockquote>      write(fd, &amp;ch, 1);</blockquote></p>     <p><blockquote>     }</blockquote></p>     <p><blockquote>    }</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote>}</blockquote></p>     <blockquote>      <b>Примечание</b>      <p>В реальную программу было бы неплохо вставить переменную, содержащую наибольший подключенный номер <blockquote>fd</blockquote> (необязательно самый последний подключенный номер <blockquote>fd</blockquote>). Это помешает просмотру в цикле тысяч номеров <blockquote>fd</blockquote>, которые даже не подсоединены и потенциально не могут быть готовы к чтению. Мы пропустили этот фрагмент кода для краткости и простоты примера.</p>     </blockquote>     <p>При запуске этой версии сервера многочисленные клиенты будут обрабатываться последовательно в единственном процессе.</p>     <p><blockquote>$ <b>./server5 &amp;</b></blockquote></p>     <p><blockquote>[1] 26686</blockquote></p>     <p><blockquote>server waiting</blockquote></p>     <p><blockquote>$ <b>./client3 &amp; ./client3 &amp; ./client3 &amp; ps x</b></blockquote></p>     <p><blockquote>[2] 26689</blockquote></p>     <p><blockquote>[3] 26690</blockquote></p>     <p><blockquote>adding client on fd 4</blockquote></p>     <p><blockquote>server waiting</blockquote></p>     <p><blockquote>[4] 26691</blockquote></p>     <p><blockquote>PID   TTY  STAT TIME COMMAND</blockquote></p>     <p><blockquote>26686 pts/1 S   0:00 ./server5</blockquote></p>     <p><blockquote>26689 pts/1 S   0:00 ./client3</blockquote></p>     <p><blockquote>26690 pts/1 S   0:00 ./client3</blockquote></p>     <p><blockquote>26691 pts/1 S   0:00 ./client3</blockquote></p>     <p><blockquote>26692 pts/1 R+  0:00 ps x</blockquote></p>     <p><blockquote>$ serving client on fd 4</blockquote></p>     <p><blockquote>server waiting</blockquote></p>     <p><blockquote>adding client on fd 5</blockquote></p>     <p><blockquote>server waiting</blockquote></p>     <p><blockquote>adding client on fd 6</blockquote></p>     <p><blockquote>char from server = В</blockquote></p>     <p><blockquote>serving client on fd 5</blockquote></p>     <p><blockquote>server waiting</blockquote></p>     <p><blockquote>removing client on fd 4</blockquote></p>     <p><blockquote>char from server = В</blockquote></p>     <p><blockquote>serving client on fd 6</blockquote></p>     <p><blockquote>server waiting</blockquote></p>     <p><blockquote>removing client on fd 5</blockquote></p>     <p><blockquote>server waiting</blockquote></p>     <p><blockquote>char from server = В</blockquote></p>     <p><blockquote>removing client on fd 6</blockquote></p>     <p><blockquote>server waiting</blockquote></p>     <p><blockquote>[2]  Done  ./client3</blockquote></p>     <p><blockquote>[3]- Done  ./client3</blockquote></p>     <p><blockquote>[4]+ Done  ./client3</blockquote></p>     <p>Для полноты аналогии, упомянутой в начале главы, в табл. 15.5 приведены параллели между соединениями на базе сокетов и телефонными переговорами.</p>     <br>     <p><i><b>Таблица 15.5</b></i></p>     <table>      <tr>       <th valign="top">Телефон</th>       <th valign="top">Сетевые сокеты</th>      </tr>      <tr>       <td valign="top">Звонок в компанию по номеру 555-0828</td>       <td valign="top">Подключение к IP-адресу 127.0.0.1</td>      </tr>      <tr>       <td valign="top">Ответ на звонок секретаря приемной</td>       <td valign="top">Установка соединения с <blockquote>remote host</blockquote></td>      </tr>      <tr>       <td valign="top">Просьба соединить с финансовым отделом.</td>       <td valign="top">Маршрутизация с помощью заданного порта (9734)</td>      </tr>      <tr>       <td valign="top">Ответ на звонок администратора финансового отдела</td>       <td valign="top">Вызов <blockquote>select</blockquote> вернул управление серверу</td>      </tr>      <tr>       <td valign="top">Звонок переадресован свободному менеджеру по работе с корпоративными заказчиками</td>       <td valign="top">Сервер вызывает <blockquote>accept</blockquote>, создавая новый сокет на добавочный номер 456</td>      </tr>     </table>              <a name="metkadoc20"><h1>Дейтаграммы</h1></a>    <p>В этой главе мы сосредоточились на программировании приложений, поддерживающих связь со своими клиентами с помощью TCP-соединений на базе сокетов. Существуют ситуации, в которых затраты на установку и поддержку соединения с помощью сокетов излишни.</p>    <p>Хорошим примером может служить сервис <blockquote>daytime</blockquote>, использованный ранее в программе getdate.c. Вы создаете сокет, выполняете соединение, читаете единственный ответ и разрываете соединение. Столько операций для простого получения даты!</p>    <p>Сервис <blockquote>daytime</blockquote> так же доступен с помощью UDP-соединений, применяющих дейтаграммы. Для того чтобы воспользоваться им, просто пошлите сервису одну дейтаграмму и получите в ответ единственную дейтаграмму, содержащую дату и время. Все просто.</p>    <p>Сервисы, предоставляемые по UDP-протоколу, применяются в тех случаях, когда клиенту нужно создать короткий запрос к серверу, и он ожидает единственный короткий ответ. Если стоимость времени процессора достаточно низкая, сервер способен обеспечить такой сервис, обрабатывая запросы клиентов по одному и разрешая операционной системе хранить очередь входящих запросов. Такой подход упрощает программирование сервера.</p>    <p>Поскольку UDP — не дающий гарантий сервис, вы можете столкнуться с потерей вашей дейтаграммы или ответа сервера. Если данные важны для вас, возможно, придется тщательно программировать ваших UDP-клиентов, проверяя ошибки и при необходимости повторяя попытки. На практике в локальных сетях UDP-дейтаграммы очень надежны.</p>    <p>Для доступа к сервису, обеспечиваемому UDP-протоколом, вам следует применять системные вызовы <blockquote>socket</blockquote> и <blockquote>close</blockquote>, но вместо использования вызовов <blockquote>read</blockquote> и <blockquote>write</blockquote> для сокета вы применяете два системных вызова, характерных для дейтаграмм: <blockquote>sendto</blockquote> и <blockquote>recvfrom</blockquote>.</p>    <p>Далее приведена модифицированная версия программы getdate.c, которая получает дату с помощью сервиса UDP-дейтаграмм. Изменения по сравнению с предыдущей версией выделены цветом.</p>    <p><blockquote>/* Начните с обычных include и объявлений. */</blockquote></p>    <p><blockquote>#include &lt;sys/socket.h&gt;</blockquote></p>    <p><blockquote>#include &lt;netinet/in.h&gt;</blockquote></p>    <p><blockquote>#include &lt;netdb.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>    <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>    <br>    <p><blockquote>int main(int argc, char *argv[]) {</blockquote></p>    <p><blockquote> char *host;</blockquote></p>    <p><blockquote> int sockfd;</blockquote></p>    <p><blockquote> int len, result;</blockquote></p>    <p><blockquote> struct sockaddr_in address;</blockquote></p>    <p><blockquote> struct hostent *hostinfo;</blockquote></p>    <p><blockquote> struct servent *servinfo;</blockquote></p>    <p><blockquote> char buffer[128];</blockquote></p>    <p><blockquote> if (argc == 1) host = "localhost";</blockquote></p>    <p><blockquote> else host = argv[1];</blockquote></p>    <p><blockquote> /* Ищет адрес хоста и сообщает об ошибке, если не находит. */</blockquote></p>    <p><blockquote> hostinfo = gethostbyname(host);</blockquote></p>    <p><blockquote> if (!hostinfo) {</blockquote></p>    <p><blockquote>  fprintf(stderr, "no host: %s\n", host);</blockquote></p>    <p><blockquote>  exit(1);</blockquote></p>    <p><blockquote> }</blockquote></p>    <p><blockquote> /* Проверяет наличие на компьютере сервиса daytime. */</blockquote></p>    <p><blockquote><i> servinfo = getservbyname("daytime", "udp");</i></blockquote></p>    <p><blockquote> if (!servinfo) {</blockquote></p>    <p><blockquote>  fprintf(stderr, "no daytime service\n");</blockquote></p>    <p><blockquote>  exit(1);</blockquote></p>    <p><blockquote> }</blockquote></p>    <p><blockquote> printf("daytime port is %d\n", ntohs(servinfo-&gt;s_port));</blockquote></p>    <p><blockquote><i> /* Создает UDP-сокет. */</i></blockquote></p>    <p><blockquote><i> sockfd = socket(AF_INEТ, SOCK_DGRAM, 0); </i></blockquote></p>    <p><blockquote><i> /* Формирует адрес для использования в вызовах sendto/recvfrom... */</i></blockquote></p>    <p><blockquote> address.sin_family = AF_INET;</blockquote></p>    <p><blockquote> address.sin_port = servinfo-&gt;s_port;</blockquote></p>    <p><blockquote> address.sin_addr = *(struct in_addr*)*hostinfo-&gt;h_addr_list;</blockquote></p>    <p><blockquote> len = sizeof(address);</blockquote></p>    <p><blockquote><i> result = sendto(sockfd, buffer, 1, 0, (struct sockaddr *)&amp;address, len);</i></blockquote></p>    <p><blockquote><i> result = recvfrom(sockfd, buffer, sizeof(buffer), 0,</i></blockquote></p>    <p><blockquote><i>  (struct sockaddr *)&amp;address, &amp;len);</i></blockquote></p>    <p><blockquote> buffer [result] = '\0';</blockquote></p>    <p><blockquote> printf("read %d bytes: %s", result, buffer);</blockquote></p>    <p><blockquote> close(sockfd);</blockquote></p>    <p><blockquote> exit(0);</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Как видите, необходимы лишь незначительные изменения. Как и раньше, вы ищете сервис <blockquote>daytime</blockquote> с помощью вызова <blockquote>getservbyname</blockquote>, но задаете дейтаграммный сервис, запрашивая UDP-протокол. Дейтаграммный сокет создается с помощью вызова <blockquote>socket</blockquote> с параметром <blockquote>SOCK_DGRAM</blockquote>. Адрес назначения задается, как и раньше, но теперь вместо чтения из сокета вы должны послать дейтаграмму.</p>    <p>Поскольку вы не устанавливаете явное соединение с сервисами на базе UDP, у вас должен быть способ оповещения сервера о том, что вы хотите получить ответ. В данном случае вы посылаете дейтаграмму (в нашем примере вы отправляете один байт из буфера, в который вы хотите получить ответ) сервису и он посылает в ответ дату и время.</p>    <p>Системный вызов <blockquote>sendto</blockquote> отправляет дейтаграмму из буфера на сокет, используя адрес сокета и длину адреса. У этого вызова фактически следующий прототип:</p>    <p><b><blockquote><b>int sendto(int sockfd, void *buffer, size_t len, int flags,</b></blockquote></b></p>    <p><b><blockquote><b> struct sockaddr *to, socklen_t tolen);</b></blockquote></b></p>    <p>В случае обычного применения параметр <blockquote>flags</blockquote> можно оставлять нулевым.</p>    <p>Системный вызов recvfrom ожидает дейтаграмму в соединении сокета с заданным адресом и помещает ее в буфер. У этого вызова следующий прототип:</p>    <p><b><blockquote><b>int recvfrom(int sockfd, void *buffer, size_t len, int flags,</b></blockquote></b></p>    <p><b><blockquote><b> struct sockaddr *from, socklen_t *fromlen);</b></blockquote></b></p>    <p>И снова в случае обычного применения параметр <blockquote>flags</blockquote> можно оставлять нулевым.</p>    <p>Для упрощения примера мы пропустили обработку ошибок. Оба вызова, <blockquote>sendto</blockquote> и <blockquote>recvfrom</blockquote>, в случае возникновения ошибки вернут -1 и присвоят переменной <blockquote>errno</blockquote> соответствующее значение. Возможные ошибки перечислены в табл. 15.6.</p>    <br>    <p><b><i>Таблица 15.6</i></b></p>    <table>     <tr>      <th valign="top">Значение <blockquote>errno</blockquote></th>      <th valign="top">Описание</th>     </tr>     <tr>      <td valign="top"><blockquote>EBADF</blockquote></td>      <td valign="top">Был передан неверный файловый дескриптор</td>     </tr>     <tr>      <td valign="top"><blockquote>EINTR</blockquote></td>      <td valign="top">Появился сигнал</td>     </tr>    </table>    <p>Если сокет не был определен как неблокирующийся с помощью вызова <blockquote>fcntl</blockquote> (как вы видели ранее для TCP-соединений), вызов <blockquote>recvfrom</blockquote> будет заблокирован на неопределенное время. Но сокет можно использовать с помощью вызова <blockquote>select</blockquote> и времени ожидания, позволяющих определить, поступили ли данные, так же, как в случае серверов с устанавливаемыми соединениями. В противном случае можно применить сигнал тревоги для прерывания операции получения данных <i>(см. главу 11).</i></p>          <a name="metkadoc21"><h1>Резюме </h1></a>    <p>В этой главе мы предложили еще один способ взаимодействия процессов — сокеты. Они позволяют разрабатывать по-настоящему распределенные клиент-серверные приложения, которые выполняются в сетевой среде. Было дано краткое описание некоторых информационных функций базы данных сетевых узлов и способы обработки в системе Linux стандартных системных сервисов с помощью интернет-демонов. Вы проработали ряд примеров клиент-серверных программ, демонстрирующих обработку и сетевую организацию множественных клиентов.</p>    <p>В заключение вы познакомились с системным вызовом <blockquote>select</blockquote>, позволяющим уведомлять программу об активности ввода и вывода сразу на нескольких открытых файловых дескрипторах и сокетах. </p>     <br><br>
<center><div align="center"><a href="index.php.html">Оглавление</a></div></center>




<br>
<script type="text/javascript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="https://www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script><br>

<noindex>
<div align="center">
<center>

<!-- SAPE RTB DIV 600x340 -->
<div id="SRTB_507029"></div>
<!-- SAPE RTB END -->

</center>
</div>
</noindex>

</td>
<td width="240" valign="top">

<br>

<div id="menu3">
<ul>
<li><a href="../../alternativnaja_medicina/index.html"><span>Альтернативная медицина</span></a></li>
<li><a href="../../astronomija_i_kosmos/index.html"><span>Астрономия и Космос</span></a></li>
<li><a href="../../biologija/index.html"><span>Биология</span></a></li>
<li><a href="../../voennaja_istorija/index.html"><span>Военная история</span></a></li>
<li><a href="../../geologija_i_geografija/index.html"><span>Геология и география</span></a></li>
<li><a href="../../gosudarstvo_i_pravo/index.html"><span>Государство и право</span></a></li>
<li><a href="../../delovaja_literatura/index.html"><span>Деловая литература</span></a></li>
<li><a href="../../domashnie_zhivotnye/index.html"><span>Домашние животные</span></a></li>
<li><a href="../../domovodstvo/index.html"><span>Домоводство</span></a></li>
<li><a href="../../zdorove/index.html"><span>Здоровье</span></a></li>
<li><a href="../../istorija/index.html"><span>История</span></a></li>
<li><a href="../index.html"><span>Компьютеры и Интернет</span></a></li>
<li><a href="../../kulinarija/index.html"><span>Кулинария</span></a></li>
<li><a href="../../kulturologija/index.html"><span>Культурология</span></a></li>
<li><a href="../../literaturovedenie/index.html"><span>Литературоведение</span></a></li>
<li><a href="../../matematika/index.html"><span>Математика</span></a></li>
<li><a href="../../medicina/index.html"><span>Медицина</span></a></li>
<li><a href="../../nauchnaja_literatura_prochee/index.html"><span>Науч. литер. - прочее</span></a></li>
<li><a href="../../pedagogika/index.html"><span>Педагогика</span></a></li>
<li><a href="../../politika/index.html"><span>Политика</span></a></li>
<li><a href="../../psihologija/index.html"><span>Психология</span></a></li>
<li><a href="../../religiovedenie/index.html"><span>Религиоведение</span></a></li>
<li><a href="../../sad_i_ogorod/index.html"><span>Сад и огород</span></a></li>
<li><a href="../../samosovershenstvovanie/index.html"><span>Самосовершенствование</span></a></li>
<li><a href="../../sdelai_sam/index.html"><span>Сделай сам</span></a></li>
<li><a href="../../sport/index.html"><span>Спорт</span></a></li>
<li><a href="../../tehnicheskie_nauki/index.html"><span>Технические науки</span></a></li>
<li><a href="../../transport_i_aviacija/index.html"><span>Транспорт и авиация</span></a></li>
<li><a href="../../uchebniki/index.html"><span>Учебники</span></a></li>
<li><a href="../../fizika/index.html"><span>Физика</span></a></li>
<li><a href="../../filosofija/index.html"><span>Философия</span></a></li>
<li><a href="../../himija/index.html"><span>Химия</span></a></li>
<li><a href="../../hobbi_i_remesla/index.html"><span>Хобби и ремесла</span></a></li>
<li><a href="../../shpargalki/index.html"><span>Шпаргалки</span></a></li>
<li><a href="../../yezoterika/index.html"><span>Эзотерика</span></a></li>
<li><a href="../../yurisprudencija/index.html"><span>Юриспруденция</span></a></li>
<li><a href="../../jazykoznanie/index.html"><span>Языкознание</span></a></li>
</ul>
</div>

<br>
<div align="center">
<center>
<noindex>

<!-- SAPE RTB DIV 240x400 -->
<div id="SRTB_507028"></div>
<!-- SAPE RTB END -->

</noindex>
</center>
</div>

</td>
</tr>
<tr>
<td colspan="3" align="center">


<hr>
<a href="../../index.html"><span>Главная</span></a> | 
<a rel="sidebar" href="p19.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a> | 
<a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a> | 
<a href="p19.php.html#" onClick="scroll(0,0); return false" title="наверх">Наверх</a>
</td>
</tr>
<tr>
<td colspan="3" valign="top" align="left">
<br>

 



</td>
</tr>
</table>

<noindex>
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter21717787 = new Ya.Metrika({id:21717787,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="http://mc.yandex.ru/watch/21717787" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

</noindex>
</center>
</div></body>
</html>