<html>
<head>
<meta http-equiv="Content-Language" content="ru">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<link href="../../0img/style.css" rel="stylesheet" type="text/css" />
<link rel="SHORTCUT ICON" href="http://www.redov.ru/0img/favicon.ico" type="image/x-icon"> 
<title>Глава 12 Потоки POSIX / Основы программирования в Linux</title>
</head>
<body>
<div align="center">
<center>
<table border="0" cellpadding="0" cellspacing="0" width="1260">
<tr>
<td colspan="3" valign="top" align="left" height="100">
<table border="0" cellpadding="0" cellspacing="0" width="1260" height="100">
<tr>
<td valign="middle" align="center" width="350">
<a href="../../index.html"><img src="../../0img/logo.jpg" width="350" height="100" title="Онлайн библиотека redov.ru"/></a>
</td>
<td valign="middle" align="center" width="910">

<noindex>

<!-- SAPE RTB JS -->
<script
    async="async"
    src="http://cdn-rtb.sape.ru/rtb-b/js/393/2/106393.js"
    type="text/javascript">
</script>
<!-- SAPE RTB END -->

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507025"></div>
<!-- SAPE RTB END -->

</noindex>

</td>
</tr>
</table>
</td>
</tr>
<tr>
<td colspan="3" valign="middle" align="left">

<div id="menu">
<ul>
		<li><a href="../../index.html"><span>Главная</span></a></li>
		<li><a rel="sidebar" href="p16.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a></li>
		<li><a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a></li>
		<li><a href="p16.php.html#" onClick="scroll(0,9999999); return false"><span>Вниз</span></a></li>
</ul>
</div>


</td>
</tr>
<tr>
<td width="240" valign="top" align="center">

<br>
<noindex>
<!-- SAPE RTB DIV 160x600 -->
<div id="SRTB_733378"></div>
<!-- SAPE RTB END -->
</noindex>



</td>
<td valign="top" align="left" style="padding-left: 5; padding-right: 5" width="780">
<br>
<noindex>
<div align="center">

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507027"></div>
<!-- SAPE RTB END -->

</div>
</noindex>
<br>



<li><a href="p16.php.html#metkadoc2">     Что такое поток?     </a></li>
<li><a href="p16.php.html#metkadoc3">     Достоинства и недостатки потоков     </a></li>
<li><a href="p16.php.html#metkadoc4">     Первая программа с применением потоков     </a></li>
<li><a href="p16.php.html#metkadoc5">     Одновременное выполнение     </a></li>
<li><a href="p16.php.html#metkadoc6">     Синхронизация     </a></li>
<li><a href="p16.php.html#metkadoc7">      Синхронизация с помощью семафоров      </a></li>
<li><a href="p16.php.html#metkadoc8">      Синхронизация с помощью мьютексов      </a></li>
<li><a href="p16.php.html#metkadoc9">     Атрибуты потока     </a></li>
<li><a href="p16.php.html#metkadoc10">      Атрибуты планирования потока      </a></li>
<li><a href="p16.php.html#metkadoc11">     Отмена потока     </a></li>
<li><a href="p16.php.html#metkadoc12">     Потоки в изобилии     </a></li>
<li><a href="p16.php.html#metkadoc13">     Резюме     </a></li>
<a name="metkadoc1"><h1>Глава 12</p>    <p>Потоки POSIX</h1></a>       <p>В<i> главе 11 </i>вы видели, как обрабатываются процессы в ОС Linux (и конечно в UNIX). Эти средства обработки множественных процессов долгое время были характерной чертой UNIX-подобных операционных систем. Порой бывает полезно заставить одну программу делать два дела одновременно или, по крайней мере, создать впечатление такой работы. А может быть, вы хотите, чтобы несколько событий произошло одновременно и все они были тесно связаны, но при этом накладные расходы на создание нового процесса с помощью функции <blockquote>fork</blockquote> считаете слишком большими. В таких ситуациях можно применить потоки, позволяющие одному процессу стать многозадачным.</p>    <p>В этой главе мы рассмотрим следующие темы:</p>    <p>&#9633; создание новых потоков в процессе;</p>    <p>&#9633; синхронизацию доступа к данным потоков одного процесса;</p>    <p>&#9633; изменение атрибутов потока;</p>    <p>&#9633; управление в одном и том же процессе одним потоком из другого.</p>          <a name="metkadoc2"><h1>Что такое поток?</h1></a>    <p>Множественные нити исполнения в одной программе называют<i> потоками. </i>Более точно поток — это последовательность или цикл управления в процессе. Все программы, которые вы видели до настоящего момента, выполняли единственный процесс, хотя, как и многие другие операционные системы, ОС Linux вполне способна выполнять множественные процессы одновременно. В действительности у всех процессов есть как минимум один поток исполнения. У всех процессов, с которыми вы пока познакомились в этой книге, был только один поток исполнения.</p>    <p>Важно понять разницу между системным вызовом fork и созданием новых потоков. Когда процесс выполняет системный вызов fork, создается новая копия процесса с ее собственными переменными и собственным PID. Время выполнения этого нового процесса планируется независимо и выполняется он (в основном) независимо от создавшего его процесса. Когда мы создаем в процессе новый поток, этот поток исполнения в противоположность новому процессу получает собственный стек (и, следовательно, локальные переменные), но использует совместно с создавшим его процессом глобальные переменные, файловые дескрипторы, обработчики сигналов и положение текущего каталога.</p>    <p>Идея потоков была популярна какое-то время, но пока Комитет IEEE POSIX не опубликовал некоторые стандарты, потоки не были широко распространены в UNIX-подобных операционных системах и существовавшие реализации разных поставщиков сильно отличались друг от друга. С появлением стандарта POSIX 1003.1c все изменилось; потоки теперь не только лучше стандартизованы, но также реализованы в большинстве дистрибутивов Linux. В наше время многоядерные процессоры стали обычными даже в настольных компьютерах, так что у большинства машин есть низкоуровневая аппаратная поддержка, позволяющая им выполнять несколько потоков одновременно. Раньше при наличии одноядерных ЦПУ одновременное исполнение потоков было лишь изобретательной, хотя и очень эффективной иллюзией.</p>    <p>Впервые ОС Linux обзавелась поддержкой потоков около 1996 г. благодаря появлению библиотеки, которую часто называют "LinuxThreads" (потоки Linux). Она почти соответствует стандарту POSIX (на самом деле в большинстве случаев отличия не заметны) и стала важным шагом на пути первого применения потоков программистами Linux. Но между реализацией потоков в Linux и стандартом POSIX есть слабые расхождения, в основном касающиеся обработки сигналов. Ограничения накладываются не столько реализацией библиотеки, сколько низкоуровневой поддержкой ядра Linux.</p>    <p>Разные проекты рассматривали возможности улучшения поддержки потоков в Linux, касающиеся не только устранения слабых расхождений со стандартом POSIX, но и повышения производительности и удаления любых ненужных ограничений. Основная работа была направлена на поиск способов отображения потоков пользовательского уровня на потоки уровня ядра системы. Двумя главными проектами были New Generation POSIX Threads (NGPT, потоки POSIX нового поколения) и Native POSIX Thread Library (NPTL, библиотека истинных потоков POSIX). Оба проекта должны были внести изменения в ядро Linux, обеспечивающие поддержку новых библиотек, и оба предлагали существенное повышение производительности по сравнению с прежней реализацией потоков в Linux.</p>    <p>В 2002 г. команда NGPT объявила, что не хочет разделять сообщество и приостанавливает разработку новых средств для проекта NGPT, но продолжит работу по улучшению поддержки потоков в ОС Linux, присоединив свои усилия к стараниям NPTL. Библиотека NPTL стала новым стандартом для потоков в Linux, выпустив первую основную версию в дистрибутиве Red Hat Linux 9. Вы можете найти интересную основополагающую информацию о NPTL в статье "The Native POSIX Thread Library for Linux" ("Библиотека истинных потоков POSIX для Linux") Ульриха Дреппера (Ulrich Drepper) и Инго Мольнара (Ingo Molnar), которая во время написания книги была доступна в Интернете по адресу <b>http://people.redhat.com/drepper/nptl-design.pdf</b>.</p>    <p>Большая часть программного кода из этой главы будет работать с любой библиотекой потоков, поскольку основана на стандарте POSIX, общем для всех библиотек потоков. Но вы сможете заметить небольшие отличия, если пользуетесь старой версией дистрибутива Linux, особенно когда примените команду <blockquote>ps</blockquote> для просмотра примеров во время их выполнения.</p>          <a name="metkadoc3"><h1>Достоинства и недостатки потоков</h1></a>    <p>В определенных обстоятельствах создание нового потока обладает явно выраженными преимуществами по сравнению с созданием нового процесса. Накладные расходы при создании нового потока существенно меньше, чем при создании нового процесса (несмотря на то, что создание новых процессов в Linux очень эффективно по сравнению с другими операционными системами).</p>    <p>Далее перечислены некоторые достоинства потоков.</p>    <p>&#9633; Иногда очень полезно создать программу, которая выполняет два дела одновременно. Классический пример — подсчет в режиме реального времени слов в документе в ходе редактирования текста. Один поток может управлять пользовательским вводом и выполнять редактирование. Другой, способный видеть то же содержимое документа, может непрерывно обновлять переменную-счетчик количества слов. Первый поток (или даже третий) может использовать эту переменную для информирования пользователя. Другой пример — многопоточный сервер базы данных, в котором единый наблюдаемый процесс обслуживает множество клиентов, улучшая общую пропускную способность за счет обслуживания одних запросов и одновременной блокировки других, ожидающих готовности диска. Серверу базы данных реализовать эту скрытую многозадачность в разных процессах очень трудно, т.к. требования блокировки и непротиворечивости данных приводят к тесной связи двух этих процессов. С помощью множественных потоков воплотить в жизнь этот алгоритм гораздо легче.</p>    <p>&#9633; Производительность приложения, в котором смешаны ввод, вычисления и вывод, можно повысить, запустив эти операции как три отдельных потока. Пока поток ввода или вывода ждет подсоединения, один из оставшихся потоков может продолжить вычисления. Серверное приложение, обрабатывающее многочисленные сетевые подключения, также может подойти для организации программы с множественными потоками.</p>    <p>&#9633; Сейчас, когда многоядерные ЦПУ обычны в настольных и портативных компьютерах, применение множественных потоков внутри процесса может при наличии подходящего приложения позволить одному процессу лучше использовать доступные аппаратные ресурсы.</p>    <p>&#9633; Вообще переключение между потоками требует от операционной системы гораздо меньше усилий, чем переключение между процессами. Таким образом, множественные потоки гораздо менее требовательны к ресурсам, чем множественные процессы, и с ними гораздо практичнее выполнять в однопроцессорных системах программы, логика которых требует применения нескольких потоков исполнения. Считается, что трудности разработки при написании многопоточной программы весьма значительны, и это утверждение нельзя не принимать всерьез.</p>    <p>У потоков есть и недостатки.</p>    <p>&#9633; Создание многопоточной программы требует очень тщательной разработки. Вероятность появления незначительных временных сбоев или ошибок, вызванных нечаянным совместным использованием переменных, в такой программе весьма значительна. Алан Кокс (Alan Сох, всеми уважаемый гуру Linux) сказал, что потоки равнозначны умению "выстрелить в обе собственные ноги одновременно".</p>    <p>&#9633; Отладка многопоточной программы гораздо труднее, чем отладка одного потока исполнения, поскольку взаимосвязи потоков очень трудно контролировать.</p>    <p>&#9633; Программа, в которой громоздкие вычисления разделены на две части, и эти две части выполняются как отдельные потоки, необязательно будет работать быстрее на машине с одним процессором, если только вычисление не позволяет выполнять обе ее части одновременно и у машины, на которой выполняется программа, нет многоядерного процессора для поддержки истинной многопоточности.</p>          <a name="metkadoc4"><h1>Первая программа с применением потоков</h1></a>    <p>Существует целый ряд библиотечных вызовов, связанных с потоками, большинство имен которых начинается с префикса pthread. Для применения этих библиотечных вызовов вы должны определить макрос <blockquote>_REENTRANT</blockquote>, включить файл pthread.h и скомпоновать программу с библиотекой потоков, используя опцию <blockquote>-lpthread</blockquote>.</p>    <p>Когда разрабатывались первые версии библиотечных подпрограмм UNIX и POSIX, предполагалось, что в каждом процессе будет только один поток исполнения. Яркий пример — переменная <blockquote>errno</blockquote>, применяемая для хранения сведений об ошибке после аварийного завершения вызова. В многопоточной программе по умолчанию будет одна переменная <blockquote>errno</blockquote>, совместно используемая всеми потоками. Переменная может легко быть изменена вызовом в одном потоке до того, как другой поток успеет извлечь код предыдущей ошибки. Аналогичные проблемы есть и у функций, таких как <blockquote>fputs</blockquote>, которые, как правило, используют одну глобальную область для буферизации вывода.</p>    <p>Вам нужны реентерабельные подпрограммы. Реентерабельный программный код может вызываться несколько раз либо разными потоками, либо каким-то образом вложенными вызовами и при этом работать корректно. Следовательно, реентерабельная часть программного кода обычно должна применять локальные переменные таким образом, чтобы любой и каждый вызов кода получал собственную уникальную копию данных.</p>    <p>В многопоточных программах вы сообщаете компилятору, что вам нужно это средство, определяя в вашей программе макрос <blockquote>_REENTRANT</blockquote> до любых директив <blockquote>#include</blockquote>. При этом делаются три вещи и столь искусно, что обычно вам даже не нужно знать, какая работа проделана.</p>    <p>&#9633; Некоторые функции получают безопасный реентерабельный вариант прототипа или объявления. При этом имя функции остается обычно прежним, но в конце добавляется суффикс <blockquote>_r</blockquote>, например функция <blockquote>gethostbyname</blockquote> заменяется функцией <blockquote>gethostbyname_r</blockquote>.</p>    <p>&#9633; Некоторые функции из файла stdio.h, которые обычно реализованы как макросы, становятся соответствующими реентерабельными безопасными функциями.</p>    <p>&#9633; Переменная <blockquote>errno</blockquote> из файла errno.h заменяется вызовом функции, которая может определить действительное значение <blockquote>errno</blockquote> безопасным образом с точки зрения многопоточности.</p>    <p>Включение файла pthread.h предоставляет другие прототипы и определения, которые нужны в вашем программном коде, во многом так же, как делает stdio.h для подпрограмм стандартного ввода и вывода. В заключение следует убедиться в том, что вы включили в программу соответствующий заголовочный файл потоков и скомпоновали программу с подходящей библиотекой потоков, в которой реализованы функции семейства <blockquote>pthread</blockquote>. Позже в упражнении данного раздела приведены подробности, касающиеся компиляции вашей программы, но сначала рассмотрим новые функции, необходимые для управления потоками. Функция <blockquote>pthread_create</blockquote> создает новый поток во многом так же, как функция <blockquote>fork</blockquote> создает новый процесс.</p>    <p><blockquote><b>#include &lt;pthread.h&gt;</b></blockquote></p>    <p><blockquote><b>int pthread_create(pthread_t * thread, pthread_attr_t *attr,</b></blockquote></p>    <p><blockquote><b> void *(*start_routine)(void *), void *arg);</b></blockquote></p>    <p>Прототип выглядит внушительно, но функцию очень легко применять. Первый аргумент — указатель на переменную типа <blockquote>pthread_t</blockquote>. Когда поток создан, в область памяти, на которую указывает эта переменная, записывается идентификатор. Этот идентификатор позволяет ссылаться на поток. Следующий аргумент задает атрибуты потока. Обычно нет нужды в особых атрибутах, и вы можете просто передать в этом аргументе <blockquote>NULL</blockquote>. Позже в этой главе вы увидите, как применять атрибуты потока. В последних двух аргументах потоку передается функция, которую он должен начать выполнять, и аргументы, которые нужно передать этой функции.</p>    <p><blockquote>void *(*start_routine)(void *)</blockquote></p>    <p>Предыдущая строка просто говорит о том, что вы должны передать адрес функции, принимающей бестиповой указатель <blockquote>void</blockquote> как параметр, и функция вернет указатель на <blockquote>void</blockquote>. Следовательно, вы можете передать единственный аргумент любого типа и вернуть указатель на любой тип. Применение функции <blockquote>fork</blockquote> заставит продолжить выполнение в том же месте, но с другим кодом возврата, в то время как использование нового потока непосредственно предоставит указатель на функцию, которую новый поток должен начать выполнять.</p>    <p>Возвращаемое значение равно 0 в случае успеха и номеру ошибки, если что-то пошло не так. В интерактивном справочном руководстве есть подробная информация об ошибочных ситуациях для этой и других функций, применяемых в данной главе.</p>    <blockquote>     <b>Примечание</b>     <p><blockquote>pthread_create</blockquote> как большинство функций семейства <blockquote>pthread_</blockquote> относится к тем немногим функциям Linux, которые не соблюдают соглашение об использовании значения -1 для обозначения ошибок. Если нет полной уверенности, всегда безопаснее всего дважды проверить справочное руководство перед проверкой кода возврата.</p>    </blockquote>    <p>Когда поток завершается, он вызывает функцию <blockquote>pthread_exit</blockquote>, во многом так же, как процесс во время завершения вызывает <blockquote>exit</blockquote>. Функция завершает вызванный поток, возвращая указатель на объект. Никогда не применяйте ее для возврата указателя на локальную переменную, потому что переменная перестает существовать, когда поток завершается, вызывая серьезную ошибку. Функция <blockquote>pthread_exit</blockquote> объявляется следующим образом:</p>    <p><blockquote><b>#include &lt;рthread.h&gt;</b></blockquote></p>    <p><blockquote><b>void pthread_exit(void *retval);</b></blockquote></p>    <p>Функция <blockquote>pthread_join</blockquote> — эквивалент функции <blockquote>wait</blockquote>, которую процессы применяют для ожидания дочерних процессов. Она объявляется так:</p>    <p><blockquote><b>#include &lt;рthread.h&gt;</b></blockquote></p>    <p><blockquote><b>int pthread_join(pthread_t th, void** thread_return);</b></blockquote></p>    <p>Первый параметр — это поток, который следует ждать, идентификатор, который для вас добывает функция <blockquote>pthread_create</blockquote>. Второй аргумент — указатель на указатель, который указывает на возвращаемое из потока значение. Как и <blockquote>pthread_create</blockquote>, эта функция возвращает ноль в случае успешного завершения и код ошибки при сбое.</p>    <p>Выполните упражнение 12.1.</p>    <b>Упражнение 12.1. Простая программа с потоками</b>    <p>Данная программа создает один дополнительный поток, показывает, что он совместно с исходным потоком использует переменные и заставляет новый поток вернуть результат исходному потоку. Далее приведена программа thread1.с.</p>    <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>    <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>    <p><blockquote>#include &lt;string.h&gt;</blockquote></p>    <p><blockquote>#include &lt;pthread.h&gt;</blockquote></p>    <br>    <p><blockquote>void *thread_function(void *arg);</blockquote></p>    <p><blockquote>char message[] = "Hello World";</blockquote></p>    <br>    <p><blockquote>int main() {</blockquote></p>    <p><blockquote> int res;</blockquote></p>    <p><blockquote> pthread_t a_thread;</blockquote></p>    <p><blockquote> void *thread_result;</blockquote></p>    <p><blockquote> res = pthread_create(&amp;a_thread, NULL, thread_function, (void *)message);</blockquote></p>    <p><blockquote> if (res ! = 0) {</blockquote></p>    <p><blockquote>  perror("Thread creation failed");</blockquote></p>    <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>    <p><blockquote> }</blockquote></p>    <p><blockquote> printf("Waiting for thread to finish...\n");</blockquote></p>    <p><blockquote> res = pthread_join(a_thread, &amp;thread_result);</blockquote></p>    <p><blockquote> if (res != 0) {</blockquote></p>    <p><blockquote>  perror("Thread join-failed");</blockquote></p>    <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>    <p><blockquote> }</blockquote></p>    <p><blockquote> printf("Thread-joined, it returned %s\n", (char *)thread_result);</blockquote></p>    <p><blockquote> printf("Message is now %s\n", message);</blockquote></p>    <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>    <p><blockquote>}</blockquote></p>    <br>    <p><blockquote>void *thread_function(void *arg) {</blockquote></p>    <p><blockquote> printf("thread_function is running. Argument was %s\n", (char *)arg);</blockquote></p>    <p><blockquote> sleep(3);</blockquote></p>    <p><blockquote> strcpy(message, "Bye!");</blockquote></p>    <p><blockquote> pthread_exit("Thank you for the CPU time");</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Итак:</p>    <p>1. Перед компиляцией программы вы должны убедиться в том, что определен макрос <blockquote>_REENTRANT</blockquote>. В некоторых системах вы также должны определить <blockquote>_POSIX_C_SOURCE</blockquote>, но обычно в этом нет необходимости.</p>    <p>2. Далее вы должны убедиться в том, что программа скомпонована с подходящей библиотекой потоков. В случае маловероятной ситуации применения старой версии дистрибутива Linux, в которой NPTL не является библиотекой потоков по умолчанию, возможно, у вас возникнет желание обновить ее, хотя большая часть программного кода, приведенного в этой главе, совместима со старой реализацией потоков в Linux. Легкий способ проверить — заглянуть в файл /usr/include/pthread.h. Если в этом файле приведен в качестве даты авторского права (copyright date) 2003 г. или более поздний, почти наверняка у вас реализация NPTL. Если указана более ранняя дата, может быть, самое время получить современную версию дистрибутива Linux.</p>    <p>3. Определив и установив нужные файлы, вы можете откомпилировать и скомпоновать вашу программу следующим образом:</p>    <p><blockquote>$ <b>cc -D_REENTRANT -I/usr/include/nptl threadl.с -о thread1 -L/usr/lib/nptl -lpthread</b></blockquote></p>    <blockquote>     <b>Примечание</b>     <p>Если в вашей системе по умолчанию установлена NPTL (что очень вероятно), почти наверняка вам не нужны опции <blockquote>-I</blockquote> и <blockquote>-L</blockquote>, и можно применить более простой вариант:</p>     <p><blockquote>$ <b>cc -D_REENTRANT thread1.с -о thread1 -lpthread</b></blockquote></p>     <p>В данной главе мы будем применять этот более простой вариант строки компиляции.</p>    </blockquote>    <p>4. Когда вы выполните эту программу, то увидите следующие строки:</p>    <p><blockquote>$ <b>./thread1</b></blockquote></p>    <p><blockquote>Waiting for thread to finish...</blockquote></p>    <p><blockquote>thread_function is running. Argument was Hello World</blockquote></p>    <p><blockquote>Thread joined, it returned Thank you for the CPU time</blockquote></p>    <p><blockquote>Message is now Bye!</blockquote></p>    <p>Стоит потратить немного времени на анализ данной программы, поскольку мы будем использовать ее как основу в большинстве примеров этой главы.</p>    <p><b>Как это работает</b></p>    <p>Вы объявляете прототип функции, которую вызовет поток, когда вы его создадите:</p>    <p><blockquote>void *thread_function(void *arg);</blockquote></p>    <p>Как требует функция <blockquote>pthread_create</blockquote>, данная функция принимает в качестве своего единственного параметра указатель на <blockquote>void</blockquote> и возвращает указатель на <blockquote>void</blockquote>. (Мы перейдем к реализации <blockquote>thread_function</blockquote> через минуту.)</p>    <p>В функции <blockquote>main</blockquote> объявлено несколько переменных и затем осуществляется вызов функции <blockquote>pthread_create</blockquote>, чтобы начать выполнение нового потока.</p>    <p><blockquote>pthread_t a_thread;</blockquote></p>    <p><blockquote>void *thread_result;</blockquote></p>    <p><blockquote>res = pthread_create(&amp;a_thread, NULL, thread_function, (void *)message);</blockquote></p>    <p>Вы передаете адрес объекта типа <blockquote>pthread_t</blockquote>, который можете применять в дальнейшем для ссылки на поток. Вы не хотите менять атрибуты потока, заданные по умолчанию, поэтому во втором параметре передаете <blockquote>NULL</blockquote>. Последние два параметра — вызываемая функция и передаваемый ей параметр.</p>    <p>Если вызов завершился нормально, теперь выполняются два потока. Исходный поток (<blockquote>main</blockquote>) продолжается и выполняет код, расположенный следом за функцией <blockquote>pthread_create</blockquote>, а новый поток начинает выполнение в функции, образно названной <blockquote>thread_function</blockquote>.</p>    <p>Исходный поток проверяет, запустился ли новый поток, и затем вызывает функцию <blockquote>pthread_join</blockquote>:</p>    <p><blockquote>res = pthread_join(a_thread, &amp;thread_result);</blockquote></p>    <p>Здесь вы передаете идентификатор потока, который ждете, чтобы присоединить, и указатель на результат. Эта функция, прежде чем вернуть управление, будет ждать, пока другой поток не завершится. Затем она выводит возвращаемое из потока значение и содержимое переменной и завершается.</p>    <p>Новый поток начинает выполнение, запуская функцию <blockquote>thread_function</blockquote>, которая выводит свои аргументы, засыпает на короткий период, обновляет глобальные переменные и затем завершается, возвращая строку в поток <blockquote>main</blockquote>. Новый поток пишет в тот же массив <blockquote>message</blockquote>, к которому у исходного потока есть доступ. Если бы вы вызвали функцию <blockquote>fork</blockquote> вместо <blockquote>pthread_create</blockquote>, массив представлял бы собой копию массива <blockquote>message</blockquote>, а не сам массив.</p>          <a name="metkadoc5"><h1>Одновременное выполнение</h1></a>    <p>В упражнении 12.2 показано, как написать программу, которая проверяет одновременное выполнение двух потоков. (Вы, конечно, применяете однопроцессорную систему, ЦП будет искусно переключаться между потоками, а не одновременно выполнять оба потока, используя отдельные ядра процессора аппаратными средствами.) Поскольку вы не встречались еще с какими-либо функциями синхронизации потоков, это будет очень неэффективная программа, делающая нечто, именуемое <i>опросом </i>(polling) двух потоков. И снова вы воспользуетесь тем, что все, за исключением локальных переменных функции, совместно используется двумя потоками в процессе.</p>    <b>Упражнение 12.2. Одновременное выполнение двух потоков</b>    <p>Программа thread2.c в этом упражнении создается за счет небольших изменений программы thread1.c. Вы добавите дополнительную глобальную переменную для определения выполняющегося потока.</p>    <blockquote>     <b>Примечание</b>     <p>Файлы с полными текстами примеров можно загрузить с Web-сайта книги.</p>    </blockquote>    <p><blockquote>int run_now = 1;</blockquote></p>    <p>Задайте <blockquote>run_now</blockquote> равной 1, когда выполняется функция <blockquote>main</blockquote>, и 2, когда выполняется новый поток.</p>    <p>В функцию <blockquote>main</blockquote> после создания нового потока добавьте следующий код:</p>    <p><blockquote>int print_count1 = 0;</blockquote></p>    <p><blockquote>while (print_count1+ &lt; 20) {</blockquote></p>    <p><blockquote> if (run_now == 1) {</blockquote></p>    <p><blockquote>  printf("1");</blockquote></p>    <p><blockquote>  run_now = 2;</blockquote></p>    <p><blockquote> } else {</blockquote></p>    <p><blockquote>  sleep(1);</blockquote></p>    <p><blockquote> }</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Если переменная <blockquote>run_now</blockquote> равна 1, выведите "1" и присвойте переменной значение 2. В противном случае вы на короткое время засыпаете и снова проверяете значение. Вы ждете, пока значение изменится на 1, проверяя время от времени снова. Этот прием называется<i> циклам активного</i> или<i> деятельного ожидания</i> (busy wait), несмотря, на то, что в данном случае программа засыпает на секунду между очередными проверками. Позже в этой главе вы увидите, как сделать это лучше.</p>    <p>В функции <blockquote>thread_function</blockquote>, где выполняется ваш новый поток, вы делаете примерно то же самое, но с противоположными значениями.</p>    <p><blockquote>int print_count2 = 0;</blockquote></p>    <p><blockquote>while (print_count2++ &lt; 20) {</blockquote></p>    <p><blockquote> if (run_now == 2) {</blockquote></p>    <p><blockquote>  printf("2");</blockquote></p>    <p><blockquote>  run_now = 1;</blockquote></p>    <p><blockquote> } else {</blockquote></p>    <p><blockquote>  sleep(1);</blockquote></p>    <p><blockquote> }</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Вы удаляете переданные параметр и возвращаемое значение, т.к. они вас больше не интересуют.</p>    <p>Когда вы выполните программу, то увидите следующий вывод. (Вы можете обнаружить, что для формирования вывода, особенно на машине с одноядерным ЦП, программе потребуется несколько секунд.)</p>    <p><blockquote>$ <b>cc -D_REENTRANT thread2.с -о thread2 -lpthread</b></blockquote></p>    <p><blockquote>$ <b>./thread2</b></blockquote></p>    <p><blockquote>12121212121212121212</blockquote></p>    <p><blockquote>Waiting for thread to finish...</blockquote></p>    <p><blockquote>Thread joined</blockquote></p>    <p><b>Как это работает</b></p>    <p>Каждый поток заставляет другой поток выполняться, задавая переменную <blockquote>run_now</blockquote> и затем ожидая, пока другой поток не изменит значение, чтобы можно было продолжить выполнение. Из программы видно, что выполнение переходит от одного потока к другому автоматическими кроме того, она демонстрирует точку, совместно используемую обоими потоками, — переменную <blockquote>run_now</blockquote>.</p>          <a name="metkadoc6"><h1>Синхронизация</h1></a>         <p>В предыдущем разделе вы видели, что два потока выполняются одновременно, но метод переключения между ними топорный и очень неэффективный. К счастью, существует ряд функций, специально разработанных для предоставления лучших способов управления исполнением потоков и доступа к важным фрагментам кода.</p>     <p>В этом разделе мы рассмотрим два основных метода:<i> семафоры,</i> действующие как сторожа, охраняющие фрагменты кода, и мьютексы или исключающие семафоры, действующие как устройство взаимного исключения (отсюда и имя — исключающий семафор) для защиты фрагментов программного кода. На самом деле эти методы похожи, и один может быть описан в терминах другого. Тем не менее существуют ситуации, в которых семантика проблемы делает один более выразительным, чем другой. Например, управление доступом к некоторой области совместно используемой памяти, к которой может обращаться только один поток в каждый момент времени, более естественным кажется исключающий семафор или мьютекс. Для управления доступом к ряду идентичных объектов в целом, например, предоставление потоку одной телефонной линии из набора, включающего пять доступных линий, больше подходит семафор. Какой метод выберите вы, зависит от личных предпочтений и наиболее подходящего для вашей программы алгоритма.</p>             <a name="metkadoc7"><h1>Синхронизация с помощью семафоров</h1></a>     <p>Для семафоров есть два набора интерфейсных функций: один взят из POSIX Realtime Extensions (дополнения POSIX для режима реального времени) и применяется для потоков, а другой, известный как семафоры System V, обычно применяется для синхронизации процессов. (Мы обсудим второй тип в<i> главе 14.)</i> Оба набора не гарантируют взаимозаменяемости и хотя очень похожи, используют вызовы разных функций.</p>     <p>Дейкстра, голландский ученый, специалист по компьютерным наукам, первым сформулировал идею семафоров.<i> Семафор</i> — это переменная особого типа, которая может изменяться с положительным или отрицательным приращением, но обращение к переменной в ответственный момент всегда атомарно даже в многопоточных программах. Это означает, что если два потока (или несколько) в программе пытаются изменить значение семафора, система гарантирует, что все операции будут на самом деле выполняться одна за другой. В случае обычных переменных результат конфликтных операций разных потоков в одной программе произволен.</p>     <p>В этом разделе мы рассмотрим простейший тип семафора, двоичный или бинарный семафор, который принимает только значения 0 и 1. Существует и более обобщенный вид семафора, считающий (counting) семафор, принимающий более широкий диапазон значений. Обычно семафоры используются для защиты фрагмента программного кода, так чтобы только один поток исполнения мог изменить его в любой конкретный момент времени. Для этого нужен двоичный семафор. Порой вам необходимо разрешить ограниченному числу потоков выполнять заданный фрагмент кода, для этого вам следует применять считающий семафор. Поскольку считающие семафоры гораздо менее популярны, мы не будем их обсуждать в дальнейшем, отметив лишь, что они представляют собой логическое расширение двоичного семафора и что реальные вызовы функций должны быть идентичны.</p>     <p>Имена функций семафоров начинаются не с префикса <blockquote>pthread_</blockquote>, как большинство функций, относящихся к потокам, а с <blockquote>sem_</blockquote>. Для работы с потоками применяют четыре базовые функций семафоров. Они все очень просты.</p>     <p>Семафор создается с помощью функции <blockquote>sem_init</blockquote>, которая объявляется следующим образом.</p>     <p><blockquote><b>#include &lt;semaphore.h&gt;</b></blockquote></p>     <p><blockquote><b>int sem_init(sem_t *sem, int pshared, unsigned int value);</b></blockquote></p>     <p>Эта функция инициализирует объект-семафор, на который указывает параметр <blockquote>sem</blockquote>, задает вариант его совместного использования (который мы обсудим через минуту) и присваивает ему начальное целочисленное значение. Параметр <blockquote>pshared</blockquote> управляет типом семафора. Если <blockquote>pshared</blockquote> равен 0, семафор локален по отношению к текущему процессу. В противном случае семафор может быть совместно использован разными процессами. Нас сейчас интересуют семафоры, которые не используются совместно разными процессами. Во время написания книги ОС Linux не поддерживала такое совместное использование и передача ненулевого значения параметру <blockquote>pshared</blockquote> приводила к аварийному завершению вызова.</p>     <p>Следующая пара функций управляет значением семафора и объявляется следующим образом.</p>     <p><blockquote><b>#include &lt;semaphore.h&gt;</b></blockquote></p>     <p><blockquote><b>int sem_wait(sem_t* sem);</b></blockquote></p>     <p><blockquote><b>int sem_post(sem_t* sem);</b></blockquote></p>     <p>Обе они принимают указатель на объект-семафор, инициализированный вызовом <blockquote>sem_init</blockquote>.</p>     <p>Функция <blockquote>sem_post</blockquote> атомарно увеличивает значение семафора на 1. Атомарно в данном случае означает, что если два потока одновременно пытаются увеличить значение единственного семафора на 1, они не мешают друг другу, как в случае двух программ, которые читают, увеличивают и записывают значение в файл в одно и то же время. Если обе программы пытаются увеличить значение на 1, семафор всегда будет корректно увеличивать значение на 2.</p>     <p>Функция <blockquote>sem_wait</blockquote> атомарно уменьшает значение семафора на единицу, но всегда ждет до тех пор, пока сначала счетчик семафора не получит ненулевое значение. Таким образом, если вы вызываете <blockquote>sem_wait</blockquote> для семафора со значением 2, поток продолжит выполнение, а семафор будет уменьшен до 1. Если <blockquote>sem_wait</blockquote> вызывается для семафора со значением 0, функция будет ждать до тех пор, пока какой-нибудь другой поток не увеличит значение, и оно станет ненулевым. Если оба потока ждут в функции <blockquote>sem_wait</blockquote>, чтобы один и тот же семафор стал ненулевым, и он увеличивается когда-нибудь третьим потоком, только один из двух ждущих потоков получит возможность уменьшить семафор и продолжиться; другой поток так и останется ждущим. Эта атомарная способность "проверить и установить" в одной функции и делает семафор столь ценным.</p>     <blockquote>      <b>Примечание</b>      <p>Есть и другая функция семафора <blockquote>sem_trywait</blockquote> — это неблокирующий партнер <blockquote>sem_wait</blockquote>. Мы не будем ее обсуждать в книге в дальнейшем, дополнительную информацию см. в интерактивном справочном руководстве.</p>     </blockquote>     <p>Последняя функция семафоров — <blockquote>sem_destroy</blockquote>. Она очищает семафор, когда вы закончили работу с ним, и объявляется следующим образом:</p>     <p><blockquote><b>#include &lt;semaphore.h&gt;</b></blockquote></p>     <p><blockquote><b>int sem_destroy(gem_t* sem);</b></blockquote></p>     <p>И снова эта функция принимает указатель на семафор и очищает любые ресурсы, которые у него могли быть. Если вы попытаетесь уничтожить семафор, которого дожидается какой-либо поток, то получите ошибку.</p>     <p>Как и большинство других, функций, все перечисленные функции возвращают 0 в случае успешного завершения.</p>     <p>А теперь выполните упражнение 12.3.</p>     <b>Упражнение 12.3. Семафор потока</b>     <p>Текст этой программы thread3.c также основан на тексте программы thread1.c. Поскольку изменения значительны, мы приводим новый вариант полностью.</p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <p><blockquote>#include &lt;pthread.h&gt;</blockquote></p>     <p><blockquote>#include &lt;semaphore.h&gt;</blockquote></p>     <br>     <p><blockquote>void *thread_function(void *arg);</blockquote></p>     <p><blockquote>sem_t bin_sem;</blockquote></p>     <br>     <p><blockquote>#define WORK_SIZE 1024</blockquote></p>     <p><blockquote>char work_area[WORK_SIZE];</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int res;</blockquote></p>     <p><blockquote> pthread_t a_thread;</blockquote></p>     <p><blockquote> void *thread result;</blockquote></p>     <p><blockquote> res = sem_init(&amp;bin_sem, 0, 0);</blockquote></p>     <p><blockquote> if (res != 0) {</blockquote></p>     <p><blockquote>  perror("Semaphore initialization failed");</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> res = pthread_create(&amp;a_thread, NULL, thread_function, NULL);</blockquote></p>     <p><blockquote> if (res != 0) {</blockquote></p>     <p><blockquote>  perror("Thread creation failed");</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> printf("Input some text. Enter 'end' to finish\n");</blockquote></p>     <p><blockquote> while (strncmp("end", work_area, 3) != 0) {</blockquote></p>     <p><blockquote>  fgets(work_area, WORK_SIZE, stdin);</blockquote></p>     <p><blockquote>  sem_post(&amp;bin_sem);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> printf("\nWaiting for thread to finish...\n");</blockquote></p>     <p><blockquote> res = pthread_join(a_thread, &amp;thread_result);</blockquote></p>     <p><blockquote> if (res != 0) {</blockquote></p>     <p><blockquote>  perror("Thread join failed");</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> printf("Thread joined\n");</blockquote></p>     <p><blockquote> sem_destroy(&amp;bin_sem);</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote>void *thread function(void *arg) { sem_wait(&amp;bin_sem);</blockquote></p>     <p><blockquote> while(strncmp("end", work area, 3) != 0) {</blockquote></p>     <p><blockquote>  printf("You input %d characters\n", strlen(work_area)-1);</blockquote></p>     <p><blockquote>  sem_wait(&amp;bin_sem);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> pthread_exit(NULL);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Первое важное изменение — включение файла semaphore.h для обеспечения доступа к функциям семафоров. Далее вы объявляете семафор и несколько переменных и инициализируете семафор<i> перед</i> тем, как создать новый поток.</p>     <p><blockquote>sem_t bin_sem;</blockquote></p>     <p><blockquote>#define WORK_SIZE 1024</blockquote></p>     <p><blockquote>char work_area[WORK_SIZE];</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int res;</blockquote></p>     <p><blockquote> pthread_t a_thread;</blockquote></p>     <p><blockquote> void *thread_result;</blockquote></p>     <p><blockquote> res = sem_init(&amp;bin_sem, 0, 0);</blockquote></p>     <p><blockquote> if (res != 0) {</blockquote></p>     <p><blockquote>  perror("Semaphore initialization failed");</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p>Обратите внимание на то, что начальное значение семафора равно 0.</p>     <p>В функции <blockquote>main</blockquote>, после того как вы запустили новый поток, вы читаете некоторый текст с клавиатуры, загружаете вашу рабочую область и затем наращиваете счетчик семафора с помощью <blockquote>sem_post</blockquote>:</p>     <p><blockquote> printf("Input some text. Enter 'end' to finish\n");</blockquote></p>     <p><blockquote> while(strncmp("end", work_area, 3) != 0) {</blockquote></p>     <p><blockquote>  fgets(work_area, WORK_SIZE, stdin);</blockquote></p>     <p><blockquote>  sem_post(&amp;bin_sem);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p>В новом потоке вы ждете семафор и затем подсчитываете символы ввода:</p>     <p><blockquote> sem_wait(&amp;bin_sem);</blockquote></p>     <p><blockquote> while(strncmp("end", work_area, 3) != 0) {</blockquote></p>     <p><blockquote>  printf("You input %d characters\n", strlen(work_area)-1);</blockquote></p>     <p><blockquote>  sem_wait(&amp;bin_sem);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p>Пока семафор установлен, вы ждете ввода с клавиатуры. Когда вы получите некоторый ввод, то освобождаете семафор, разрешив второму потоку сосчитать символы перед тем, как первый поток начнет снова считывать ввод с клавиатуры.</p>     <p>И опять потоки совместно используют один и тот же массив <blockquote>work_area</blockquote>. Для того чтобы программный код был короче и за ним легче было следить, мы опять пропустили некоторые проверки ошибок, например значения, возвращаемые из функции <blockquote>sem_wait</blockquote>. Но в рабочем программном коде вы всегда должны проверять ошибочные возвращаемые значения, если нет достаточных оснований для отказа от проверки.</p>     <p>Дайте программе отработать:</p>     <p><blockquote>$ <b>cc -D_REENTRANT thread3.с -о threads -lpthread</b></blockquote></p>     <p><blockquote>$ <b>./thread3</b></blockquote></p>     <p><blockquote>Input some text. Enter 'end', to finish</blockquote></p>     <p><blockquote><b>The Wasp Factory</b></blockquote></p>     <p><blockquote>You input 16 characters</blockquote></p>     <p><blockquote><b>Iain Banks</b></blockquote></p>     <p><blockquote>You input 10 characters</blockquote></p>     <p><blockquote><b>end</b></blockquote></p>     <br>     <p><blockquote>Waiting for thread to finish...</blockquote></p>     <p><blockquote>Thread joined</blockquote></p>     <p>В программах с потоками временные ошибки всегда трудно найти, но программа кажется приспособленной и к быстрому вводу текста, и более неспешным паузам.</p>     <p><b>Как это работает</b></p>     <p>Когда вы инициализируете семафор, то задаете ему начальное значение, равное 0. Следовательно, когда запускается функция потока, вызов <blockquote>sem_wait</blockquote> приостанавливает выполнение и ждет, когда семафор станет ненулевым.</p>     <p>В потоке <blockquote>main</blockquote> вы ждете до тех пор, пока у вас не будет некоторого текста, и затем увеличиваете счетчик семафора с помощью функции <blockquote>sem_post</blockquote>, которая немедленно разрешает другому потоку вернуться из своей функции <blockquote>sem_wait</blockquote> и начать выполнение. После того как он сосчитает символы, поток вновь вызывает <blockquote>sem_wait</blockquote> и приостанавливает выполнение до тех пор, пока поток main не вызовет снова <blockquote>sem_post</blockquote> для того, чтобы увеличить семафор.</p>     <p>Неочевидные недочеты в разработке, которые заканчиваются в результате неявными ошибками, легко пропустить. Давайте слегка изменим программу на thread3a.c, так чтобы вводимый с клавиатуры текст временами заменялся автоматически формируемым текстом. Замените цикл чтения в <blockquote>main</blockquote> следующим:</p>     <p><blockquote>printf("Input some text. Enter 'end' to finish\n");</blockquote></p>     <p><blockquote>while (strncmp("end", work_area, 3) != 0) {</blockquote></p>     <p><blockquote> if (strncmp(work_area, "FAST", 4) == 0) {</blockquote></p>     <p><blockquote>  sem_post(&amp;bin_sem);</blockquote></p>     <p><blockquote>  strcpy(work_area, "Wheeee...");</blockquote></p>     <p><blockquote> } else {</blockquote></p>     <p><blockquote>  fgets(work_area, WORK_SIZE, stdin);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> sem_post(&amp;bin_sem);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Теперь, если вы введете <blockquote>FAST</blockquote>, программа вызовет <blockquote>sem_post</blockquote>, чтобы запустить счетчик символов, но немедленно обновит <blockquote>work_area</blockquote> чем-то другим.</p>     <p><blockquote>$ <b>cc -D_REENTRANT thread3a.с -о thread3a -lpthread</b></blockquote></p>     <p><blockquote>$ <b>./thread3a</b></blockquote></p>     <p><blockquote>Input some text. Enter 'end' to finish</blockquote></p>     <p><blockquote><b>Excession</b></blockquote></p>     <p><blockquote>You input 9 characters</blockquote></p>     <p><blockquote><b>FAST</b></blockquote></p>     <p><blockquote>You input 7 characters</blockquote></p>     <p><blockquote>You input 7 characters</blockquote></p>     <p><blockquote>You input 7 characters</blockquote></p>     <p><blockquote><b>end</b></blockquote></p>     <p><blockquote>Waiting for thread to finish...</blockquote></p>     <p><blockquote>Thread joined</blockquote></p>     <p>Проблема этой программы заключается в том, что она рассчитывала на то, что ввод текста из программы продлится так долго, что у другого потока хватит времени для подсчета символов до того, как поток <blockquote>main</blockquote> подготовится передать ему новую порцию текста для подсчета. Когда вы попытались предложить ему два набора слов для подсчета, быстро следующих друг за другом (<blockquote>FAST</blockquote> с клавиатуры и затем <blockquote>Wheeee...</blockquote>, формируемое автоматически), у второго потока не было времени для выполнения. Но семафор наращивался несколько раз, поэтому считающий поток продолжал считать слова и уменьшал значение семафора до тех пор, пока оно снова не стало нулевым.</p>     <p>Этот пример показывает, как аккуратны вы должны быть с временны&#769;ми условиями в многопоточных программах. Исправить программу можно, применяя дополнительный семафор для того, чтобы заставить поток <blockquote>main</blockquote> ждать, пока у считающего потока не появится возможность закончить свой подсчет, но гораздо легче применить мьютекс или исключающий семафор, который мы рассмотрим далее.</p>             <a name="metkadoc8"><h1>Синхронизация с помощью мьютексов</h1></a>     <p>Другой способ синхронизации доступа в многопоточных программах — применение<i> мьютексов</i> (сокращение от <i>mutual exclusions</i> — взаимные исключения) или<i> исключающих семафоров,</i> которые разрешают программистам "запирать" объект так, что только один поток может обратиться к нему.</p>     <p>Базовые функции, необходимые для использования мьютексов, очень похожи на функции семафоров. Они объявляются следующим образом:</p>     <p><blockquote><b>#include &lt;рthread.h&gt;</b></blockquote></p>     <p><blockquote><b>int pthread_mutex_init(pthread_mutex_t* mutex,</b></blockquote></p>     <p><blockquote><b> const pthread_mutexattr_t *mutexattr);</b></blockquote></p>     <p><blockquote><b>int pthread_mutex_lock(pthread_mutex_t* mutex);</b></blockquote></p>     <p><blockquote><b>int pthread_mutex_unlock(pthread mutex_t* mutex);</b></blockquote></p>     <p><blockquote><b>int pthread_mutex_destroy(pthread_mutex_t *mutex);</b></blockquote></p>     <p>Как обычно, в случае успешного завершения возвращается 0 и код ошибки в случае аварийного завершения, но переменная <blockquote>errno</blockquote> не задается, вам придется использовать код возврата.</p>     <p>Как и функции семафоров, функции мьютексов принимают указатель на предварительно объявленный объект, в данном случае типа <blockquote>pthread_mutex_t</blockquote>. Дополнительный параметр атрибутов в функции <blockquote>pthread_mutex_init</blockquote> позволяет задать атрибуты мьютекса, управляющие его поведением. По умолчанию тип атрибута — "fast". У него есть небольшой недостаток: если ваша программа попытается вызвать функцию <blockquote>pthread_mutex_lock</blockquote> для мьютекса, который уже заблокирован, программа блокируется. Поскольку поток, удерживающий блокировку, в данный момент заблокирован, мьютекс никогда не будет открыт, и программа попадает в тупиковую ситуацию. Есть возможность изменить атрибуты мьютекса так, чтобы он либо проверял наличие такой ситуации и возвращал ошибку, либо действовал рекурсивно и разрешал множественные блокировки тем же самым потоком, если будет такое же количество разблокировок в дальнейшем.</p>     <p>Установка атрибутов мьютекса в этой книге не рассматривается, поэтому мы будем передавать <blockquote>NULL</blockquote> в указателе на атрибуты, и использовать поведение по умолчанию. Дополнительную информацию об изменении атрибутов можно найти в интерактивном справочном руководстве к функции <blockquote>pthread_mutex_init</blockquote>.</p>     <p>Выполните упражнение 12.4. </p>     <b>Упражнение 12.4. Мьютекс потока</b>     <p>Далее приводится еще одна модификация исходной программы thread1.с, но значительно измененная. На этот раз вы уделите особое внимание доступу к вашим важным переменным и примените мьютекс для того, чтобы быть уверенными в том, что они доступны в любой момент времени только одному потоку. Для легкости чтения текста примера мы пропустили некоторые проверки ошибок при возвратах из мьютекса, заблокированного и открытого. В рабочем программном коде вы обязательно должны проверять эти возвращаемые значения. Далее приведен текст новой программы thread4.c.</p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <p><blockquote>#include &lt;pthread.h&gt;</blockquote></p>     <p><blockquote>#include &lt;semaphore.h&gt;</blockquote></p>     <br>     <p><blockquote>void *thread_function(void *arg);</blockquote></p>     <p><blockquote>pthread_mutex_t work_mutex; /* защищает work_area и time_to_exit */</blockquote></p>     <br>     <p><blockquote>#define WORK_SIZE 1024</blockquote></p>     <p><blockquote>char work_area[WORK_SIZE];</blockquote></p>     <p><blockquote>int time_to_exit = 0;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int res;</blockquote></p>     <p><blockquote> pthread_t a_thread;</blockquote></p>     <p><blockquote> void *thread_result;</blockquote></p>     <p><blockquote> res = pthread_mutex_init(&amp;work_mutex, NULL);</blockquote></p>     <p><blockquote> if (res != 0) {</blockquote></p>     <p><blockquote>  perror("Mutex initialization failed");</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> res pthread_create(&amp;a_thread, NULL, thread_function, NULL);</blockquote></p>     <p><blockquote> if (res != 0) {</blockquote></p>     <p><blockquote>  perror("Thread creation failed");</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> pthread_mutex_lock(&amp;work_mutex);</blockquote></p>     <p><blockquote> printf("Input same text. Enter 'end' to finish\n");</blockquote></p>     <p><blockquote> while (!time_to_exit) {</blockquote></p>     <p><blockquote>  fgets (work_area, WORK_SIZE, stdin);</blockquote></p>     <p><blockquote>  pthread_mutex_unlock(&amp;work_mutex);</blockquote></p>     <p><blockquote>  while(1) {</blockquote></p>     <p><blockquote>   pthread_mutex_lock(&amp;work_mutex);</blockquote></p>     <p><blockquote>   if (work_area[0] != '\0') {</blockquote></p>     <p><blockquote>    pthread_mutex_unlock(&amp;work_mutex);</blockquote></p>     <p><blockquote>    sleep(1);</blockquote></p>     <p><blockquote>   } else {</blockquote></p>     <p><blockquote>    break;</blockquote></p>     <p><blockquote>   }</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> pthread_mutex_unlock(&amp;work_mutex);</blockquote></p>     <p><blockquote> printf("\nWaiting for thread to finish...\n");</blockquote></p>     <p><blockquote> res = pthread_join(a_thread, &amp;thread_result);</blockquote></p>     <p><blockquote> if (res ! = 0) {</blockquote></p>     <p><blockquote>  perror("Thread join failed");</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> printf("Thread joined\n");</blockquote></p>     <p><blockquote> pthread_mutex_destroy(&amp;work_mutex);</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote>void *thread_function(void *arg) {</blockquote></p>     <p><blockquote> sleep(1);</blockquote></p>     <p><blockquote> pthread_mutex_lock(&amp;work_mutex);</blockquote></p>     <p><blockquote> while(strncmp("end", work_area, 3) ! = 0) {</blockquote></p>     <p><blockquote>  printf("You input %d characters\n", strlen(work_area)-1);</blockquote></p>     <p><blockquote>  work_area[0] = '\0';</blockquote></p>     <p><blockquote>  pthread_mutex_unlock(&amp;work_mutex);</blockquote></p>     <p><blockquote>  sleep(1);</blockquote></p>     <p><blockquote>  pthread_mutex_lock(&amp;work_mutex);</blockquote></p>     <p><blockquote>  while (work_area[0] == '\0') {</blockquote></p>     <p><blockquote>   pthread_mutex_unlock(&amp;work_mutex);</blockquote></p>     <p><blockquote>   sleep(1);</blockquote></p>     <p><blockquote>   pthread_mutex_lock(&amp;work_mutex);</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> time_to_exit = 1;</blockquote></p>     <p><blockquote> work_area[0] = '\0';</blockquote></p>     <p><blockquote> pthread_mutex_unlock(&amp;work_mutex);</blockquote></p>     <p><blockquote> pthread_exit(0);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>После запуска вы получите следующий вывод:</p>     <p><blockquote>$ <b>cc -D_REENTRANT thread4.с -о thread4 -lpthread</b></blockquote></p>     <p><blockquote>$ <b>./thread4</b></blockquote></p>     <p><blockquote>Input some text. Enter 'end' to finish</blockquote></p>     <p><blockquote><b>Whit</b></blockquote></p>     <p><blockquote>You input 4 characters</blockquote></p>     <p><blockquote><b>The Crow Road</b></blockquote></p>     <p><blockquote>You input 13 characters</blockquote></p>     <p><blockquote><b>end</b></blockquote></p>     <p><blockquote>Waiting for thread to finish...</blockquote></p>     <p><blockquote>Thread joined</blockquote></p>     <p><b>Как это работает</b></p>     <p>Вы начинаете с объявления мьютекса вашей рабочей области и на сей раз дополнительной переменной <blockquote>time_to_exit</blockquote>:</p>     <p><blockquote>pthread_mutex_t work_mutex; /* защищает work_area и time_to_exit */</blockquote></p>     <p><blockquote>#define WORK_SIZE 1024</blockquote></p>     <p><blockquote>char work_area[WORK_SIZE];</blockquote></p>     <p><blockquote>int time_to_exit = 0;</blockquote></p>     <p>Далее инициализируется мьютекс:</p>     <p><blockquote>res = pthread_mutex_init(&amp;work_mutex, NULL);</blockquote></p>     <p><blockquote>if (res != 0) {</blockquote></p>     <p><blockquote> perror("Mutex initialization failed");</blockquote></p>     <p><blockquote> exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Затем запускается новый поток. Далее приведен код, выполняемый в функции потока:</p>     <p><blockquote>pthread_mutex_lock(&amp;work_mutex);</blockquote></p>     <p><blockquote>while(strncmp("end", work_area, 3) != 0) {</blockquote></p>     <p><blockquote> printf("You input id characters\n", strlen(work_area)-1);</blockquote></p>     <p><blockquote> work_area[0] = '\0';</blockquote></p>     <p><blockquote> pthread_mutex_unlock(&amp;work_mutex);</blockquote></p>     <p><blockquote> sleep(1);</blockquote></p>     <p><blockquote> pthread_mutex_lock(&amp;work_mutex);</blockquote></p>     <p><blockquote> while (work_area[0] == '\0') {</blockquote></p>     <p><blockquote>  pthread_mutex_unlock(&amp;work_mutex);</blockquote></p>     <p><blockquote>  sleep(1);</blockquote></p>     <p><blockquote>  pthread_mutex_lock(&amp;work_mutex);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote>}</blockquote></p>     <p><blockquote>time_to_exit = 1;</blockquote></p>     <p><blockquote>work_area[0] = '\0';</blockquote></p>     <p><blockquote>pthread_mutex_unlock(&amp;work_mutex);</blockquote></p>     <p>Сначала новый поток пытается заблокировать мьютекс. Если он уже заблокирован, вызов задерживается до тех пор, пока мьютекс не освободится. После получения доступа вы проверяете, нет ли к вам запроса на завершение выполнения. Если запрашивается завершение, просто задайте переменную <blockquote>time_to_exit</blockquote>, сотрите первый символ в рабочей области и завершите выполнение. </p>     <p>Если вы не хотите завершать выполнение, сосчитайте символы и очистите первый символ, сделав его пустым (null). Пустой первый символ применяется как способ информирования считывающей программы о завершении подсчета символов. Далее вы открываете мьютекс и ждете выполнения потока <blockquote>main</blockquote>. Периодически вы пытаетесь заблокировать мьютекс и, когда вам это удается, проверяете, подготовил ли поток main новую работу для вас. Если нет, вы открываете мьютекс и ждете какое-то время. Если работа есть, вы считаете символы и выполняете проход цикла снова.</p>     <p>Далее приведен поток <blockquote>main</blockquote>.</p>     <p><blockquote>pthread_mutex_lock(&amp;work_mutex)</blockquote></p>     <p><blockquote>printf("Input some text. Enter 'end' to finish\n");</blockquote></p>     <p><blockquote>while (!time_to_exit) {</blockquote></p>     <p><blockquote> fgets(work_area, WORK_SIZE, stdin);</blockquote></p>     <p><blockquote> pthread_mutex_unlock(&amp;work_mutex);</blockquote></p>     <p><blockquote> while(1) {</blockquote></p>     <p><blockquote>  pthread_mutex_lock(&amp;work_mutex);</blockquote></p>     <p><blockquote>  if (work_area[0] != '\0') {</blockquote></p>     <p><blockquote>   pthread_mutex_unlock(&amp;work_mutex);</blockquote></p>     <p><blockquote>   sleep(1);</blockquote></p>     <p><blockquote>  } else {</blockquote></p>     <p><blockquote>   break;</blockquote></p>     <p><blockquote>  }</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote>}</blockquote></p>     <p><blockquote>pthread_mutex_unlock(&amp;work_mutex);</blockquote></p>     <p>Он аналогичен второму потоку. Вы блокируете рабочую область и можете читать в нее текст, а затем вы снимаете блокировку, чтобы открыть доступ другому потоку для подсчета слов. Периодически вы блокируете мьютекс, проверяете, сосчитаны ли слова (элемент <blockquote>work_area[0]</blockquote> равен пустому символу), и освобождаете мьютекс, если нужно продолжить ожидание. Как уже отмечалось ранее, этот вид опроса и получения ответа в основном не слишком удачный прием и в реальной жизни вам, возможно, придется применить семафор для его замены. Тем не менее, программный код справляется с задачей демонстрации примера применения мьютекса.</p>              <a name="metkadoc9"><h1>Атрибуты потока</h1></a>         <p>Когда мы начали рассматривать потоки, то не обсуждали более сложную тему — атрибуты потока. Теперь, рассказав о синхронизации потоков — ключевой теме главы, мы можем вернуться назад и остановиться на этих характеристиках потока. Существует лишь несколько атрибутов потока, которыми вы можете управлять; здесь мы собираемся обсудить только те, которые вам понадобятся, скорее всего. Подробную информацию о других атрибутах вы можете найти в интерактивном справочном руководстве.</p>     <p>Во всех предыдущих примерах вы должны были повторно синхронизовать потоки с помощью функции <blockquote>pthread_join</blockquote>, прежде чем разрешить программе завершить выполнение. Это необходимо сделать, если вы хотите, чтобы один поток вернул данные другому потоку, создавшему данный. Иногда вам не нужно ни возвращать информацию из второго потока в поток <blockquote>main</blockquote>, ни заставлять поток <blockquote>main</blockquote> ждать этого.</p>     <p>Предположим, что вы создаете второй поток для записи в буфер резервной копии файла данных, который редактируется, пока поток <blockquote>main</blockquote> продолжает обслуживать пользователя. Когда создание копии закончено, второй поток может тут же завершиться. Ему не нужно присоединяться к потоку <blockquote>main</blockquote>.</p>     <p>Вы можете создать потоки, ведущие себя подобным образом. Они называются<i> отсоединенными</i> или<i> обособленными</i> потоками, и вы создаете их, изменяя атрибуты потока или вызывая функцию <blockquote>pthread_detach</blockquote>. Поскольку мы хотим продемонстрировать атрибуты, то применим здесь первый метод.</p>     <p>Самая важная функция, которая вам понадобится, — <blockquote>pthread_attr_init</blockquote>, инициализирующая объект атрибутов потока:</p>     <p><blockquote><b>#include &lt;pthread.h&gt;</b></blockquote></p>     <p><blockquote><b>int pthread_attr_init(pthread_attr_t *attr);</b></blockquote></p>     <p>И снова 0 возвращается в случае успешного завершения и код ошибки в случае аварийного.</p>     <p>Есть и функция для уничтожения: <blockquote>pthread_attr_destroy</blockquote>. Ее задача — обеспечить чистое уничтожение объекта атрибутов. После того как объект уничтожен, он не может быть использован снова до тех пор, пока не будет инициализирован повторно.</p>     <p>Когда вы инициализировали объект атрибутов потока, можно использовать множество дополнительных функций, с помощью которых задается поведение разных атрибутов. Далее перечислены основные из них (полный список вы можете найти в интерактивном справочном руководстве, в разделе, посвященном pthread.h), но мы рассмотрим подробно только два: <blockquote>detechedstate</blockquote> и <blockquote>schedpolicy</blockquote>.</p>     <p><blockquote><b>#include &lt;рthread.h&gt;</b></blockquote></p>     <p><blockquote><b>int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);</b></blockquote></p>     <p><blockquote><b>int pthread_attr_getdetachstate(const pthread_attr_t *attr,</b></blockquote></p>     <p><blockquote><b> int *detachstate);</b></blockquote></p>     <p><blockquote><b>int pthread_attr_setschedpolicy(pthread_attr_t* attr, int policy);</b></blockquote></p>     <p><blockquote><b>int pthread_attr_getschedpolicy(const pthread_attr_t *attr, int* policy);</b></blockquote></p>     <p><blockquote><b>int pthread_attr_setschedparam(pthread_attr_t *attr,</b></blockquote></p>     <p><blockquote><b> const struct sched_param *param);</b></blockquote></p>     <p><blockquote><b>int pthread_attr_getschedparam(const pthread_attr_t *attr,</b></blockquote></p>     <p><blockquote><b> struct sched_param *param);</b></blockquote></p>     <p><blockquote><b>int pthread_attr_setinheritsched(pthread_attr_t *attr, int inherit);</b></blockquote></p>     <p><blockquote><b>int pthread_attr_getinheritsched(const pthread_attr_t *attr,</b></blockquote></p>     <p><blockquote><b> int *inherit);</b></blockquote></p>     <p><blockquote><b>int pthread_attr_setscope(pthread_attr_t *attr, int scope);</b></blockquote></p>     <p><blockquote><b>int pthread_attr_getscope(const pthread_attr_t *attr, int *scope);</b></blockquote></p>     <p><blockquote><b>int pthread_attr_setstacksize(pthread_attr_t *attr, int scope);</b></blockquote></p>     <p><blockquote><b>int pthread_attr_getstacksize(const pthread_attr_t *attr, int* scope);</b></blockquote></p>     <p>Как видите, существует лишь несколько атрибутов, которые вы можете применять, но к счастью у вас, как правило, не возникнет необходимости в использовании большинства из них.</p>     <p>&#9633; <blockquote>detachedstate</blockquote> — этот атрибут позволяет избежать необходимости присоединения потоков (rejoin). Как и большинство этих функций с префиксом <blockquote>_set</blockquote>, эта функция принимает указатель на атрибут и флаг для определения требуемого состояния. Два возможных значения флага для функции <blockquote>attr_setdetachstate</blockquote> — <blockquote>PTHREAD_CREATE_JOINABLE</blockquote> и <blockquote>PTHREAD_CREATE_DETACHED</blockquote>. По умолчанию у атрибута будет значение <blockquote>PTHREAD_CREATE_JOINABLE</blockquote>, поэтому вы сможете разрешить двум потокам объединяться (один ждет завершения другого). Если задать состояние <blockquote>PTHREAD_CREATE_DETACHED</blockquote>, вы не сможете вызвать функцию <blockquote>pthread_join</blockquote>, чтобы выяснить код завершения другого потока.</p>     <p>&#9633; <blockquote>schedpolicy</blockquote> — этот атрибут управляет планированием потоков. Возможные значения — <blockquote>SCHED_OTHER</blockquote>, <blockquote>SCHED_RR</blockquote> и <blockquote>SCHED_FIFO</blockquote>. По умолчанию атрибут равен <blockquote>SCHED_OTHER</blockquote>. Два других типа планирования доступны только для процессов, выполняющихся с правами суперпользователя, поскольку они оба задают планирование в режиме реального времени, но с немного разным поведением. <blockquote>SCHED_RR</blockquote> использует круговую или циклическую схему планирования, a <blockquote>SCHED_FIFO</blockquote> — алгоритм "первым прибыл, первым обслужен". Оба эти алгоритма не обсуждаются в этой книге.</p>     <p>&#9633; <blockquote>schedparam</blockquote> — это напарник атрибута <blockquote>schedpolicy</blockquote> и позволяет управлять планированием потоков, выполняющихся с типом планирования <blockquote>SCHED_OTHER</blockquote>. Мы рассмотрим пример его применения чуть позже в этой главе.</p>     <p>&#9633; <blockquote>inheritsched</blockquote> — этот атрибут принимает одно из двух значений: <blockquote>PTHREAD_EXPLICIT_SCHED</blockquote> и <blockquote>PTHREAD_INHERIT_SCHED</blockquote>. По умолчанию значение атрибута <blockquote>PTHREAD_EXPLICIT_SCHED</blockquote>, что означает планирование, явно заданное атрибутами. Если задать <blockquote>PTHREAD_INHERIT_SCHED</blockquote>, новый поток будет вместо этого применять параметры, используемые потоком, создавшим его.</p>     <p>&#9633; <blockquote>scope</blockquote> — этот атрибут управляет способом вычисления параметров планирования потока. Поскольку ОС Linux в настоящее время поддерживает единственное значение <blockquote>PTHREAD_SCOPE_SYSTEM</blockquote>, мы не будем рассматривать его в дальнейшем.</p>     <p>&#9633; <blockquote>stacksize</blockquote> — этот атрибут управляет размером стека при создании потока, задается в байтах. Это часть необязательного раздела стандарта и поддерживается только в тех реализациях, у которых определено значение <blockquote>_PTHREAD_THREAD_ATTR_STACKSIZE</blockquote>. Linux по умолчанию реализует потоки со стеком большого размера, поэтому этот атрибут в ОС Linux избыточен.</p>     <p>Выполните упражнение 12.5.</p>     <b>Упражнение 12.5. Установка атрибута отсоединенного состояния</b>     <p>В примере с отсоединенным или обособленным потоком thread5.c вы создаете атрибут потока, задаете состояние потока как отсоединенное и затем создаете с помощью этого атрибута поток. Теперь, когда закончится дочерний поток, он вызовет обычным образом <blockquote>pthread_exit</blockquote>. В это время исходный поток больше не ждет созданный им поток для присоединения. В данном примере используется простой флаг <blockquote>thread_finished</blockquote>, чтобы позволить потоку <blockquote>main</blockquote> определить, закончился ли дочерний поток, и показать, что потоки все еще совместно используют переменные.</p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>     <p><blockquote>#include &lt;pthread.h&gt;</blockquote></p>     <br>     <p><blockquote>void *thread_function(void *arg);</blockquote></p>     <p><blockquote>char message[] = "Hello World";</blockquote></p>     <p><blockquote>int thread_finished = 0;</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> int res;</blockquote></p>     <p><blockquote> pthread_t a_thread;</blockquote></p>     <p><blockquote> pthread_attr_t thread_attr;</blockquote></p>     <p><blockquote> res = pthread_attr_init(&amp;thread_attr);</blockquote></p>     <p><blockquote> if (res != 0) {</blockquote></p>     <p><blockquote>  perror("Attribute creation failed");</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> res = pthread_attr_setdetachstate(&amp;thread_attr,</blockquote></p>     <p><blockquote>  PTHREAD_CREATE_DETACHED);</blockquote></p>     <p><blockquote> if (res != 0) {</blockquote></p>     <p><blockquote>  perror("Setting detached attribute failed");</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> res = pthread_create(&amp;a_thread, &amp;thread_attr,</blockquote></p>     <p><blockquote>  thread_function, (void *)message);</blockquote></p>     <p><blockquote> if (res != 0) {</blockquote></p>     <p><blockquote>  perror("Thread creation failed");</blockquote></p>     <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> (void)pthread_attr_destroy(&amp;thread_attr);</blockquote></p>     <p><blockquote> while (!thread_finished) {</blockquote></p>     <p><blockquote>  printf("Waiting for thread to say it's finished...\n");</blockquote></p>     <p><blockquote>  sleep(1);</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> printf("Other thread finished, bye!\n");</blockquote></p>     <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote>void *thread_function(void *arg) {</blockquote></p>     <p><blockquote> printf("thread_function is running. Argument was %s\n", (char *)arg);</blockquote></p>     <p><blockquote> sleep(4);</blockquote></p>     <p><blockquote> printf("Second thread setting finished flag, and exiting now\n");</blockquote></p>     <p><blockquote> thread_finished = 1;</blockquote></p>     <p><blockquote> pthread_exit(NULL);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Вывод не принесет сюрпризов:</p>     <p><blockquote>$ <b>./threads</b></blockquote></p>     <p><blockquote>Waiting for thread to say it's finished...</blockquote></p>     <p><blockquote>thread_function is running. Argument was Hello World</blockquote></p>     <p><blockquote>Waiting for thread to say it's finished...</blockquote></p>     <p><blockquote>Waiting for thread to say it's finished...</blockquote></p>     <p><blockquote>Waiting for thread to say it's finished...</blockquote></p>     <p><blockquote>Second thread setting finished flag, and exiting now</blockquote></p>     <p><blockquote>Other thread finished, bye!</blockquote></p>     <p>Как видите, установка отсоединенного состояния позволяет второму потоку завершиться независимо, без необходимости исходному потоку ждать этого события.</p>     <p><b>Как это работает</b></p>     <p>В исходном тексте программы два важных фрагмента:</p>     <p><blockquote>pthread_attr_t thread_attr;</blockquote></p>     <p><blockquote>res = pthread_attr_init(&amp;thread_attr);</blockquote></p>     <p><blockquote>if (res != 0) {</blockquote></p>     <p><blockquote> perror("Attribute creation failed");</blockquote></p>     <p><blockquote> exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>который объявляет атрибут потока и инициализирует его, и</p>     <p><blockquote>res = pthread_attr_setdetachstatе(&amp;thread_attr, PTHREAD_CREATE_DETACHED);</blockquote></p>     <p><blockquote>if (res != 0) {</blockquote></p>     <p><blockquote> perror("Setting detached attribute failed");</blockquote></p>     <p><blockquote> exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>который устанавливает значения атрибутов для задания отсоединенного состояния потока.</p>     <p>К другим незначительным отличиям относится создание потока с передачей адреса атрибутов:</p>     <p><blockquote>res = pthread_create(&amp;a_thread, &amp;thread_attr, thread_function, (void*)message);</blockquote></p>     <p>и для завершенности уничтожение атрибутов после их использования:</p>     <p><blockquote>pthread_attr_destroy(&amp;thread_attr);</blockquote></p>             <a name="metkadoc10"><h1>Атрибуты планирования потока</h1></a>     <p>Давайте рассмотрим второй атрибут потока, который вам, возможно, захочется изменить, — атрибут планирования. Изменение этого атрибута очень похоже на установку отсоединенного состояния потока, но есть дополнительные функции, которые можно применять для подбора допустимых уровней приоритета, <blockquote>sched_get_priority_max</blockquote> и <blockquote>sched_get_priority_min</blockquote>.</p>     <p>Выполните упражнение 12.6.</p>     <b>Упражнение 12.6. Планирование</b>     <p>Поскольку данная программа thread6.c очень похожа на программу предыдущего упражнения, мы рассмотрим только отличия.</p>     <p>1. Прежде всего, вам понадобится несколько дополнительных переменных:</p>     <p><blockquote>int max_priority;</blockquote></p>     <p><blockquote>int min_priority;</blockquote></p>     <p><blockquote>struct sched_param scheduling_value;</blockquote></p>     <p>2. После того как установлен атрибут отсоединения, вы задаете политику планирования:</p>     <p><blockquote>res = pthread_attr_setschedpolicy(&amp;thread_attr, SCHED_OTHER);</blockquote></p>     <p><blockquote>if (res != 0) {</blockquote></p>     <p><blockquote> perror("Setting scheduling policy failed");</blockquote></p>     <p><blockquote> exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>3. Далее находите диапазон допустимых приоритетов</p>     <p><blockquote>max_priority = sched_get_priority_max(SCHED_OTHER);</blockquote></p>     <p><blockquote>min_priority = sched_get_priority_min(SCHED_OTHER);</blockquote></p>     <p>и задаете один из них:</p>     <p><blockquote>scheduling_value.sched_priority = min_priority;</blockquote></p>     <p><blockquote>res = pthread_attr_setschedparam(&amp;thread_attr, &amp;scheduling_value);</blockquote></p>     <p><blockquote>if (res != 0) {</blockquote></p>     <p><blockquote> perror("Setting scheduling priority failed");</blockquote></p>     <p><blockquote> exit(EXIT_FAILURE);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Когда вы запустите программу, то получите следующий вывод:</p>     <p><blockquote>$ <b>./thread6</b></blockquote></p>     <p><blockquote>Waiting for thread to say it's finished...</blockquote></p>     <p><blockquote>thread_function is running. Argument was Hello World</blockquote></p>     <p><blockquote>Waiting for thread to say it's finished...</blockquote></p>     <p><blockquote>Waiting for thread to say it's finished...</blockquote></p>     <p><blockquote>Waiting for thread to say it's finished...</blockquote></p>     <p><blockquote>Second thread setting finished flag, and exiting now</blockquote></p>     <p><blockquote>Other thread finished, bye!</blockquote></p>     <p><b>Как это работает</b></p>     <p>Этот пример очень похож на установку атрибута отсоединенного состояния за исключением того, что вы задаете вместо него способ планирования.</p>              <a name="metkadoc11"><h1>Отмена потока</h1></a>    <p>Иногда требуется, чтобы один поток попросил другой завершиться досрочно способом, очень похожим на отправку ему сигнала. Сделать это можно с помощью потоков и параллельно с помощью обработки сигнала; у потоков появляется возможность изменить свое поведение, когда их просят завершиться.</p>    <p>Давайте сначала рассмотрим функцию для создания запроса на завершение потока.</p>    <p><blockquote><b>#include &lt;pthread.h&gt;</b></blockquote></p>    <p><blockquote><b>int pthread_cancel(pthread_t thread);</b></blockquote></p>    <p>Она достаточно проста: имея идентификатор потока, вы можете запросить его аннулирование. На приемном конце запроса на отмену все немного сложнее, но не слишком. Поток может установить состояние отмены с помощью функции <blockquote>pthread_setcancelstate</blockquote>.</p>    <p><blockquote><b>#include &lt;pthread.h&gt;</b></blockquote></p>    <p><blockquote><b>int pthread_setcancelstate(int state, int *oldstate);</b></blockquote></p>    <p>Первый параметр равен либо значению <blockquote>PHTREAD_CANCEL_ENABLE</blockquote>, позволяющему получать запросы на отмену, либо <blockquote>PTHREAD_CANCEL_DISABLE</blockquote>, заставляющему игнорировать подобные запросы. Указатель <blockquote>oldstate</blockquote> дает возможность получить предыдущее состояние. Если оно вас не интересует, можно просто передать в этом параметре <blockquote>NULL</blockquote>. Если запросы на отмену принимаются, есть второй уровень управления, принимаемый потоком, — тип отмены, который задается функцией <blockquote>pthread_setcanceltype</blockquote>.</p>    <p><blockquote><b>#include &lt;pthread.h&gt;</b></blockquote></p>    <p><blockquote><b>int pthread_setcanceltype(int type, int *oldtype);</b></blockquote></p>    <p>Тип отмены может принимать одно из следующих значений: <blockquote>PTHREAD_CANCEL_ASYNCHRONOUS</blockquote>, заставляющее обрабатывать запросы на отмену немедленно, и <blockquote>PTHREAD_CANCEL_DEFERRED</blockquote>, заставляющее запросы на отмену ждать, пока поток не выполнит одну из следующих функций: <blockquote>pthread_join</blockquote>, <blockquote>pthread_cond_wait</blockquote>, <blockquote>pthread_cond_timedwait</blockquote>, <blockquote>pthread_testcancel</blockquote>, <blockquote>sem_wait</blockquote> или <blockquote>sigwait</blockquote>.</p>    <p>Мы не описываем все эти функции в данной главе, поскольку, как правило, не все они нужны. Когда они понадобятся, вы сможете найти дополнительную информацию на страницах интерактивного справочного руководства.</p>    <blockquote>     <b>Примечание</b>     <p>В соответствии со стандартом POSIX системные вызовы, способные задерживать выполнение, такие как <blockquote>read</blockquote>, <blockquote>wait</blockquote> и т.д., должны также быть точками отмены потока. Во время написания книги поддержка этого стандарта в ОС Linux представлялась незавершенной. Но кое-какая работа была проделана, скажем, некоторые задерживающие вызовы, такие как <blockquote>sleep</blockquote>, на самом деле допускают отмену. Для того чтобы обезопасить себя, добавляйте вызовы <blockquote>pthread_testcancel</blockquote> в программный код, который по вашим расчетам может быть отменен.</p>    </blockquote>    <p>Параметр <blockquote>oldtype</blockquote> позволяет получить предыдущее состояние, если оно вас не интересует, можно передать <blockquote>NULL</blockquote>. По умолчанию потоки запускаются с состоянием отмены, равным <blockquote>PTHREAD_CANCEL_ENABLE</blockquote>, и типом отмены — <blockquote>PTHREAD_CANCEL_DEFERRED</blockquote>.</p>    <p>Выполните упражнение 12.7.</p>    <b>Упражнение 12.7. Отмена потока</b>    <p>Программа thread7.c — ещё один потомок программы thread1.с. На этот раз основной поток отправляет запрос на отмену потока, который он создал.</p>    <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>    <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>    <p><blockquote>#include &lt;pthread.h&gt;</blockquote></p>    <br>    <p><blockquote>void *thread_function(void *arg);</blockquote></p>    <br>    <p><blockquote>int main() {</blockquote></p>    <p><blockquote> int res;</blockquote></p>    <p><blockquote> pthread_t a_thread;</blockquote></p>    <p><blockquote> void *thread_result;</blockquote></p>    <p><blockquote> res = pthread_create(&amp;a_thread, NULL, thread_function, NULL);</blockquote></p>    <p><blockquote> if (res != 0) {</blockquote></p>    <p><blockquote>  perror("Thread creation failed");</blockquote></p>    <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>    <p><blockquote> }</blockquote></p>    <p><blockquote> sleep(3);</blockquote></p>    <p><blockquote> printf("Canceling thread...\n");</blockquote></p>    <p><blockquote> res = pthread_cancel(a_thread);</blockquote></p>    <p><blockquote> if (res != 0) {</blockquote></p>    <p><blockquote>  perror("Thread cancelation failed");</blockquote></p>    <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>    <p><blockquote> }</blockquote></p>    <p><blockquote> printf("Waiting for thread to finish...\n");</blockquote></p>    <p><blockquote> res = pthread_join(a_thread, &amp;thread_result);</blockquote></p>    <p><blockquote> if (res != 0) {</blockquote></p>    <p><blockquote>  perror("Thread join failed");</blockquote></p>    <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>    <p><blockquote> }</blockquote></p>    <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>    <p><blockquote>}</blockquote></p>    <br>    <p><blockquote>void *thread_function(void *arg) {</blockquote></p>    <p><blockquote> int i, res;</blockquote></p>    <p><blockquote> res = pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);</blockquote></p>    <p><blockquote> if (res != 0) {</blockquote></p>    <p><blockquote>  perror("Thread pthread_setcancelstate failed");</blockquote></p>    <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>    <p><blockquote> }</blockquote></p>    <p><blockquote> res = pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, NULL);</blockquote></p>    <p><blockquote> if (res != 0) {</blockquote></p>    <p><blockquote>  perror{"Thread pthread_setcanceltype failed");</blockquote></p>    <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>    <p><blockquote> }</blockquote></p>    <p><blockquote> printf("thread_function is running\n");</blockquote></p>    <p><blockquote> for(i = 0; i &lt; 10; i++) {</blockquote></p>    <p><blockquote>  printf("Thread is still running (%d)...\n", i);</blockquote></p>    <p><blockquote>  sleep(1);</blockquote></p>    <p><blockquote> }</blockquote></p>    <p><blockquote> pthread_exit(0);</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Когда вы выполните эту программу, то увидите следующий вывод, демонстрирующий отмену потока:</p>    <p><blockquote>$ <b>./thread7</b></blockquote></p>    <p><blockquote>thread_function is running</blockquote></p>    <p><blockquote>Thread is still running (0)...</blockquote></p>    <p><blockquote>Thread is still running (1)...</blockquote></p>    <p><blockquote>Thread is still running (2)...</blockquote></p>    <p><blockquote>Canceling thread...</blockquote></p>    <p><blockquote>Waiting for thread to finish...</blockquote></p>    <p><blockquote>$</blockquote></p>    <p><b>Как это работает</b></p>    <p>После того как новый поток был создан обычным способом, основной поток засыпает (чтобы дать новому потоку время для запуска) и затем отправляет запрос на отмену потока.</p>    <p><blockquote>sleep(3);</blockquote></p>    <p><blockquote>printf("Cancelling thread...\n");</blockquote></p>    <p><blockquote>res = pthread_cancel(a_thread);</blockquote></p>    <p><blockquote>if (res != 0) {</blockquote></p>    <p><blockquote> perror("Thread cancelation failed");</blockquote></p>    <p><blockquote> exit(EXIT_FAILURE);</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>В созданном потоке вы сначала задаете состояние отмены, чтобы разрешить отмену потока:</p>    <p><blockquote>res = pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);</blockquote></p>    <p><blockquote>if (res != 0) {</blockquote></p>    <p><blockquote> perror("Thread pthread_setcancelstate failed");</blockquote></p>    <p><blockquote> exit(EXIT_FAILURE);</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Далее вы задаете тип отмены <blockquote>PTHREAD_CANCEL_DEFERRED</blockquote>:</p>    <p><blockquote>res = pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, NULL);</blockquote></p>    <p><blockquote>if (res != 0) {</blockquote></p>    <p><blockquote> perror("Thread pthread_setcanceltype failed");</blockquote></p>    <p><blockquote> exit(EXIT_FAILURE);</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>И в конце поток ждет отмену:</p>    <p><blockquote>for (i = 0; i &lt; 10; i++) {</blockquote></p>    <p><blockquote> printf("Thread is still running (%d)...\n", i);</blockquote></p>    <p><blockquote> sleep(1);</blockquote></p>    <p><blockquote>}</blockquote></p>          <a name="metkadoc12"><h1>Потоки в изобилии</h1></a>    <p>До настоящего момента у нас всегда был обычный поток исполнения программы, создающий еще только один поток. Тем не менее мы не хотим, чтобы вы думали, что можно создать только один дополнительный поток (упражнение 12.8).</p>    <b>Упражнение 12.8. Много потоков</b>    <p>В заключительном примере этой главы thread8.c мы покажем, как создать несколько потоков в одной и той же программе и затем собрать их снова в последовательности, отличающейся от порядка их создания.</p>    <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>    <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>    <p><blockquote>#include &lt;pthread.h&gt;</blockquote></p>    <br>    <p><blockquote>#define NUM_THREADS 6</blockquote></p>    <p><blockquote>void *thread_function(void *arg);</blockquote></p>    <br>    <p><blockquote>int main() {</blockquote></p>    <p><blockquote> int res;</blockquote></p>    <p><blockquote> pthread_t a_thread[NUM_THREADS];</blockquote></p>    <p><blockquote> void *thread_result;</blockquote></p>    <p><blockquote> int lots_of_threads;</blockquote></p>    <p><blockquote> for (lots_of_threads = 0; lots_of_threads &lt; NUM_THREADS; lots_of_threads++) {</blockquote></p>    <p><blockquote>  res = pthread_create(&amp;(a_thread[lots_of_threads]), NULL, thread_function, (void*)&amp;lots_of_threads);</blockquote></p>    <p><blockquote>  if (res != 0) {</blockquote></p>    <p><blockquote>   perror("Thread creation failed");</blockquote></p>    <p><blockquote>   exit(EXIT_FAILURE);</blockquote></p>    <p><blockquote>  }</blockquote></p>    <p><blockquote>  sleep(1);</blockquote></p>    <p><blockquote> }</blockquote></p>    <p><blockquote> printf("Waiting for threads' to finish...\n");</blockquote></p>    <p><blockquote> for(lots of_threads = NUM_THREADS - 1; lots_of_threads &gt;= 0; lots_of_threads--) {</blockquote></p>    <p><blockquote>  res = pthread_join(a_thread[lots_of_threads], &amp;thread_result);</blockquote></p>    <p><blockquote>  if (res == 0) {</blockquote></p>    <p><blockquote>   printf("Picked up a thread\n");</blockquote></p>    <p><blockquote>  } else {</blockquote></p>    <p><blockquote>   perror("pthread_join failed");</blockquote></p>    <p><blockquote>  }</blockquote></p>    <p><blockquote> }</blockquote></p>    <p><blockquote> printf("All done\n");</blockquote></p>    <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>    <p><blockquote>}</blockquote></p>    <br>    <p><blockquote>void *thread_function(void *arg) {</blockquote></p>    <p><blockquote> int my_number = *(int*)arg;</blockquote></p>    <p><blockquote> int rand_num;</blockquote></p>    <p><blockquote> printf("thread_function is running. Argument was %d\n", my_number);</blockquote></p>    <p><blockquote> rand_num = 1 + (int)(9.0*rand() / (RAND_MAX+1.0));</blockquote></p>    <p><blockquote> sleep(rand_num);</blockquote></p>    <p><blockquote> printf("Bye from %d\n", my_number);</blockquote></p>    <p><blockquote> pthread_exit(NULL);</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Выполнив эту программу, вы получите следующий вывод:</p>    <p><blockquote>$ <b>./thread8</b></blockquote></p>    <p><blockquote>thread_function is running. Argument was 0</blockquote></p>    <p><blockquote>thread_function is running. Argument was 1</blockquote></p>    <p><blockquote>thread_function is running. Argument was 2</blockquote></p>    <p><blockquote>thread_function is running. Argument was 3</blockquote></p>    <p><blockquote>thread_function is running. Argument was 4</blockquote></p>    <p><blockquote>Bye from 1</blockquote></p>    <p><blockquote>thread_function is running. Argument was 5</blockquote></p>    <p><blockquote>Waiting for threads to finish...</blockquote></p>    <p><blockquote>Bye from 5</blockquote></p>    <p><blockquote>Picked up a thread</blockquote></p>    <p><blockquote>Bye from 0</blockquote></p>    <p><blockquote>Bye from 2</blockquote></p>    <p><blockquote>Bye from 3</blockquote></p>    <p><blockquote>Bye from 4</blockquote></p>    <p><blockquote>Picked up a thread</blockquote></p>    <p><blockquote>Picked up a thread</blockquote></p>    <p><blockquote>Picked up a thread</blockquote></p>    <p><blockquote>Picked up a thread</blockquote></p>    <p><blockquote>Picked up a thread</blockquote></p>    <p><blockquote>All done</blockquote></p>    <p>Как видите, вы создали много потоков и разрешили им завершаться в произвольной последовательности. В этой программе есть маленькая ошибка, которая проявит себя, если вы удалите вызов sleep из цикла, запускающего потоки. Мы включили ее, чтобы показать, как вы должны быть внимательны при написании программ, применяющих потоки. Вы нашли ее? В следующем<i> разд. "Как это работает" </i>будет дано объяснение.</p>    <p><b>Как это работает</b></p>    <p>На сей раз вы создаете массив идентификаторов потоков:</p>    <p><blockquote>pthread_t a_thread[NUM_THREADS];</blockquote></p>    <p>и заключаете в цикл создание нескольких потоков:</p>    <p><blockquote>for (lots_of_threads = 0; lots_of_threads &lt; NUM_THREADS; lots_of_threads++) {</blockquote></p>    <p><blockquote> res = pthread_create(&amp;(a_thread[lots_of_threads]), NULL,</blockquote></p>    <p><blockquote>  thread_function, (void *)&amp;lots_of_threads);</blockquote></p>    <p><blockquote> if (res != 0) {</blockquote></p>    <p><blockquote>  perror("Thread creation failed");</blockquote></p>    <p><blockquote>  exit(EXIT_FAILURE);</blockquote></p>    <p><blockquote> }</blockquote></p>    <p><blockquote> sleep(1);</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Затем потоки сами по себе ждут в течение случайного промежутка времени, прежде чем начать выполнение:</p>    <p><blockquote>void *thread_function(void *arg) {</blockquote></p>    <p><blockquote> int my_number = *(int *)arg;</blockquote></p>    <p><blockquote> int rand_num;</blockquote></p>    <p><blockquote> printf("thread_function is running. Argument was %d\n", my_number);</blockquote></p>    <p><blockquote> rand_num = 1+(int)(9.0* rand()/(RAND_MAX+1.0));</blockquote></p>    <p><blockquote> sleep(randnum);</blockquote></p>    <p><blockquote> printf("Bye from %d\n", my_number);</blockquote></p>    <p><blockquote> pthread_exit(NULL);</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>В это время в основном (исходном) потоке вы ждете, чтобы собрать потоки, но не в том порядке, в каком вы их создали:</p>    <p><blockquote>for (lots_of_threads = NUM_THREADS - 1; lots_of_threads &gt;= 0; lots_of_threads--) {</blockquote></p>    <p><blockquote> res = pthread_join(a_thread[lots_of__threads], &amp;thread_result);</blockquote></p>    <p><blockquote> if (res == 0) {</blockquote></p>    <p><blockquote>  printf("Picked up a thread\n");</blockquote></p>    <p><blockquote> } else {</blockquote></p>    <p><blockquote>  perror("pthread_join failed");</blockquote></p>    <p><blockquote> }</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Если вы попробуете выполнить программу без вызова <blockquote>sleep</blockquote>, то увидите странный эффект: некоторые потоки запускаются с одним и тем же номером, например, вы можете получить вывод, похожий на следующий:</p>    <p><blockquote>thread_function is running. Argument was 0</blockquote></p>    <p><blockquote>thread_function is running. Argument was 2</blockquote></p>    <p><blockquote>thread_function is running. Argument was 2</blockquote></p>    <p><blockquote>thread_function is running. Argument was 4</blockquote></p>    <p><blockquote>thread_function is running. Argument was 4</blockquote></p>    <p><blockquote>thread_function is running. Argument was 5</blockquote></p>    <p><blockquote>Waiting for threads to finish...</blockquote></p>    <p><blockquote>Bye from 5</blockquote></p>    <p><blockquote>Picked up a thread</blockquote></p>    <p><blockquote>Bye from 2</blockquote></p>    <p><blockquote>Bye from 0</blockquote></p>    <p><blockquote>Bye from 2</blockquote></p>    <p><blockquote>Bye from 4</blockquote></p>    <p><blockquote>Bye from 4</blockquote></p>    <p><blockquote>Picked up a thread</blockquote></p>    <p><blockquote>Picked up a thread</blockquote></p>    <p><blockquote>Picked up a thread</blockquote></p>    <p><blockquote>Picked up a thread</blockquote></p>    <p><blockquote>Picked up a thread</blockquote></p>    <p><blockquote>All done</blockquote></p>    <p>Вы догадались, что произошло? Потоки запускаются, используя локальную переменную как аргумент функции потока. Эта переменная обновляется в цикле. Далее приведены ошибочные строки:</p>    <p><blockquote>for (lots_of_threads = 0; lots_of_threads &lt; NUM_THREADS; lots_of_threads++) {</blockquote></p>    <p><blockquote> res = pthread_create(&amp;(a_thread[lots_of_threads]), NULL,</blockquote></p>    <p><blockquote>  thread_function, (void *)&amp;lots_of_threads);</blockquote></p>    <p>Если поток <blockquote>main</blockquote> выполняется достаточно быстро, он может искажать аргумент (<blockquote>lots_of_threads</blockquote>) для некоторых потоков. Поведение, подобное этому, наблюдается, когда недостаточно внимания уделяется совместно используемым переменным и множественным путям исполнения (multiple execution paths). Мы предупреждали вас о том, что программирование потоков требует повышенного внимания при разработке! Для исправления ошибки вам следует передавать непосредственно значение следующим образом:</p>    <p><blockquote>res = pthread_create(&amp;(a_thread[lots_of_threads]), NULL,</blockquote></p>    <p><blockquote> thread_function, (void *)lots_of_threads);</blockquote></p>    <p>и конечно изменить <blockquote>thread_function</blockquote>:</p>    <p><blockquote>void *thread_function(void *arg) {</blockquote></p>    <p><blockquote> int my_number = (int)arg;</blockquote></p>    <p>Все исправления, выделенные цветом, показаны в программе thread8a.c.</p>    <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>    <p><blockquote>#include &lt;unistd.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>    <p><blockquote>#include &lt;string.h&gt;</blockquote></p>    <p><blockquote>#include &lt;pthread.h&gt;</blockquote></p>    <p><blockquote>#define NUM_THREADS 6</blockquote></p>    <br>    <p><blockquote>void *thread_function(void *arg);</blockquote></p>    <br>    <p><blockquote>int main() {</blockquote></p>    <p><blockquote> int res;</blockquote></p>    <p><blockquote> pthread_t a_thread[NUM_THREADS];</blockquote></p>    <p><blockquote> void *thread_result;</blockquote></p>    <p><blockquote> int lots_of_threads;</blockquote></p>    <p><blockquote> for (lots_of_threads = 0; lots_of_threads &lt; NUM_THREADS; lots_of_threads++) {</blockquote></p>    <p><blockquote><i>  res = pthread_create(&amp;(a_thread[lots_of_thread]), NULL,</i></blockquote></p>    <p><blockquote><i>   thread_function, (void*)lots_оf_threads);</i></blockquote></p>    <p><blockquote><i>  if (res != 0) {</i></blockquote></p>    <p><blockquote><i>   perror("Thread creation failed");</i></blockquote></p>    <p><blockquote><i>   exit(EXIT_FAILURE);</i></blockquote></p>    <p><blockquote><i>  }</i></blockquote></p>    <p><blockquote> }</blockquote></p>    <p><blockquote> printf("Waiting for threads to finish...\n");</blockquote></p>    <p><blockquote> for (lots_of_threads = NUM_THREADS - 1; lots_of_threads &gt;= 0;</blockquote></p>    <p><blockquote>  lots of threads--) {</blockquote></p>    <p><blockquote>  res = pthread_join(a_thread[lots_of_threads], &amp;thread_result);</blockquote></p>    <p><blockquote>  if (res == 0) {</blockquote></p>    <p><blockquote>   printf("Picked up a thread\n");</blockquote></p>    <p><blockquote>  } else {</blockquote></p>    <p><blockquote>   perror("pthread_join failed");</blockquote></p>    <p><blockquote>  }</blockquote></p>    <p><blockquote> }</blockquote></p>    <p><blockquote> printf("All done\n");</blockquote></p>    <p><blockquote> exit(EXIT_SUCCESS);</blockquote></p>    <p><blockquote>}</blockquote></p>    <br>    <p><blockquote><i>void* thread_function(void* arg) {</i></blockquote></p>    <p><blockquote><i> int my_number = (int)arg;</i></blockquote></p>    <p><blockquote> int rand_num;</blockquote></p>    <p><blockquote> printf("thread_function is running. Argument was %d\n", my_number);</blockquote></p>    <p><blockquote> rand_num = 1+(int)(9.0*rand()/(RAND_MAX+1.0));</blockquote></p>    <p><blockquote> sleep(rand_num);</blockquote></p>    <p><blockquote> printf("Bye from %d\n", my_number);</blockquote></p>    <p><blockquote> pthread_exit(NULL);</blockquote></p>    <p><blockquote>}</blockquote></p>          <a name="metkadoc13"><h1>Резюме</h1></a>    <p>В этой главе вы узнали, как создать несколько потоков исполнения внутри процесса, которые совместно используют глобальные переменные. Вы рассмотрели два способа управления — семафоры и мьютексы, применяемые потоками для доступа к важным фрагментам кода и данным. Далее вы увидели, как управлять атрибутами потоков и, в особенности, как можно отсоединить потоки от основного, не заставляя его ждать завершения созданных им потоков. После краткого обзора способов формирования в одном потоке запросов на отмену других потоков и вариантов управления такими запросами в потоке, получившем их, мы представили программу с множественными одновременно выполняющимися потоками.</p>    <p>Объем книги не позволяет обсудить все до единой функции и тонкости, связанные с потоками, но теперь у вас достаточно знаний для того, чтобы начать писать собственные программы, применяющие потоки, и изучать глубоко скрытые свойства потоков, читая страницы интерактивного справочного руководства.</p>     <br><br>
<center><div align="center"><a href="index.php.html">Оглавление</a></div></center>




<br>
<script type="text/javascript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="https://www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script><br>

<noindex>
<div align="center">
<center>

<!-- SAPE RTB DIV 600x340 -->
<div id="SRTB_507029"></div>
<!-- SAPE RTB END -->

</center>
</div>
</noindex>

</td>
<td width="240" valign="top">

<br>

<div id="menu3">
<ul>
<li><a href="../../alternativnaja_medicina/index.html"><span>Альтернативная медицина</span></a></li>
<li><a href="../../astronomija_i_kosmos/index.html"><span>Астрономия и Космос</span></a></li>
<li><a href="../../biologija/index.html"><span>Биология</span></a></li>
<li><a href="../../voennaja_istorija/index.html"><span>Военная история</span></a></li>
<li><a href="../../geologija_i_geografija/index.html"><span>Геология и география</span></a></li>
<li><a href="../../gosudarstvo_i_pravo/index.html"><span>Государство и право</span></a></li>
<li><a href="../../delovaja_literatura/index.html"><span>Деловая литература</span></a></li>
<li><a href="../../domashnie_zhivotnye/index.html"><span>Домашние животные</span></a></li>
<li><a href="../../domovodstvo/index.html"><span>Домоводство</span></a></li>
<li><a href="../../zdorove/index.html"><span>Здоровье</span></a></li>
<li><a href="../../istorija/index.html"><span>История</span></a></li>
<li><a href="../index.html"><span>Компьютеры и Интернет</span></a></li>
<li><a href="../../kulinarija/index.html"><span>Кулинария</span></a></li>
<li><a href="../../kulturologija/index.html"><span>Культурология</span></a></li>
<li><a href="../../literaturovedenie/index.html"><span>Литературоведение</span></a></li>
<li><a href="../../matematika/index.html"><span>Математика</span></a></li>
<li><a href="../../medicina/index.html"><span>Медицина</span></a></li>
<li><a href="../../nauchnaja_literatura_prochee/index.html"><span>Науч. литер. - прочее</span></a></li>
<li><a href="../../pedagogika/index.html"><span>Педагогика</span></a></li>
<li><a href="../../politika/index.html"><span>Политика</span></a></li>
<li><a href="../../psihologija/index.html"><span>Психология</span></a></li>
<li><a href="../../religiovedenie/index.html"><span>Религиоведение</span></a></li>
<li><a href="../../sad_i_ogorod/index.html"><span>Сад и огород</span></a></li>
<li><a href="../../samosovershenstvovanie/index.html"><span>Самосовершенствование</span></a></li>
<li><a href="../../sdelai_sam/index.html"><span>Сделай сам</span></a></li>
<li><a href="../../sport/index.html"><span>Спорт</span></a></li>
<li><a href="../../tehnicheskie_nauki/index.html"><span>Технические науки</span></a></li>
<li><a href="../../transport_i_aviacija/index.html"><span>Транспорт и авиация</span></a></li>
<li><a href="../../uchebniki/index.html"><span>Учебники</span></a></li>
<li><a href="../../fizika/index.html"><span>Физика</span></a></li>
<li><a href="../../filosofija/index.html"><span>Философия</span></a></li>
<li><a href="../../himija/index.html"><span>Химия</span></a></li>
<li><a href="../../hobbi_i_remesla/index.html"><span>Хобби и ремесла</span></a></li>
<li><a href="../../shpargalki/index.html"><span>Шпаргалки</span></a></li>
<li><a href="../../yezoterika/index.html"><span>Эзотерика</span></a></li>
<li><a href="../../yurisprudencija/index.html"><span>Юриспруденция</span></a></li>
<li><a href="../../jazykoznanie/index.html"><span>Языкознание</span></a></li>
</ul>
</div>

<br>
<div align="center">
<center>
<noindex>

<!-- SAPE RTB DIV 240x400 -->
<div id="SRTB_507028"></div>
<!-- SAPE RTB END -->

</noindex>
</center>
</div>

</td>
</tr>
<tr>
<td colspan="3" align="center">


<hr>
<a href="../../index.html"><span>Главная</span></a> | 
<a rel="sidebar" href="p16.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a> | 
<a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a> | 
<a href="p16.php.html#" onClick="scroll(0,0); return false" title="наверх">Наверх</a>
</td>
</tr>
<tr>
<td colspan="3" valign="top" align="left">
<br>

 



</td>
</tr>
</table>

<noindex>
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter21717787 = new Ya.Metrika({id:21717787,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="http://mc.yandex.ru/watch/21717787" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

</noindex>
</center>
</div></body>
</html>