<html>
<head>
<meta http-equiv="Content-Language" content="ru">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<link href="../../0img/style.css" rel="stylesheet" type="text/css" />
<link rel="SHORTCUT ICON" href="http://www.redov.ru/0img/favicon.ico" type="image/x-icon"> 
<title>Глава 16 Программирование в GNOME с помощью GTK+ / Основы программирования в Linux</title>
</head>
<body>
<div align="center">
<center>
<table border="0" cellpadding="0" cellspacing="0" width="1260">
<tr>
<td colspan="3" valign="top" align="left" height="100">
<table border="0" cellpadding="0" cellspacing="0" width="1260" height="100">
<tr>
<td valign="middle" align="center" width="350">
<a href="../../index.html"><img src="../../0img/logo.jpg" width="350" height="100" title="Онлайн библиотека redov.ru"/></a>
</td>
<td valign="middle" align="center" width="910">

<noindex>

<!-- SAPE RTB JS -->
<script
    async="async"
    src="http://cdn-rtb.sape.ru/rtb-b/js/393/2/106393.js"
    type="text/javascript">
</script>
<!-- SAPE RTB END -->

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507025"></div>
<!-- SAPE RTB END -->

</noindex>

</td>
</tr>
</table>
</td>
</tr>
<tr>
<td colspan="3" valign="middle" align="left">

<div id="menu">
<ul>
		<li><a href="../../index.html"><span>Главная</span></a></li>
		<li><a rel="sidebar" href="p20.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a></li>
		<li><a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a></li>
		<li><a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a></li>
		<li><a href="p20.php.html#" onClick="scroll(0,9999999); return false"><span>Вниз</span></a></li>
</ul>
</div>


</td>
</tr>
<tr>
<td width="240" valign="top" align="center">

<br>
<noindex>
<!-- SAPE RTB DIV 160x600 -->
<div id="SRTB_733378"></div>
<!-- SAPE RTB END -->
</noindex>



</td>
<td valign="top" align="left" style="padding-left: 5; padding-right: 5" width="780">
<br>
<noindex>
<div align="center">

<!-- SAPE RTB DIV 728x90 -->
<div id="SRTB_507027"></div>
<!-- SAPE RTB END -->

</div>
</noindex>
<br>



<li><a href="p20.php.html#metkadoc2">     Введение в систему X     </a></li>
<li><a href="p20.php.html#metkadoc3">      X-сервер      </a></li>
<li><a href="p20.php.html#metkadoc4">      X-клиент      </a></li>
<li><a href="p20.php.html#metkadoc5">      X-протокол      </a></li>
<li><a href="p20.php.html#metkadoc6">      Xlib      </a></li>
<li><a href="p20.php.html#metkadoc7">      Комплекты инструментов      </a></li>
<li><a href="p20.php.html#metkadoc8">      Оконные менеджеры      </a></li>
<li><a href="p20.php.html#metkadoc9">      Другие способы создания GUI — платформно-независимые оконные API      </a></li>
<li><a href="p20.php.html#metkadoc10">     Введение в GTK+     </a></li>
<li><a href="p20.php.html#metkadoc11">      Система типов GLib      </a></li>
<li><a href="p20.php.html#metkadoc12">      Система объектов GTK+      </a></li>
<li><a href="p20.php.html#metkadoc13">      Знакомство с GNOME      </a></li>
<li><a href="p20.php.html#metkadoc14">      Установка библиотек разработки GNOME/GTK+      </a></li>
<li><a href="p20.php.html#metkadoc15">     События, сигналы и обратные вызовы     </a></li>
<li><a href="p20.php.html#metkadoc16">     Виджеты упаковочных контейнеров     </a></li>
<li><a href="p20.php.html#metkadoc17">     Виджеты GTK+     </a></li>
<li><a href="p20.php.html#metkadoc18">      <i>GtkWindow</i>      </a></li>
<li><a href="p20.php.html#metkadoc19">      <i>GtkEntry</i>      </a></li>
<li><a href="p20.php.html#metkadoc20">      <i>GtkSpinButton</i>      </a></li>
<li><a href="p20.php.html#metkadoc21">      <i>GtkButton</i>      </a></li>
<li><a href="p20.php.html#metkadoc22">      <i>GtkTreeView</i>      </a></li>
<li><a href="p20.php.html#metkadoc23">     Виджеты GNOME     </a></li>
<li><a href="p20.php.html#metkadoc24">     Меню GNOME     </a></li>
<li><a href="p20.php.html#metkadoc25">     Диалоговые окна     </a></li>
<li><a href="p20.php.html#metkadoc26">      <i>GtkDialog</i>      </a></li>
<li><a href="p20.php.html#metkadoc27">      Модальное диалоговое окно      </a></li>
<li><a href="p20.php.html#metkadoc28">      Немодальные диалоговые окна      </a></li>
<li><a href="p20.php.html#metkadoc29">      <i>GtkMessageDialog</i>      </a></li>
<li><a href="p20.php.html#metkadoc30">     Приложение для работы с базой данных компакт-дисков     </a></li>
<li><a href="p20.php.html#metkadoc31">     Резюме     </a></li>
<a name="metkadoc1"><h1>Глава 16</p>    <p>Программирование в GNOME с помощью GTK+</h1></a>       <p>До сих пор в этой книге мы обсуждали основные методы программирования в ОС Linux, касающиеся сложной внутренней начинки. Теперь же пора вдохнуть жизнь в наши приложения и узнать, как включить в них графический пользовательский интерфейс (Graphical User Interface, GUI). В этой главе и в<i> главе 17</i> мы собираемся рассмотреть две самые популярные библиотеки GUI для ОС Linux: GTK+ и KDE/Qt. Эти библиотеки соответствуют двум популярнейшим интегрированным средам рабочего стола Linux: GNOME (GTK+) и KDE.</p>    <p>Все библиотеки GUI в Linux размещены поверх низкоуровневой оконной системы, называемой X Window System (чаще X11 или просто X), поэтому, прежде чем вдаваться в подробности среды GNOME/GTK+, мы приведем обзор основных принципов работы системы X и поможем понять, как различные слои оконной системы пригоняются один к другому для создания того, что мы называем<i> рабочим столом.</i></p>    <p>В этой главе обсуждаются следующие темы:</p>    <p>&#9633; система X Window System;</p>    <p>&#9633; введение в среду GNOME/GTK+;</p>    <p>&#9633; виджеты или интерфейсные элементы окна GTK+;</p>    <p>&#9633; виджеты и меню среды GNOME;</p>    <p>&#9633; диалоговые окна;</p>    <p>&#9633; GUI базы данных компакт-дисков с использованием GNOME/GTK+.</p>          <a name="metkadoc2"><h1>Введение в систему X</h1></a>         <p>Если вы когда-либо применяли оконную систему рабочего стола в ОС Linux, скорее всего вы использовали графическую систему X с открытым программным кодом. Одна из наиболее передовых и в результате разочаровывающих характеристик X — жесткая привязка к идеологии "инструментов, а не политики". Это означает, что в системе X нет определения какого-либо пользовательского интерфейса, но есть средства для его создания. Вы вольны создавать целиком собственную среду рабочего стола, экспериментируя и вводя новшества при желании. Но это же свойство долгое время тормозило разработку пользовательских интерфейсов в системах Linux и UNIX. Для заполнения этой пустоты возникли два проекта рабочего стола, предпочитаемые пользователями Linux: GNOME и KDE. Рабочий стол ОС Linux, тем не менее, не ограничивается системой X. В действительности рабочий стол в Linux — это довольно расплывчатая субстанция без определенной версии, выпущенной в рамках одного проекта или какой-либо группой специалистов. Современная установка содержит мириады библиотек, утилит и приложений, которые все вместе называются "рабочим столом".</p>     <p>У системы X, первоначально разработанной в MIT (Массачусетский технологический институт) в начале 1980 гг., длинная и яркая история. Она создавалась как унифицированная оконная система для высокопроизводительных рабочих станций того времени, которые были очень дорогими перемалывающими огромные объемы чисел чудовищами.</p>     <p>Когда наступили 1990 гг. и цены на оборудование упали, энтузиасты перенесли систему X на недорогие домашние компьютеры PC, этот проект стал называться XFree86 (процессоры PC, выпускавшиеся корпорацией Intel и другими компаниями, были известны как процессоры x86), и сегодня вместе с системой Linux распространяются потомки проекта XFree86, а в большинстве дистрибутивов Linux применяется вариант системы X, названный X.Org,</p>     <p>X Window System разделена на компоненты аппаратного и программного уровней, называемые Х-сервером и Х-клиентом. Эти компоненты взаимодействуют с помощью протокола с легко угадываемым названием "X-протокол". В следующих разделах рассматривается по очереди каждый из этих компонентов.</p>             <a name="metkadoc3"><h1>X-сервер</h1></a>     <p>X-сервер запускается на пользовательской локальной машине и выполняет низкоуровневые операции прорисовки графического экрана. Присутствие в названии слова "сервер" часто смущает: X-сервер выполняется на вашем настольном ПК. X-клиенты могут запускаться на вашем настольном ПК или на самом деле выполняться на других компьютерах в вашей сети, включая серверы. Если подумать, обратная терминология не лишена смысла, но часто кажется применяемой задом наперед.</p>     <p>Поскольку X-сервер напрямую общается с видеокартой, вы должны применять X-сервер, соответствующий вашей видеокарте, и для него следует задавать подходящее разрешение, скорость обновления экрана, количество цветов и т.д. Файл конфигурации называется xorg.conf или Xfree86Config. В прошлом вы обычно должны были вручную редактировать файл конфигурации, чтобы добиться корректной работы системы X. К счастью, современные дистрибутивы Linux автоматически определяют нужные установочные параметры, экономя время пользователя и избавляя его от решения головоломок!</p>     <p>X-сервер ждет ввод пользователя от мыши и клавиатуры и передает нажатия клавиш и щелчки кнопками мыши приложениям, X-клиентам. Эти сообщения называют событиями; они служат основными элементами программирования GUI. Позже в этой главе мы подробно рассмотрим события и их логическое расширение GTK+ сигналы.</p>             <a name="metkadoc4"><h1>X-клиент</h1></a>     <p>X-клиент — это любая программа, использующая X Window System как GUI. Примерами могут служить xterm, xcalc и более сложные, приложения, например, Abiword. X-клиент ждет события пользователя, посылаемые X-сервером, и отвечает на них отправкой обратно серверу сообщений об обновлении изображений.</p>     <blockquote>      <b>Примечание</b>      <p>X-клиент необязательно должен быть на той же машине, что и X-сервер.</p>     </blockquote>             <a name="metkadoc5"><h1>X-протокол</h1></a>     <p>X-клиент и X-сервер взаимодействуют с помощью X-протокола, который позволяет клиенту и серверу быть разделенными сетью. Например, вы можете запустить приложение X-клиент с удаленного компьютера через Интернет или шифруемую виртуальную частную сеть (Virtual Private Network, VPN). В большинстве персональных систем Linux X-клиенты и X-сервер работают в одной и той же системе.</p>             <a name="metkadoc6"><h1>Xlib</h1></a>     <p>Xlib — это библиотека, неявно используемая X-клиентом для генерации сообщений X-протокола. Она предоставляет API очень низкого уровня, позволяющий клиенту отображать простейшие элементы на X-сервере и откликаться на простейший ввод. Мы должны подчеркнуть, что Xlib — это библиотека очень низкого уровня, и создание с ее применением даже чего-либо столь же простого, как меню, — невероятно трудоемкий процесс, требующий сотен строк программного кода.</p>     <p>Разработчик GUI не может эффективно программировать непосредственно с помощью Xlib. Вам нужен API, делающий легким и простым создание таких элементов GUI, как меню, кнопки и раскрывающиеся списки. Говоря кратко, эту роль играет<i> комплект инструментальных средств</i> или<i> элементов интерфейса.</i></p>             <a name="metkadoc7"><h1>Комплекты инструментов</h1></a>     <p>Комплект инструментов или элементов интерфейса — это библиотека GUI, которую X-клиенты применяют для значительного упрощения создания окон, меню, кнопок и т.п. С помощью комплекта инструментальных средств вы можете создавать кнопки, меню, фреймы и тому подобное с помощью вызовов одной функции. Общий термин для обозначения элементов GUI, подобных перечисленным, — <i>виджеты</i>, универсальный элемент, который вы найдете во всех современных библиотеках GUI.</p>     <p>Существует масса комплектов инструментов для системы X, из которых вы можете выбирать, и каждый из них обладает определенными достоинствами и недостатками. На каком остановиться — важное проектное решение для вашего приложения, и при выборе следует учитывать следующие факторы.</p>     <p>&#9633; Для кого предназначено ваше приложение?</p>     <p>&#9633; Будут ли установлены библиотеки комплекта инструментов у ваших пользователей?</p>     <p>&#9633; Перенесен ли комплект инструментов в другие популярные операционные системы?</p>     <p>&#9633; Какой лицензией программного обеспечения пользуется комплект инструментов и согласуется ли она с предполагаемым вами использованием?</p>     <p>&#9633; Поддерживает ли комплект инструментов ваш язык программирования?</p>     <p>&#9633; Современный ли внешний вид и реализация у комплекта инструментов?</p>     <p>На протяжении многих лет самыми популярными комплектами инструментальных средств были Motif, OpenLook и Xt, но они уступили технически более совершенным комплектам GTK+ и Qt, формирующим основу рабочих столов GNOME и KDE соответственно.</p>             <a name="metkadoc8"><h1>Оконные менеджеры</h1></a>     <p>Последний компонент X-мозаики — оконный менеджер или диспетчер, который отвечает за расположение окон на экране. Оконные менеджеры часто поддерживают отдельные "рабочие области", на которые делится рабочий стол, увеличивая область экрана, с которой вы можете взаимодействовать. Оконный менеджер также отвечает за графическое оформление всех окон, состоящее, как правило, из рамки и полосы заголовка с пиктограммами максимизации, минимизации и закрытия окна. Оконные менеджеры обеспечивают частично внешний вид рабочего стола, например заголовки окон.</p>     <p>К широко распространенным относятся следующие оконные менеджеры:</p>     <p>&#9633; Metacity — оконный менеджер, используемый по умолчанию для рабочего стола GNOME;</p>     <p>&#9633; KWin — оконный менеджер, применяемый по умолчанию для рабочего стола KDE;</p>     <p>&#9633; Openbox — разработанный для экономии ресурсов и запускаемый на более старых и медленных системах;</p>     <p>&#9633; Enlightenment — оконный менеджер, отображающий превосходную графику и спецэффекты.</p>     <p>Как и все в системе X, оконные менеджеры можно переключать. Тем не менее, большинство пользователей запускает оконный менеджер, входящий в их поставку среды рабочего стола.</p>             <a name="metkadoc9"><h1>Другие способы создания GUI — платформно-независимые оконные API</h1></a>     <p>Следует упомянуть и другие способы создания GUI, характерные для ОС Linux, — существуют языки с собственной поддержкой GUI, функционирующей под управлением Linux.</p>     <p>&#9633; Язык Java поддерживает программирование GUI с помощью Swing и более старых API AWT. Внешнее оформление GUI на языке Java понравится не всем и на более старых машинах интерфейс может восприниматься как громоздкий и медленно реагирующий. Огромное преимущество Java заключается в том, что единожды откомпилированный код на языке Java выполняется неизменным да любой платформе с виртуальной машиной Java (Java Virtual Machine), которая включает Linux, Windows, Mac OS и мобильные устройства. Дополнительную информацию см. на Web-сайте <b>http://java.sun.com.</b></p>     <p>&#9633; Язык программирования C# очень похож на язык Java. В систему Linux общеязыковая исполняющая среда (C# Common Language или CLR) пришла из проекта Mono, см. Web-сайт <b>http://www.mono-project.com.</b> C# на платформе Mono поддерживает модель программирования Windows Forms, применяемую в Windows, и специальную привязку к комплекту инструментов GTK+, названную Gtk#.</p>     <p>&#9633; Tcl/Tk — язык сценариев, отлично подходящий для быстрой разработки интерфейсов GUI и работающий с X, Windows и Mac OS. Он очень удобен для быстрого макетирования или маленьких утилит, нуждающихся в простоте и удобстве сопровождения сценария. Все подробности можно найти на Web-сайте <b>http://tcl.tk.</b></p>     <p>&#9633; Python — тоже язык сценариев. Вы можете применять Tk, часть Tcl/Tk, из Python или программировать в привязке Python к GTK+, разрабатывая программы GTK+ на языке Python. Дополнительную информацию о языке Python см. на Web-сайте <b>http://www.python.org.</b></p>     <p>&#9633; Perl — еще один популярный язык сценариев в Linux. Вы можете применять Tk, часть Tcl/Tk, в языке Perl как Perl/Tk. Дополнительную информацию о Perl см. на Web-сайте <b>http://www.perl.org/.</b></p>     <p>За платформою независимость, которую приносят эти языки, приходится платить. Совместное использование данных их собственными приложениями — например, применение операции перетаскивания мышью (drag and drop) — затруднено, и сохранение конфигурации обычно следует выполнять специфическим, а не стандартным способом, характерным для рабочего стола. Иногда поставщики программного обеспечения на языке Java хитрят, включая в поставку платформно-зависимые расширения для того, чтобы избежать подобных проблем.</p>              <a name="metkadoc10"><h1>Введение в GTK+</h1></a>         <p>Теперь, когда вы познакомились с системой X Window System, самое время рассмотреть комплект инструментальных средств GTK+ Toolkit. GTK+ появился на свет как часть популярного графического редактора GNU Image Manipulation Program (GIMP), от которого он и унаследовал свое имя (The Gimp ToolKit). Очевидно, что программисты GIMP всерьез предвидели превращение GTK+ в самостоятельный проект, поскольку он вырос и стал одним из самых мощных и популярных комплектов инструментов. Домашнюю страницу проекта GTK+ можно найти по адресу <b>http://www.gtk.org.</b></p>     <blockquote>      <b>Примечание</b>      <p>В итоге, GTK+ — это библиотека, которая существенно упрощает создание графических интерфейсов пользователей (Graphical User Interface, GUI), предоставляя набор готовых компонентов, именуемых<i> виджетами,</i> которые вы соединяете вместе с помощью легких в использовании вызовов функций, включенных в логическую структуру вашего приложения.</p>     </blockquote>     <p>Несмотря на то, что GTK+ — это проект GNU, как и GIMP, он выпущен на условиях более либеральной лицензии (Lesser General Public License, Стандартная общественная лицензия ограниченного применения GNU), которая освобождает программное обеспечение (включая патентованное программное обеспечение с закрытым программным кодом), написанное с использованием GTK+, от уплаты лицензионных вознаграждений или авторских гонораров, а также других ограничений. Свобода, предлагаемая лицензией GTK+, отличает этот комплект инструментов от его конкурента Qt (который будет обсуждаться в следующей главе), чья лицензия GPL запрещает разработку коммерческого программного обеспечения с использованием Qt (в этом случае вы должны купить коммерческую лицензию для Qt).</p>     <p>Комплект GTK+ целиком написан на языке С и большая часть программного обеспечения GTK+ также написана на С. К счастью, существует ряд привязок к языкам (language binding), позволяющих применять GTK+ в предпочитаемом вами языке программирования, будь то С++, Python, PHP, Ruby, Perl, C# или Java.</p>     <p>Комплект GTK+ сформирован как надстройка для ряда других библиотек, К ним относятся следующие:</p>     <p>&#9633; GLib — предоставляет низкоуровневые структуры данных, типы, поддержку потоков, циклов событий и динамической загрузки;</p>     <p>&#9633; GObject — реализует объектно-ориентированную систему на языке С, не требующую применения языка С++;</p>     <p>&#9633; Pango — поддерживает визуализацию и форматирование текста;</p>     <p>&#9633; ATK — помогает создавать приложения с доступом и позволяет пользователям запускать ваши приложения с помощью средств чтения экрана и других средств доступа;</p>     <p>&#9633; GDK (GIMP Drawing Kit) — обрабатывает визуализацию низкоуровневой графики поверх библиотеки Xlib;</p>     <p>&#9633; GdkPixbuf — помогает манипулировать изображениями в программах GTK+;</p>     <p>&#9633; Xlib — предоставляет низкоуровневую графику в системах Linux и UNIX.</p>             <a name="metkadoc11"><h1>Система типов GLib</h1></a>     <p>Если вы когда-нибудь просматривали программный код GTK+, то могли удивиться, увидев множество типов данных языка С с префиксом <blockquote>g</blockquote>, например, <blockquote>gint</blockquote>, <blockquote>gchar</blockquote>, <blockquote>gshort</blockquote>, а также незнакомые типы <blockquote>gint32</blockquote> и <blockquote>gpointer</blockquote>. Дело в том, что комплект GTK+ основан на библиотеках переносимости языка С (portability libraries), названных GLib и GObject, которые определяют эти типы для того, чтобы способствовать межплатформным разработкам.</p>     <p>GLib и GObject помогают межплатформным разработкам, обеспечивая стандартный набор типов данных замещения, функций и макросов для поддержки управления памятью и общих задач. Эти типы, функции и макросы означают, что, как программисты GTK+, мы можем быть уверены в том, что наш программный код надежно переносится на другие платформы и архитектуры.</p>     <p>В библиотеке Glib также определено несколько очень удобных констант:</p>     <p><blockquote><b>#include &lt;glib/gmacros.h&gt;</b></blockquote></p>     <p><blockquote><b>#define FALSE 0</b></blockquote></p>     <p><blockquote><b>#define TRUE !FALSE</b></blockquote></p>     <p>Дополнительные типы данных — это типы, служащие заменой для стандартных типов данных C (из соображений совместимости и читабельности) и гарантирующие одинаковый размер в байтах на. всех платформах:</p>     <p>&#9633; <blockquote>gint</blockquote>, <blockquote>guint</blockquote>, <blockquote>gchar</blockquote>, <blockquote>guchar</blockquote>, <blockquote>glong</blockquote>, <blockquote>gulong</blockquote>, <blockquote>gfloat</blockquote> и <blockquote>gdouble </blockquote>— просто замены для стандартных типов С для совместимости;</p>     <p>&#9633; <blockquote>gpointer</blockquote> — синоним типа (<blockquote>void*</blockquote>);</p>     <p>&#9633; <blockquote>gboolean</blockquote> — полезен для представления логических значений и служит оболочкой для <blockquote>int</blockquote>;</p>     <p>&#9633; <blockquote>gint8</blockquote>, <blockquote>guint8</blockquote>, <blockquote>gint16</blockquote>, <blockquote>guint16</blockquote>, <blockquote>gint32</blockquote> и <blockquote>guint32</blockquote> — знаковые и беззнаковые типы с гарантированным размером в байтах.</p>     <p>Удобно то, что применение библиотек GLib и GObject почти прозрачно. Glib широко используется в GTK+, поэтому если у вас есть работающая установка GTK+, то вы обнаружите, что библиотека Glib уже установлена. Как вы увидите позже в этой главе, при программировании с помощью комплекта GTK+ вам даже не придется явно включать заголовочный файл glib.h.</p>             <a name="metkadoc12"><h1>Система объектов GTK+</h1></a>     <p>Все, у кого уже есть опыт программирования GUI, возможно, поймут наше утверждение о строгой приверженности библиотек GUI концепции объектно-ориентированного программирования (ООП), настолько строгой, что все современные комплекты инструментов, включая GTK+, написаны в стиле объектно-ориентированного программирования.</p>     <p>Несмотря на то, что комплект инструментов GTK+ написан на чистом С, он поддерживает объекты и ООП благодаря библиотеке GObject. Эта библиотека поддерживает наследование объектов и полиморфизм с помощью макросов.</p>     <p>Давайте рассмотрим образец наследования и полиморфизма на примере иерархии объектов GtkWindow, взятой из документации GTK+ API.</p>     <p><blockquote>GObject</blockquote></p>     <p><blockquote> +---GInitiallyUnowned</blockquote></p>     <p><blockquote> +----GtkObject</blockquote></p>     <p><blockquote>       +----GtkWidget</blockquote></p>     <p><blockquote>             +----GtkContainer</blockquote></p>     <p><blockquote>                   +----GtkBin</blockquote></p>     <p><blockquote>                         +----GtkWindow</blockquote></p>     <p>Этот список объектов говорит о том, что объект <blockquote>GtkWindow</blockquote> — потомок <blockquote>GtkBin</blockquote>, и, следовательно, любую функцию, которую вы вызываете с объектом <blockquote>GtkBin</blockquote>, вы можете вызвать и с объектом <blockquote>GtkWindow</blockquote>. Точно так же объект <blockquote>GtkWindow</blockquote> наследует из объекта <blockquote>GtkContainer</blockquote>, который в свою очередь наследует из объекта <blockquote>GtkWidget</blockquote>.</p>     <p>Для удобства все функции создания виджетов возвращают тип <blockquote>GtkWidget</blockquote>. Например,</p>     <p><blockquote><b>GtkWidget* gtk_window_new(GtkWindowType type);</b></blockquote></p>     <p>Предположим, что вы создаете объект <blockquote>GtkWindow</blockquote> и хотите передать возвращенное значение в функцию, ожидающую объект типа <blockquote>GtkContainer</blockquote>, например, такую, как <blockquote>gtk_container_add</blockquote>:</p>     <p><blockquote><b>void gtk_container_add(GtkContainer* container, GtkWidget *widget);</b></blockquote></p>     <p>Вы применяете макрос <blockquote>GTK_CONTAINER</blockquote> для приведения типов <blockquote>GtkWidget</blockquote> и <blockquote>GtkContainer</blockquote>:</p>     <p><blockquote>GtkWidget * window = gtk_window_new(GTK GTK_WINDOW_TOPLEVEL);</blockquote></p>     <p><blockquote>gtk_container_add(GTK_CONTAINER(window), awidget);</blockquote></p>     <p>Назначение этих функций вы узнаете позже; сейчас просто отметьте для себя частое применение макросов. Для каждого возможного приведения типа существует макрос.</p>     <blockquote>      <b>Примечание</b>      <p>Не беспокойтесь, если вам все это не очень понятно; вам не нужно разбираться в подробностях ООП для того, чтобы освоить GNOME/GTK+. На самом деле это безболезненный способ усвоить идеи и преимущества ООП на базе знакомого вам языка С.</p>     </blockquote>             <a name="metkadoc13"><h1>Знакомство с GNOME</h1></a>     <p>GNOME — имя, данное проекту, начатому в 1997 г. программистами, работавшими в проекте GNU Image Manipulation Program (GIMP) над созданием унифицированного рабочего стола для Linux. Все были согласны с тем, что выбор ОС Linux как платформы рабочего стола тормозился отсутствием согласованной стратегии. В то время рабочий стол Linux напоминал Дикий Запад без общих стандартов или выработанных на практике приемов, и программисты могли делать все, что вздумается. Без сводной группы, контролирующей меню рабочего стола, согласованное представление и отображение, документацию, трансляцию и т.д., освоение рабочего стола новичком было в лучшем случае путанным, а в худшем — непригодным.</p>     <p>Группа GNOME намеревалась создать рабочий стол для ОС Linux с лицензией GPL, разрабатывая утилиты и программы настройки в едином согласованном стиле, одновременно способствуя развитию стандартов для взаимодействия приложений, печати, управления сеансами и лучших приемов в программировании GUI приложений.</p>     <p>Результаты их стараний очевидны: среда GNOME — основа стандартного рабочего стола Linux в дистрибутивах Fedora, Red Hat, Ubuntu, openSUSE и др. (рис. 16.1).</p>     <p>Первоначально название GNOME означало GNU Network Object Model Environment (среда сетевых объектных моделей GNU), что отражает одну из ранее поставленных задач, внедрение в систему Linux объектной интегрированной системы, такой как Microsoft OLE, для того, чтобы вы могли, например, встроить электронную таблицу в документ текстового процессора. Теперь поставлены новые задачи, и то, что сегодня нам известно как GNOME, — это законченная среда рабочего стола, содержащая панель для запуска приложений, комплект программ и утилит, библиотеки программирования и средства поддержки разработчиков.</p>     <p>Перед тем как начать программировать, следует убедиться в том, что все библиотеки установлены.</p>     <img src="image051.jpg"/>     <p><b>Рис. 16.1</b> </p>             <a name="metkadoc14"><h1>Установка библиотек разработки GNOME/GTK+</h1></a>     <p>Полный рабочий стол GNOME со своими стандартными приложениями и библиотеками разработки GNOME/GTK+ включает в себя более 60 пакетов, поэтому установка GNOME с нуля вручную или из исходного кода — устрашающая перспектива. К счастью, в современных дистрибутивах Linux есть отличные утилиты управления пакетами, превращающие установку GNOME/GTK+ и библиотек разработки в пустяковое дело.</p>     <p>В дистрибутивах Linux Red Hat и Fedora вы открываете средство <b>Package Management</b> (Управление пакетами), щелкнув мышью кнопку меню <b>Applications </b>(Приложения) и выбрав команду <b>Add/Remove Software</b> (Добавить/удалить программы). Когда появится <b>Package Management</b> (рис. 16.2), убедитесь в том, что установлен флажок <b>GNOME Software Development</b> (Разработка программ GNOME). Загляните в область <b>Development</b> (Разработка) для этого установочного параметра.</p>     <p>В этой главе вы будете работать с GNOME/GTK+ 2, поэтому убедитесь в том, что установлены библиотеки версии 2<i>.x.</i><b>Рис. 16.2</b> </p>     <img src="image052.jpg"/>     <br>     <p>В случае дистрибутивов, применяющих RPM-пакеты, у вас должны быть установлены как минимум следующие RPM-пакеты:</p>     <p>&#9633; gtk2-2.10.11-7.fc7.rpm;</p>     <p>&#9633; gtk2-devel-2.10.11-7.fc7.rpm;</p>     <p>&#9633; gtk2-engines-2.10.0-3.fc7.rpm;</p>     <p>&#9633; libgnome-2.18.0-4.fc7.rpm;</p>     <p>&#9633; libgnomeui-2.18.l-2.fc7.rpm;</p>     <p>&#9633; libgnome-devel-2.18.0-4.fc7.rpm;</p>     <p>&#9633; libgnomeui-devel-2.18.1-2.fc7.rpm.</p>     <blockquote>      <b>Примечание</b>      <p>В этом примере комбинация символов fc7 указывает на дистрибутив Linux Fedora 7. В вашей системе могут быть слегка отличающиеся имена.</p>     </blockquote>     <p>В дистрибутиве Debian и основанных на Debian системах, таких как Ubuntu, вы можете использовать программу apt-get для установки пакетов GNOME/GTK+ с разных сайтов-зеркал (mirrors). Для выяснения подробностей следуйте по ссылкам Web-сайта <b>http://www.gnome.org.</b></p>     <p>Опробуйте также демонстрационное приложение GTK+, в котором показаны все виджеты и их оформление (рис. 16.3).</p>     <p><blockquote>$ <b>gtk-demo</b></blockquote></p>     <img src="image053.jpg"/>     <p><b>Рис. 16.3</b> </p>     <br>     <b>Примечание</b>     <p>Для каждого виджета отображаются вкладки <b>Info</b> (Информация) и <b>Source</b> (Исходный код). На вкладке <b>Source</b> (Исходный код) приведен программный код на языке С для применения данного виджета. На ней может быть представлено множество примеров.</p>     <p>Выполните упражнение 16.1.</p>     <p>Упражнение 16.1. Обычное окно <blockquote>GtkWindow</blockquote></p>     <p>Давайте начнем программирование средствами GTK+ с простейшей из программ GUI — отображения окна. Вы увидите библиотеки GTK+ в действии и большой набор функциональных возможностей, получаемых из очень короткого программного кода.</p>     <p>1. Введите программу и назовите ее gtk1.с:</p>     <p><blockquote>#include &lt;gtk/gtk.h&gt;</blockquote></p>     <br>     <p><blockquote>int main(int argc, char *argv[]) {</blockquote></p>     <p><blockquote> GtkWidget *window;</blockquote></p>     <p><blockquote> gtk_init(&amp;argc, &amp;argv);</blockquote></p>     <p><blockquote> window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</blockquote></p>     <p><blockquote> gtk_widget_show(window);</blockquote></p>     <p><blockquote> gtk_main();</blockquote></p>     <p><blockquote> return 0;</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>2. Для компиляции gtk1.c введите следующую команду:</p>     <p><blockquote>$ <b>gcc gtk1.c -о gtk1 `pkg-config --cflags --libs gtk+-2.0`</b></blockquote></p>     <blockquote>      <b>Примечание</b>      <p>Будьте внимательны и набирайте обратные апострофы, а не обычные апострофы — помните о том, что обратные апострофы — это инструкции, заставляющие оболочку выполнить заключенную в них команду и добавить ее вывод в конец строки.</p>     </blockquote>     <p>Когда вы выполните программу с помощью следующей команды, ваше окно должно раскрыться (рис. 16.4).</p>     <p><blockquote>$ <b>./gtk1</b></blockquote></p>     <img src="image054.jpg"/>     <p><b>Рис. 16.4</b> </p>     <br>     <p>Учтите, что вы можете перемещать окно, изменять его размер, сворачивать и раскрывать его на весь экран.</p>     <p><b>Как это работает</b></p>     <p>Включить заголовочные файлы, необходимые для библиотек GTK+ и связанных с ними библиотек, можно с помощью одного оператора <blockquote>#include &lt;gtk/gtk.h&gt;</blockquote>. Далее вы объявляете окно как указатель на объект <blockquote>GtkWidget</blockquote>.</p>     <p>Затем для инициализации библиотек GTK+ следует выполнить вызов <blockquote>gtk_init</blockquote>, передав аргументы командной строки <blockquote>argc</blockquote> и <blockquote>argv</blockquote>. Это дает возможность GTK+ выполнить синтаксический анализ любых параметров командной строки, о которых комплект должен знать. Учтите, что вы всегда должны инициализировать GTK+ таким способом перед вызовом любых функций GTK+.</p>     <p>Суть примера заключается в вызове функции <blockquote>gtk_window_new</blockquote>. Далее приведен ее прототип:</p>     <p><blockquote><b>GtkWidget* gtk_window_new(GtkWindowType type);</b></blockquote></p>     <p>Параметр type может принимать в зависимости от назначения окна одно из двух значений:</p>     <p>&#9633; <blockquote>GTK_WINDOW_TOPLEVEL</blockquote> — стандартное окно с рамкой;</p>     <p>&#9633; <blockquote>GTK_WINDOW_POPUP</blockquote> — окно без рамки, подходящее для диалогового окна.</p>     <p>Почти всегда вы будете применять значение <blockquote>GTK_WINDOW_TOPLEVEL</blockquote>, потому что для создания диалоговых окон, как вы узнаете позже, есть гораздо более удобные способы.</p>     <p>Вызов <blockquote>gtk_window_new</blockquote> создает окно в памяти, таким образом у вас появляется возможность перед реальным выводом окна на экран заполнить его виджетами, изменить размер окна, его заголовок и т.д. Для того чтобы окно появилось на экране, выполните вызов функции <blockquote>gtk_widget_show</blockquote>:</p>     <p><blockquote>gtk_widget_show(window);</blockquote></p>     <p>Эта функция принимает указатель типа <blockquote>GtkWidget</blockquote>, поэтому вы просто предоставляете ссылку на свое окно.</p>     <p>Последним вы выполняете вызов функции <blockquote>gtk_main</blockquote>. Эта основная функция запускает процесс обмена информацией (interactivity process), передавая управление GTK+, и не возвращает его до тех пор, пока не будет выполнен вызов функции <blockquote>gtk_main_quit</blockquote>. Как видно в программе gtk1.с, этого никогда не происходит, поэтому приложение не завершается даже после закрытия окна. Проверьте это, щелкнув кнопкой мыши пиктограмму закрытия окна и убедившись в отсутствии строки, приглашающей вводить команду. Вы исправите это поведение после того, как познакомитесь с сигналами и обратными вызовами в следующем разделе. Сейчас завершите приложение, нажав комбинацию клавиш &lt;Ctrl&gt;+&lt;C&gt; в окне командной оболочки, которое вы использовали для запуска программы gtk1.</p>              <a name="metkadoc15"><h1>События, сигналы и обратные вызовы</h1></a>    <p>У всех библиотек GUI есть нечто общее. Должен существовать некий механизм для выполнения программного кода в ответ на действие пользователя. Программа, выполняющаяся в режиме командной строки, может позволить себе останов выполнения в ожидании ввода и затем применить нечто вроде оператора выбора для выполнения разных ветвей программы в зависимости от введенных данных. Такой подход нецелесообразен в случае приложения GUI, поскольку оно должно непрерывно реагировать на ввод пользователя, например, ему приходится постоянно обновлять области окна.</p>    <p>У современных оконных систем есть система событий и приемники событий, которым адресована эта задача. Идея заключается в том, что каждый пользовательский ввод обычно с помощью мыши или клавиатуры инициирует событие. Нажатие на клавиатуре, например, вызовет "событие клавиатуры". Затем пишется программный код, который ждет приема такого события и выполняется в случае его возникновения.</p>    <p>Как вы уже видели, эти события генерирует система X Window System, но они мало помогут вам как программисту GTK+, т.к. они очень низкоуровневые. Когда производится щелчок кнопкой мыши, X порождает событие, содержащее координаты указателя мыши, а вам нужно знать, когда пользователь активизирует виджет.</p>    <p>У GTK+ есть собственная система событий и приемников событий, называемых сигналами и обратными вызовами. Их очень легко применять, поскольку для установки обработчика сигнала можно использовать очень полезное свойство языка С, указатель на функцию.</p>    <p>Сначала несколько определений. Сигнал GTK+ порождается объектом типа <blockquote>GtkObject</blockquote>, когда происходит нечто, например, ввод пользователя. Функция, связанная с сигналом и, следовательно, вызываемая при любом порождении сигнала, называется<i> функцией обратного вызова.</i></p>    <blockquote>     <b>Примечание</b>     <p>Имейте в виду, что сигнал GTK+ — это нечто иное, чем сигнал UNIX, обсуждавшийся в <i>главе 11.</i></p>    </blockquote>    <p>Как программист, использующий GTK+, вы должны заботиться только о написании и связывании функций обратного вызова, поскольку код порождения сигнала — это внутренний программный код определенного виджета.</p>    <p>Прототип или заголовок функции обратного вызова обычно похож на следующий:</p>    <p><b><blockquote><b>void a_callback_function(GtkWidget *widget, gpointer user_data);</b></blockquote></b></p>    <p>Вы передаете два параметра: первый — указатель на виджет, породивший сигнал, второй — произвольный указатель, который вы выбираете самостоятельно, когда связываете обратный вызов. Вы можете использовать этот указатель для любых целей.</p>    <p>Связать функцию обратного вызова тоже очень просто. Вы вызываете функцию <blockquote>g_signal_connect</blockquote> и передаете ей виджет, имя сигнала в виде строки, указатель на функцию обратного вызова и ваш произвольный указатель:</p>    <p><blockquote><b>gulong g_signal_connect(gpointer *object, const gchar *name,</b></blockquote></p>    <p><blockquote><b> GCallback func, gpointer user_data);</b></blockquote></p>    <p>Следует отметить, что для связывания функций обратного вызова нет ограничений. Вы можете иметь много сигналов, связанных с одной и той же функцией обратного вызова, и много функций обратного вызова, связанных с единственным сигналом.</p>    <p>В документации по API GTK+ можно найти подробное описание сигналов, порождаемых каждым виджетом.</p>    <blockquote>     <b>Примечание</b>     <p>До появления GTK+ 2 для связывания функций обратного вызова применялась функция <blockquote>gtk_signal_connect</blockquote>. Она была заменена функцией <blockquote>g_signal_connect</blockquote> и не должна применяться во вновь разрабатываемом программном коде.</p>    </blockquote>    <p>Вы опробуете функцию <blockquote>g_signal_connect</blockquote> в упражнении 16.2.</p>    <b>Упражнение 16.2. Функция обратного вызова</b>    <p>В программе gtk2.c вставьте в свое окно кнопку и свяжите сигнал <blockquote>clicked</blockquote> (щелчок мышью по кнопке) с вашей функцией обратного вызова для вывода короткого сообщения:</p>    <p><blockquote>#include &lt;gtk/gtk.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>    <br>    <p><blockquote>static int count = 0;</blockquote></p>    <p><blockquote>void button_clicked(GtkWidget *button, gpointer data) {</blockquote></p>    <p><blockquote> printf("%s pressed %d time(s) \n", (char *)data, ++count);</blockquote></p>    <p><blockquote>}</blockquote></p>    <br>    <p><blockquote>int main(int argc, char* argv[]) {</blockquote></p>    <p><blockquote> GtkWidget *window;</blockquote></p>    <p><blockquote> GtkWidget *button;</blockquote></p>    <p><blockquote> gtk_init(&amp;argc, &amp;argv);</blockquote></p>    <p><blockquote> window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</blockquote></p>    <p><blockquote> button = gtk_button_new_with_label("Hello World!");</blockquote></p>    <p><blockquote> gtk_container_add(GTK_CONTAINER(window), button);</blockquote></p>    <p><blockquote> g_signal_connect(GTK_OBJECT(button), "clicked",</blockquote></p>    <p><blockquote>  GTK_SIGNAL_FUNC(button_clicked), "Button 1");</blockquote></p>    <p><blockquote> gtk_widget_show(button);</blockquote></p>    <p><blockquote> gtk_widget_show(window);</blockquote></p>    <p><blockquote> gtk_main();</blockquote></p>    <p><blockquote> return 0;</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Введите исходный текст программы и сохраните его в файле с именем gtk2.c. Откомпилируйте и скомпонуйте программу аналогично программе gtk1.с из предыдущего упражнения. Запустив ее, вы получите окно с кнопкой. При каждом щелчке кнопки мышью будет выводиться короткое сообщение (рис. 16.5).</p>    <img src="image055.jpg"/>    <p><b>Рис. 16.5</b></p>    <br>    <p><b>Как это работает</b></p>    <p>Вы добавили два новых элемента в программу gtk2.c: виджет <blockquote>GtkButton</blockquote> и функцию обратного вызова. <blockquote>GtkButton</blockquote> — это виджет простой кнопки, которая может содержать текст, в нашем случае "Hello World", и порождает сигнал, названный <blockquote>clicked</blockquote>, каждый раз, когда кнопку щелкают мышью.</p>    <p>Функция обратного вызова <blockquote>button_clicked</blockquote> связана с сигналом <blockquote>clicked</blockquote> виджета кнопки с помощью функции <blockquote>g_signal_connect</blockquote>:</p>    <p><blockquote>g_signal_connect(GTK_OBJECT(app), "clicked",</blockquote></p>    <p><blockquote> GTK_SIGNAL_FUNC(button_clicked), "Button 1");</blockquote></p>    <p>Обратите внимание на то, что имя кнопки — "Button 1" — передается в функцию обратного вызова как данные пользователя.</p>    <p>Весь остальной добавленный программный код касается виджета кнопки, создаваемой так же, как окно — вызовом функции <blockquote>gtk_button_new_with_label</blockquote> — функция <blockquote>gtk_widget_show</blockquote> делает ее видимой.</p>    <p>Для расположения кнопки в окне вызывается функция <blockquote>gtk_container_add</blockquote>. Эта простая функция помещает <blockquote>GtkWidget</blockquote> внутрь объекта <blockquote>GtkContainer</blockquote> и принимает контейнер и виджет как аргументы: </p>    <p><blockquote>void gtk_container_add(GtkContainer* container, GtkWidget *widget);</blockquote> </p>    <p>Как вы уже знаете, <blockquote>GtkWindow</blockquote> — потомок или дочерний объект объекта <blockquote>GtkContainer</blockquote>. поэтому вы можете привести тип вашего объекта-окна к типу <blockquote>GtkContainer</blockquote> с помощью макроса <blockquote>GTK_CONTAINER</blockquote>:</p>    <p><blockquote>gtk_container_add(GTK_CONTAINER(window), button);</blockquote></p>    <p>Функция <blockquote>gtk_container_add</blockquote> прекрасно подходит для расположения в окне одиночного виджета, но гораздо чаще вам потребуется для создания хорошего интерфейса размещать несколько виджетов в разных частях окна. У комплекта GTK+ есть специальные виджеты как раз для этой цели, именуемые виджетами упаковочных контейнеров,</p>          <a name="metkadoc16"><h1>Виджеты упаковочных контейнеров</h1></a>    <p>Компоновка GUI исключительно важна для удобства применения интерфейса, и добиться наилучшей компоновки труднее всего. Реальная трудность в размещении виджетов заключается в том, что вы не можете полагаться на наличие у всех пользователей одинаковых размеров окон, тем, шрифтов и цветовых схем. То, что может быть отличным интерфейсом для одной системы, в другой системе может оказаться просто нечитаемым.</p>    <p>Для создания GUI, который выглядит одинаково во всех системах, вам необходимо избегать размещения виджетов на основе абсолютных координат и использовать более гибкую систему компоновки. У GTK+ есть для этой цели виджеты контейнеров. Виджеты-контейнеры позволяют управлять компоновкой виджетов в окнах вашего приложения. Виджеты упаковочных контейнеров (box) представляют очень удобный тип виджета-контейнера. GTK+ предлагает множество виджетов-контейнеров других типов, описанных в интерактивной документации к GTK+.</p>    <p><i>Виджеты упаковочных контейнеров </i>— невидимые виджеты, задача которых — хранить другие виджеты и управлять их компоновкой или схемой размещения. Для управления размером отдельных виджетов, содержащихся в виджете упаковочного контейнера, вы задаете правила вместо координат. Поскольку виджеты упаковочных контейнеров могут содержать любые объекты <blockquote>GtkWidget</blockquote> и объект <blockquote>GtkBox</blockquote> сам является объектом типа <blockquote>GtkWidget</blockquote>, для создания сложных компоновок можно формировать виджеты упаковочных контейнеров, вложенные один в другой.</p>    <p>У типа <blockquote>GtkBox</blockquote> существуют два основных подкласса:</p>    <p>&#9633; <blockquote>GtkHBox</blockquote> — однострочный горизонтальный упаковочный контейнер;</p>    <p>&#9633; <blockquote>GtkVBox</blockquote> — одностолбцовый вертикальный упаковочный контейнер.</p>    <p>После создания упаковочных контейнеров следует задать два параметра: <blockquote>homogeneous</blockquote> и <blockquote>spacing</blockquote>:</p>    <p><blockquote><b>GtkWidget* gtk_hbox_new(gboolean homogeneous, gint spacing);</b></blockquote></p>    <p><blockquote><b>GtkWidget* gtk_vbox_new(gboolean homogeneous, gint spacing);</b></blockquote></p>    <p>Эти параметры управляют компоновкой всех виджетов в конкретном упаковочном контейнере. Параметр <blockquote>homogeneous</blockquote> — логический, если он равен <blockquote>TRUE</blockquote>, виджеты занимают одинаковую площадь независимо от их индивидуальных размеров. Параметр <blockquote>spacing</blockquote> задает расстояние между виджетами в пикселах.</p>    <p>После того как упаковочный контейнер создан, добавьте в него виджеты с помощью функций <blockquote>gtk_box_pack_start</blockquote> и <blockquote>gtk_box_pack_end</blockquote>:</p>    <p><blockquote><b>void gtk_box_pack_start(GtkBox *box, GtkWidget *child,</b></blockquote></p>    <p><blockquote><b> gboolean expand, gboolean f ill, guint padding);</b></blockquote></p>    <p><blockquote><b>void gtk_box_pack_end(GtkBox *box, GtkWidget *child,</b></blockquote></p>    <p><blockquote><b> gboolean expand, gboolean fill, guint padding);</b></blockquote></p>    <p>Функция <blockquote>gtk_box_pack_start</blockquote> вставляет виджеты, начиная от левого края контейнера <blockquote>GtkHBox</blockquote> и нижнего края контейнера <blockquote>GtkVBox</blockquote>; функция <blockquote>gtk_box_pack_end</blockquote>, наоборот, начинает от правого и верхнего краев контейнера. Параметры функций управляют расстоянием между виджетами и форматом каждого виджета, находящегося в упаковочном контейнере.</p>    <p>В табл. 16.1 описаны параметры, которые вы можете передавать в функцию <blockquote>gtk_box_pack_start</blockquote> или <blockquote>gtk_box_pack_end</blockquote>.</p>    <br>    <p><i><b>Таблица 16.1</b></i></p>    <table>     <tr>      <th valign="top">Параметр</th>      <th valign="top">Описание</th>     </tr>     <tr>      <td valign="top"><blockquote>GtkBox *box</blockquote></td>      <td valign="top">Заполняемый упаковочный контейнер</td>     </tr>     <tr>      <td valign="top"><blockquote>GtkWidget *child</blockquote></td>      <td valign="top">Виджет, который следует поместить в упаковочный контейнер</td>     </tr>     <tr>      <td valign="top"><blockquote>gboolean expand</blockquote></td>      <td valign="top">Если равен <blockquote>TRUE</blockquote>, данный виджет занимает все доступное пространство, используемое совместно с другими виджетами, у которых этот флаг также равен <blockquote>TRUE</blockquote></td>     </tr>     <tr>      <td valign="top"><blockquote>gboolean fill</blockquote></td>      <td valign="top">Если равен <blockquote>TRUE</blockquote>, данный виджет будет занимать всю доступную площадь вместо использования ее как отступа от краев. Действует, только если флаг <blockquote>expand</blockquote> равен <blockquote>TRUE</blockquote></td>     </tr>     <tr>      <td valign="top"><blockquote>guint padding</blockquote></td>      <td valign="top">Размер отступа вокруг виджета в пикселах</td>     </tr>    </table>    <p>Давайте теперь рассмотрим эти виджеты упаковочных контейнеров и создадим более сложный пользовательский интерфейс, демонстрирующий вложенные упаковочные контейнеры (упражнение 16.3).</p>    <b>Упражнение 16.3. Макет виджета-контейнера</b>    <p>В этом примере вы спланируете размещение нескольких простых виджетов-меток типа <blockquote>GtkLabel</blockquote> с помощью контейнеров типа <blockquote>GtkHBox</blockquote> и <blockquote>GtkVBox</blockquote>. Виджеты-метки — простые графические элементы, подходящие для вывода коротких текстовых фрагментов. Назовите эту программу container.c:</p>    <p><blockquote>#include &lt;gtk/gtk.h&gt;</blockquote></p>    <br>    <p><blockquote>void closeApp(GtkWidget *window, gpointer data) {</blockquote></p>    <p><blockquote> gtk_main_quit();</blockquote></p>    <p><blockquote>}</blockquote></p>    <br>    <p><blockquote>/* Обратный вызов позволяет приложению отменить событие</blockquote></p>    <p><blockquote>   close/destroy. (Для отмены возвращает TRUE.) */</blockquote></p>    <p><blockquote>gboolean delete_event(GtkWidget *widget, GdkEvent *event, gpointer data) {</blockquote></p>    <p><blockquote> printf("In delete_event\n");</blockquote></p>    <p><blockquote> return FALSE;</blockquote></p>    <p><blockquote>}</blockquote></p>    <br>    <p><blockquote>int main (int argc, char *argv[]) {</blockquote></p>    <p><blockquote> GtkWidget *window;</blockquote></p>    <p><blockquote> GtkWidget *label1, *label2, *label3;</blockquote></p>    <p><blockquote> GtkWidget *hbox;</blockquote></p>    <p><blockquote> GtkWidget *vbox;</blockquote></p>    <p><blockquote> gtk_init(&amp;argc, &amp;argv);</blockquote></p>    <p><blockquote> window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</blockquote></p>    <p><blockquote> gtk_window_set_title(GTK_WINDOW window), "The Window Title");</blockquote></p>    <p><blockquote> gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);</blockquote></p>    <p><blockquote> gtk_window_set_default_size(GTK_WTNDOW(window), 300, 200);</blockquote></p>    <p><blockquote> g_signal_connect(GTK_OBJECT(window), "destroy",</blockquote></p>    <p><blockquote>  GTK_SIGNAL_FUNC(closeApp), NULL);</blockquote></p>    <p><blockquote> g_signal_connect(GTK_OBJECT(window), "delete_event",</blockquote></p>    <p><blockquote>  GTK_SIGNAL_FUNC(delete_event), NULL);</blockquote></p>    <p><blockquote> label1 = gtk_label_new("Label 1");</blockquote></p>    <p><blockquote> label2 = gtk_label_new("Label 2");</blockquote></p>    <p><blockquote> label3 = gtk_label_new("Label 3");</blockquote></p>    <p><blockquote> hbox = gtk_hbox_new(TRUE, 5);</blockquote></p>    <p><blockquote> vbox = gtk_vbox_new(FALSE, 10);</blockquote></p>    <p><blockquote> gtk_box_pack_start(GTK_BOX(vbox), label1, TRUE, FALSE, 5);</blockquote></p>    <p><blockquote> gtk_box_pack_start(GTK_BOX(vbox), label2, TRUE, FALSE, 5);</blockquote></p>    <p><blockquote> gtk_box_pack_start(GTK_BOX(hbox), vbox, FALSE, FALSE, 5);</blockquote></p>    <p><blockquote> gtk_box_pack_start(GTK_BOX(hbox), label3, FALSE, FALSE, 5);</blockquote></p>    <p><blockquote> gtk_container_add(GTK_CONTAINER(window), hbox);</blockquote></p>    <p><blockquote> gtk_widget_show_all(window);</blockquote></p>    <p><blockquote> gtk_main();</blockquote></p>    <p><blockquote> return 0;</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Когда вы выполните эту программу, то увидите следующую схему расположения виджетов-меток в вашем окне (рис. 16.6).</p>    <img src="image056.jpg"/>    <p><b>Рис. 16.6</b></p>    <br>    <p><b>Как это работает</b></p>    <p>Вы создаете два виджета упаковочных контейнеров: <blockquote>hbox</blockquote> и <blockquote>vbox</blockquote>. С помощью функции <blockquote>gtk_box_pack_start</blockquote> вы заполняете <blockquote>vbox</blockquote> виджетами <blockquote>label1</blockquote> и <blockquote>label2</blockquote>, причем <blockquote>label2</blockquote> располагается у нижнего края контейнера, потому что вставляется после <blockquote>label1</blockquote>. Далее контейнер <blockquote>vbox</blockquote> целиком наряду с меткой <blockquote>label3</blockquote> вставляется в контейнер <blockquote>hbox</blockquote>.</p>    <p>В заключение <blockquote>hbox</blockquote> добавляется в окно и выводится на экран с помощью функции <blockquote>gtk_widget_show_all</blockquote>.</p>    <p>Схему размещения упаковочного контейнера легче понять с помощью блок-схемы, показанной на рис. 16.7.</p>    <img src="image057.jpg"/>    <p><b>Рис. 16.7</b></p>    <br>    <p>Познакомившись с виджетами, сигналами, обратными вызовами и виджетами-контейнерами, вы рассмотрели основы комплекта инструментов GTK+. Но для того чтобы стать программистом, профессионально применяющим GTK+, нужно понять, как наилучшим образом использовать имеющиеся в комплекте виджеты.</p>          <a name="metkadoc17"><h1>Виджеты GTK+</h1></a>         <p>В этом разделе мы рассмотрим API самых популярных виджетов GTK+, которые вы будете применять чаще всего в своих приложениях.</p>             <a name="metkadoc18"><h1><i>GtkWindow</i></h1></a>     <p><blockquote>GtkWindow</blockquote> — базовый элемент всех приложений GTK+. До сих пор вы использовали его для хранения своих виджетов.</p>     <p><blockquote>GtkWidget</blockquote></p>     <p><blockquote> +---- GtkContainer</blockquote></p>     <p><blockquote>        +---- GtkBin</blockquote></p>     <p><blockquote>               +---- GtkWindow</blockquote></p>     <p>Существуют десятки вызовов API <blockquote>GtkWindow</blockquote>, но далее приведены функции, заслуживающие особого внимания.</p>     <p><blockquote><b>GtkWidget* gtk_window_new(GtkWindowType type);</b></blockquote></p>     <p><blockquote><b>void gtk_window_set_title(GtkWindow *window, const gchar *title);</b></blockquote></p>     <p><blockquote><b>void gtk_window_set_position(GtkWindow *window, GtkWindowPosition position);</b></blockquote></p>     <p><blockquote><b>void gtk_window_set_default_size(GtkWindow *window, gint width, gint height);</b></blockquote></p>     <p><blockquote><b>void gtk_window_resize(GtkWindow *window, gint width, gint height);</b></blockquote></p>     <p><blockquote><b>void gtk_window_set_resizable(GtkWindow *window, gboolean resizable);</b></blockquote></p>     <p><blockquote><b>void gtk_window_present(GtkWindow *window);</b></blockquote></p>     <p><blockquote><b>void gtk_window_maximize(GtkWindow *window);</b></blockquote></p>     <p><blockquote><b>void gtk_window_unmaximize(GtkWindow *window);</b></blockquote></p>     <p>Как вы видели, функция <blockquote>gtk_window_new</blockquote> создает в памяти новое пустое окно. Заголовок окна не задан и размер и местоположение окна не определены. Обычно вы будете заполнять окно виджетами и задавать меню и панель инструментов перед выводом окна на экран с помощью вызова функции <blockquote>gtk_widget_show</blockquote>.</p>     <p>Функция <blockquote>gtk_window_set_title</blockquote> изменяет текст полосы заголовка, информируя оконный менеджер запроса.</p>     <blockquote>      <b>Примечание</b>      <p>Поскольку за отображение оформления окна отвечает оконный менеджер, а не библиотека GTK+, шрифт, цвет и размер текста зависят от вашего выбора оконного менеджера.</p>     </blockquote>     <p>Функция <blockquote>gtk_window_setposition</blockquote> управляет начальным местоположением на экране. Параметр <blockquote>position</blockquote> может принимать пять значений, перечисленных в табл. 16.2.</p>     <br>     <p><b><i>Таблица 16.2</i></b></p>     <table>      <tr>       <th valign="top">Параметр <blockquote>position</blockquote></th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>GTK_WIN_POS_NONE</blockquote></td>       <td valign="top">Окно располагается по усмотрению оконного менеджера</td>      </tr>      <tr>       <td valign="top"><blockquote>GTK_WIN_POS_CENTER</blockquote></td>       <td valign="top">Окно центрируется на экране</td>      </tr>      <tr>       <td valign="top"><blockquote>GTK_WIN_POS_MOUSE</blockquote></td>       <td valign="top">Расположение окна задаётся указателем мыши</td>      </tr>      <tr>       <td valign="top"><blockquote>GTK_WIN_POS_CENTER_ALWAYS</blockquote></td>       <td valign="top">Окно остается отцентрированным независимо от его размера</td>      </tr>      <tr>       <td valign="top"><blockquote>GTK_WIN_POS_CENTER_ON_PARENT</blockquote></td>       <td valign="top">Окно центрируется относительно родительского окна (удобно для диалоговых окон)</td>      </tr>     </table>     <p>Функция <blockquote>gtk_window_set_default_size</blockquote> задает окно на экране в единицах отображения GTK+. Явное задание размера окна гарантирует, что содержимое окна не будет закрыто чем-либо или скрыто. Для того чтобы изменить размеры окна после его вывода на экран, можно воспользоваться функцией <blockquote>gtk_window_resize</blockquote>. По умолчанию пользователь может изменить размеры окна, перемещая обычным способом его границу мышью. Если вы хотите помешать этому, можно вызвать функцию <blockquote>gtk_window_set_resizeable</blockquote>, приравненную FALSE.</p>     <p>Для того чтобы убедиться в том, что ваше окно присутствует на экране и видно пользователю, т.е. не свернуто или скрыто, подойдет функция <blockquote>gtk_window_present</blockquote>. Она полезна для диалоговых окон, т.к. позволяет убедиться в том, что окна не свернуты, когда вам нужен какой-либо пользовательский ввод. В противном случае, для раскрытия окна на весь экран и его сворачивания у вас есть функции <blockquote>gtk_window_maximize</blockquote> и <blockquote>gtk_window_minimize</blockquote>.</p>             <a name="metkadoc19"><h1><i>GtkEntry</i></h1></a>     <p><blockquote>GtkEntry</blockquote> — виджет однострочного текстового поля, который обычно применяется для ввода простых текстовых данных, например, адреса электронной почты, имени пользователя или имени узла сети. Существуют вызовы API, позволяющие задать как считывание введенного текста, так и его максимальную длину в символах, а также другие параметры, управляющие местоположением текста и его выделением.</p>     <p><blockquote>GtkWidget</blockquote></p>     <p><blockquote> +----GtkEntry</blockquote></p>     <p>Можно настроить <blockquote>GtkEntry</blockquote> на отображение звездочек (или любого другого определенного пользователем символа) на месте набранных буквенно-цифровых символов, что очень удобно для ввода паролей, когда вы не хотите, чтобы кто-то заглядывал через ваше плечо и читал текст.</p>     <p>Мы опишем большинство самых полезных функций виджета <blockquote>GtkEntry</blockquote>:</p>     <p><blockquote><b>GtkWidget* gtk_entry_new(void);</b></blockquote></p>     <p><blockquote><b>GtkWidget* gtk_entry_new_with_max_length(gint max);</b></blockquote></p>     <p><blockquote><b>void gtk_entry_set_max_length(GtkEntry *entry, gint max);</b></blockquote></p>     <p><blockquote><b>G_CONST_RETURN gchar* gtk_entry_get_text(GtkEntry *entry);</b></blockquote></p>     <p><blockquote><b>void gtk_entry_set_text(GtkEntry *entry, const gchar *text);</b></blockquote></p>     <p><blockquote><b>void gtk_entry_append_text(GtkEntry *entry, const gchar *text);</b></blockquote></p>     <p><blockquote><b>void gtk_entry_prepend_text(GtkEntry* entry, const gchar *text);</b></blockquote></p>     <p><blockquote><b>void gtk_entry_set_visibility(GtkEntry *entry, gboolean visible);</b></blockquote></p>     <p><blockquote><b>void gtk_entry_set_invisible_char(GtkEntry *entry, gchar invch);</b></blockquote></p>     <p><blockquote><b>void gtk_entry_set_editable(GtkEntry *entry, gboolean editable);</b></blockquote></p>     <p>Вы можете создать <blockquote>GtkEntry</blockquote> с помощью функции <blockquote>gtk_entry_new</blockquote> или при вводе текста фиксированной длины с помощью функции <blockquote>gtk_entry_new_with_max_length</blockquote>. Ограничение ввода определенной длиной текста избавляет вас от проверки корректности длины ввода и, возможно, необходимости информировать пользователя о том, что текст слишком длинный.</p>     <p>Для получения содержимого виджета <blockquote>GtkEntry</blockquote> вызывайте функцию <blockquote>gtk_entry_get_text</blockquote>, которая возвращает указатель <blockquote>const char</blockquote>, внутренний по отношению к <blockquote>GtkEntry</blockquote> (<blockquote>G_CONST_RETURN</blockquote> — макрос, определенный в библиотеке GLib). Если вы хотите изменить текст или передать его в функцию, которая может его модифицировать, следует скопировать строку с помощью, например, функции <blockquote>strcpy</blockquote>.</p>     <p>Вы можете вручную задавать и изменять содержимое виджета <blockquote>GtkEntry</blockquote>, применяя функции <blockquote>_set_text</blockquote>, <blockquote>_append_text</blockquote> и <blockquote>_modify_text</blockquote>. Учтите, что они принимают указатели const.</p>     <p>Для применения <blockquote>GtkEntry</blockquote> в качестве поля ввода пароля, которое отображает звездочки на месте символов, воспользуйтесь функцией <blockquote>gtk_entry_set_visibility</blockquote>, передав ей параметр <blockquote>visible</blockquote> со значением <blockquote>FALSE</blockquote>. Скрывающий символ можно изменить в соответствии с вашими требованиями с помощью функции <blockquote>gtk_entry_set_invisible_char</blockquote>.</p>     <p>Выполните упражнение 16.4.</p>     <b>Упражнение 16.4. Ввод имени пользователя или пароля</b>     <p>Теперь, познакомившись с функциями виджета GtkEntry, посмотрим на них в действии в небольшой программе. Программа entry.c будет создавать окно ввода имени пользователя и пароля и сравнивать введенный пароль с секретным.</p>     <p>1. Сначала определим секретный пароль, остроумно заданный как <blockquote>secret</blockquote>:</p>     <p><blockquote>#include &lt;gtk/gtk.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <p><blockquote>#include &lt;string.h&gt;</blockquote></p>     <p><blockquote>const char * password = "secret";</blockquote></p>     <p>2. У вас есть две функции обратного вызова, которые вызываются, когда уничтожается окно и щелкается мышью кнопка <b>OK</b>:</p>     <p><blockquote>void closeApp(GtkWidget *window, gpointer data) {</blockquote></p>     <p><blockquote> gtk_main_quit();</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote>void button_clicked(GtkWidget *button, gpointer data) {</blockquote></p>     <p><blockquote> const char *password_text =</blockquote></p>     <p><blockquote>  gtk_entry_get_text(GTK_ENTRY((GtkWidget *) data));</blockquote></p>     <p><blockquote> if (strcmp(password_text, password) == 0)</blockquote></p>     <p><blockquote> printf("Access granted!\n");</blockquote></p>     <p><blockquote> else printf("Access denied!\n");</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>3. В функции <blockquote>main</blockquote> создается, компонуется интерфейс и связываются обратные вызовы с сигналами. Для компоновки виджетов меток и полей ввода примените виджеты-контейнеры hbox и vbox:</p>     <p><blockquote>int main (int argc, char *argv[]) {</blockquote></p>     <p><blockquote> GtkWidget *window;</blockquote></p>     <p><blockquote> GtkWidget *username_label, *password_label;</blockquote></p>     <p><blockquote> GtkWidget *username_entry, *password_entry;</blockquote></p>     <p><blockquote> GtkWidget *ok_button;</blockquote></p>     <p><blockquote> GtkWidget *hbox1, *hbox2;</blockquote></p>     <p><blockquote> GtkWidget *vbox;</blockquote></p>     <p><blockquote> gtk_init(&amp;argc, &amp;argv);</blockquote></p>     <p><blockquote> window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</blockquote></p>     <p><blockquote> gtk_window_set_title(GTK_WINDOW(window), "GtkEntryBox");</blockquote></p>     <p><blockquote> gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);</blockquote></p>     <p><blockquote> gtk_windowset_default_size(GTK_WINDOW(window), 200, 200);</blockquote></p>     <p><blockquote> g_signal_connect(GTK_OBJECT(window), "destroy",</blockquote></p>     <p><blockquote> GTK_SIGNAL_FUNC(closeApp), NULL);</blockquote></p>     <p><blockquote> username_label = gtk_label_new("Login:");</blockquote></p>     <p><blockquote> password_label = gtk_label_new("Password:");</blockquote></p>     <p><blockquote> username_entry = gtk_entry_new();</blockquote></p>     <p><blockquote> password_entry = gtk_entry_new();</blockquote></p>     <p><blockquote> gtk_entry_set_visibility(GTK_ENTRY(password_entry), FALSE);</blockquote></p>     <p><blockquote> ok_button = gtk_button_new_with_label("Ok");</blockquote></p>     <p><blockquote> g_signal_connect(GTK_OBJECT(ok_button), "clicked",</blockquote></p>     <p><blockquote>  GTK_SIGNAL_FUNC(button_clicked), password_entry);</blockquote></p>     <p><blockquote> hbox1 = gtk_hbox_new(TRUE, 5);</blockquote></p>     <p><blockquote> hbox2 = gtk_hbox_new(TRUE, 5);</blockquote></p>     <p><blockquote> vbox = gtk_vbox_new(FALSE, 10);</blockquote></p>     <p><blockquote> gtk_box_pack_start(GTK_BOX(hbox1), username_label, TRUE, FALSE, 5);</blockquote></p>     <p><blockquote> gtk_box_pack_start(GTK_BOX(hbox1), username_entry, TRUE, FALSE, 5);</blockquote></p>     <p><blockquote> gtk_box_pack_start(GTK_BOX(hbox2), password_label, TRUE, FALSE, 5);</blockquote></p>     <p><blockquote> gtk_box_pack_start(GTK_BOX(hbox2), password_entry, TRUE, FALSE, 5);</blockquote></p>     <p><blockquote> gtk_box_pack_start(GTK_BOX(vbox), hbox1, FALSE, FALSE, 5);</blockquote></p>     <p><blockquote> gtk_box_pack_start(GTK_BOX(vbox), hbox2, FALSE, FALSE, 5);</blockquote></p>     <p><blockquote> gtk_box_pack_start(GTK_BOX(vbox), ck_button, FALSE, FALSE, 5);</blockquote></p>     <p><blockquote> gtk_container_add(GTK_CONTAINER(window), vbox);</blockquote></p>     <p><blockquote> gtk_widget_show_all(window);</blockquote></p>     <p><blockquote> gtk_main();</blockquote></p>     <p><blockquote> return 0;</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Когда вы запустите программу, то получите окно, показанное на рис. 16.8.</p>     <img src="image058.jpg"/>     <p><b>Рис. 16.8</b> </p>     <br>     <p><b>Как это работает</b></p>     <p>Программа создает два виджета типа <blockquote>GtkEntry</blockquote>, <blockquote>username_entry</blockquote> и <blockquote>password_entry</blockquote>, а также задает видимость <blockquote>password_entry</blockquote>, равной <blockquote>FALSE</blockquote>, чтобы скрыть введенный пароль. Затем она формирует кнопку <blockquote>GtkButton</blockquote>, с помощью которой вы связываете сигнал <blockquote>clicked</blockquote> с функцией обратного вызова <blockquote>button_clicked</blockquote>.</p>     <p>Как только в функции обратного вызова программа извлечет введенный пароль и сравнит его с секретным паролем, на экран выводится соответствующее сообщение.</p>     <p>Обратите внимание на то, что для вставки виджетов в свои контейнеры вы много раз повторили операторы <blockquote>gtk_box_pack_start</blockquote>. Для сокращения этого повторяющегося программного кода в последующих примерах будет определена вспомогательная функция.</p>             <a name="metkadoc20"><h1><i>GtkSpinButton</i></h1></a>     <p>Порой вам нужно, чтобы пользователь ввел числовое значение, например, максимальную скорость или размер инструмента, и в такой ситуации виджет <blockquote>GtkSpinButton</blockquote> (кнопка-счетчик) идеален. Он ограничивает ввод пользователя только цифровыми символами и можно задать диапазон допустимых значений от нижней до верхней границы. Виджет также содержит стрелки, направленные вверх и вниз, так что пользователь может "накручивать" значение, для удобства пользуясь только мышью.</p>     <p><blockquote>GtkWidget</blockquote></p>     <p><blockquote> +---- GtkEntry</blockquote></p>     <p><blockquote>        +---- GtkSpinButton</blockquote></p>     <p>И снова API понятен, и мы перечислим наиболее часто применяемые вызовы:</p>     <p><blockquote><b>GtkWidget* gtk_spin_button_new(GtkAdjustment *adjustment,</b></blockquote></p>     <p><blockquote><b> gdouble climb_rate, guint digits);</b></blockquote></p>     <p><blockquote><b>GtkWidget* gtk_spin_button_new_with_range(gdouble min, gdouble max,</b></blockquote></p>     <p><blockquote><b> gdouble step);</b></blockquote></p>     <p><blockquote><b>void gtk_spin_button_set_digits(GtkSpinButton *spin_button, guint digits);</b></blockquote></p>     <p><blockquote><b>void gtk_spin_button_set_increments(GtkSpinButton *spin_button,</b></blockquote></p>     <p><blockquote><b> gdouble step, gdouble page);</b></blockquote></p>     <p><blockquote><b>void gtk_spin_button_set_range(GtkSpinButton *spin_button, gdouble min,</b></blockquote></p>     <p><blockquote><b> gdouble max);</b></blockquote></p>     <p><blockquote><b>gdouble gtk_spin_button_get_value(GtkSpinButton *spin_button);</b></blockquote></p>     <p><blockquote><b>gint gtk_spin_button_get_value_as_int(GtkSpinButton *spin_button);</b></blockquote></p>     <p><blockquote><b>void gtk_spin_button_set_value(GtkSpinButton *spin button, gdouble value);</b></blockquote></p>     <p>Для создания виджета <blockquote>GtkSpinButton</blockquote> с помощью функции <blockquote>gtk_spin_button_new</blockquote> вы сначала должны создать объект <blockquote>GtkAdjustment</blockquote>. Виджет <blockquote>GtkAdjustment</blockquote> — это абстрактный объект, содержащий логику, касающуюся управления значениями с ограничениями. Он также применяется и в других виджетах, таких как <blockquote>GtkHScale</blockquote> и <blockquote>GtkVScale</blockquote>.</p>     <p>Для создания объекта типа <blockquote>GtkAdjustment</blockquote> передайте в функцию нижнюю и верхнюю границы и размер приращения.</p>     <p><blockquote><b>GtkObject* gtk_adjustment_new(gdouble value, gdouble lower,</b></blockquote></p>     <p><blockquote><b> gdouble upper, gdouble step_increment,</b></blockquote></p>     <p><blockquote><b> gdouble page_increment, gdouble page_size);</b></blockquote></p>     <p>Значения параметров <blockquote>step_increment</blockquote> и <blockquote>page_increment</blockquote> задают величину минимального и максимального приращений, В случае кнопки-счетчика <blockquote>GtkSpinButton</blockquote> параметр <blockquote>step_increment</blockquote> определяет, насколько изменится значение при щелчке мышью стрелки виджета. Параметры <blockquote>page_increment</blockquote> и <blockquote>page_size</blockquote> в виджетах <blockquote>GtkSpinButton</blockquote> не важны.</p>     <p>Второй параметр, <blockquote>climb_rate</blockquote>, функции <blockquote>gtk_spin_button_new</blockquote> управляет скоростью прокрутки значений при нажатии и удерживании кнопки со стрелкой. И наконец, параметр <blockquote>digits</blockquote> задает точность представления числового значения, виджета, если, например, <blockquote>digits</blockquote> равен 3, кнопка-счетчик отобразит 0.00.</p>     <p>Функция <blockquote>gtk_spin_button_new_with_range</blockquote> — удобный способ создания объекта <blockquote>GtkAdjustment</blockquote>. Просто задайте нижнюю и верхнюю границы и величину приращения.</p>     <p>Прочесть текущее значение очень легко благодаря функции <blockquote>gtk_spin_button_getvalue</blockquote>, а если вам нужно целое число, можно применить функцию <blockquote>gtk_spin_button_get_value_as_int</blockquote>.</p>     <p>Выполните упражнение 16.5.</p>     <b>Упражнение 16.5. Использование виджета <blockquote>GtkSpinButton</blockquote></b>     <p>Сейчас мы посмотрим в коротком примере, как действует кнопка-счетчик GtkSpinButton. Назовите файл spin.с.</p>     <p><blockquote>#include &lt;gtk/gtk.h&gt;</blockquote></p>     <br>     <p><blockquote>void closeApp(GtkWidget *window, gpointer data) {</blockquote></p>     <p><blockquote> gtk_main_quit();</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote>int main(int argc, char *argv[]) {</blockquote></p>     <p><blockquote> GtkWidget* window;</blockquote></p>     <p><blockquote> GtkWidget *spinbutton;</blockquote></p>     <p><blockquote> GtkObject *adjustment;</blockquote></p>     <p><blockquote> gtk_init(&amp;argc, &amp;argv);</blockquote></p>     <p><blockquote> window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</blockquote></p>     <p><blockquote> gtk_window_set_default_size(GTK_WINDOW(window), 300, 200);</blockquote></p>     <p><blockquote> g_signal_connect(GTK_OBJECT(window), "destroy",</blockquote></p>     <p><blockquote>  GTK_SIGNAL_FUNC(closeApp), NULL);</blockquote></p>     <p><blockquote> adjustment = gtk_adjustment_new(100.0, 50.0, 150.0, 0.5, 0.05, 0.05);</blockquote></p>     <p><blockquote> spinbutton = gtk_spin_button_new(GTK_ADJUSTMENT(adjustment), 0.01, 2);</blockquote></p>     <p><blockquote> gtk_container_add(GTK_CONTAINER(window), spinbutton);</blockquote></p>     <p><blockquote> gtk_widget_show_all(window);</blockquote></p>     <p><blockquote> gtk_main();</blockquote></p>     <p><blockquote> return 0;</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Когда вы выполните программу, то получите кнопку-счетчик, ограниченную диапазоном значений 50–150 (рис. 16.9).</p>     <img src="image059.jpg"/>     <p><b>Рис. 16.9</b> </p>             <a name="metkadoc21"><h1><i>GtkButton</i></h1></a>     <p>Вы уже видели виджет кнопки <blockquote>GtkButton</blockquote> в действии, но существует несколько виджетов, потомков <blockquote>GtkButton</blockquote>, с чуть большими функциональными возможностями, заслуживающими упоминания.</p>     <p><blockquote>GtkButton</blockquote></p>     <p><blockquote> +----GtkToggleButton</blockquote></p>     <p><blockquote>       +----GtkCheckButton</blockquote></p>     <p><blockquote>             +----GtkRadioButton</blockquote></p>     <p>Как видно из иерархии виджетов, кнопка-переключатель типа <blockquote>GtkToggleButton</blockquote> — прямой потомок кнопки <blockquote>GtkButton</blockquote>, кнопка-флажок <blockquote>GtkCheckButton</blockquote> — кнопки-выключателя <blockquote>GtkToggleButton</blockquote> и то же самое для переключателя <blockquote>GtkRadioButton</blockquote>, причем каждый дочерний виджет предназначен для определенных задач.</p>     <b><i>GtkToggleButton</i></b>     <p>Виджет <blockquote>GtkToggleButton</blockquote> идентичен виджету <blockquote>GtkButton</blockquote> за исключением одной важной детали: <blockquote>GtkToggleButton</blockquote> обладает<i> состоянием.</i> Это означает, что кнопка-выключатель может быть включена или выключена. Когда пользователь щелкает мышью виджет <blockquote>GtkToggleButton</blockquote>, последний стандартным способом порождает сигнал <blockquote>clicked</blockquote> и изменяет (или "переключает") свое состояние.</p>     <p>API у виджета <blockquote>GtkToggleButton</blockquote> очень простой:</p>     <p><blockquote><b>GtkWidget* gtk_toggle_button_new(void);</b></blockquote></p>     <p><blockquote><b>GtkWidget* gtk_toggle_button_new_with_label(const gchar* label);</b></blockquote></p>     <p><blockquote><b>gboolean gtk_toggle_button_get_active(GtkToggleButton *toggle_button);</b></blockquote></p>     <p><blockquote><b>void gtk_toggle_button_set_active(GtkToggleButton *toggle_button,</b></blockquote></p>     <p><blockquote><b> gboolean is_active);</b></blockquote></p>     <p>Наиболее интересные функции — <blockquote>gtk_toggle_button_get_active</blockquote> и <blockquote>gtk_toggle_button_set_active</blockquote>, которые вы вызываете для чтения и установки состояния кнопки-выключателя. Если характеристика функционирования равна <blockquote>TRUE</blockquote>, это означает, что кнопка-выключатель <blockquote>GtkToggleButton</blockquote> включена.</p>     <b><i>GtkCheckButton</i></b>     <p>Кнопка-флажок <blockquote>GtkCheckButton</blockquote> — это замаскированная кнопка-выключатель <blockquote>GtkToggleButton</blockquote>. Вместо скучного прямоугольного отображения <blockquote>GtkToggleButton</blockquote> кнопка <blockquote>GtkCheckButton</blockquote> выводится как привлекательный флажок с расположенным рядом текстом. Функциональных различий между ними нет.</p>     <p><blockquote><b>GtkWidget* gtk_check_button_new(void);</b></blockquote></p>     <p><blockquote><b>GtkWidget* gtk_check_button_new_with_label(const gchar *label);</b></blockquote></p>     <b><i>GtkRadioButton</i></b>     <p>Эта кнопка немного отличается от предыдущих, т.к. может группироваться с другими кнопками того же типа. Переключатель (или радиокнопка) <blockquote>GtkRadioButton</blockquote> — одна из тех кнопок, которые позволяют выбирать только один вариант из группы предложенных. Имя заимствовано у старых радиоприемников с механическими кнопками, которые выскакивали с треском, возвращаясь в прежнее состояние, при нажатии другой кнопки.</p>     <p><blockquote><b>GtkWidget* gtk_radio_button_new(GSList *group);</b></blockquote></p>     <p><blockquote><b>GtkWidget* gtk_radio_button_new_from_widget(GtkRadioButton *group);</b></blockquote></p>     <p><blockquote><b>GtkWidget* gtk_radio_button_new_with_label(GSList *group, const gchar *label);</b></blockquote></p>     <p><blockquote><b>void gtk_radio_button_set_group(GtkRadioButton *radio_button, GSList *group);</b></blockquote></p>     <p><blockquote><b>GSList* gtk_radio_button_get_group(GtkRadioButton *radio_button);</b></blockquote></p>     <p>Группа переключателей представлена в объекте-списке библиотеки GLib, названном <blockquote>GSList</blockquote>. Для того чтобы объединить переключатели в группу, вы можете создать объект <blockquote>GSList</blockquote> и затем передать ему каждую кнопку с помощью функций <blockquote>gtk_radio_button_new</blockquote> и <blockquote>gtk_radio_button_get_group</blockquote>, есть и более легкий способ в виде функции <blockquote>gtk_radio_button_new_with_widget</blockquote>, которая включает в GSList существующую кнопку. Вы увидите ее в действии в упражнении 16.6, которое позволит вам опробовать разные кнопки <blockquote>GtkButton</blockquote>.</p>     <b>Упражнение 16.6. <blockquote>GtkCheckButton</blockquote>, <blockquote>GtkToggleButton</blockquote> и <blockquote>GtkRadioButton</blockquote></b>     <p>Введите следующий текст в файл с именем buttons.с.</p>     <p>1. Сначала объявите указатели на кнопки как глобальные переменные:</p>     <p><blockquote>#include &lt;gtk/gtk.h&gt;</blockquote></p>     <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>     <br>     <p><blockquote>GtkWidget *togglebutton;</blockquote></p>     <p><blockquote>GtkWidget *checkbutton;</blockquote></p>     <p><blockquote>GtkWidget *radiobutton1, *radiobutton2;</blockquote></p>     <p><blockquote>void closeApp(GtkWidget *window, gpointer data) {</blockquote></p>     <p><blockquote> gtk_main_quit();</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>2. Далее определите вспомогательную функцию, которая упаковывает <blockquote>GtkWidget</blockquote> и <blockquote>GtkLabel</blockquote> в контейнер <blockquote>GtkHbox</blockquote> и затем вставляет этот <blockquote>GtkHbox</blockquote> в заданный виджет- контейнер. Это поможет вам сократить повторяющийся программный код:</p>     <p><blockquote>void add_widget_with_label(GtkContainer * box, gchar * caption,</blockquote></p>     <p><blockquote> GtkWidget * widget) {</blockquote></p>     <p><blockquote> GtkWidget *label = gtk_label_new(caption);</blockquote></p>     <p><blockquote> GtkWidget *hbox = gtk_hbox_new(TRUE, 4);</blockquote></p>     <p><blockquote> gtk_container_add(GTK_CONTAINER(hbox), label);</blockquote></p>     <p><blockquote> gtk_container_add(GTK_CONTAINER(hbox), widget);</blockquote></p>     <p><blockquote> gtk_container_add(box, hbox);</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>3. <blockquote>print_active</blockquote> — еще одна вспомогательная функция, которая выводит текущее состояние заданной кнопки-выключателя <blockquote>GtkToggleButton</blockquote> со строкой описания. Он вызывается из функции <blockquote>button_clicked</blockquote>, функции обратного вызова, связанной с сигналом <blockquote>clicked</blockquote> кнопки <b>OK.</b> При каждом щелчке мышью этой кнопки вы получаете на экране отчет о состоянии кнопок:</p>     <p><blockquote>void print_active(char * button_name, GtkToggleButton* button) {</blockquote></p>     <p><blockquote> gboolean active = gtk_toggle_button_get_active(button);</blockquote></p>     <p><blockquote> printf("%s is %s\n", button_name, active?"active":"not active");</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote>void button_clicked(GtkWidget *button, gpointer data) {</blockquote></p>     <p><blockquote> print_active("Checkbutton", GTK_TOGGLE_BUTTON(checkbutton));</blockquote></p>     <p><blockquote> print_active("Togglebutton", GTK_TOGGLE_BUTTON(togglebutton));</blockquote></p>     <p><blockquote> print_active("Radiobutton1", GTK_TOGGLE_BUTTON(radiobutton1));</blockquote></p>     <p><blockquote> print_active("Radiobutton2", GTK_TOGGLE_BUTTON(radiobutton2));</blockquote></p>     <p><blockquote> printf("\n");</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>4. В функции <blockquote>main</blockquote> вы создаете виджеты кнопок, поочередно помещаете их в контейнер <blockquote>GtkVBox</blockquote>, добавив пояснительные метки, и связываете сигнал обратного вызова с кнопкой <b>OK</b>:</p>     <p><blockquote>gint main(gint argc, gchar *argv[]) {</blockquote></p>     <p><blockquote> GtkWidget* window;</blockquote></p>     <p><blockquote> GtkWidget *button;</blockquote></p>     <p><blockquote> GtkWidget *vbox;</blockquote></p>     <p><blockquote> gtk_init(&amp;argc, &amp;argv);</blockquote></p>     <p><blockquote> window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</blockquote></p>     <p><blockquote> gtk_window_set_default_size(GTK_WINDOW(window), 200, 200);</blockquote></p>     <p><blockquote> g_signal_connect(GTK_OBJECT(window), "destroy",</blockquote></p>     <p><blockquote>  GTK_SIGNAL_FUNC(closeApp), NULL);</blockquote></p>     <p><blockquote> button = gtk_button_new_with_label("Ok");</blockquote></p>     <p><blockquote> togglebutton = gtk_toggle_button_new_with_label("Toggle");</blockquote></p>     <p><blockquote> checkbutton = gtk_check_button_new();</blockquote></p>     <p><blockquote> radiobutton1 = gtk_radio_button_new(NULL);</blockquote></p>     <p><blockquote> radiobutton2 =</blockquote></p>     <p><blockquote>  gtk_radio_button_new_from_widget(GTK_RADIO_BUTTON(radiobutton1));</blockquote></p>     <p><blockquote> vbox = gtk_vbox_new(TRUE, 4);</blockquote></p>     <p><blockquote> add_widget_with_label(GTK_CONTAINER(vbox), "ToggleButton:",</blockquote></p>     <p><blockquote>  togglebutton);</blockquote></p>     <p><blockquote> add_widget_with_label(GTK_CONTAINER(vbox), "CheckButton:",</blockquote></p>     <p><blockquote>  checkbutton);</blockquote></p>     <p><blockquote> add_widget_with_label(GTK_CONTAINER(vbox), "Radio 1:", radiobutton1);</blockquote></p>     <p><blockquote> add_widget_with_label(GTK_CONTAINER(vbox), "Radio 2:", radiobutton2);</blockquote></p>     <p><blockquote> add_widget_with_label(GTK_CONTAINER(vbox), "Button:", button);</blockquote></p>     <p><blockquote> g_signal_connect(GTK_OBJECT(button), "clicked",</blockquote></p>     <p><blockquote>  GTK_SIGNAL_FUNC(button_clicked), NULL);</blockquote></p>     <p><blockquote> gtk_container_add(GTK_CONTAINER(window), vbox);</blockquote></p>     <p><blockquote> gtk_widget_show_all(window);</blockquote></p>     <p><blockquote> gtk_main();</blockquote></p>     <p><blockquote> return 0;</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>На рис. 16.10 показана программа buttons.c в действии с виджетами <blockquote>GtkButton</blockquote> четырех часто применяемых типов.</p>     <img src="image060.jpg"/>     <p><b>Рис. 16.10</b></p>     <br>     <p>Щелкните мышью кнопку <b>OK</b>, чтобы увидеть состояние разных кнопок.</p>     <p>Данная программа — простой пример использования кнопок <blockquote>GtkButton</blockquote> четырех типов — показывает, как можно считать состояние кнопки типа <blockquote>GtkToggleButton</blockquote>, <blockquote>GtkCheckButton</blockquote> и <blockquote>GtkRadioButton</blockquote> с помощью единственной функции <blockquote>gtk_toggle_button_get_active</blockquote>. Это одно из огромных преимуществ объектно-ориентированного подхода — поскольку вам не нужны отдельные функции <blockquote>get_active</blockquote> для каждого типа кнопки, вы можете сократить требующийся программный код.</p>             <a name="metkadoc22"><h1><i>GtkTreeView</i></h1></a>     <p>К этому моменту мы рассмотрели несколько простых виджетов GTK+, но не все виджеты представляют собой однострочные инструменты для ввода или отображения. Сложность виджетов ничем не ограничивается, и <blockquote>GtkTreeView</blockquote> — яркий пример виджета, инкапсулирующего огромный объем функциональных возможностей.</p>     <p><blockquote>GtkWidget</blockquote></p>     <p><blockquote> +---- GtkContainer</blockquote></p>     <p><blockquote>        +---- GtkTreeView</blockquote></p>     <p><blockquote>GtkTreeView</blockquote> — член семейства виджетов, новых для комплекта GTK+ 2, создающий представление данных в виде дерева или списка наподобие тех, которые вы можете встретить в электронной таблице или файловом менеджере. С помощью виджета <blockquote>GtkTreeView</blockquote> можно создать сложные представления данных, смешивая текст, растровую графику и даже данные, вводимые с помощью виджетов <blockquote>GtkEntry</blockquote>, и т.д.</p>     <p>Самый быстрый способ испытания <blockquote>GtkTreeView</blockquote> — запуск приложения gtk-demo, которое поставляется вместе с GTK+. Демонстрационное приложение показывает возможности всех виджетов GTK+, включая <blockquote>GtkTreeView</blockquote> (рис. 16.11).</p>     <img src="image061.jpg"/>     <p><b>Рис. 16.11</b></p>     <br>     <p>Семейство <blockquote>GtkTreeView</blockquote> составляется из четырех компонентов:</p>     <p>&#9633; <blockquote>GtkTreeView</blockquote> — отображение дерева или списка;</p>     <p>&#9633; <blockquote>GtkTreeViewColumn</blockquote> — представление столбца списка или дерева;</p>     <p>&#9633; <blockquote>GtkCellRenderer</blockquote> — управление отображаемыми ячейками;</p>     <p>&#9633; <blockquote>GtkTreeModel</blockquote> — представление данных дерева и списка. </p>     <p>Первые три компонента формируют так называемое<i> Представление,</i> а последний —<i> Модель.</i> Концепция разделения<i> Представления</i> и<i> Модели</i> (часто называемая проектным шаблоном<i> Модель/Представление/Действие</i> (Model/View/Controller) или сокращенно MVC) не свойственна GTK+, но проектированию уделяется все больше и больше внимания на всех этапах программирования.</p>     <p>Ключевое достоинство проектного шаблона MVC заключается в возможности одновременной визуализации данных в виде разных представлений без ненужного их дублирования. Например, текстовые редакторы могут иметь две разные панели и редактировать разные фрагменты документа без хранения в памяти двух копий документа.</p>     <p>Шаблон MVC также очень популярен в Web-программировании, поскольку облегчает создание Web-сайтов, которые визуализируются в мобильных или WAP-обозревателях не так, как в настольных, просто за счет наличия отдельных компонентов<i> Представление,</i> оптимизированных для Web-обозревателя каждого типа. Вы также можете отделить логику сбора данных, например, запросов к базе данных, от логики пользовательского интерфейса.</p>     <p>Мы начнем с рассмотрения компонента<i> Модель</i>, представленного в GTK+ двумя типами. Объект типа <blockquote>GtkTreeStore</blockquote> содержит многоуровневые данные, например иерархию каталогов, а объект <blockquote>GtkListStore</blockquote> предназначен для простых данных.</p>     <p>Для создания объекта <blockquote>GtkTreeStore</blockquote> в функцию передается количество столбцов, за которым следуют типы всех столбцов:</p>     <p><blockquote>GtkWidget *store = gtk_tree_store_new(3, G_TYPE_STRING, G_TYPE_INT,</blockquote></p>     <p><blockquote> G_TYPE_BOOLEAN);</blockquote></p>     <p>Чтение, вставка, редактирование и удаление данных из модели выполняется с помощью структур <blockquote>GtkTreeIter</blockquote>. Эти структуры итераторов указывают на узлы дерева (или строки списка) и помогают находить фрагменты структур данных потенциально очень большого объема, а также манипулировать ими. Есть несколько вызовов API для получения объекта-итератора для разных точек дерева, но мы рассмотрим простейшую функцию <blockquote>gtk_tree_store_append</blockquote>.</p>     <p>Перед тем как вставлять какие-либо данные в модель дерева, вам нужно получить итератор, указывающий на новую строку. Функция <blockquote>gtk_tree_store_append</blockquote> заполняет объект <blockquote>GtkTreeIter</blockquote>, который представляет новую строку в дереве, как строку верхнего уровня (если вы передаете значение <blockquote>NULL</blockquote> в третьем аргументе), так и подчиненную или дочернюю строку (если вы передаете итератор главной или родительской строки):</p>     <p><blockquote>GtkTreeIter iter;</blockquote></p>     <p><blockquote>gtk_tree_store_append(store, &amp;iter, NULL);</blockquote></p>     <p>Получив итератор, вы можете заполнять строку с помощью функции <blockquote>gtk_tree_store_set</blockquote>:</p>     <p><blockquote>gtk_tree_store_set(store, &amp;iter,</blockquote></p>     <p><blockquote> 0, "Def Leppard",</blockquote></p>     <p><blockquote> 1, 1987,</blockquote></p>     <p><blockquote> 2, TRUE, -1);</blockquote></p>     <p>Номер столбца и данные передаются парами, которые завершаются -1. Позже вы примените тип enum для того, чтобы сделать номера столбцов более информативными.</p>     <p>Для того чтобы добавить ветвь к данной строке (дочернюю строку), вам нужен только итератор для дочерней строки, который вы получаете, вызвав снова функцию <blockquote>gtk_tree_store_append</blockquote> и указав на этот раз в качестве параметра строку верхнего уровня:</p>     <p><blockquote>GtkTreeIter child;</blockquote></p>     <p><blockquote>gtk_tree_store_append(store, &amp;child, &amp;iter);</blockquote></p>     <p>Дополнительную информацию об объектах <blockquote>GtkTreeStore</blockquote> и функциях объекта <blockquote>GtkListStore</blockquote> см. в документации API, а мы пойдем дальше и рассмотрим компонент<i> Представление</i> типа <blockquote>GtkTreeView</blockquote>.</p>     <p>Создание объекта <blockquote>GtkTreeView</blockquote> — сама простота: только передайте в конструктор в качестве параметра модель типа <blockquote>GtkTreeStore</blockquote> или <blockquote>GtkListStore</blockquote>:</p>     <p><blockquote>GtkWidget* view = gtk_tree_view_new_with_model(GTK_TREE_MODEL(store));</blockquote></p>     <p>Сейчас самое время настроить виджет для отображения данных именно так, как вы хотите. Для каждого столбца следует определить <blockquote>GtkCellRenderer</blockquote> и источник данных. Можно выбрать, например, визуализацию только определенных столбцов данных или изменить порядок вывода столбцов.</p>     <p><blockquote>GtkCellRenderer</blockquote> — это объект, отвечающий за прорисовку каждой ячейки на экране, и существует три подкласса, имеющие дело с текстовыми ячейками, ячейками пиксельной графики и ячейками кнопок-выключателей:</p>     <p>&#9633; <blockquote>GtkCellRendererText</blockquote>;</p>     <p>&#9633; <blockquote>GtkCellRendererPixBuf</blockquote>;</p>     <p>&#9633; <blockquote>GtkCellRendererToggle</blockquote>.</p>     <p>В вашем<i> Представлении</i> будет применено текстовое представление ячеек, <blockquote>GtkCellRendererText</blockquote>.</p>     <p><blockquote>GtkCellRenderer* renderer = gtk_cell_renderer_text_new();</blockquote></p>     <p><blockquote>gtk_tree_view_insert_column_with_attributes(GTK_TREE_VIEW(view),</blockquote></p>     <p><blockquote> "This is the column title", renderer, "text", 0, NULL);</blockquote></p>     <p>Вы создаете представление ячейки и передаете его в функцию вставки столбца. Эта функция позволяет сразу задать свойства <blockquote>GtkCellRendererText</blockquote>, передавая заканчивающиеся значением <blockquote>NULL</blockquote> пары "ключ/значение". В качестве параметров указаны представление дерева, номер столбца, заголовок столбца, представление ячейки и его свойства. В приведенном примере вы задаете атрибут "text", передав номер столбца источника данных. Для объекта <blockquote>GtkCellRendererText</blockquote> определено несколько других атрибутов, включая подчеркивание, шрифт, размер и т.д.</p>     <p>В упражнении 16.7, выполнив необходимые шаги, вы увидите, как это работает на практике.</p>     <b>Упражнение 16.7. Использование виджета <blockquote>GtkTreeView</blockquote></b>     <p>Введите следующий программный код и назовите файл tree.с.</p>     <p>1. Примените тип <blockquote>enum</blockquote> для обозначения столбцов, чтобы можно было ссылаться на них по именам. Общее количество столбцов удобно обозначить как <blockquote>N_COLUMNS</blockquote>:</p>     <p><blockquote>#include &lt;gtk/gtk.h&gt;</blockquote></p>     <br>     <p><blockquote>enum {</blockquote></p>     <p><blockquote> COLUMN_TITLE, COLUMN_ARTIST, COLUMN_CATALOGUE, N_COLUMNS</blockquote></p>     <p><blockquote>};</blockquote></p>     <br>     <p><blockquote>void closeApp(GtkWidget *window, gpointer data) {</blockquote></p>     <p><blockquote> gtk_main_quit();</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote>int main(int argc, char *argv[]) {</blockquote></p>     <p><blockquote> GtkWidget *window;</blockquote></p>     <p><blockquote> GtkTreeStore *store;</blockquote></p>     <p><blockquote> GtkWidget *view;</blockquote></p>     <p><blockquote> GtkTreeIter parent_iter, child_iter;</blockquote></p>     <p><blockquote> GtkCellRenderer *renderer;</blockquote></p>     <p><blockquote> gtk_init(&amp;argc, &amp;argv);</blockquote></p>     <p><blockquote> window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</blockquote></p>     <p><blockquote> gtk_window_set_default_size(GTK_WINDOW(window), 300, 200);</blockquote></p>     <p><blockquote> g_signal_connect(GTK_OBJECT(window), "destroy",</blockquote></p>     <p><blockquote>  GTK_SIGNAL_FUNC(сloseApp), NULL);</blockquote></p>     <p>2. Далее вы создаете модель дерева, передавая количество столбцов и тип каждого из них:</p>     <p><blockquote> store = gtk_tree_store_new(N_COLUMNS, G_TYPE_STRING, G_TYPE_STRING,</blockquote></p>     <p><blockquote>  G_TYPE_STRING);</blockquote></p>     <p>3. Следующий этап — вставка родительской и дочерней строк в дерево:</p>     <p><blockquote> gtk_tree_store_append(store, &amp;parent_iter, NULL);</blockquote></p>     <p><blockquote> gtk_tree_store_set(store, &amp;parent_iter,</blockquote></p>     <p><blockquote>  COLUMN_TITLE, "Dark Side of the Moon",</blockquote></p>     <p><blockquote>  COLUMN_ARTIST, "Pink Floyd",</blockquote></p>     <p><blockquote>  COLUMN_CATALOGUE, "B000024D4P", -1);</blockquote></p>     <p><blockquote> gtk_tree_store_append(store, &amp;child_iter, &amp;parent_iter);</blockquote></p>     <p><blockquote> gtk_tree_store_set (store, &amp;child_iter,</blockquote></p>     <p><blockquote>  COLUMN_TITLE, "Speak to Me", -1);</blockquote></p>     <p><blockquote> view = gtk_tree_view_new_with_model(GTK_TREE_MODEL(store));</blockquote></p>     <p>4. Наконец, добавьте столбцы в представление, задавая источники данных для них и заголовки:</p>     <p><blockquote> renderer = gtk_cell_renderer_text_new();</blockquote></p>     <p><blockquote> gtk_tree_view_insert_column_with_attributes(GTK_TREE_VIEW(view),</blockquote></p>     <p><blockquote>  COLUMN_TITLE, "Title", renderer, "text",</blockquote></p>     <p><blockquote>  COLUMN_TITLE, NULL);</blockquote></p>     <p><blockquote> gtk_tree_view_insert_column_with_attributes(GTK_TREE_VIEW(view),</blockquote></p>     <p><blockquote>  COLUMN_ARTIST, "Artist", renderer, "text",</blockquote></p>     <p><blockquote>  COLUMN_ARTIST, NULL);</blockquote></p>     <p><blockquote> gtk_tree_view_insert_column_with_attributes(GTK_TREE_VIEW(view),</blockquote></p>     <p><blockquote>  COLUMN_CATALOGUE, "Catalogue", renderer, "text",</blockquote></p>     <p><blockquote>  COLUMN_CATALOGUE, NULL);</blockquote></p>     <p><blockquote> gtk_container_add(GTK_CONTAINER(window), view);</blockquote></p>     <p><blockquote> gtk_widget_show_all(window); gtk_main();</blockquote></p>     <p><blockquote> return 0;</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>Вы будете применять <blockquote>GtkTreeView</blockquote> как основной объект вашего приложения для работы с компакт-дисками, когда будете модифицировать содержимое <blockquote>GtkTreeView</blockquote> в соответствии с запросами к базе данных компакт-дисков.</p>     <p>Мы завершили обзор виджетов GTK+ и теперь обратим наше внимание на другую половину: среду GNOME. Вы увидите, как вставлять меню в ваше приложение с помощью библиотек GNOME и как виджеты GNOME облегчают программирование для рабочего стола GNOME.</p>              <a name="metkadoc23"><h1>Виджеты GNOME</h1></a>    <p>Комплект GTK+ спроектирован как нейтральный по отношению к рабочему столу, т.е. GTK+ не делает никаких допущений о том, что он выполняется в среде GNOME или даже в системе Linux. Причина заключается в том, что комплект инструментов GTK+ можно с относительной легкостью перенести для выполнения в ОС Windows или любой другой оконной системе. В результате GTK+ не хватает средств для связывания программы с рабочим столом, таких как средства сохранения настройки программы, отображение файлов помощи или программные апплеты (апплеты — это небольшие утилиты, выполняющиеся на краевых панелях (edge panels)).</p>    <p>Библиотеки среды включают виджеты GNOME, расширяющие комплект GTK+ и замещающие его части более легкими в применении виджетами. В этом разделе мы расскажем, как программировать с помощью виджетов GNOME.</p>    <p>Перед использованием библиотек GNOME их следует инициализировать при запуске ваших программ точно так же, как вы поступали с библиотеками GTK+. Вы вызываете функцию <blockquote>gnome_program_init</blockquote> также, как вы вызывали функцию <blockquote>gtk_init</blockquote> в чистых программах GTK+.</p>    <p>Эта функция принимает параметры <blockquote>app_id</blockquote> и <blockquote>арр_version</blockquote>, применяемые для описания вашей программы в среде GNOME, <blockquote>module_info</blockquote>, сообщающий GNOME о том, какой библиотечный модуль инициализировать, параметры командной строки и свойства приложения, заданные как NULL-терминированный список пар "имя/значение".</p>    <p><blockquote><b>GnomeProgram* gnome_program_init(const char *app_id,</b></blockquote></p>    <p><blockquote><b> const char *app_version, const GnomeModuleInfо *module_infо,</b></blockquote></p>    <p><blockquote><b> int argc, char **argv, const char *first_property_name, ...);</b></blockquote></p>    <p>Необязательный список свойств позволяет задать такие характеристики, как, например, каталог для поиска растровой графики.</p>    <p>Выполните упражнение 16.8.</p>    <b>Упражнение 16.8. Окно GNOME</b>    <p>Давайте рассмотрим программу, применяющую средства GNOME, в которой выполняется GNOME-замещение объекта <blockquote>GtkWindow</blockquote> виджетом <blockquote>GnomeApp</blockquote>.</p>    <p>Введите эту программу и назовите ее gnome1.c:</p>    <p><blockquote>#include &lt;gnome.h&gt;</blockquote></p>    <br>    <p><blockquote>int main(int argc, char* argv[]) {</blockquote></p>    <p><blockquote> GtkWidget *app;</blockquote></p>    <p><blockquote> gnome_program_init("gnome1", "1.0", MODULE, argc, argv, NULL);</blockquote></p>    <p><blockquote> app = gnome_app_new("gnome1", "The Window Title");</blockquote></p>    <p><blockquote> gtk_widget_show(app);</blockquote></p>    <p><blockquote> gtk_main();</blockquote></p>    <p><blockquote> return 0;</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Для компиляции вам необходимо включить заголовочные файлы GNOME, поэтому передайте библиотеки libgnomeui и libgnome в команду <blockquote>pkg-config</blockquote>:</p>    <p><blockquote>$ <b>gcc gnome1.с -о gnome1 `pkg-config --cflags --libs libgnome-2.0 libgnomeui-2.0`</b></blockquote></p>    <p>Виджет <blockquote>GnomeApp</blockquote> расширяет возможности GtkWindow и облегчает вставку меню, панелей инструментов и строки состояния вдоль нижнего края окна. Поскольку он потомок <blockquote>GtkWindow</blockquote>, вы можете применять к виджету <blockquote>GnomeApp</blockquote> любую функцию виджета <blockquote>GtkWindow</blockquote>. Далее вы познакомитесь с созданием меню и добавите строку состояния в ваш финальный пример.</p>    <blockquote>     <b>Примечание</b>     <p>Вы можете использовать комплект инструментов GTK+ для создания меню, но среда GNOME предоставляет полезные структуры и макросы, которые существенно облегчают эту задачу. В интерактивной документации описывается, как создавать меню средствами GTK+.</p>    </blockquote>          <a name="metkadoc24"><h1>Меню GNOME</h1></a>    <p>Создание строки раскрывающихся меню в среде GNOME на удивление просто. Каждый пункт в строке меню представляется как массив структур <blockquote>GNOMEUIInfo</blockquote>, причем каждый элемент массива соответствует одному пункту меню. Например, если у вас есть меню <b>File</b> (Файл), <b>Edit</b> (Правка) и <b>View</b> (Вид), то у вас будут три массива, описывающих содержимое каждого меню.</p>    <p>После определения отдельных меню создается строка меню как таковая с помощью ссылок на эти массивы в еще одном массиве структур <blockquote>GNOMEUIInfo</blockquote>.</p>    <p>Структура <blockquote>GNOMEUIInfo</blockquote> немного сложна и нуждается в дополнительных пояснениях.</p>    <p><blockquote><b>typedef struct {</b></blockquote></p>    <p><blockquote><b> GnomeUIInfoType type;</b></blockquote></p>    <p><blockquote><b> gchar const *label;</b></blockquote></p>    <p><blockquote><b> gchar const *hint;</b></blockquote></p>    <p><blockquote><b> gpointer moreinfо;</b></blockquote></p>    <p><blockquote><b> gpointer user_data;</b></blockquote></p>    <p><blockquote><b> gpointer unused_data;</b></blockquote></p>    <p><blockquote><b> GnomeUIPixmapType pixmap_type;</b></blockquote></p>    <p><blockquote><b> gconstpointer pixmap_info;</b></blockquote></p>    <p><blockquote><b> guint accelerator_key;</b></blockquote></p>    <p><blockquote><b> GdkModifierType ac_mods;</b></blockquote></p>    <p><blockquote><b> GtkWidget *widget;</b></blockquote></p>    <p><blockquote><b>} GnomeUIInfo;</b></blockquote></p>    <p>Первый элемент в структуре, <blockquote>type</blockquote>, определяет тип элемента меню, который описывается далее. Он может быть одним из 11 типов <blockquote>GnomeUIInfоТуре</blockquote>, определяемых средой GNOME и приведенных в табл. 16.3.</p>    <br>    <p><i><b>Таблица 16.3</b></i></p>    <table>     <tr>      <th valign="top">Типы <blockquote>GnomeUIInfоТуре</blockquote></th>      <th valign="top">Описание</th>     </tr>     <tr>      <td valign="top"><blockquote>GNOME_APP_UI_ENDOFINFO</blockquote></td>      <td valign="top">Означает, что этот элемент — последний пункт меню в массиве</td>     </tr>     <tr>      <td valign="top"><blockquote>GNOME_APP_UI_ITEM</blockquote></td>      <td valign="top">Обычный пункт меню или переключатель, если ему предшествует элемент <blockquote>GNOME_APP_UI_RADIOITEMS</blockquote></td>     </tr>     <tr>      <td valign="top"><blockquote>GNOME_APP_UI_TOGGLEITEM</blockquote></td>      <td valign="top">Пункт меню в виде кнопки-переключателя или кнопки-флажка</td>     </tr>     <tr>      <td valign="top"><blockquote>GNOME_APP_UI_RADIOITEMS</blockquote></td>      <td valign="top">Группа переключателей или зависимых переключателей</td>     </tr>     <tr>      <td valign="top">GNOME_APP_UI_SUBTREE</td>      <td valign="top">Означает, что данный элемент представляет собой подменю. Задайте <blockquote>moreinfo</blockquote> для указания на массив подменю</td>     </tr>     <tr>      <td valign="top"><blockquote>GNOME_APP_UI_SEPARATOR</blockquote></td>      <td valign="top">Вставляет разделительную линию в меню</td>     </tr>     <tr>      <td valign="top"><blockquote>GNOME_APP_UI_HELP</blockquote></td>      <td valign="top">Создает список тем справки для использования в меню <b>Help</b> (Справка)</td>     </tr>     <tr>      <td valign="top"><blockquote>GNOME_APP_UI_BUILDER_DATA</blockquote></td>      <td valign="top">Задает данные построения (builder data) для следующих элементов</td>     </tr>     <tr>      <td valign="top"><blockquote>GNOME_APP_UI_ITEM_CONFIGURABLE</blockquote></td>      <td valign="top">Настраиваемый пункт меню</td>     </tr>     <tr>      <td valign="top"><blockquote>GNOME_APP_UI_SUBTREE_STOCK</blockquote></td>      <td valign="top">Такой же, как <blockquote>GNOME_APP_UI_SUBTREE</blockquote> за исключением того, что надписи следует искать в каталоге gnome-libs</td>     </tr>     <tr>      <td valign="top"><blockquote>GNOME_APP_UI_INCLUDE</blockquote></td>      <td valign="top">Такой же, как <blockquote>GNOME_APP_UI_SUBTREE</blockquote> за исключением того, что пункты включены в текущее меню, а не в подменю</td>     </tr>    </table>    <p>Второй и третий элементы структуры определяют текст пункта меню и всплывающей подсказки. (Подсказка выводится в строке состояния, у нижнего края окна.)</p>    <p>Назначение элемента <blockquote>moreinfo</blockquote> зависит от типа. В случае <blockquote>ITEM</blockquote> и <blockquote>TOGGLEITEM</blockquote> он указывает на функцию обратного вызова, которую следует вызвать при активации пункта меню. Для <blockquote>RADIOITEMS</blockquote> он указывает на массив структур <blockquote>GnomeUIInfo</blockquote>, в которых группируются переключатели.</p>    <p><blockquote>user_data</blockquote> — произвольный указатель, передаваемый в функцию обратного вызова. Элементы <blockquote>pixmap_type</blockquote> и <blockquote>pixmap_info</blockquote> позволяют добавить к пункту меню растровую пиктограмму, a <blockquote>accelerator_key</blockquote> и <blockquote>ac_mods</blockquote> помогут определить клавиатурный эквивалент пункта меню.</p>    <p>И наконец, элемент <blockquote>widget</blockquote> применяется для внутреннего хранения указателя на виджет пункта меню функцией создания меню.</p>    <p>Выполните упражнение 16.9.</p>    <b>Упражнение 16.9. Меню GNOME</b>    <p>Вы сможете опробовать меню с помощью данной короткой программы. Назовите ее menu1.с.</p>    <p><blockquote>#include &lt;gnome.h&gt;</blockquote></p>    <p><blockquote>void closeApp(GtkWidget *window, gpointer data) {</blockquote></p>    <p><blockquote> gtk_main_quit();</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>1. Определите для пунктов меню функцию обратного вызова, названную <blockquote>item_clicked</blockquote>:</p>    <p><blockquote>void item clicked(GtkWidget *widget, gpointer user_data) {</blockquote></p>    <p><blockquote> printf("Item Clicked!\n");</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>2. Далее следуют определения меню. У вас есть подменю, меню верхнего уровня и массив строки меню:</p>    <p><blockquote>static GnomeUIInfo submenu[] = {</blockquote></p>    <p><blockquote> {GNOME_APP_UI_ITEM, "SubMenu", "SubMenu Hint",</blockquote></p>    <p><blockquote>  GTK_SIGNAL_FUNC(item_clicked), NULL, NULL, 0, NULL, 0, 0, NULL},</blockquote></p>    <p><blockquote> {GNOME_APP_UI_ENDOFINFO, NULL, NULL, NULL, NULL, NULL, 0, NULL, 0, 0,</blockquote></p>    <p><blockquote>  NULL}</blockquote></p>    <p><blockquote>};</blockquote></p>    <p><blockquote>static GnomeUIInfo menu[] = {</blockquote></p>    <p><blockquote> {GNOME_APP_UI_ITEM, "Menu Item 1", "Menu Hint",</blockquote></p>    <p><blockquote>  NULL, NULL, NULL, 0, NULL, 0, 0, NULL},</blockquote></p>    <p><blockquote> {GNOME_APP_UI_SUBTREE, "Menu Item 2", "Menu Hint",</blockquote></p>    <p><blockquote>  submenu, NULL, NULL, 0, NULL, 0, 0, NULL},</blockquote></p>    <p><blockquote> {GNOME_APP_UI_ENDOFINFO, NULL, NULL, null,</blockquote></p>    <p><blockquote>  NULL, NULL, 0, NULL, 0, 0, NULL}</blockquote></p>    <p><blockquote>};</blockquote></p>    <p><blockquote>static GnomeUIInfo menubar[] = {</blockquote></p>    <p><blockquote> {GNOME_APP_UI_SUBTREE, "Toplevel Item", NULL, </blockquote></p>    <p><blockquote>  menu, NULL, NULL, 0, NULL, 0, 0, NULL},</blockquote></p>    <p><blockquote> {GNOME_APP_UI_ENDOFINFO, NULL, NULL, NULL,</blockquote></p>    <p><blockquote>  NULL, NULL, 0, NULL, 0, 0, NULL}</blockquote></p>    <p><blockquote>};</blockquote></p>    <p>3. В функции <blockquote>main</blockquote> вы имеете дело с обычной инициализацией и затем создаете ваш виджет <blockquote>GnomeApp</blockquote> и задаете все меню:</p>    <p><blockquote>int main (int argc, char *argv[]) {</blockquote></p>    <p><blockquote> GtkWidget *app;</blockquote></p>    <p><blockquote> gnome_program_init("gnome1", "0.1", LIBGNOMEUI_MODULE,</blockquote></p>    <p><blockquote>  argc, argv, GNOME_PARAM_NONE);</blockquote></p>    <p><blockquote> app = gnome_app_new("gnome1", "Menus, menus, menus");</blockquote></p>    <p><blockquote> gtk_window_set_default_size(GTK_WINDOW(app), 300, 200);</blockquote></p>    <p><blockquote> g_signal_connect(GTK_OBJECT(app), "destroy",</blockquote></p>    <p><blockquote>  GTK_SIGNAL_FUNC(closeApp), NULL);</blockquote></p>    <p><blockquote> gnome_app_create_menus(GNOME_APP(app), menubar);</blockquote></p>    <p><blockquote> gtk_widget_show(app);</blockquote></p>    <p><blockquote> gtk_main();</blockquote></p>    <p><blockquote> return 0;</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Попробуйте выполнить menu1 и посмотрите в действии строку меню, подменю и меню GNOME обратного вызова, показанные на рис. 16.12.</p>    <img src="image062.jpg"/>    <p><b>Рис. 16.12</b></p>    <br>    <p>Структура <blockquote>GnomeUIInfo</blockquote> едва ли дружественная по отношению к программисту, если учесть, что она состоит из 11 элементов, большинство из которых обычно равно <blockquote>NULL</blockquote> или нулю. При их вводе очень легко допустить ошибку и трудно отличить одно поле от другого в длинном массиве элементов. Для улучшения сложившейся ситуации в среде GNOME определены макросы, устраняющие необходимость определения структур вручную. Эти макросы также вставляют пиктограммы и клавиатурные акселераторы для вас, и все даром. На самом деле редко возникают причины, заставляющие использовать вместо них что-то другое.</p>    <p>Существуют два набора макросов, первый из которых определяет отдельные пункты меню. Эти макросы принимают два параметра: указатель на функцию обратного вызова и данные пользователя.</p>    <p><blockquote><b>#include &lt;libgnomeui/libgnameui.h&gt;</b></blockquote></p>    <p><blockquote><b>#define GNOMEUIINFO_MENU_OPEN_ITEM(cb, data)</b></blockquote></p>    <p><blockquote><b>#define GNOMEUIINFO_MENU_SAVE_ITEM(cb, data)</b></blockquote></p>    <p><blockquote><b>#define GNOMEUIINFO_MENU_SAVE_AS_IТЕМ(cb, data)</b></blockquote></p>    <p><blockquote><b>#define GNOMEUIINFO_MENU_PRINT_ITEM(cb, data)</b></blockquote></p>    <p><blockquote><b>#define GNOMEUIINFO_MENU_PRINT_SETUP_ITEM(cb, data)</b></blockquote></p>    <p><blockquote><b>#define GNOMEUIINFO_MENU_CLOSE_IТЕМ(cb, data)</b></blockquote></p>    <p><blockquote><b>#define GNOMEUIINFO_MENU_EXIT_IТЕМ(cb, data)</b></blockquote></p>    <p><blockquote><b>#define GNOMEUIINFO_MENU_QUIT_IТЕМ(cb, data)</b></blockquote></p>    <p><blockquote><b>#define GNOMEUIINFO_MENU_CUT_ITEM(cb, data)</b></blockquote></p>    <p><blockquote><b>#define GNOMEUIINFO_MENU_COPY_ITEM(cb, data)</b></blockquote></p>    <p><blockquote><b>#define GNOMEUIINFO_MENU_PASTE_ITEM(cb, data)</b></blockquote></p>    <p><blockquote><b>#define GNOMEUIINFO_MENU_SELECT_ALL_ITEM(cb, data)</b></blockquote></p>    <p><blockquote>...</blockquote></p>    <p>Второй набор предназначен для определений верхнего уровня, в него вы просто передаете массив.</p>    <p><blockquote><b>#define GNOMEUIINFO_MENU_FILE_TREE     (tree)</b></blockquote></p>    <p><blockquote><b>#define GNOMEUIINFO_MENU_EDIT_TREE     (tree)</b></blockquote></p>    <p><blockquote><b>#define GNOMEUIINFO_MENU_VIEW_TREE     (tree)</b></blockquote></p>    <p><blockquote><b>#define GNOMEUIINFO_MENU_SETTINGS_TREE (tree)</b></blockquote></p>    <p><blockquote><b>#define GNOMEUIINFO_MENU_FILES_TREE    (tree)</b></blockquote></p>    <p><blockquote><b>#define GNOMEUIINFO_MENU_WINDOWS_TREE  (tree)</b></blockquote></p>    <p><blockquote><b>#define GNOMEUIINFO_MENU_HELP_TREE     (tree)</b></blockquote></p>    <p><blockquote><b>#define GNOMEUIINFO_MENU_GAME_TREE     (tree)</b></blockquote></p>    <p>Выполните упражнение 16.10.</p>    <b>Упражнение 16.10. Меню с помощью макросов GNOME</b>    <p>В этом примере вы воспользуетесь уже заданными меню и посмотрите, как работают макросы. Внесите следующие изменения в программу menu1.с и назовите новый вариант menu2.c. Для простоты в этом примере для пунктов меню не определены функции обратного вызова. В данном случае наша задача — просто продемонстрировать удобство применения макросов GNOME, формирующих меню.</p>    <p><blockquote>#include &lt;gnome.h&gt;</blockquote></p>    <br>    <p><blockquote><i>static GnomeUIInfo filemenu[] = {</i></blockquote></p>    <p><blockquote><i> GNOMEUIINFO_MENU_NEW_ITEM("New", "Menu Hint", NULL, NULL),</i></blockquote></p>    <p><blockquote><i> GNOMEUIINFO_MENU_OPEN_ITEM(NULL, NULL),</i></blockquote></p>    <p><blockquote><i> GNOMEUIINFO_MENU_SAVE_AS_ITEM(NULL, NULL),</i></blockquote></p>    <p><blockquote><i> GNOMEUIINFO_SEPARATOR,</i></blockquote></p>    <p><blockquote><i> GNOMEIINFO_MENU_EXIT_ITEM(NULL, NULL),</i></blockquote></p>    <p><blockquote><i> GNOMEUUINFO_END</i></blockquote></p>    <p><blockquote><i>};</i></blockquote></p>    <br>    <p><blockquote><i>static GnomeUUInfo editmenu[] = </i></blockquote></p>    <p><blockquote><i> GNOMEUIINFO_MENU_FIND_ITEM(NULL, NULL),</i></blockquote></p>    <p><blockquote><i> GNOMEUIINFO_END</i></blockquote></p>    <p><blockquote><i>};</i></blockquote></p>    <br>    <p><blockquote><i>static GnomeUIInfo menubar[] = {</i></blockquote></p>    <p><blockquote><i> GNOMEUIINFO_MENU_FILE_TREE(filemenu),</i></blockquote></p>    <p><blockquote><i> GNOMEUIINFO_MENU_EDIT_TREE(editmenu),</i></blockquote></p>    <p><blockquote><i> GNOMEUIINFO_END</i></blockquote></p>    <p><blockquote><i>};</i></blockquote></p>    <br>    <p><blockquote>int main(int argc, char *argv[]) {</blockquote></p>    <p><blockquote> GtkWidget *app, *toolbar;</blockquote></p>    <p><blockquote> gnome_program_init("gnome1", "0.1", LIBGNOMEUI_MODULE,</blockquote></p>    <p><blockquote>  argc, argv, GNOME_PARAM_NONE);</blockquote></p>    <p><blockquote> app = gnome_app_new("gnome1", "Menus, menus, menus");</blockquote></p>    <p><blockquote> gtk_window_set_default_size(GTK_WINDOW(app), 300, 200);</blockquote></p>    <p><blockquote> gnome_app_create_menus(GNOME_APP(app), menubar);</blockquote></p>    <p><blockquote> gtk_widget_show(app);</blockquote></p>    <p><blockquote> gtk_main();</blockquote></p>    <p><blockquote> return 0;</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>Применив макросы libgnomeui в menu2.c, вы значительно сократили код, который нужно набирать, и сделали его гораздо понятнее. Макросы экономят ваше время и усилия, предпринимаемые для создания меню и согласования текста меню, клавиатурных акселераторов и пиктограмм с другими приложениями GNOME. Старайтесь применять их в ваших приложениях при любой возможности.</p>    <p>На рис. 16.13 показана программа menu3.c в действии на сей раз со стандартизованными в среде GNOME пунктами меню.</p>    <img src="image063.jpg"/>    <p><b>Рис. 16.13</b></p>          <a name="metkadoc25"><h1>Диалоговые окна</h1></a>         <p>Основная часть любого приложения GUI — взаимодействие с пользователем и информирование его о важных событиях. Обычно для этого вы создаете временное окно с кнопками <b>OK</b> и <b>Cancel</b> и, если информация настолько важна, что требует немедленного отклика, например удаление файла, вам приходится блокировать доступ ко всем остальным окнам до тех пор, пока пользователь не сделает выбор (такие окна называют<i> модальными диалоговыми окнами</i>).</p>     <p>Мы только что описали диалоговое окно, и в комплекте GTK+ есть специальные виджеты диалоговых окон, являющиеся потомками виджета GtkWindow, что существенно облегчает вашу программистскую работу.</p>             <a name="metkadoc26"><h1><i>GtkDialog</i></h1></a>     <p>Как вы можете видеть, объект <blockquote>GtkDialog</blockquote> — потомок объекта <blockquote>GtkWindow</blockquote> и наследует все его функции и свойства.</p>     <p><blockquote>GtkWindow</blockquote></p>     <p><blockquote> +----GtkDialog</blockquote></p>     <p><blockquote>GtkDialog</blockquote> делит окно на две области, одна для содержимого виджета и другая для кнопок, которые располагаются вдоль нижнего края окна. Вы можете задать нужные вам кнопки и другие параметры диалогового окна во время его создания.</p>     <p><blockquote><b>GtkWidget* gtk_dialog_new_with_buttons(const gchar *title,</b></blockquote></p>     <p><blockquote><b> GtkWindow *parent, GtkDialogFlags flags,</b></blockquote></p>     <p><blockquote><b> const gchar *first button text, ...);</b></blockquote></p>     <p>Эта функция создает диалоговое окно с заголовком и кнопками. Второй параметр, <blockquote>parent</blockquote>, должен указывать на главное окно вашего приложения, чтобы комплект GTK+ мог убедиться в том, что диалоговое окно остается присоединенным к главному окну и минимизируется при сворачивании главного окна.</p>     <p>Параметр <blockquote>flags</blockquote> определяет комбинацию свойств диалогового окна:</p>     <p>&#9633; <blockquote>GTK_DIALOG_MODAL</blockquote>;</p>     <p>&#9633; <blockquote>GTK_DIALOG_DESTROY_WITH_PARENT</blockquote>;</p>     <p>&#9633; <blockquote>GTK_DIALOG_NO_SEPARATOR</blockquote>.</p>     <p>Вы можете комбинировать флаги с помощью поразрядной операции <blockquote>OR</blockquote>; например, комбинация <blockquote>GTK_DIALOG_MODAL | GTK_DIALOG_NO_SEPARATOR</blockquote> означает одновременно и модальное окно, и окно без разделительной линии между основной областью окна и областью кнопок.</p>     <p>Оставшиеся параметры — это <blockquote>NULL</blockquote>-терминированный список кнопок и код соответствующего отклика. Вы поймете, что именно означает этот код отклика, когда познакомитесь с функцией <blockquote>gtk_dialog_run</blockquote>. Обычно кнопки выбираются из длинного списка готовых кнопок, которые определяет GTK+, поскольку вы получите уже готовые пиктограммы в кнопках.</p>     <p>Далее показано, как бы вы создавали диалоговое окно с кнопками <b>OK</b> и <b>Cancel</b>, которое возвращает <blockquote>GTK_RESPONSE_ACCEPT</blockquote> и <blockquote>GTK_RESPONSE_REJECT</blockquote> при нажатии этих кнопок:</p>     <p><blockquote>GtkWidget *dialog = gtk_dialog_new_with_buttons("Important question",</blockquote></p>     <p><blockquote> parent_window,</blockquote></p>     <p><blockquote> GTK_DIALOG_DESTROY_WITH_PARENT, GTK_STOCK_OK, </blockquote></p>     <p><blockquote> GTK_RESPONSE_ACCEPT, GTK_STOCK_CANCEL,</blockquote></p>     <p><blockquote> GTK_RESPONSE_REJECT, NULL);</blockquote></p>     <p>Мы остановились на двух кнопках, но на самом деле на количество кнопок в диалоговом окне нет ограничений. Более того, вы можете выбирать из ряда флагов типа отклика. Флаги <blockquote>accept</blockquote> (принять) и <blockquote>reject</blockquote> (отвергнуть) не применяются в стандарте GNOME и могут использоваться в ваших приложениях по вашему усмотрению. (Помните о том, что <blockquote>accept</blockquote> в вашем приложении должен означать "принять".) Другие варианты, включая отклик OK и CANCEL, приведены в типе <blockquote>GtkResponseType enum</blockquote> в следующем разделе.</p>     <p>Естественно, вы должны вставить содержимое в ваше диалоговое окно и для этого объект <blockquote>GtkDialog</blockquote> содержит готовый упаковочный контейнер <blockquote>GtkVBox</blockquote> для заполнения виджетами. Вы получаете указатель прямо из объекта:</p>     <p><blockquote>GtkWidget *vbox = GTK_DIALOG(dialog)-&gt;vbox;</blockquote></p>     <p>Этот <blockquote>GtkVBox</blockquote> применяется обычным способом с помощью функции <blockquote>gtk_box_pack_start</blockquote> или чего-то подобного.</p>     <p>После того как диалоговое окно создано, следующий шаг — представить его пользователю и ждать от него ответа. Сделать это можно двумя способами: в модальном режиме, который блокирует весь ввод за исключением диалогового окна, или в немодальном режиме, который воспринимает диалоговое окно как любое другое окно. Давайте сначала рассмотрим запуск модального диалогового окна.</p>             <a name="metkadoc27"><h1>Модальное диалоговое окно</h1></a>     <p>Модальное диалоговое окно заставляет пользователя ответить до того, как сможет выполниться любое другое действие. Оно полезно в тех ситуациях, когда пользователь собирается сделать что-то, сопряженное с серьезными последствиями, или нужно вывести сообщения об ошибках и предупреждениях.</p>     <p>Диалоговое окно можно сделать модальным, установив флаг <blockquote>GTK_DIALOG_MODAL</blockquote> и вызвав функцию <blockquote>gtk_widget_show</blockquote>, но есть лучший путь. Функция <blockquote>gtk_dialog_run</blockquote> выполнит за вас всю тяжелую работу, остановив дальнейшее выполнение программы до тех пор, пока не будет нажата кнопка в диалоговом окне.</p>     <p>Когда пользователь нажимает кнопку (или диалоговое окно уничтожается), функция <blockquote>gtk_dialog_run</blockquote> возвращает результат типа <blockquote>int</blockquote>, указывающий на кнопку, нажатую пользователем. В GTK+ очень кстати определен тип <blockquote>enum</blockquote> для описания возможных значений.</p>     <p><blockquote><b>typedef enum {</b></blockquote></p>     <p><blockquote><b> GTK_RESPONSE_NONE = -1,</b></blockquote></p>     <p><blockquote><b> GTK_RESPONSE_REJECT = -2,</b></blockquote></p>     <p><blockquote><b> GTK_RESPONSE_ACCEPT = -3,</b></blockquote></p>     <p><blockquote><b> GTK_RESPONSE_DELETE_EVENT = -4</b></blockquote></p>     <p><blockquote><b> GTK_RESPONSE_OK = -5,</b></blockquote></p>     <p><blockquote><b> GTK_RESPONSE_CANCEL = -6,</b></blockquote></p>     <p><blockquote><b> GTK_RESPONSE_CLOSE = -7,</b></blockquote></p>     <p><blockquote><b> GTK_RESPONSE_YES = -8,</b></blockquote></p>     <p><blockquote><b> GTK_RESPONSE_NO = -9,</b></blockquote></p>     <p><blockquote><b> GTK_RESPONSE_APPLY = -10,</b></blockquote></p>     <p><blockquote><b> GTK_RESPONSE_HELP = -11</b></blockquote></p>     <p><blockquote><b>} GtkResponseType;</b></blockquote></p>     <p>Теперь мы можем объяснить код отклика, передаваемый в функцию <blockquote>gtk_dialog_new_with_buttons</blockquote>, — это код возврата типа <blockquote>GtkResponseType</blockquote>, который функция <blockquote>gtk_dialog_run</blockquote> возвращает, когда нажата кнопка. Если диалоговое окно уничтожается (это происходит, например, когда пользователь щелкает кнопкой мыши пиктограмму закрытия), вы получаете результат <blockquote>GTK_RESPONSE_NONE</blockquote>.</p>     <p>Для вызова соответствующих операторов идеально подходит конструкция <blockquote>switch</blockquote>:</p>     <p><blockquote>GtkWidget* dialog = create_dialog();</blockquote></p>     <p><blockquote>int result = gtk_dialog_run(GTK_DIALOG(dialog));</blockquote></p>     <p><blockquote>switch(result) {</blockquote></p>     <p><blockquote>case GTK_RESPONSE_ACCEPT:</blockquote></p>     <p><blockquote> delete_file();</blockquote></p>     <p><blockquote> break;</blockquote></p>     <p><blockquote>сазе GTK_RESPONSE_REJECT:</blockquote></p>     <p><blockquote> do_nothing();</blockquote></p>     <p><blockquote> break;</blockquote></p>     <p><blockquote>default:</blockquote></p>     <p><blockquote> dialog_was_cancelled();</blockquote></p>     <p><blockquote> break;</blockquote></p>     <p><blockquote>}</blockquote></p>     <p><blockquote>gtk_widget_destroy(dialog);</blockquote></p>     <p>Это все, что есть для простых модальных окон в комплекте инструментов GTK+. Как видите, включен очень небольшой программный код и потрачено немного усилий. В конце нужно только провести чистку с помощью функции <blockquote>gtk_widget_destroy</blockquote>.</p>     <p>Если вам понадобится немодальное диалоговое окно, все будет не так просто. Вы не сможете использовать функцию <blockquote>gtk_dialog_run</blockquote>, вместо нее придется связать функции обратного вызова с кнопками диалогового окна.</p>             <a name="metkadoc28"><h1>Немодальные диалоговые окна</h1></a>     <p>Мы рассмотрели, как применять функцию <blockquote>gtk_dialog_run</blockquote> для создания модального (блокирующего) диалогового окна. Немодальное окно действует несколько иначе, хотя и создается тем же способом. Вместо вызова функции <blockquote>gtk_dialog_run</blockquote> вы связываете функцию обратного вызова с сигналом отклика объекта <blockquote>GtkDialog</blockquote>, который генерируется при щелчке кнопки мышью или уничтожении окна.</p>     <p>Связывание сигнала обратного вызова выполняется обычным образом с той лишь разницей, что у функции обратного вызова появляется дополнительный аргумент отклика, играющий ту же роль, что код возврата функции <blockquote>gtk_dialog_run</blockquote>. В приведенном далее фрагменте программного кода показаны основные принципы использования немодального диалогового окна:</p>     <p><blockquote>void dialog_button_clicked(GtkWidget *dialog, gint response,</blockquote></p>     <p><blockquote> gpointer user_data) {</blockquote></p>     <p><blockquote> switch (response) {</blockquote></p>     <p><blockquote> case GTK_RESPONSE_ACCEPT:</blockquote></p>     <p><blockquote>  do_stuff();</blockquote></p>     <p><blockquote>  break;</blockquote></p>     <p><blockquote> case GTK_RESPONSE_REJECT:</blockquote></p>     <p><blockquote>  do_nothing();</blockquote></p>     <p><blockquote>  break;</blockquote></p>     <p><blockquote> default:</blockquote></p>     <p><blockquote>  dialog_was_cancelled();</blockquote></p>     <p><blockquote>  break;</blockquote></p>     <p><blockquote> }</blockquote></p>     <p><blockquote> gtk_widget_destroy(dialog);</blockquote></p>     <p><blockquote>}</blockquote></p>     <br>     <p><blockquote>int main() {</blockquote></p>     <p><blockquote> ...</blockquote></p>     <p><blockquote> GtkWidget *dialog = create_dialog();</blockquote></p>     <p><blockquote> g_signal_connect(GTK_OBJECT(dialog), "response",</blockquote></p>     <p><blockquote>  GTK_SIGNAL_FUNC(dialog_button_clicked), user_data);</blockquote></p>     <p><blockquote> gtk_widget_show(dialog);</blockquote></p>     <p><blockquote> ...</blockquote></p>     <p><blockquote>}</blockquote></p>     <p>С немодальными диалоговыми окнами могут возникать сложности, т.к. от пользователя не требуется немедленного ответа, и он может свернуть диалоговое окно и забыть о нем. Вы должны предусмотреть действия при попытке пользователя повторно открыть диалоговое окно до закрытия первого экземпляра окна. Следует проверить, равен ли <blockquote>NULL</blockquote> указатель диалогового окна и если нет, повторно вывести уже открытое диалоговое окно на экран, вызвав функцию <blockquote>gtk_window_present</blockquote>. Вы увидите этот прием в действии в<i> разд. "Приложение для работы с базой данных компакт-дисков" в конце данной главы.</i></p>             <a name="metkadoc29"><h1><i>GtkMessageDialog</i></h1></a>     <p>Для очень простых диалоговых окон даже тип <blockquote>GtkDialog</blockquote> излишне сложен.</p>     <p><blockquote>GtkDialog</blockquote></p>     <p><blockquote> +----GtkMessageDialog</blockquote></p>     <p>С помощью типа <blockquote>GtkMessageDialog</blockquote> вы можете создать информационное диалоговое окно одной строкой программного кода.</p>     <p><blockquote><b>GtkWidget* gtk_message_dialog_new(GtkWindow *parent,</b></blockquote></p>     <p><blockquote><b> GtkDialogFlags flags, GtkMessageType type,</b></blockquote></p>     <p><blockquote><b> GtkButtonsType buttons, const gchar *message_format, ...);</b></blockquote></p>     <p>Эта функция создает диалоговое окно, снабженное пиктограммами, заголовком и настраиваемыми кнопками. <blockquote>Параметр</blockquote> type задает готовую пиктограмму и заголовок диалогового окна в соответствии с его предполагаемым назначением; например, окно с предупреждением содержит пиктограмму предупреждения в виде треугольника. Существует четыре возможных варианта для простых диалоговых окон, с которыми вы будете сталкиваться чаще всего:</p>     <p>&#9633; <blockquote>GTK_MESSAGE_INFO</blockquote>;</p>     <p>&#9633; <blockquote>GTK_MESSAGE_WARNING</blockquote>;</p>     <p>&#9633; <blockquote>GTK_MESSAGE_QUESTION</blockquote>;</p>     <p>&#9633; <blockquote>GTK_MESSAGE_ERROR</blockquote>.</p>     <p>Вы также можете выбрать значение <blockquote>GTK_MESSAGE_OTHER</blockquote>, применяемое в тех случаях, когда не используются перечисленные типы. Для окна типа <blockquote>GtkMessageDialog</blockquote> можно передать тип <blockquote>GtkButtonsType</blockquote> (табл. 16.4) вместо перечисления всех кнопок по очереди.</p>     <br>     <p><i><b>Таблица 16.4</b></i></p>     <table>      <tr>       <th valign="top">Тип <blockquote>GtkButtonsType</blockquote></th>       <th valign="top">Описание</th>      </tr>      <tr>       <td valign="top"><blockquote>GTK_BUTTONS_OK</blockquote></td>       <td valign="top">Кнопка <b>OK</b></td>      </tr>      <tr>       <td valign="top"><blockquote>GTK_BUTTONS_CLOSE</blockquote></td>       <td valign="top">Кнопка <b>Close</b></td>      </tr>      <tr>       <td valign="top"><blockquote>GTK_BUTTONS_CANCEL</blockquote></td>       <td valign="top">Кнопка <b>Cancel</b></td>      </tr>      <tr>       <td valign="top"><blockquote>GTK_BUTTONS_YES_NO</blockquote></td>       <td valign="top">Кнопки <b>Yes</b> и <b>No</b></td>      </tr>      <tr>       <td valign="top"><blockquote>GTK_BUTTONS_OK_CANCEL</blockquote></td>       <td valign="top">Кнопки <b>OK</b> и <b>Cancel</b></td>      </tr>      <tr>       <td valign="top"><blockquote>GTK_BUTTONS_NONE</blockquote></td>       <td valign="top">Нет кнопок</td>      </tr>     </table>     <p>Теперь остается только текст диалогового окна, который можно создать из строки подстановки, формируемой так же, как в функции <blockquote>printf</blockquote>. В данном примере вы спрашиваете пользователя, настаивает ли он на своем требовании удалить файл:</p>     <p><blockquote>GtkWidget *dialog = gtk_message_dialog_new(main_window,</blockquote></p>     <p><blockquote> GTK_DIALOG_DESTROY_WITH_PARENT,</blockquote></p>     <p><blockquote> GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO,</blockquote></p>     <p><blockquote> "Are you sure you wish to delete %s?", filename);</blockquote></p>     <p><blockquote>result = gtk_dialog_run(GTK_DIALOG(dialog));</blockquote></p>     <p><blockquote>gtk_widget_destroy(dialog);</blockquote></p>     <p>Это диалоговое окно будет отображаться так, как показано на рис. 16.14.</p>     <img src="image064.jpg"/>     <p><b>Рис. 16.14</b></p>     <br>     <p>Окно типа <blockquote>GtkMessageDialog</blockquote> — простейший способ обмена информацией или получения ответов на вопросы типа "да/нет". Вы воспользуетесь им в следующем разделе, когда примените полученные знания для создания GUI вашего приложения для работы с базой данных компакт-дисков.</p>              <a name="metkadoc30"><h1>Приложение для работы с базой данных компакт-дисков</h1></a>    <p>В предыдущих главах вы разрабатывали базу данных компакт-дисков с помощью MySQL и интерфейса на языке С. Теперь вы увидите, как просто вставить внешний GUI средствами GNOME/GTK+ и создать пользовательский интерфейс с богатыми функциональными возможностями. </p>    <blockquote>     <b>Примечание</b>     <p>Для проверки примера приложения для работы с базой данных компакт-дисков у вас должны быть установлены СУБД MySQL и библиотеки разработки, т.е. должны выполняться те же самые требования, что и к аналогичному приложению в<i> главе 8.</i></p>    </blockquote>    <p>Из соображений простоты и ясности мы создадим базовый скелетный интерфейс, в котором реализовано лишь подмножество функций — к примеру, вы не сможете добавлять информацию о дорожках в компакт-диски или удалять CD. Но вы увидите в вашем приложении в действии виджеты, обсуждавшиеся в этой главе, и поймете, как они применяются в реальных программах.</p>    <p>Будет написан программный код для следующих ключевых действий:</p>    <p>&#9633; регистрация в базе данных из GUI;</p>    <p>&#9633; поиск компакт-диска;</p>    <p>&#9633; отображение сведений о компакт-диске и его дорожках;</p>    <p>&#9633; вставка компакт-диска в базу данных;</p>    <p>&#9633; создание окна <b>About</b> (О программе);</p>    <p>&#9633; формирование подтверждения при завершении работы пользователя.</p>    <p>Разделим код на три файла, совместно использующие заголовочный файл cdapp_gnome.h. В исходных файлах функции создания окон и диалоговых окон — функции формирования интерфейса — отделены от функций обратного вызова (упражнения 16.11-16.14).</p>    <b>Упражнение 16.11. Файл cdapp_gnome.h</b>    <p>Сначала рассмотрим файл cdapp_gnome.h и функции, которые вы должны реализовать.</p>    <p>1. Включите в исходный текст программы заголовочные файлы среды GNOME и заголовочный файл для функций интерфейса, разработанного вами в<i> главе 8. </i>В данном примере программы используются файлы app_mysql.h и app_mysql.c из<i> главы 8</i> и созданная там же база данных.</p>    <p><blockquote>#include &lt;gnome.h&gt;</blockquote></p>    <p><blockquote>#include "app_mysql.h"</blockquote></p>    <p>2. В типе <blockquote>enum</blockquote> обозначены столбцы виджета <blockquote>GtkTreeView</blockquote>, который вы будете применять для отображения сведений о компакт-дисках и их дорожках. </p>    <p><blockquote>enum {</blockquote></p>    <p><blockquote> COLUMN_TITLE,</blockquote></p>    <p><blockquote> COLUMN_ARTIST,</blockquote></p>    <p><blockquote> COLUMN_CATALOGUE,</blockquote></p>    <p><blockquote> N_COLUMNS</blockquote></p>    <p><blockquote>};</blockquote></p>    <p>3. У вас есть три функции создания окна в файле interface.c.</p>    <p><blockquote>GtkWidget *create_main_window();</blockquote></p>    <p><blockquote>GtkWidget *create_login_dialog();</blockquote></p>    <p><blockquote>GtkWidget *create_addcd_dialog();</blockquote></p>    <p>4. Функции обратного вызова для пунктов меню, панели инструментов, кнопок диалогового окна и кнопки поиска находятся в файле callbacks.с.</p>    <p><blockquote>/* Обратный вызов для выхода из приложения */</blockquote></p>    <p><blockquote>void quit_app(GtkWidget* window, gpointer data);</blockquote></p>    <p><blockquote>/* Обратный вызов для подтверждения завершения перед выходом */</blockquote></p>    <p><blockquote>gboolean delete_event_handler(GtkWidget* window, GdkEvent *event,</blockquote></p>    <p><blockquote> gpointer data);</blockquote></p>    <p><blockquote>/* Обратный вызов, связанный с сигналом отклика диалогового окна addcd */</blockquote></p>    <p><blockquote>void addcd_dialog_button_clicked(GtkDialog * dialog, gint response,</blockquote></p>    <p><blockquote> gpointer userdata);</blockquote></p>    <p><blockquote>/* Обратный вызов для кнопки Add CD меню и панели инструментов */</blockquote></p>    <p><blockquote>void on_addcd_activate(GtkWidget *widget, gpointer user_data);</blockquote></p>    <p><blockquote>/* Обратный вызов для кнопки меню About */</blockquote></p>    <p><blockquote>void on_about_activate(GtkWidget* widget, gpointer user_data);</blockquote></p>    <p><blockquote>/* Обратный вызов для кнопки поиска */</blockquote></p>    <p><blockquote>void on_search_button_clicked(GtkWidget *widget, gpointer userdata);</blockquote></p>    <b>Упражнение 16.12. Файл interface.c</b>    <p>Первым рассмотрим файл interface.c, в котором определяются окна и диалоговые окна, применяемые в приложении.</p>    <p>1. Сначала несколько указателей виджетов, на которые вы ссылаетесь в файлах callbacks.c и main.c:</p>    <p><blockquote>#include "app_gnome.h"</blockquote></p>    <br>    <p><blockquote>GtkWidget* treeview;</blockquote></p>    <p><blockquote>GtkWidget* appbar;</blockquote></p>    <p><blockquote>GtkWidget* artist_entry;</blockquote></p>    <p><blockquote>GtkWidget *title_entry;</blockquote></p>    <p><blockquote>GtkWidget *catalogue_entry;</blockquote></p>    <p><blockquote>GtkWidget *username_entry;</blockquote></p>    <p><blockquote>GtkWidget *password_entry;</blockquote></p>    <p>2. <blockquote>app</blockquote> — глобальная переменная, указатель на главное окно:</p>    <p><blockquote>static GtkWidget *арр;</blockquote></p>    <p>3. Определите вспомогательную функцию, которая вставляет в контейнер виджет-метку с заданным текстом:</p>    <p><blockquote>void add_widget_with_label(GtkContainer *box,</blockquote></p>    <p><blockquote> gchar *caption, GtkWidget *widget) {</blockquote></p>    <p><blockquote> GtkWidget *label = gtk_label_new(caption);</blockquote></p>    <p><blockquote> GtkWidget *hbox = gtk_hbox_new(TRUE, 4);</blockquote></p>    <p><blockquote> gtk_container_add(GTK_CONTAINER(hbox), label);</blockquote></p>    <p><blockquote> gtk_container_add(GTK_CONTAINER(hbox), widget);</blockquote></p>    <p><blockquote> gtk_container_add(box, hbox);</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>4. Определения строки меню, использующие для удобства макросы <blockquote>GNOMEUIINFO</blockquote>:</p>    <p><blockquote>static GnomeUIInfo filemenu[] = {</blockquote></p>    <p><blockquote> GNOMEUIINFO_MENU_NEW_ITEM("_New CD", NULL, on_addcd_activate, NULL),</blockquote></p>    <p><blockquote> GNOMEUIINFO_SEPARATOR,</blockquote></p>    <p><blockquote> GNOMEUIINFO_MENU_EXIT_ITEM(close_app, NULL),</blockquote></p>    <p><blockquote> GNOMEUIINFO_END</blockquote></p>    <p><blockquote>};</blockquote></p>    <p><blockquote>static GnomeUIInfo helpmenu[] = {</blockquote></p>    <p><blockquote> GNOMEUIINFO_MENU_ABOUT_ITEM(on_about_activate, NULL),</blockquote></p>    <p><blockquote> GNOMEUIINFO_END</blockquote></p>    <p><blockquote>};</blockquote></p>    <p><blockquote>static GnomeUIInfo menubar[] = {</blockquote></p>    <p><blockquote> GNOMEUIINFO_MENU_FILE_TREE(filemenu),</blockquote></p>    <p><blockquote> GNOMEUIINFO_MENU_HELP_TREE(helpmenu),</blockquote></p>    <p><blockquote> GNOMEUIINFO_END</blockquote></p>    <p><blockquote>};</blockquote></p>    <p>5. Теперь вы создаете главное окно, вставляете меню и панель инструментов, задаете их размер, центрируете относительно экрана и собираете виджеты, формирующие интерфейс. Учтите, что эта функция не отображает окно на экране, а просто возвращает указатель на окно:</p>    <p><blockquote>GtkWidget *create_main_window() {</blockquote></p>    <p><blockquote> GtkWidget* toolbar;</blockquote></p>    <p><blockquote> GtkWidget* vbox;</blockquote></p>    <p><blockquote> GtkWidget* hbox;</blockquote></p>    <p><blockquote> GtkWidget* label;</blockquote></p>    <p><blockquote> GtkWidget* entry;</blockquote></p>    <p><blockquote> GtkWidget *search_button;</blockquote></p>    <p><blockquote> GtkWidget* scrolledwindow;</blockquote></p>    <p><blockquote> GtkCellRenderer *renderer;</blockquote></p>    <p><blockquote> app = gnome_app_new("GnomeCD", "CD Database");</blockquote></p>    <p><blockquote> gtk_window_set_position(GTK_WINDOW(app), GTK_WIN_POS_CENTER);</blockquote></p>    <p><blockquote> gtk_window_set_defeult_size(GTK_WINDOW(app ), 540, 480);</blockquote></p>    <p><blockquote> gnome_app_create_menus(GNOME_APP(app), menubar);</blockquote></p>    <p>6. Создайте панель инструментов с помощью стандартных пиктограмм GTK+ и свяжите с ней функции обратного вызова:</p>    <p><blockquote> toolbar = gtk_toolbar_new();</blockquote></p>    <p><blockquote> gnome_app_add_toolbar(GNOME_APP(app), GTK_TOOLBAR(toolbar),</blockquote></p>    <p><blockquote>  "toolbar", BONOBO_DOCK_ITEM_BEH_EXCLUSIVE,</blockquote></p>    <p><blockquote>  BONOBO_DOCK_TOP, 1, 0, 0);</blockquote></p>    <p><blockquote> gtk_container_set_border_width(GTK_CONTAINER(toolbar), 1);</blockquote></p>    <p><blockquote> gtk_toolbar_insert_stock(GTK_TOOLBAR(toolbar), "gtk-add", "Add new CD",</blockquote></p>    <p><blockquote>  NULL, GTK_SIGNAL_FUNC(on_addcd_activate), NULL, -1);</blockquote></p>    <p><blockquote> gtk_toolbar_insert_space(GTK_TOOLBAR(toolbar), 1);</blockquote></p>    <p><blockquote> gtk_toolbar_insert_stock(GTK_TOOLBAR(toolbar), "gtk-quit",</blockquote></p>    <p><blockquote>  "Quit the Application", NULL, GTK_SIGNAL_FUNC(on_quit_activate), NULL, -1);</blockquote></p>    <p>7. Затем вы создаете виджеты, используемые для поиска компакт-диска:</p>    <p><blockquote> label = gtk_label_new("Search String:");</blockquote></p>    <p><blockquote> entry = gtk_entry_new();</blockquote></p>    <p><blockquote> search_button = gtk_button_new_with_label("Search");</blockquote></p>    <p>8. Окно <blockquote>gtk_scrolled_window</blockquote> предоставляет полосы прокрутки, позволяя виджету (в данном случае <blockquote>GtkTreeView</blockquote>) превышать размеры окна:</p>    <p><blockquote> scrolledwindow = gtk_scrolled_window_new(NULL, NULL);</blockquote></p>    <p><blockquote> gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolledwindow),</blockquote></p>    <p><blockquote>  GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);</blockquote></p>    <p>9. Далее скомпонуйте интерфейс, применяя стандартным способом виджеты-контейнеры:</p>    <p><blockquote> vbox = gtk_vbox_new(FALSE, 0);</blockquote></p>    <p><blockquote> hbox = gtk_hbox_new(FALSE, 0);</blockquote></p>    <p><blockquote> gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 5);</blockquote></p>    <p><blockquote> gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 5);</blockquote></p>    <p><blockquote> gtk_box_pack_start(GTK_BOX(hbox), entry, TRUE, TRUE, 6);</blockquote></p>    <p><blockquote> gtk_box_pack_start(GTK_BOX(hbox), search_button, FALSE, FALSE, 5);</blockquote></p>    <p><blockquote> gtk_box_pack_start(GTK_BOX(vbox), scrolledwindow, TRUE, TRUE, 0);</blockquote></p>    <p>10. Затем создайте виджет <blockquote>GtkTreeView</blockquote>, вставьте три столбца и поместите его в окно <blockquote>GtkScrolledWindow</blockquote>:</p>    <p><blockquote> treeview = gtk_tree_view_new();</blockquote></p>    <p><blockquote> renderer = gtk_cell_renderer_text_new();</blockquote></p>    <p><blockquote> gtk_tree_view_insert_column_with_attributes(GTK_TREE_VIEW(treeview),</blockquote></p>    <p><blockquote>  COLUMN_TITLE, "Title", renderer, "text", COLUMN_TITLE, NULL);</blockquote></p>    <p><blockquote> gtk_tree_view_insert_column_with_attributes(GTK_TREE_VIEW(treeview),</blockquote></p>    <p><blockquote>  COLUMN_ARTIST, "Artist", renderer, "text", CQLUMN_ARTIST, NULL);</blockquote></p>    <p><blockquote> gtk_tree_view_insert_column_with_attrihutes(GTK_TREE_VIEW(treeview),</blockquote></p>    <p><blockquote>  COLUMN_CATALOGUE, "Catalogue", renderer, "text", COLUMN_CATALOGUE, NULL);</blockquote></p>    <p><blockquote> gtk_tree_view_set_search_column(GTK_TREE_VIEW(treeview),</blockquote></p>    <p><blockquote>  COLUMN_TITLE);</blockquote></p>    <p><blockquote> gtk_container_add(GTK_CONTAINER(scrolledwindow), treeview);</blockquote></p>    <p>11. В заключение задайте содержимое главного окна, вставьте строку состояния <blockquote>GnomeApp</blockquote> и подсоедините нужные обратные вызовы:</p>    <p><blockquote> gnome_app_set_contents(GNOMEAPP(app), vbox);</blockquote></p>    <p><blockquote> appbar = gnome_appbar_new(FALSE, TRUE, GNOME_PREFERENCES_NEVER);</blockquote></p>    <p><blockquote> gnome_app_set_statusbar(GNOME_APP(app), appbar);</blockquote></p>    <p><blockquote> gnome_app_install_menu_hints(GNOME_APP(app), menubar);</blockquote></p>    <p><blockquote> g_signal_connect(GTK_OBJECT(search_button), "clicked",</blockquote></p>    <p><blockquote>  GTK_SIGNAL_FUNC(on_search_button_clicked), entry);</blockquote></p>    <p><blockquote> g_signal_connect(GTK_OBJECT(app), "delete_event",</blockquote></p>    <p><blockquote>  GTK_SIGNAL_FUNC(delete_event_handler), NULL);</blockquote></p>    <p><blockquote> g_signal_connect(GTK_OBJECT(app), "destroy",</blockquote></p>    <p><blockquote>  GTK_SIGNAL_FUNC(quit_app), NULL);</blockquote></p>    <p><blockquote> return app;</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>12. Следующая функция создает простое диалоговое окно, позволяющее добавлять новый компакт-диск в базу данных. Оно состоит из полей ввода для исполнителя, названия и полей каталога, а также кнопок <b>OK</b> и <b>Cancel</b>:</p>    <p><blockquote>GtkWidget *create_addcd_dialog() {</blockquote></p>    <p><blockquote> artist_entry = gtk_entry_new();</blockquote></p>    <p><blockquote> title_entry = gtk_entry_new();</blockquote></p>    <p><blockquote> catalogue_entry = gtk_entry_new();</blockquote></p>    <p><blockquote> GtkWidget* dialog = gtk_dialog_new_with_buttons("Add CD",</blockquote></p>    <p><blockquote>  app,</blockquote></p>    <p><blockquote>  GTK_DIALOG_DESTROY_WITH_PARENT,</blockquote></p>    <p><blockquote>  GTK_STOCK_OK,</blockquote></p>    <p><blockquote>  GTK_RESPONSE_ACCEPT,</blockquote></p>    <p><blockquote>  GTK_STOCK_CANCEL,</blockquote></p>    <p><blockquote>  GTK_RESPONSE_REJECT,</blockquote></p>    <p><blockquote>  NULL);</blockquote></p>    <p><blockquote> add_widget_with_label(GTK_CONTAINER(GTK_DIALOG(dialog)-&gt;vbox),</blockquote></p>    <p><blockquote>  "Artist", artist_entry);</blockquote></p>    <p><blockquote> add_widget_with_label(GTK_CONTAINER(GTK_DIALOG(dialog)-&gt;vbox),</blockquote></p>    <p><blockquote>  "Title", title_entry);</blockquote></p>    <p><blockquote> add_widget_with_label(GTK_CONTAINER(GTK_DIALOG(dialog)-&gt;vbox),</blockquote></p>    <p><blockquote>  "Catalogue", catalogue_entry);</blockquote></p>    <p><blockquote> g_signal_connect(GTK_OBJECT(dialog), "response",</blockquote></p>    <p><blockquote>  GTK_SIGNAL_FUNC(addcd_dialog_button_clicked), NULL);</blockquote></p>    <p><blockquote> return dialog;</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>13. База данных требует регистрации пользователя перед выполнением запросов к ней, поэтому данная функция создает диалоговое окно для ввода имени пользователя и пароля:</p>    <p><blockquote>GtkWidget *create_login_dialog() {</blockquote></p>    <p><blockquote> GtkWidget* dialog = gtk_dialog_new_with_buttons("Database Login",</blockquote></p>    <p><blockquote>  app, GTK_DIALOG_MODAL, GTK_STOCK_OK, GTK_RESPONSE_ACCEPT,</blockquote></p>    <p><blockquote>  GTK_STOCK_CANCEL, GTK_RESPONSE_REJECT, NULL);</blockquote></p>    <p><blockquote> username_entry = gtk_entry_new();</blockquote></p>    <p><blockquote> password_entry = gtk_entry_new();</blockquote></p>    <p><blockquote> gtk_entry_set_visibility(GTK_ENTRY(password_entry), FALSE);</blockquote></p>    <p><blockquote> add_widget_with_label(GTK_CONTAINER(GTK_DIALOG(dialog)-&gt;vbox),</blockquote></p>    <p><blockquote>  "Username", username_entry);</blockquote></p>    <p><blockquote> add_widget_with_label(GTK_CONTAINER(GTK_DIALOG(dialog)-&gt;vbox),</blockquote></p>    <p><blockquote>  "Password", password_entry);</blockquote></p>    <p><blockquote> gtk_widget_show_all(GTK_WIDGET(GTK_DIALOG(dialog)-&gt;vbox));</blockquote></p>    <p><blockquote> return dialog;</blockquote></p>    <p><blockquote>}</blockquote></p>    <b>Упражнение 16.13. callbacks.c</b>    <p>Файл callbacks.с содержит функции, задающие обратные вызовы для виджетов пользовательского интерфейса.</p>    <p>1. Сначала необходимо включить заголовочный файл и ссылки на некоторые определенные в файле interface.c глобальные переменные для чтения и изменения конкретных свойств виджетов:</p>    <p><blockquote>#include "app_gnome.h"</blockquote></p>    <br>    <p><blockquote>extern GtkWidget *treeview;</blockquote></p>    <p><blockquote>extern GtkWidget *app;</blockquote></p>    <p><blockquote>extern GtkWidget *appbar;</blockquote></p>    <p><blockquote>extern GtkWidget *artist_entry;</blockquote></p>    <p><blockquote>extern GtkWidget *title_entry;</blockquote></p>    <p><blockquote>extern GtkWidget *catalogue_entry;</blockquote></p>    <p><blockquote>static GtkWidget *addcd_dialog;</blockquote></p>    <p>2. В функции <blockquote>quit_app</blockquote> вы вызываете функцию <blockquote>database_end</blockquote> для чистки и закрытия базы данных перед выходом:</p>    <p><blockquote>void quit_app(GtkWidget* window, gpointer data) {</blockquote></p>    <p><blockquote> database_end();</blockquote></p>    <p><blockquote> gtk_main_quit();</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>3. Следующая функция выводит простое диалоговое окно для подтверждения вашего желания завершить приложение, возвращая отклик в виде значения <blockquote>gboolean</blockquote>:</p>    <p><blockquote>gboolean confirm_exit() {</blockquote></p>    <p><blockquote> gint result;</blockquote></p>    <p><blockquote> GtkWidget* dialog = gtk_message_dialog_new(NULL,</blockquote></p>    <p><blockquote>  GTK_DIALOG_MODAL, GTK_MESSAGE_QUESTION,</blockquote></p>    <p><blockquote>  GTK_BUTTONS_YES_NO, "Are you sure you want to quit?");</blockquote></p>    <p><blockquote> result = gtk_dialog_run(GTK_DIALOG(dialog));</blockquote></p>    <p><blockquote> gtk_widget_destroy(dialog);</blockquote></p>    <p><blockquote> return (result == GTK_RESPONSE_YES);</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>4. <blockquote>delete_event_handler</blockquote> — функция обратного вызова, которую вы связываете с событием главного окна <blockquote>Gdk delete event</blockquote>. Событие генерируется, когда вы пытаетесь закрыть окно до того (что существенно), как послан сигнал GTK+ уничтожения окна:</p>    <p><blockquote>gboolean delete_event_handler(GtkWidget* window, GdkEvent *event,</blockquote></p>    <p><blockquote> gpointer data) {</blockquote></p>    <p><blockquote> return !confirm_exit();</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>5. Следующая функция вызывается, когда мышью щелкается кнопка в диалоговом окне вставки компакт-диска. Если вы щелкнули мышью кнопку <b>OK</b>, программа копирует строки в массив типа char и передает его данные в интерфейсную функцию MySQL add_cd:</p>    <p><blockquote>void addcd_dialog_button_clicked(GtkDialog * dialog, gint response,</blockquote></p>    <p><blockquote> gpointer userdata) {</blockquote></p>    <p><blockquote> const gchar *artist_const;</blockquote></p>    <p><blockquote> const gchar* title_const;</blockquote></p>    <p><blockquote> const gchar *catalogue_const;</blockquote></p>    <p><blockquote> gchar artist[200];</blockquote></p>    <p><blockquote> gchar title[200];</blockquote></p>    <p><blockquote> gchar catalogue[200];</blockquote></p>    <p><blockquote> gint *cd_id;</blockquote></p>    <p><blockquote> if (response == GTK_RESPONSE_ACCEPT) {</blockquote></p>    <p><blockquote>  artist_const = gtk_entry_get_text(GTK_ENTRY(artist_entry));</blockquote></p>    <p><blockquote>  title_const = gtk_entry_get_text(GTK_ENTRY(title_entry));</blockquote></p>    <p><blockquote>  catalogue_const = gtk_entry_get_text(GTK_ENTRY(catalogue_entry));</blockquote></p>    <p><blockquote>  strcpy(artist, artist_const);</blockquote></p>    <p><blockquote>  strcpy(title, title_const);</blockquote></p>    <p><blockquote>  strcpy(catalogue, catalogue_const);</blockquote></p>    <p><blockquote>  add_cd(artist, title, catalogue, cd_id);</blockquote></p>    <p><blockquote> }</blockquote></p>    <p><blockquote> addcd_dialog = NULL;</blockquote></p>    <p><blockquote> gtk_widget_destroy(GTK_WIDGET(dialog));</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>6. Далее идет самая важная часть приложения: извлечение результатов поиска и заполнение объекта <blockquote>GtkTreeView</blockquote>:</p>    <p><blockquote>void on_search_button_clicked(GtkButton* button, gpointer userdata) {</blockquote></p>    <p><blockquote> struct cd_search_st cd_res;</blockquote></p>    <p><blockquote> struct current_cd_st cd;</blockquote></p>    <p><blockquote> struct current_tracks_st ct;</blockquote></p>    <p><blockquote> gint res1, res2, res3;</blockquote></p>    <p><blockquote> gchar track_title[110];</blockquote></p>    <p><blockquote> const gchar *search_string_const;</blockquote></p>    <p><blockquote> gchar search string[200];</blockquote></p>    <p><blockquote> gchar search_text[200];</blockquote></p>    <p><blockquote> gint i = 0, j = 0;</blockquote></p>    <p><blockquote> GtkTreeStore *tree_store;</blockquote></p>    <p><blockquote> GtkTreeIter parent_iter, child_iter;</blockquote></p>    <p><blockquote> memset(&amp;track_title, 0, sizeof(track_title));</blockquote></p>    <p>7. Здесь вы получаете строку поиска из виджета ввода, копируете ее в переменную и выбираете соответствующие ID компакт-дисков:</p>    <p><blockquote> search_string_const = gtk_entry_get_text(GTK_ENTRY(userdata));</blockquote></p>    <p><blockquote> strcpy(search_string, search_string_const);</blockquote></p>    <p><blockquote> resl = find_cds(search_string, &amp;cd_res);</blockquote></p>    <p>8. Затем вы обновляете <blockquote>appbar</blockquote> для вывода сообщения, информирующего пользователя о результатах поиска:</p>    <p><blockquote> sprintf(search_text, "Displaying %d result(s) for search string ' %s'",</blockquote></p>    <p><blockquote>  MIN(res1, MAX_CD_RESULT), search_string);</blockquote></p>    <p><blockquote> gnome_appbar_push(GNOME_APPBAR(appbar), search_text);</blockquote></p>    <p>9. Теперь у вас есть результаты поиска, и можно заполнять ими модель <blockquote>GtkTreeStore</blockquote>. Для каждого ID компакт-диска необходимо извлечь соответствующую структуру типа <blockquote>current_cd_st</blockquote>, которая содержит название и исполнителя CD, и затем извлечь список дорожек диска. В заголовочном файле app_mysql.h задано ограничение количества элементов, <blockquote>MAX_CD_RESULT</blockquote>, для того, чтобы не было переполнения модели <blockquote>GtkTreeStore</blockquote>:</p>    <p><blockquote> tree_store = gtk_tree_store_new(N_COLUMNS,</blockquote></p>    <p><blockquote>  G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);</blockquote></p>    <p><blockquote> while (i &lt; res1 &amp;&amp; i &lt; MAX_CD_RESULT) {</blockquote></p>    <p><blockquote>  res2 = get_cd(cd_res.cd_id[i], &amp;cd);</blockquote></p>    <p><blockquote>  /* В модель вставляется новая строка */</blockquote></p>    <p><blockquote>  gtk_tree_store_append(tree_store, &amp;parent_iter, NULL);</blockquote></p>    <p><blockquote>  gtk_tree_store_set(tree_store, &amp;parent_iter, COLUMN_TITLE,</blockquote></p>    <p><blockquote>   cd.title, COLUMN_ARTIST, cd.artist_name, COLUMN_CATALOGUE,</blockquote></p>    <p><blockquote>   cd.catalogue, -1);</blockquote></p>    <p><blockquote>  res3 = get_cd_tracks(cd_res.cd_id[i++], &amp;ct);</blockquote></p>    <p><blockquote>  j = 0;</blockquote></p>    <p><blockquote>  /* Заполнение дерева дорожками текущего компакт-диска */</blockquote></p>    <p><blockquote>  while (j &lt; res3) {</blockquote></p>    <p><blockquote>   sprintf(track_title, " Track %d. ", j+1);</blockquote></p>    <p><blockquote>   strcat(track_title, ct.track[j++]);</blockquote></p>    <p><blockquote>   gtk_tree_store_append(tree_store, &amp;child_iter, &amp;parent_iter);</blockquote></p>    <p><blockquote>   gtk_tree_store_set(tree_store, &amp;child_iter,</blockquote></p>    <p><blockquote>    COLUMN_TITLE, track_title, -1);</blockquote></p>    <p><blockquote>  }</blockquote></p>    <p><blockquote> }</blockquote></p>    <p><blockquote> gtk_tree_view_set_model(GTK_TREE_VIEW(treeview),</blockquote></p>    <p><blockquote> GTK_TREE_MODEL(tree_store));</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>10. Диалоговое окно <blockquote>addcd</blockquote> немодальное. Следовательно, перед его созданием и отображением вы проверяете, не активно ли оно уже:</p>    <p><blockquote>void on_addcd_activate(GtkMenuItem* menuitem, gpointer user_data) {</blockquote></p>    <p><blockquote> if (addcd_dialog != NULL) return;</blockquote></p>    <p><blockquote> addcd_dialog = create_addcd_dialog();</blockquote></p>    <p><blockquote> gtk_widget_show_all(addcd_dialog);</blockquote></p>    <p><blockquote>}</blockquote></p>    <br>    <p><blockquote>gboolean close_app(GtkWidget * window, gpointer data) {</blockquote></p>    <p><blockquote> gboolean exit;</blockquote></p>    <p><blockquote> if ((exit = confirm_exit())) {</blockquote></p>    <p><blockquote>  quit_app(NULL, NULL);</blockquote></p>    <p><blockquote> }</blockquote></p>    <p><blockquote> return exit;</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>11. Когда вы щелкаете мышью кнопку <b>About</b> (О программе), раскрывается стандартное поле <blockquote>about</blockquote> среды GNOME:</p>    <p><blockquote>void on_about_activate(GtkMenuItem* menuitem, gpointer user_data) {</blockquote></p>    <p><blockquote> const char* authors[] = {"Wrox Press", NULL};</blockquote></p>    <p><blockquote> GtkWidget* about = gnome_about_new("CD Database", "1.0",</blockquote></p>    <p><blockquote>  " (c) Wrox Press", "Beginning Linux Programming",</blockquote></p>    <p><blockquote>  (const char **)authors, NULL, "Translators", NULL);</blockquote></p>    <p><blockquote> gtk_widget_show(about);</blockquote></p>    <p><blockquote>}</blockquote></p>    <b>Упражнение 16.14. Файл main.c</b>    <p>Введите следующий программный код в файл main.с, содержащий функцию <blockquote>main</blockquote> программы.</p>    <p>1. После операторов <blockquote>include</blockquote> вы ссылаетесь на поля ввода имени пользователя и пароля из файла interface.c:</p>    <p><blockquote>#include &lt;stdio.h&gt;</blockquote></p>    <p><blockquote>#include &lt;stdlib.h&gt;</blockquote></p>    <p><blockquote>#include "app_gnome.h"</blockquote></p>    <br>    <p><blockquote>extern GtkWidget* username_entry;</blockquote></p>    <p><blockquote>extern GtkWidget* password_entry;</blockquote></p>    <br>    <p><blockquote>gint main(gint argc, gchar *argv[]) {</blockquote></p>    <p><blockquote> GtkWidget *main_window;</blockquote></p>    <p><blockquote> GtkWidget *login_dialog;</blockquote></p>    <p><blockquote> const char *user_const;</blockquote></p>    <p><blockquote> const char *pass_const;</blockquote></p>    <p><blockquote> gchar username[100];</blockquote></p>    <p><blockquote> gchar password[100];</blockquote></p>    <p><blockquote> gint result;</blockquote></p>    <p>2. Инициализируйте как обычно библиотеки GNOME и затем создайте и отобразите на экране главное окно и диалоговое окно вашей регистрации:</p>    <p><blockquote> gnome_program_init("CdDatabase", "0.1", LIBGNOMEUI_MODULE, argc, argv,</blockquote></p>    <p><blockquote>  GNOME_PARAM_APP_DATADIR, "", NULL);</blockquote></p>    <p><blockquote> main_window = create_main_window();</blockquote></p>    <p><blockquote> gtk_widget_show_all(main_window);</blockquote></p>    <p><blockquote> login_dialog = create_login_dialog();</blockquote></p>    <p>3. Вы ждете в цикле, пока пользователь не введет корректную комбинацию имени пользователя и пароля. Он может выйти из приложения, щелкнув мышью кнопку <b>Cancel</b>, причем в этом случае ему придется подтвердить свое действие:</p>    <p><blockquote> while (1) {</blockquote></p>    <p><blockquote>  result = gtk_dialog_run(GTK_DIALOG(login_dialog));</blockquote></p>    <p><blockquote>  if (result != GTK_RESPONSE_ACCEPT) {</blockquote></p>    <p><blockquote>   if (confirm_exit()) return 0;</blockquote></p>    <p><blockquote>   else continue;</blockquote></p>    <p><blockquote>  }</blockquote></p>    <p><blockquote>  user_const = gtk_entry_get_text(GTK_ENTRY(username_entry));</blockquote></p>    <p><blockquote>  pass_const = gtk_entry_get_text(GTK_ENTRY(password_entry));</blockquote></p>    <p><blockquote>  strcpy(username, user_const);</blockquote></p>    <p><blockquote>  strcpy(password, pass_const);</blockquote></p>    <p><blockquote>  if (database_start(username, password) == TRUE) break;</blockquote></p>    <p>4. Если функция <blockquote>database_start</blockquote> завершается аварийно, вы выводите сообщение и диалоговое окно регистрации снова отображается на экране:</p>    <p><blockquote>  GtkWidget* error_dialog =</blockquote></p>    <p><blockquote>   gtk_message_dialog_new(GTK_WINDOW(main_window),</blockquote></p>    <p><blockquote>    GTK_DIALOG_DESTROY_WITH_PARENT,</blockquote></p>    <p><blockquote>    GTK_MESSAGE_ERROR, GTK_BUTTONS_CLOSE,</blockquote></p>    <p><blockquote>    "Could not log on! — Check Username and Password");</blockquote></p>    <p><blockquote>  gtk_dialog_run(GTK_DIALOG(error_dialog));</blockquote></p>    <p><blockquote>  gtk_widget_destroy(error_dialog);</blockquote></p>    <p><blockquote> }</blockquote></p>    <p><blockquote> gtk_widget_destroy(login_dialog);</blockquote></p>    <p><blockquote> gtk_main();</blockquote></p>    <p><blockquote> return 0;</blockquote></p>    <p><blockquote>}</blockquote></p>    <p>5. Для компиляции этого приложения напишите make-файл. Как и в<i> главе 8</i>, вам, возможно, придется указать место расположения библиотеки mysql-клиента с помощью строки, подобной приведенной далее:</p>    <p><blockquote>-L/usr/lib/mysql</blockquote></p>    <p>После опции <blockquote>-L</blockquote> поместите каталог, в котором ваша система хранит библиотеки MySQL:</p>    <p><blockquote>all: app</blockquote></p>    <br>    <p><blockquote>app: app_mysql.c callbacks.с interface.c main.с app_gnome.h app_mysql.h</blockquote></p>    <p><blockquote> gcc -o app -I/usr/include/mysql app_mysql.с callbacks.с interface.c main.с -lmysqlclient `pkg-config --cflags --libs libgnome-2.0 libgnomeui-2.0`</blockquote></p>    <br>    <p><blockquote>clean:</blockquote></p>    <p><blockquote> rm -f app</blockquote></p>    <p>6. Теперь для компиляции приложения для работы с компакт-дисками просто воспользуйтесь командой <blockquote>make</blockquote>:</p>    <p><blockquote><b>make -f Makefile</b></blockquote></p>    <p>Когда вы запустите приложение арр, то получите ваше приложение для работы с базой данных компакт-дисков в стиле GNOME (рис. 16.15)!</p>    <img src="image065.jpg"/>    <p><b>Рис. 16.15</b> </p>          <a name="metkadoc31"><h1>Резюме</h1></a>    <p>В этой главе вы узнали о программировании с помощью библиотек GTK+/GNOME для создания приложений с профессионально выглядящем интерфейсом GUI. Сначала вы рассмотрели с X Window System и научились применять комплекты инструментальных средств, а затем вкратце познакомились с принципами работы GTK+ под управлением системы объектов и механизма сигналов/обратных вызовов этого комплекта инструментов.</p>    <p>Далее вы перешли к API виджетов GTK+, продемонстрировав их применение на простых и более сложных примерах, приведенных в нескольких листингах программ. Рассмотрев виджет <blockquote>GnomeApp</blockquote>, вы научились легко создавать меню с помощью вспомогательных макросов. В заключение вы узнали, как создавать модальные и немодальные диалоговые окна для взаимодействия с пользователем.</p>    <p>И в конце главы вы создали средствами GNOME/GTK+ интерфейс пользователя для вашей базы данных компакт-дисков, который позволяет регистрироваться в базе данных, искать компакт-диски и пополнять базу данных новыми CD.</p>    <p>В<i> главе 17 </i>вы познакомитесь с комплектом инструментальных средств, конкурирующим с GTK+, и научитесь программировать в среде KDE, применяя комплект Qt.</p>     <br><br>
<center><div align="center"><a href="index.php.html">Оглавление</a></div></center>




<br>
<script type="text/javascript">
<!--
var _acic={dataProvider:10};(function(){var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="https://www.acint.net/aci.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()
//-->
</script><br>

<noindex>
<div align="center">
<center>

<!-- SAPE RTB DIV 600x340 -->
<div id="SRTB_507029"></div>
<!-- SAPE RTB END -->

</center>
</div>
</noindex>

</td>
<td width="240" valign="top">

<br>

<div id="menu3">
<ul>
<li><a href="../../alternativnaja_medicina/index.html"><span>Альтернативная медицина</span></a></li>
<li><a href="../../astronomija_i_kosmos/index.html"><span>Астрономия и Космос</span></a></li>
<li><a href="../../biologija/index.html"><span>Биология</span></a></li>
<li><a href="../../voennaja_istorija/index.html"><span>Военная история</span></a></li>
<li><a href="../../geologija_i_geografija/index.html"><span>Геология и география</span></a></li>
<li><a href="../../gosudarstvo_i_pravo/index.html"><span>Государство и право</span></a></li>
<li><a href="../../delovaja_literatura/index.html"><span>Деловая литература</span></a></li>
<li><a href="../../domashnie_zhivotnye/index.html"><span>Домашние животные</span></a></li>
<li><a href="../../domovodstvo/index.html"><span>Домоводство</span></a></li>
<li><a href="../../zdorove/index.html"><span>Здоровье</span></a></li>
<li><a href="../../istorija/index.html"><span>История</span></a></li>
<li><a href="../index.html"><span>Компьютеры и Интернет</span></a></li>
<li><a href="../../kulinarija/index.html"><span>Кулинария</span></a></li>
<li><a href="../../kulturologija/index.html"><span>Культурология</span></a></li>
<li><a href="../../literaturovedenie/index.html"><span>Литературоведение</span></a></li>
<li><a href="../../matematika/index.html"><span>Математика</span></a></li>
<li><a href="../../medicina/index.html"><span>Медицина</span></a></li>
<li><a href="../../nauchnaja_literatura_prochee/index.html"><span>Науч. литер. - прочее</span></a></li>
<li><a href="../../pedagogika/index.html"><span>Педагогика</span></a></li>
<li><a href="../../politika/index.html"><span>Политика</span></a></li>
<li><a href="../../psihologija/index.html"><span>Психология</span></a></li>
<li><a href="../../religiovedenie/index.html"><span>Религиоведение</span></a></li>
<li><a href="../../sad_i_ogorod/index.html"><span>Сад и огород</span></a></li>
<li><a href="../../samosovershenstvovanie/index.html"><span>Самосовершенствование</span></a></li>
<li><a href="../../sdelai_sam/index.html"><span>Сделай сам</span></a></li>
<li><a href="../../sport/index.html"><span>Спорт</span></a></li>
<li><a href="../../tehnicheskie_nauki/index.html"><span>Технические науки</span></a></li>
<li><a href="../../transport_i_aviacija/index.html"><span>Транспорт и авиация</span></a></li>
<li><a href="../../uchebniki/index.html"><span>Учебники</span></a></li>
<li><a href="../../fizika/index.html"><span>Физика</span></a></li>
<li><a href="../../filosofija/index.html"><span>Философия</span></a></li>
<li><a href="../../himija/index.html"><span>Химия</span></a></li>
<li><a href="../../hobbi_i_remesla/index.html"><span>Хобби и ремесла</span></a></li>
<li><a href="../../shpargalki/index.html"><span>Шпаргалки</span></a></li>
<li><a href="../../yezoterika/index.html"><span>Эзотерика</span></a></li>
<li><a href="../../yurisprudencija/index.html"><span>Юриспруденция</span></a></li>
<li><a href="../../jazykoznanie/index.html"><span>Языкознание</span></a></li>
</ul>
</div>

<br>
<div align="center">
<center>
<noindex>

<!-- SAPE RTB DIV 240x400 -->
<div id="SRTB_507028"></div>
<!-- SAPE RTB END -->

</noindex>
</center>
</div>

</td>
</tr>
<tr>
<td colspan="3" align="center">


<hr>
<a href="../../index.html"><span>Главная</span></a> | 
<a rel="sidebar" href="p20.php.html" onclick="this.title=document.title;this.href=document.URL;if(window.external && (!document.createTextNode || (typeof(window.external.AddFavorite)=='unknown'))){window.external.AddFavorite(document.URL, document.title);return false}"><span>В избранное</span></a> | 
<a href="mailto:websi@maleu.ru"><span>Наш E-MAIL</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Материал для сайта  redov.ru"><span>Прислать материал</span></a> | 
<a href="mailto:websi@maleu.ru?subject=Ошибка на сайте redov.ru"><span>Нашёл ошибку</span></a> | 
<a href="p20.php.html#" onClick="scroll(0,0); return false" title="наверх">Наверх</a>
</td>
</tr>
<tr>
<td colspan="3" valign="top" align="left">
<br>

 



</td>
</tr>
</table>

<noindex>
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter21717787 = new Ya.Metrika({id:21717787,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="http://mc.yandex.ru/watch/21717787" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

</noindex>
</center>
</div></body>
</html>